<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="主要记录算法和web开发方面的心得体会">
<meta property="og:type" content="website">
<meta property="og:title" content="YifanChen&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="YifanChen&#39;s Blog">
<meta property="og:description" content="主要记录算法和web开发方面的心得体会">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yifan Chen">
<meta property="article:tag" content="C++, Python, Java, Django, Springboot, 算法, web开发">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>YifanChen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YifanChen's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">YifanChen's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个专注技术的新手程序员</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yfchenkeepgoing/yfchenkeepgoing.github.io" class="github-corner" title="YifanChen GitHub" aria-label="YifanChen GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/29/Day-5-Leetcode-242-349-202-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/29/Day-5-Leetcode-242-349-202-1/" class="post-title-link" itemprop="url">Day 5 | Leetcode 242, 349, 202, 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-29 07:48:25" itemprop="dateCreated datePublished" datetime="2024-01-29T07:48:25+00:00">2024-01-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/27/Day-4-Leetcode-24-19-160-142/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/27/Day-4-Leetcode-24-19-160-142/" class="post-title-link" itemprop="url">Day 4 | Leetcode 24, 19, 160, 142</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-27 07:55:54" itemprop="dateCreated datePublished" datetime="2024-01-27T07:55:54+00:00">2024-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-29 07:51:27" itemprop="dateModified" datetime="2024-01-29T07:51:27+00:00">2024-01-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（链表）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">24. 两两交换链表中的节点</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">19.删除链表的倒数第N个节点</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">面试题 02.07. 链表相交</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">142.环形链表II</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87.html">链表总结篇</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><ol>
<li>两个链表的交点不是数值相等，而是指针相等。</li>
<li>本题在构造测试样例时，会输入两个单链表和两个单链表的交叉点，以及交叉点到两个链表头节点的距离。因此，只有指定的交叉点才是真正的交叉点，仅仅是值相等的节点并不一定是真正的交叉点。指定的交叉点被构造出来时在内存中的地址相同，而仅仅是值相等的两个节点在内存中的地址不一定相同。</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>应该和交换数组中的两个元素相同。需要创建一个额外的节点tmp，然后若要交换a节点和b节点，则进行：<code>tmp = b, a = b, b = tmp</code>即可。</p>
<h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p>我能想到的办法：先遍历一遍列表，返回列表有几个节点。然后再遍历一遍列表，当cur指向倒数第N个节点的前一个节点时，停止遍历链表，删除cur-&gt;next，然后返回链表的头节点即可。应该也要用到虚拟头节点，避免删除链表的第一个节点时需要特判。我按照上述思路写了代码，可以成功通过测评！！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建虚拟头节点</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 统计链表中的节点数量</span></span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            size ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 将cur指向倒数第n个节点的前一个节点</span></span><br><span class="line">        ListNode* cur1 = dummyHead;</span><br><span class="line">        <span class="type">int</span> size1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (size1 &lt; size - n)</span><br><span class="line">        &#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            size1 ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 删除倒数第n个节点，并释放其占用的内存</span></span><br><span class="line">        ListNode* tmp = cur1-&gt;next;</span><br><span class="line">        cur1-&gt;next= cur1-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更好的办法是采用双指针算法，见实现部分。</p>
<h3 id="面试题-02-07-链表相交-1"><a href="#面试题-02-07-链表相交-1" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p>我的第一想法是采用暴力解法。一个指针指向链表A的头节点，一个指针指向链表B的头节点，移动两个指针，当两个指针指向同一个节点时，说明该节点是两个链表相交的节点。据此，我写出了暴力解法的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* dummyHead2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead1-&gt;next = headA;</span><br><span class="line">        dummyHead2-&gt;next = headB;</span><br><span class="line"></span><br><span class="line">        ListNode* cur1 = dummyHead1;</span><br><span class="line">        ListNode* cur2 = dummyHead2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (cur1 = dummyHead1; cur1 != <span class="literal">NULL</span>; cur1 = cur1-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (cur2 = dummyHead2; cur2 != <span class="literal">NULL</span>; cur2 = cur2-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur1 == cur2)</span><br><span class="line">                    <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>暴力解法的时间复杂度是O(n^2)，应该有时间复杂度为O(n)的解法。时间复杂度更低的代码参见代码随想录。</p>
<h3 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><p>从没有见过这类题目，拿到题目毫无思路，直接看视频讲解和文字题解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="24-两两交换链表中的节点-1"><a href="#24-两两交换链表中的节点-1" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>注意：是交换链表中的节点，而不仅仅交换节点的数值。偶数个节点则正好两两交换，奇数个节点则最后一个点不参与交换。一定需要dummyHead，因为要交换节点1、2，就一定要用到它们之前的那个节点，即dummyHead（dummyHead-&gt;2-&gt;1-&gt;3-&gt;…）。同理，要交换节点3、4，就一定要用到它们之前的那个节点，即节点2。<strong>因此当前指针一定要指向要反转的两个节点中的前一个节点，且当前指针每次移动两位</strong>。</p>
<p>若链表中的节点个数为奇数，则cur-&gt;next-&gt;next == NULL时循环结束，若链表中的节点个数为偶数，则cur -&gt; next == NULL时循环结束。如下图所示。故遍历结束的条件为 <code>while (cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL)</code>。两个条件不可以反过来写，否则当出现空链表时，cur-&gt;next-&gt;next没有被定义，会出现空指针异常。<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/%E7%BB%98%E5%9B%BE1.png?raw=true" alt="绘图1.png"></p>
<p>接下来是两两交换节点的逻辑。改变后的链表为dummyHead-&gt;2-&gt;1-&gt;3，由于dummyHead-&gt;1改变为dummyHead-&gt;2后，原本的节点1已经不能被访问到了，因此需要先用tmp存下节点1。同理，由于要将2-&gt;3改为2-&gt;1，因此需要先用tmp1存下节点3。交换完节点的链表为：dummyHead-&gt;2-&gt;1-&gt;4-&gt;3…..。对于两两交换节点的逻辑，可以参考代码随想录教程中的三幅图片。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png" alt="24.两两交换链表中的节点3"></p>
<p>交换3和4节点的步骤时：cur目前为1，我们让1指向4，4再指向3，3再指向5（如果有5的话）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 交换两个节点需要用到这两个节点前的那个节点</span></span><br><span class="line">        <span class="comment">// 因此定义虚拟头节点，用于交换节点1和节点2</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="comment">// 搞清楚遍历的终止条件，参见笔记的图示</span></span><br><span class="line">        <span class="comment">// 以下两个终止条件分别针对节点数目为偶数和奇数的情况</span></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// dummyHead-&gt;2时，dummyHead-&gt;1不再存在，无法访问到1，因此需要事先存储节点1</span></span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 同理，2-&gt;1时，2-&gt;3不再存在，无法访问到3，因此需要事先存储节点3</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// dummyHead-&gt;2-&gt;1-&gt;3</span></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">// dummyHead-&gt;1变为dummyHead-&gt;2</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp; <span class="comment">// dummyHead-&gt;2-&gt;3变成dummyHead-&gt;2-&gt;1</span></span><br><span class="line">            tmp-&gt;next = tmp1; <span class="comment">//dummyHead-&gt;2-&gt;1再在末尾接上3</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">// cur指针后移两位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="19-删除链表的倒数第N个节点-1"><a href="#19-删除链表的倒数第N个节点-1" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p>看了代码随想录的思路之后，我独立写出了快慢指针解法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast先向后移动n位</span></span><br><span class="line">        <span class="keyword">while</span> (n -- ) fast = fast-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast移动到链表的最后一个节点（非空节点），此时slow移动到链表的倒数第n个节点前面的那个节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除倒数第n个节点</span></span><br><span class="line">        ListNode* tmp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以让fast先向后移动(n + 1)位，然后让fast和slow同时移动，直到fast移动到NULL为止，此时slow指向的也是倒数第n个节点的前一个节点。对这种办法，可以在移动fast指针前先让n ++ , 也可以在第一个while循环后让fast指针多向后移动一位。<strong>最稳妥的写法</strong>如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先将快指针移动n + 1步</span></span><br><span class="line">        n ++ ;</span><br><span class="line">        <span class="keyword">while</span> (n -- &amp;&amp; fast != <span class="literal">NULL</span>) fast = fast-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针同时移动，直到快指针指向NULL。此时慢指针指向要删除的节点前面那个节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存并删除倒数第n个节点</span></span><br><span class="line">        ListNode* tmp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于题目有如下限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The number of nodes in the list is sz.</span><br><span class="line">1 &lt;= sz &lt;= 30</span><br><span class="line">0 &lt;= Node.val &lt;= 100</span><br><span class="line">1 &lt;= n &lt;= sz</span><br></pre></td></tr></table></figure>
<p>因此即使不加上fast != NULL，也可以通过，但如果题目没有n &lt;= sz的限制，那么必须加上fast != NULL，且不能使用以下写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n -- &amp;&amp; fast != <span class="literal">NULL</span>) fast = fast-&gt;next;</span><br><span class="line">fast = fast-&gt;next;</span><br></pre></td></tr></table></figure>
<p>因为若采用以上写法，当n &gt; sz时，当while循环结束后，fast已经指向了NULL，此时再做fast = fast-&gt;next操作，会导致空指针异常。</p>
<h3 id="面试题-02-07-链表相交-2"><a href="#面试题-02-07-链表相交-2" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p>代码随想录的思路：求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB末尾对齐的位置。此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。否则循环退出返回空指针。</p>
<p>看了代码随想录的思路后，我独立写出了代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sizea = <span class="number">0</span>, sizeb = <span class="number">0</span>;</span><br><span class="line">        ListNode* cura = headA;</span><br><span class="line">        ListNode* curb = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算a链表的长度</span></span><br><span class="line">        <span class="keyword">while</span> (cura != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cura = cura-&gt;next;</span><br><span class="line">            sizea ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算b链表的长度</span></span><br><span class="line">        <span class="keyword">while</span> (curb != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curb = curb-&gt;next;</span><br><span class="line">            sizeb ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cura = headA, curb = headB;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> delta = <span class="built_in">abs</span>(sizea - sizeb); <span class="comment">// 两链表长度的差值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sizea &gt;= sizeb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (delta -- ) cura = cura-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sizeb -- )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cura == curb) <span class="keyword">return</span> cura;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cura = cura-&gt;next;</span><br><span class="line">                    curb = curb-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (delta -- ) curb = curb-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sizea -- )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cura == curb) <span class="keyword">return</span> cura;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cura = cura-&gt;next;</span><br><span class="line">                    curb = curb-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里特别需要注意的是，在计算完a链表和b链表的长度后，需要让 <code>cura = headA, curb = headB</code>。</p>
<p>代码随想录的写法更见简洁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* cura = headA, * curb = headB;</span><br><span class="line">        <span class="type">int</span> sizea = <span class="number">0</span>, sizeb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算a链表和b链表的长度</span></span><br><span class="line">        <span class="keyword">while</span> (cura != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cura = cura-&gt;next;</span><br><span class="line">            sizea ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curb != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curb = curb-&gt;next;</span><br><span class="line">            sizeb ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 始终保证链表a的长度大于等于链表b的长度</span></span><br><span class="line">        <span class="keyword">if</span> (sizea &lt; sizeb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(sizea, sizeb);</span><br><span class="line">            <span class="built_in">swap</span>(headA, headB);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 交换cura和curb后，再恢复cura和curb的指向</span></span><br><span class="line">        <span class="comment">// 也可以在上面直接swap(cura, curb)，那这句话就可以写到if判断的前面去</span></span><br><span class="line">        cura = headA, curb = headB;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 计算两链表的长度之差</span></span><br><span class="line">        <span class="type">int</span> delta = sizea - sizeb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指向链表a的指针，让链表a和b的尾部对齐</span></span><br><span class="line">        <span class="keyword">while</span> (delta -- ) cura = cura-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cura != <span class="literal">NULL</span>) <span class="comment">// 写作while (sizeb -- )也可</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cura == curb) <span class="keyword">return</span> cura;</span><br><span class="line">            cura = cura-&gt;next;</span><br><span class="line">            curb = curb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="142-环形链表II-1"><a href="#142-环形链表II-1" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><p>有两问：</p>
<ol>
<li><p>判断链表中是否有环</p>
<p>用快慢指针来判断是否有环。若链表是一条直线，则快慢指针永远不会相遇。只有当链表中有环存在时，快指针先进入了环且在环中浪费了时间，快慢指针才会相遇。快指针从头节点开始，每次移动两位，慢指针也从头节点开始，每次移动一位，二者若相遇则一定在环里相遇，相遇则说明有环。快指针是一个节点一个节点的靠近慢指针，因此二者一定会在环中相遇。</p>
</li>
<li><p>找到环的入口</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></p>
<p>列方程即可解出x：<code>x = n (y + z) - y, (n &gt;= 1)</code>，由于看不出x和负数-y之间的关系，我们让出一圈，看x和z的关系：<code>x = (n - 1) (y + z) + z, (n &gt;= 1)</code>。这就意味着：<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是环形入口的节点</strong>。</p>
<p>为什么第一次在环中相遇，slow的步数是x+y而不是 x + 若干环的长度 + y 呢？”这个问题，可以这样解释，设快指针每秒移动2格，慢指针每秒移动1格，圆的周长是k。则慢指针走一圈需要的时间是k，设两指针之间的距离为m(m &lt; k)，则快指针追上慢指针的时间是m（快指针相对于满指针每秒移动1格），此时慢指针走过的距离是m，由于m &lt; k，因此慢指针在遇到快指针之前走过的距离小于圆的周长。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head, * slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面两个循环条件保证了fast指针可以指向NULL，但不能指向NULL的next，这样就不会导致空指针异常</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next; <span class="comment">// 快指针每次移动两位</span></span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 慢指针每次移动一位</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 快慢指针相遇，说明链表中有环</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 一指针从相遇处开始移动，一指针从head处开始移动，二者相遇的位置就是环的入口，数学推导见笔记</span></span><br><span class="line">                ListNode* index1 = fast, * index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2)</span><br><span class="line">                &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 若没有返回环的入口节点，则说明没有环，返回空指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我自研的另一种写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head, * slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 判断链表中是否有环</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 有环，则返回环的起点，无环，则返回空指针</span></span><br><span class="line">        <span class="keyword">if</span> (flag &amp;&amp; fast == slow)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* index1 = head, * index2 = slow;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(index1 != index2)</span><br><span class="line">            &#123;</span><br><span class="line">                index1 = index1-&gt;next;</span><br><span class="line">                index2 = index2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，一定要通过flag判断，只有当fast和slow相等且二者都在第一个while循环中转过时，才能确保链表中有环，若fast和slow相等，则可能是链表中只有一个节点的情况，此时fast和slow都没有在第一个循环中转过，因此二者相等且都等于head。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="24-两两交换链表中的节点-2"><a href="#24-两两交换链表中的节点-2" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><ol>
<li>注意cur应该指向哪里。</li>
<li>注意遍历的终止条件（奇数/偶数个节点）</li>
<li>若原先的两节点之间的连接被断开，则需要在断开前保存两节点中后面那个节点，否则后面的那个节点无法被访问到</li>
</ol>
<h3 id="面试题-02-07-链表相交-3"><a href="#面试题-02-07-链表相交-3" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><ol>
<li>本题的关键思路在于：<strong>对齐两个链表的尾部</strong>。本题的算法实际上也是（快慢）双指针算法。</li>
<li>比较链表中的两个节点是否相同，直接用 <code>cura == curb</code>即可，不能用 <code>cura-&gt;val == curb-&gt;val &amp;&amp; cura-&gt;next == curb-&gt;next</code>，因为比较两个节点除去比较val和next这两个参数外，还需要比较其本身的内存地址。</li>
<li>本题的时间复杂度分析：<br>计算两个链表的长度：O(n) + O(m)<br>调整指针以对齐两个链表：O(n - m)或O(m - n)<br>同时遍历两个链表寻找交点：O(min(n, m))<br>第一步和第三步的时间复杂度加在一起是 <code>O(n) + O(m) + O(min(n, m))</code>。但是，因为 <code>O(min(n, m))</code>在 <code>O(n) + O(m)</code>中已经被包含（总是小于或等于 <code>n</code>和 <code>m</code>），所以总的时间复杂度简化为 <code>O(n) + O(m)</code>。第二步（调整指针以对齐两个链表）的时间复杂度实际上也包含在 <code>O(n) + O(m)</code>中，因为无论是 <code>n - m</code>还是 <code>m - n</code>，它的值总是小于或等于 <code>n</code>和 <code>m</code>。因此，整个函数的总时间复杂度为 <code>O(n + m)</code>，这里 <code>n</code>和 <code>m</code>分别是两个链表的长度。这个时间复杂度已经涵盖了所有的主要操作，包括计算长度、对齐链表和寻找交点。<strong>时间复杂度的计算应当关注主要操作，省略次要操作</strong>。</li>
<li>在leetcode中调用swap，abs等函数时，不需要自行引用头文件，基本的函数和数据结构（STL）已经默认被引用了，因此直接写出来即可。</li>
</ol>
<h3 id="142-环形链表II-2"><a href="#142-环形链表II-2" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><ol>
<li>记住使用快慢双指针算法，有环的情况下快慢指针必然会相遇。</li>
<li>画图理解如何求环的起点的index。</li>
<li><strong>记得复习时着重看这道题</strong></li>
</ol>
<h2 id="总结：链表"><a href="#总结：链表" class="headerlink" title="总结：链表"></a>总结：链表</h2><ol>
<li>插入虚拟头节点dummyHead，可以避免空链表并避免对头节点操作的特判</li>
<li>创建一个当前节点cur，对整个链表进行遍历（<code>cur = cur-&gt;next</code>），而不用链表中原本存在的节点对链表进行遍历</li>
<li>NULL节点表示不存在的节点；虚拟节点实际上是存在的，其值为0，是人为创建的节点</li>
<li>递归时，需要先检查递归的终止条件，然后执行递归步骤</li>
<li>想要删除哪个节点，就用cur指针指向其前面的那个节点</li>
<li><strong>链表中最常用的算法是双指针算法</strong>，在206.反转链表，19.删除链表的倒数第N个节点，面试题 02.07. 链表相交，142.环形链表II中都用到了，其他题目基本不需要算法，利用链表的一些基本性质进行增删改查即可。</li>
<li><strong>记得复习142.环形链表II和24.两两交换链表中的节点</strong>，前者是链表中最独特也最难的一道题，难在数学推导和想清楚细节；后者在退出循环的条件和用tmp保存节点方面需要特别注意。</li>
</ol>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/26/Day-3-Leetcode-203-707-206/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/26/Day-3-Leetcode-203-707-206/" class="post-title-link" itemprop="url">Day 3 | Leetcode 203, 707, 206</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-26 06:46:36" itemprop="dateCreated datePublished" datetime="2024-01-26T06:46:36+00:00">2024-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-29 07:54:28" itemprop="dateModified" datetime="2024-01-29T07:54:28+00:00">2024-01-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（链表）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">链表理论基础</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">203.移除链表元素</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html">707.设计链表</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">206.反转链表</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>链表是一种通过指针串联在一起的线性结构。每个节点等于数据域+指针域（存放指向下一个节点的指针）。最后一个节点的指针域指向null。头节点head。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png" alt="img"></p>
<p>单链表、双链表：既可以向前查询也可以向后查询。<br>循环链表：链表首尾相连（解决约瑟夫环问题）</p>
<p>链表在内存中不是连续分布的。其通过指针域的指针链接在内存中的各个节点。</p>
<p>链表的定义：<br>手写链表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过上述构造函数初始化节点：<code>ListNode* head = new ListNode(5);</code><br>使用默认构造函数初始化节点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p>
<p>添加节点：见图</p>
<p>数组和链表有不同的适用场景。数组适合数据量固定，频繁查找，较少增删的场景；链表适合数据量不固定，频繁增删，较少查询的场景。</p>
<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体中定义了两个变量和三个构造函数。class Solution中的removeElements函数返回的变量类型是ListNode*，即这个函数返回一个指向ListNode对象的指针。</p>
<p>如果使用C，C++编程语言的话，不要忘了还要从内存中删除这两个移除的节点。如果移除一个节点之后，没有手动在内存中删除这个节点，leetcode依然也是可以通过的，只不过，内存使用的空间大一些而已，但建议依然要养成手动清理内存的习惯。</p>
<p>删除头节点：</p>
<ul>
<li>直接使用原来的链表来进行删除操作：头节点后移一位</li>
<li>设置一个虚拟头结点在进行删除操作：原链表的所有节点就都可以按照统一的方式进行移除了，最后<code>return dummyNode-&gt;next;</code></li>
</ul>
<h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><ul>
<li>void函数可以直接return，表示退出</li>
<li>统一使用虚拟头节点的方式，便于进行增删改的操作</li>
<li>变量名前加_表示是这个类的变量，而非局部变量，这是cpp中的一种约定俗成</li>
</ul>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="203-移除链表元素-1"><a href="#203-移除链表元素-1" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p>对链表题我一直有点懵，不太熟悉链表题的格式，但是对用数组模拟链表倒是挺熟悉的。我知道算法的思路大致是：先定义一个虚的头节点，然后遍历链表，删去值等于val的节点，然后返回头节点指针指向的节点，就是新的头节点，但我不知道这种代码怎么写。</p>
<h3 id="707-设计链表-1"><a href="#707-设计链表-1" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p>这题yxc也教过，但是在他那里似乎是用数组模拟链表，实现链表的各种功能，而这里是调用链表完成函数中的功能，我认为这题不难，只是多个功能需要分别实现，单个功能的代码较为简单。这道题我基本会做，但<strong>处理边界条件时要倍加注意</strong>！！</p>
<h3 id="206-反转链表-1"><a href="#206-反转链表-1" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p>yxc也讲过这个题，但我也给完全忘了</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="203-移除链表元素-2"><a href="#203-移除链表元素-2" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><h4 id="方法1-特判头节点"><a href="#方法1-特判头节点" class="headerlink" title="方法1: 特判头节点"></a>方法1: 特判头节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head -&gt; val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            head = head -&gt; next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除非头节点</span></span><br><span class="line">        ListNode* cur = head; <span class="comment">// cur存储要删去的节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 要删的节点cur-&gt;next不可为空, cur != NULL是考虑空链表的情况</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; cur -&gt; next != <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; next -&gt; val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* tmp = cur -&gt; next;</span><br><span class="line">                cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cur = cur -&gt; next; <span class="comment">// 后移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2-加入虚拟头节点"><a href="#方法2-加入虚拟头节点" class="headerlink" title="方法2: 加入虚拟头节点"></a>方法2: 加入虚拟头节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建虚拟头节点</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead -&gt; next = head;</span><br><span class="line">        <span class="comment">// 上面的两行代码：创建虚拟头节点可以简写为：</span></span><br><span class="line">        <span class="comment">// ListNode* dummyHead = new ListNode(0, head);</span></span><br><span class="line">        <span class="comment">// 或者ListNode* dummyHead = new ListNode();</span></span><br><span class="line">        <span class="comment">// dummyHead -&gt; next = head;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统一方法删去值为val的节点</span></span><br><span class="line">        <span class="comment">// 从虚拟头节点开始遍历, cur为目标节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 此时因为加入了虚拟头节点，因此链表不可能为空，因此不再需要考虑链表为空的判断条件：cur != NULL</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur -&gt; next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; next -&gt; val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* tmp = cur -&gt; next;</span><br><span class="line">                cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head = dummyHead -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以方法2为主。</p>
<h3 id="707-设计链表-2"><a href="#707-设计链表-2" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 记住struct的写法</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedList* next;</span><br><span class="line">        <span class="built_in">LinkedList</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化, 带下划线的变量表示类中的变量，而非局部变量</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(<span class="number">0</span>); <span class="comment">// 虚拟头节点</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; ( _size - <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        LinkedList* cur = _dummyHead -&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index -- ) cur = cur -&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedList* head = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line">        head -&gt; next = _dummyHead -&gt; next;</span><br><span class="line">        _dummyHead -&gt; next = head;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedList* tail = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line"></span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        <span class="comment">// while循环中的条件不能是_size -- ，不然会破坏链表长度的准确性</span></span><br><span class="line">        <span class="keyword">while</span>(cur -&gt; next != <span class="literal">NULL</span>) cur = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = tail;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size || index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        LinkedList* node = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(index -- ) cur = cur -&gt; next;</span><br><span class="line"></span><br><span class="line">        node -&gt; next = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = node;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= _size) <span class="keyword">return</span>;</span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index -- ) cur = cur -&gt; next;</span><br><span class="line">        LinkedList* tmp = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        _size -- ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LinkedList* _dummyHead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="206-反转链表（常考）"><a href="#206-反转链表（常考）" class="headerlink" title="206.反转链表（常考）"></a>206.反转链表（常考）</h3><p>是考察对基础数据结构操作非常好的一道题目。先掌握双指针解法，再掌握递归的解法。根据双指针代码写出递归代码。</p>
<h4 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h4><p><img src="https://github.com/yfchenkeepgoing/image/blob/main/%E7%BB%98%E5%9B%BE%20(1" alt="绘图 (1).png">.png?raw=true)</p>
<p>具体解法：由于不需要让翻转以后的链表的头节点为空，因此当cur指向NULL时，遍历结束。因此循环为：<code>while(cur)</code>，cur == NULL为遍历的终止条件。</p>
<p>更新cur和pre的方式：用临时节点将cur的下一个节点保存下来。否则一旦反转后cur的写一个节点就会丢失（反转后的链表的下一个节点是pre）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = cur -&gt; next;</span><br><span class="line">            cur -&gt; next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归解法1"><a href="#递归解法1" class="headerlink" title="递归解法1"></a>递归解法1</h4><p>按照双指针的思路写递归的代码。递归的代码更简短但更难懂。</p>
<p>具体解法：定义一个reverse函数，其中有两个参数，即<code>reverse(cur, pre)</code>。</p>
<p>在主函数中调用reverse函数，需要传入两个参数cur和pre，前者对应于双指针解法中的head，后者对应于双指针解法中的null。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 仿照双指针解法，递归函数中需要传入两个参数：cur和pre</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* cur, ListNode* pre)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 先检查递归的终止条件，同双指针解法</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再执行递归的步骤</span></span><br><span class="line">        <span class="comment">// 同双指针解法中tmp = cur -&gt; next, cur -&gt; next = pre, pre = cur, cur = tmp</span></span><br><span class="line">        ListNode* tmp = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(tmp, cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 双指针解法中初始时cur = head, pre = NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(head, <span class="literal">NULL</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归解法2"><a href="#递归解法2" class="headerlink" title="递归解法2"></a>递归解法2</h4><p>另一种递归解法，思路和递归解法1完全不同，我认为相比于递归解法1更好理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断终止条件是否成立</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 空链表，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head; <span class="comment">// 递归结束，返回反转后链表的head</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行递归流程</span></span><br><span class="line">        ListNode* last = <span class="built_in">reverseList</span>(head-&gt;next); <span class="comment">// 从第二个节点开始反转链表</span></span><br><span class="line">        <span class="comment">// 将原来的头节点接到反转后链表的尾节点之后，反转后链表的尾节点是head-&gt;next</span></span><br><span class="line">        head-&gt;next-&gt;next = head; </span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 尾节点指向空</span></span><br><span class="line">        <span class="keyword">return</span> last; <span class="comment">// 返回反转后链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h3><ol>
<li>插入虚拟头节点dummyHead，可以避免空链表并避免对头节点操作的特判</li>
<li>创建一个当前节点cur，对整个链表进行遍历（<code>cur = cur-&gt;next</code>），而不用链表中原本存在的节点对链表进行遍历</li>
<li>NULL节点表示不存在的节点；虚拟节点实际上是存在的，其值为0，是人为创建的节点</li>
<li>递归时，需要先检查递归的终止条件，然后执行递归步骤</li>
</ol>
<h3 id="203-移除链表元素-3"><a href="#203-移除链表元素-3" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><ol>
<li>想要删除一个节点，需要先用tmp存下它，然后再delete删去之。</li>
<li>以后写，尽量采用方法2，即加入虚拟头节点。</li>
<li>cur -&gt; next表示的是cur节点的next变量（即指针域），而cur -&gt; val表示的是cur节点的val变量（即节点的值）。通过构造函数也可以给这两个变量直接赋值。</li>
<li>在方法1中，一定要加上判断条件<code>cur != NULL</code>，因为当链表为空时，<code>while (cur -&gt; next != NULL)</code> 这个条件将尝试访问 <code>NULL</code> 指针的 <code>next</code> 成员，这将触发未定义行为，从而导致程序报错。在方法2中，则不需要加上判断条件<code>cur != NULL</code>，因为有虚拟头节点的存在，链表不可能为空，至少有一个节点（即虚拟头节点）。当然，在方法2中加上这个判断条件也不会影响程序的正常运行。</li>
</ol>
<h3 id="707-设计链表-3"><a href="#707-设计链表-3" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><ol>
<li>想清楚一个极端情况：返回第0个节点的值，是否会出现空指针异常等错误。</li>
<li>cur节点都赋值为_dummyHead</li>
<li>注意删除第n个节点时的内存释放问题</li>
<li>在第n个节点前增加或者删除一个节点，应该让cur指向第n-1个节点，cur-&gt;next指向第n个节点。</li>
<li>注意插入节点时先更新后面的边，再更新前面的边</li>
<li>只要传入参数index，就要记得对index进行判断，排除掉不需处理的情况。对get函数和deleteAtIndex函数，判断条件都是<code>index &lt; 0 || index &gt; _size - 1</code>，但对addAtIndex函数，判断条件是<code>index &lt; 0 || index &gt; _size</code>，因为<code>index = _size</code>表示将节点插入到链表的末尾。</li>
<li>别忘记_size ++ / _size — </li>
</ol>
<h3 id="206-反转链表-2"><a href="#206-反转链表-2" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><h4 id="双指针解法-1"><a href="#双指针解法-1" class="headerlink" title="双指针解法"></a>双指针解法</h4><p>代码量少，思维量大！需要明确：cur和pre初始的取值；循环终止的条件；如何更新pre和cur。画图理解即可。</p>
<h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><p>递归解法1参照双指针解法写。<strong>这题推荐就用双指针解法，比较清楚明白</strong>，且空间复杂度为O(1)，优于递归解法的空间复杂度O(n)。递归解法2相比于递归解法1更好理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/25/Day-2-Leetcode-977-209-59/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/25/Day-2-Leetcode-977-209-59/" class="post-title-link" itemprop="url">Day 2 | Leetcode 977, 209, 59</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-25 04:41:58" itemprop="dateCreated datePublished" datetime="2024-01-25T04:41:58+00:00">2024-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-29 07:54:59" itemprop="dateModified" datetime="2024-01-29T07:54:59+00:00">2024-01-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（数组）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1QB4y1D7ep">https://www.bilibili.com/video/BV1QB4y1D7ep</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tZ4y1q7XE">https://www.bilibili.com/video/BV1tZ4y1q7XE</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1SL4y1N7mV/">https://www.bilibili.com/video/BV1SL4y1N7mV/</a></p>
<h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html">https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80</a></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/squares-of-a-sorted-array/">https://leetcode.com/problems/squares-of-a-sorted-array/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-size-subarray-sum/">https://leetcode.com/problems/minimum-size-subarray-sum/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix-ii/">https://leetcode.com/problems/spiral-matrix-ii/</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol>
<li>cpp中sort函数的用法：sort(a.begin(), a.end())，排序后的结果就存储在a中。</li>
<li><code>vector&lt;int&gt; result(A.size(), 0);</code>的意思是创建一个长度为A.size()，数值全部为0的vector。</li>
<li><p>cpp中的问号表达式——条件运算符</p>
<p>len = sub &lt; len ? sub: len;表示若sub &lt; len，则len = sub；否则len等于len，保持不变。</p>
<p>len == INT32_MAX ? 0: len;表示若len等于INT32_MAX，则l表达式值为0，否则表达式值为len。</p>
</li>
<li><code>INT32_MAX</code>：这是一个在 C++ 中定义的常量，代表 32 位整数类型（即 <code>int</code> 类型）可以表示的最大值。</li>
<li>初始化一个二维vector，让其中的元素全部为0：<code>vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0));</code>，即初始化一个全部元素为0的一维数组，然后将其复制n遍。</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p>暴力做法，先平方，再排序。双指针做法有点思路，但由于不知道如何创建一个值为0且长度与nums相同的vector，因此不能完全正确地写出代码。</p>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h3><p>滑动窗口我听yxc讲过，但是已经完全忘了，直接看视频讲解，然后看文字版讲解。</p>
<p>暴力解法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> sub = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                s += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (s &gt;= target)</span><br><span class="line">                &#123;</span><br><span class="line">                    sub = j - i + <span class="number">1</span>;</span><br><span class="line">                    len = len &lt; sub ? len: sub;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len == INT32_MAX ? <span class="number">0</span>: len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>暴力做法超时了。还是需要滑动窗口。</p>
<h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h3><p>yxc讲过这题，我印象中涉及到一个向量，撞墙了就拐弯，遇到自己之前走过的地方也拐弯，挺生动形象的，但我已经忘记怎么写了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="977-有序数组的平方-1"><a href="#977-有序数组的平方-1" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p>取平方后，最大的元素一定在原数组的两边。故用左右指针，从数组的两边向中间推进。需要一个新的数组来存储结果，新的数组的下标由大到小来更新。</p>
<h4 id="for-if写法"><a href="#for-if写法" class="headerlink" title="for+if写法"></a>for+if写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ans数组来存储答案</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于每次循环都要比较两个数的平方的大小关系，因此将最后一个数放入ans时</span></span><br><span class="line">        <span class="comment">// i和j都会等于该数的索引，因此要求i可以等于j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt;= j; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &lt;= nums[j] * nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[n -- ] = nums[j] * nums[j];</span><br><span class="line">                j -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans[n -- ] = nums[i] * nums[i];</span><br><span class="line">                i ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="for-while写法"><a href="#for-while写法" class="headerlink" title="for + while写法"></a>for + while写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>; l &lt;= r; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 一定要记得加上l &lt;= r的条件</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] * nums[l] &gt;= nums[r] * nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                res[k -- ] = nums[l] * nums[l];</span><br><span class="line">                l ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] * nums[l] &lt; nums[r] * nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                res[k -- ] = nums[r] * nums[r];</span><br><span class="line">                r -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="while-while写法"><a href="#while-while写法" class="headerlink" title="while+while写法"></a>while+while写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[i] * nums[i] &lt;= nums[j] * nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[k -- ] = nums[j] * nums[j];</span><br><span class="line">                j -- ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[i] * nums[i] &gt; nums[j] * nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[k -- ] = nums[i] * nums[i];</span><br><span class="line">                i ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="while-if写法"><a href="#while-if写法" class="headerlink" title="while + if写法"></a>while + if写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] * nums[l] &lt;= nums[r] * nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                res[k -- ] = nums[r] * nums[r];</span><br><span class="line">                r -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[k -- ] = nums[l] * nums[l];</span><br><span class="line">                l ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="209-长度最小的子数组-1"><a href="#209-长度最小的子数组-1" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h3><p>其实核心思想也是双指针，只不过取两指针中间的集合像是一个正在滑动的窗口，因此也叫滑动窗口。用一个for循环替代暴力做法里的两个for循环。一个for循环中的循环变量j若表示滑动窗口的起始位置，则j在遍历的过程中，终止位置也需要去遍历，这与暴力做法无异。<strong>因此for循环中的循环变量j表示滑动窗口的终止位置，起始位置需要动态移动地去获得</strong>。<strong>滑动窗口的精髓在于如何移动起始位置</strong>。</p>
<p>若滑动窗口的起始位置和终止位置间的数的和&gt;=target，那么起止位置可以向后移动，即窗口可以缩小，看缩小后的窗口是否还可以符合条件。若满足条件，则可更新滑动窗口。更新滑动窗口时，需要同时更新滑动窗口的起始位置和滑动窗口中元素和的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = INT32_MAX; <span class="comment">// result</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// i是滑动窗口的起始位置</span></span><br><span class="line">        <span class="type">int</span> sub = <span class="number">0</span>; <span class="comment">// 窗口长度</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 窗口之和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// j是滑动窗口的终止位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[j]; <span class="comment">// 将新的终止位置放到窗口的和中去</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新滑动窗口</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                sub = j - i + <span class="number">1</span>; </span><br><span class="line">                len = len &lt; sub ? len: sub;</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == INT32_MAX ? <span class="number">0</span>: len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="59-螺旋矩阵II-1"><a href="#59-螺旋矩阵II-1" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h3><p>不涉及算法，是道模拟题。不易写对的原因是转圈的过程中需要处理的边界条件很多。</p>
<p>边界条件：正方形的4个边界点</p>
<p>循环不变量：<br>循环——不断转圈<br>不变量——对每条边的处理规则<br>对每条边的处理规则应该不变。<strong>按照左闭右开的规则处理正方形的每一条边，每条边只处理头节点，不处理尾节点</strong>。</p>
<p>n * n的矩阵，需要转n / 2圈，若n为奇数，则中心那个值最后单独赋即可。每一圈的终止位置在上一圈的基础上-1。</p>
<p>示意图如下所示：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-01-26_06-26-17.png?raw=true" alt="Snipaste_2024-01-26_06-26-17.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">      </span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>, count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j ++ )</span><br><span class="line">                ans[startx][j] = count ++ ;</span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i ++ )</span><br><span class="line">                ans[i][j] = count ++ ;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j -- )</span><br><span class="line">                ans[i][j] = count ++ ;</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i -- )</span><br><span class="line">                ans[i][j] = count ++ ;</span><br><span class="line">          </span><br><span class="line">            startx ++ ;</span><br><span class="line">            starty ++ ;</span><br><span class="line">            offset ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) ans[n / <span class="number">2</span>][n / <span class="number">2</span>] = count;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="977易错点"><a href="#977易错点" class="headerlink" title="977易错点"></a>977易错点</h3><ol>
<li>一定要新建一个数组ans，不能在原数组的基础上修改，否则会混乱。</li>
<li>一定要注意左指针和右指针可以相等，因为最后总要处理两个元素，两个指针最终总会移到一起去。否则当两个指针指向同一个数时，该数会被落下，不会被添加到答案数组中。</li>
<li>这道题在for/while循环内用if或者while都可以，但用while的时候需要记得加上判断条件：<code>while(l &lt;= r &amp;&amp; ....)</code>，不加l &lt;= r的条件会报错：run time error。</li>
</ol>
<h3 id="209心得"><a href="#209心得" class="headerlink" title="209心得"></a>209心得</h3><p>滑动窗口方法其实脱胎于暴力做法。要特别注意遍历的是窗口的终止位置。</p>
<p>更新窗口的起始位置时，同时需要更新窗口中元素之和。</p>
<p>不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度至多是 2 × n 也就是O(n)。</p>
<h3 id="209易错点"><a href="#209易错点" class="headerlink" title="209易错点"></a>209易错点</h3><p>一定要记得把滑动窗口的初始位置定义在循环之外。</p>
<p>一定要记得在移动窗口初始位置的同时改变窗口中元素的sum。</p>
<h3 id="59易错点"><a href="#59易错点" class="headerlink" title="59易错点"></a>59易错点</h3><ol>
<li>注意每一条边都是左开右闭</li>
<li>注意画图理解</li>
<li>注意为n为奇数时单独给中心点赋值</li>
<li>注意如何定义一个二维所有元素为0的矩阵</li>
<li>offsetx/y和startx/y不会出现在同一个式子中</li>
</ol>
<h3 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h3><p>看代码随想录的数组总结</p>
<h2 id="数组总结"><a href="#数组总结" class="headerlink" title="数组总结"></a>数组总结</h2><p>数组题目中：整数二分一道（704）。双指针三道（27, 977, 包括滑动窗口209），双指针题目的难度是递增的，27最简单，977稍难，209最难。模拟题一道：59。</p>
<p>从方法上来说，704和59都应该采用循环不变量的原则，27、977、209则都是双指针算法的应用。</p>
<p>引用总结文章：<a target="_blank" rel="noopener" href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80</a><br>中的一幅图片：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/24/Day-1-Leetcode-704-27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/24/Day-1-Leetcode-704-27/" class="post-title-link" itemprop="url">Day 1 | Leetcode 704, 27</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-24 10:47:40" itemprop="dateCreated datePublished" datetime="2024-01-24T10:47:40+00:00">2024-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-29 07:55:12" itemprop="dateModified" datetime="2024-01-29T07:55:12+00:00">2024-01-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（数组）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%9C%89%E5%87%A0%E4%B8%AA%E7%96%91%E9%97%AE%EF%BC%9F.html">https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%9C%89%E5%87%A0%E4%B8%AA%E7%96%91%E9%97%AE%EF%BC%9F.html</a></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-search/">https://leetcode.com/problems/binary-search/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-element/">https://leetcode.com/problems/remove-element/</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><p>数组是存放在<strong>连续内存空间</strong>上的<strong>相同类型数据</strong>的集合。</p>
<p>注意：</p>
<ul>
<li><p>数组下标都是从0开始的</p>
</li>
<li><p>数组内存空间的地址是连续的</p>
</li>
<li><p>正是因为数组的在内存空间的地址是连续的，所以我们在<strong>删除或者增添元素的时候，就难免要移动其他元素的地址</strong></p>
</li>
<li><p>C++中，要注意vector和array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组</p>
</li>
<li><p>数组的元素是不能删的，只能覆盖</p>
</li>
<li><p>C++中二维数组在地址空间上是连续的（在现代系统上，二维数组中的每个int占用4个字节）</p>
</li>
<li><p>Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。输出的值不是真正的地址，而是经过处理的数值</p>
</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度是一个函数，它定性描述该算法的运行时间。</p>
<p>大O用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。有时业界也默认O代表的就是一般情况，而不是严格的上界。面试中说道算法的时间复杂度是多少指的都是一般情况。</p>
<p>数据用例的不一样，时间复杂度也是不同的。</p>
<p>我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大。</p>
<p>我们统一说 logn，也就是忽略底数的描述。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>是对一个算法在运行过程中占用内存空间大小的量度。</p>
<p>来看一下例子，什么时候的空间复杂度是$O(1)$呢，C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大O(1)。</p>
<p>当消耗空间和输入参数n保持线性增长，这样的空间复杂度为O(n)，来看一下这段C++代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>随着n的增大，开辟的内存大小呈线性增长，即 O(n)。</p>
<p>递归的时候，会出现空间复杂度为logn的情况。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h3><h4 id="Leetcode-704-二分查找"><a href="#Leetcode-704-二分查找" class="headerlink" title="Leetcode 704 二分查找"></a>Leetcode 704 二分查找</h4><p>这题应该是整数二分，虽然我在yxc的算法基础课里学过这题，但时隔几个月我已经彻底忘了（不管是原理还是实现），从头开始吧。</p>
<h4 id="Leetcode-27-移除元素"><a href="#Leetcode-27-移除元素" class="headerlink" title="Leetcode 27 移除元素"></a>Leetcode 27 移除元素</h4><p>试试暴力做法吧，双指针做法想不出来。根据yxc的经验，暴力做法成功后再想办法去优化。</p>
<h3 id="看完代码随想录后的想法"><a href="#看完代码随想录后的想法" class="headerlink" title="看完代码随想录后的想法"></a>看完代码随想录后的想法</h3><h4 id="Leetcode-704-二分查找-1"><a href="#Leetcode-704-二分查找-1" class="headerlink" title="Leetcode 704 二分查找"></a>Leetcode 704 二分查找</h4><p>二分法的使用前提：数组为有序数组，且数组中无重复元素。满足这两个性质的题目可尝试二分法。</p>
<p>二分法中区间的定义有两种：左闭右闭和左闭右开。<strong>每一次边界的处理都要坚持根据区间的定义来操作</strong>。</p>
<h4 id="Leetcode-27-移除元素-1"><a href="#Leetcode-27-移除元素-1" class="headerlink" title="Leetcode 27 移除元素"></a>Leetcode 27 移除元素</h4><p>暴力做法：遍历数组-&gt;找到需要移除的元素-&gt;将该元素后面的所有元素都前移一位-&gt;索引前移一位，数组长度减1</p>
<p>双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Leetcode-704-二分查找-2"><a href="#Leetcode-704-二分查找-2" class="headerlink" title="Leetcode 704 二分查找"></a>Leetcode 704 二分查找</h3><p>cpp中的vector中求数组的长度没有len函数，应该用size函数。</p>
<p>cpp中两个整数的做除法如果得到的结果变量类型为整数，则是向下取整的。</p>
<p>cpp中的vector是动态数组，要先向用push_back向其中添加元素，然后才能通过索引来访问元素。</p>
<p>左闭右闭和左闭右开的写法中，需要注意right初始值的选取的不同（由于一种写法的右边界可以取到，另一种写法的右边界取不到）。还需要注意分成三类讨论，即target &gt; nums[mid], target &lt; nums[mid]和target == nums[mid]。这样就可以避免处理大于等于和小于等于的情况。</p>
<p>返回总是返回mid，不要尝试返回l或者r，可能会遇到边界问题。</p>
<p>用(l + r) &gt;&gt; 1比(l + r) / 2要更快一点。</p>
<p>建议采用l + (r - l) / 2代替(r + l) / 2，前者可以防止(r + l)溢出整数的范围。</p>
<p>时间复杂度：O(log n)<br>空间复杂度：O(1)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左闭右闭，因此要求左右边界均可取到，因此r的值要与右边界的索引相同</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">// (l + r) &gt;&gt; 1速度更快</span></span><br><span class="line">            <span class="comment">// 分三类情况讨论</span></span><br><span class="line">            <span class="comment">// 因为区间是右闭的，所以r不可能取为mid，最大为mid - 1</span></span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[mid]) r = mid - <span class="number">1</span>; </span><br><span class="line">            <span class="comment">// 因为区间是左闭的，所以l不可能取为mid，最小为mid + 1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// return l/r都是错误的，可以通过模拟一个输入知道错误原因</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右开写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左闭右开，因此target不能取为右边界的值，要保证区间完全覆盖住target，因此r的值要比右边界的索引大1</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右边界取不到，因此是l &lt; r</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 因为区间是左闭的，所以l不可能取为mid，最小为mid + 1</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 因为区间是右开的，所以r可以取为mid</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) r = mid;</span><br><span class="line">            <span class="comment">// return l是错误的，可以通过模拟一个输入知道错误原因</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-27-移除元素-2"><a href="#Leetcode-27-移除元素-2" class="headerlink" title="Leetcode 27 移除元素"></a>Leetcode 27 移除元素</h3><h4 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h4><p>若不前移i，则若数组中出现连续的两个val时，结果会发生错误，不能完全移除数组中所有的val。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历数组，找到需要移除的元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将该元素后面的所有元素都前移一位，覆盖掉需要移除的元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j ++ )</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                <span class="comment">// 索引前移一位，数组长度减1</span></span><br><span class="line">                i -- ;</span><br><span class="line">                size -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p>
<h4 id="快慢双指针做法"><a href="#快慢双指针做法" class="headerlink" title="快慢双指针做法"></a>快慢双指针做法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快指针用于遍历所有元素、慢指针用于记录更新后数组的下标</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); fast ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val)</span><br><span class="line">                nums[slow ++ ] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="相向双指针做法"><a href="#相向双指针做法" class="headerlink" title="相向双指针做法"></a>相向双指针做法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相向双指针方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 跳过所有不需要移除的元素，剩下需要移除的元素</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] != val) l ++ ;</span><br><span class="line">            <span class="comment">// 跳过所有需要移除的元素，剩下不需要移除的元素</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[r] == val) r -- ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将右边不需要移除的元素覆盖掉左边需要移除的元素(交换左右两边的元素)</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) nums[l ++ ] = nums[r -- ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回左边的最后一个值的索引</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<p>注意：while (l &lt;= r &amp;&amp; nums[l] != val)和while (l &lt;= r &amp;&amp; nums[r] == val)中的两个判断条件不可以写反，否则会出现Runtime Error。这是因为短路原则，最好先进行边界检查，再访问数组。</p>
<p>逻辑：数组的左边放等于val的元素，因此需要跳过所有不等于val的元素；数组的右边放不等于val的元素，因此需要跳过所有等于val的元素。交换数组的左右两边，让数组的左边放不等于val的元素，数组的右边放等于val的元素，然后输出数组左边的最后一个值的索引。</p>
<p>相向双指针方法的基本过程我大致理解了，但还不理解其的细节和应用。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="Leetcode-704-二分查找-3"><a href="#Leetcode-704-二分查找-3" class="headerlink" title="Leetcode 704 二分查找"></a>Leetcode 704 二分查找</h3><p>我认为代码随想录的做法比yxc的讲解更加清晰。清楚地归纳总结出了左闭右闭和左闭右开的写法，并根据选择区间的开闭性质清晰地写出了代码。同时，分成三类讨论，避免了处理大于等于和小于等于的情况。</p>
<p>还没有做35和34，等到二刷来做。</p>
<h3 id="Leetcode-27-移除元素-3"><a href="#Leetcode-27-移除元素-3" class="headerlink" title="Leetcode 27 移除元素"></a>Leetcode 27 移除元素</h3><p>相向双指针方法的理解有待加深。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/21/Django-Project-Summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/21/Django-Project-Summary/" class="post-title-link" itemprop="url">Django Project Summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-21 21:23:39" itemprop="dateCreated datePublished" datetime="2024-01-21T21:23:39+00:00">2024-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-22 03:39:00" itemprop="dateModified" datetime="2024-01-22T03:39:00+00:00">2024-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">web开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Django项目总结"><a href="#Django项目总结" class="headerlink" title="Django项目总结"></a>Django项目总结</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>Game based on Django framework, developed by yifanChen</p>
<h3 id="Website"><a href="#Website" class="headerlink" title="Website"></a>Website</h3><p><a target="_blank" rel="noopener" href="https://app5894.acapp.acwing.com.cn/">https://app5894.acapp.acwing.com.cn/</a></p>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p><a target="_blank" rel="noopener" href="https://github.com/yfchenkeepgoing/Django_app">https://github.com/yfchenkeepgoing/Django_app</a></p>
<h3 id="Gameplay"><a href="#Gameplay" class="headerlink" title="Gameplay"></a>Gameplay</h3><ol>
<li>Right-click to move</li>
<li>Left-click plus ‘Q’ for the skill: Fireball, with a cooldown of 3 seconds</li>
<li>Left-click plus ‘F’ for the skill: Flash, with a cooldown of 5 seconds</li>
<li>In multiplayer mode, the winning player gains 10 points, and the losing player loses 5 points</li>
</ol>
<h3 id="Technology-Stack"><a href="#Technology-Stack" class="headerlink" title="Technology Stack"></a>Technology Stack</h3><ol>
<li>Frontend: JQuery</li>
<li>Backend: Django</li>
<li>Database: SQLite, Redis</li>
<li>Network Protocols: HTTPS, WSS</li>
<li>RPC: Thrift</li>
<li>Authorization Protocol: OAuth</li>
<li>Authentication: JWT</li>
</ol>
<h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ol>
<li>Complete menu interface and game interface</li>
<li>Frontend and backend separation, with AcApp and Web versions on the frontend</li>
<li>Deployed with Nginx to interface with the AcApp</li>
<li>Comprehensive account system, username and password login, and one-click login with AcWing &amp; GitHub OAuth</li>
<li>Online multiplayer and chat system implemented via WSS protocol</li>
<li>Matchmaking system implemented through Thrift service</li>
<li>Cross-origin issues resolved through Rest Framework and JWT authentication, achieving complete frontend-backend separation</li>
<li>The ranking board displays the top ten players ranked by score</li>
</ol>
<h2 id="Django项目的框架"><a href="#Django项目的框架" class="headerlink" title="Django项目的框架"></a>Django项目的框架</h2><p>一个Django项目，大致由以下六部分组成：</p>
<ol>
<li>templates目录：管理html文件</li>
<li>urls目录：管理路由，即链接与函数的对应关系，即每个链接交给哪个函数处理的信息，存储在urls文件夹中。</li>
<li>views目录：视图，管理http函数（函数实现在views目录中）</li>
<li>models目录：管理数据库数据。</li>
<li>consumers目录：管理websocket函数（views管理http函数，即负责单向连接的函数；consumers管理双向连接的函数，比如联机对战和聊天的逻辑）</li>
<li>static目录：管理静态文件，比如：</li>
</ol>
<ul>
<li>css文件：对象的格式（网页每部分的格式），比如位置、长宽、颜色、背景、字体大小等</li>
<li>js：对象的逻辑（项目的核心），比如对象的创建与销毁、事件函数、移动、变色等，渲染html也会在js部分（前端）</li>
<li>image：图片</li>
<li>audio：声音</li>
</ul>
<p>urls文件夹、views文件夹、models文件夹和consumers文件夹都由python文件组成，如果想通过import将文件导入，则需要在文件夹下创建 <code>__init__.py</code>文件（即索引文件，内容为空即可）。在所有python文件夹中都需要创建这样的函数，否则在import时就无法进去，会报错。</p>
<h2 id="项目核心逻辑"><a href="#项目核心逻辑" class="headerlink" title="项目核心逻辑"></a>项目核心逻辑</h2><p>本项目由于是一个小游戏，因此前端的js代码占比较大。游戏单人模式的实现纯粹由前端完成，我用js代码实现了一个简易的游戏引擎。游戏的单人模式不需要前后端交互。</p>
<p>需要前后端交互的部分有：</p>
<ol>
<li>注册与登录：涉及到写入、读取、查询数据库</li>
<li>acwing和GitHub一键登录：即OAuth授权登录</li>
<li>实现联机对战和聊天系统：涉及到在多名玩家之间同步五个事件（函数）：create_player, move_to, shoot_fireball, attack, message。前四个用于实现联机对战，最后一个用于实现聊天系统。</li>
<li>Rest Framework与JWT身份验证：是对第一点和第二点的补充。</li>
</ol>
<ul>
<li>JWT（json web token）相比于django自带的登录验证方式（通过session_id）安全性更高。</li>
<li>方便实现真正意义上的前后端分离，即后端只需要提供实现好的api给前端调用，而Rest Framework为这些api的调试提供了可视化界面。</li>
<li>JWT可以解决跨域产生的问题。</li>
<li>可以使用http的四大类请求方法：get, post, delete, put，而不像之前仅仅使用get方法，这又提高了令牌的安全性。</li>
</ul>
<p>纯后端的部分只有匹配系统的实现。匹配系统的实现涉及到两个后端（即django web server和match system）之间的通信，匹配系统本身涉及到多线程和锁等方面的知识。</p>
<p>我认为本项目的重点主要在于前后端交互的部分，前后端交互其实有一套统一的范式：先在views中实现后端的函数；然后在urls中为后端的函数定义url链接；再在前端代码中利用ajax技术通过url获得后端传来的数据（前后端一般以json的格式传递数据）；最后通过前端使用或展示数据。如果给用户设计了一套通过点击鼠标或者使用键盘向后端请求数据的模式，那么还需要在前端进行按键索引和绑定监听函数等操作。</p>
<h2 id="改进项目"><a href="#改进项目" class="headerlink" title="改进项目"></a>改进项目</h2><ol>
<li>使用功能更强大的前端框架，比如Vue或者React，取代简单的JQuey。</li>
<li>使用更多种类型的数据库，比如关系型数据库MySQL，文档数据库MongoDB，对象存储服务等等。</li>
<li>使用另外几种实现前后端通信的技术取代ajax，比如Fetch API，Server-Sent Events (SSE)，GraphQL和WebRTC，以提高系统的性能。</li>
<li>学习并尝试使用Springboot框架和Go语言的后端框架。</li>
<li>使用k8s来自动化部署、扩展和管理容器化应用程序。</li>
</ol>
<h2 id="漫谈"><a href="#漫谈" class="headerlink" title="漫谈"></a>漫谈</h2><h3 id="后端的主要分类"><a href="#后端的主要分类" class="headerlink" title="后端的主要分类"></a>后端的主要分类</h3><p>算法与推荐系统、开发各种服务、数据库</p>
<h3 id="对于实现客户端与服务器之间的通信功能的技术的选择"><a href="#对于实现客户端与服务器之间的通信功能的技术的选择" class="headerlink" title="对于实现客户端与服务器之间的通信功能的技术的选择"></a>对于实现客户端与服务器之间的通信功能的技术的选择</h3><p>除了AJAX，现代Web开发中还有几种其他技术可以实现类似的客户端与服务器之间的通信功能。一些技术在特定场景下比AJAX更高效。以下是一些常用的技术：</p>
<ol>
<li><strong>Fetch API</strong>： Fetch API提供了一种更简洁和强大的方式来发起网络请求。它基于Promise，使得写异步代码更加简洁和直观。Fetch API是AJAX的现代替代方案，被广泛支持和使用。</li>
<li><strong>WebSocket</strong>： WebSocket提供了全双工通信渠道，使得客户端和服务器可以实时、双向地通信。它非常适用于需要频繁和即时数据更新的应用，如在线游戏、聊天应用和实时数据流。</li>
<li><strong>Server-Sent Events (SSE)</strong>： SSE允许服务器主动向客户端发送新数据。它是单向的，只有服务器可以发送消息给客户端。SSE适合实现如股票行情、新闻订阅等场景，其中服务器定期推送更新。</li>
<li><strong>GraphQL</strong>： GraphQL是一种数据查询和操作语言，它允许客户端以更灵活的方式请求数据。与REST相比，GraphQL可以减少数据传输量，因为它允许客户端精确指定所需的数据。</li>
<li><strong>WebRTC</strong>： WebRTC（Web Real-Time Communication）允许在不需要安装插件的情况下在Web应用中实现实时通信功能，常用于视频聊天和点对点数据共享。</li>
</ol>
<p>每种技术都有其特定的应用场景和优势。选择哪一种技术取决于应用的具体需求：</p>
<ul>
<li>对于简单的异步数据请求，AJAX和Fetch API都是不错的选择。</li>
<li>对于需要高实时性的应用，WebSocket或WebRTC可能更合适。</li>
<li>对于服务器主动推送数据的场景，SSE是一个好的选择。</li>
<li>对于需要更灵活数据交互的场景，GraphQL提供了更好的解决方案。</li>
</ul>
<p>在性能方面，WebSocket和WebRTC通常在需要频繁和快速通信的场景下比AJAX更高效，因为它们建立了持久的连接，而不是像AJAX那样为每个请求创建新的连接。</p>
<h3 id="如何使用MySQL，MongoDB，对象存储服务等外置的数据库（它们不像sqlite，不集成于后端框架内）"><a href="#如何使用MySQL，MongoDB，对象存储服务等外置的数据库（它们不像sqlite，不集成于后端框架内）" class="headerlink" title="如何使用MySQL，MongoDB，对象存储服务等外置的数据库（它们不像sqlite，不集成于后端框架内）"></a>如何使用MySQL，MongoDB，对象存储服务等外置的数据库（它们不像sqlite，不集成于后端框架内）</h3><ul>
<li>租一台数据库服务器</li>
<li>在框架中负责数据库的部分配置数据库服务器的连接/登录</li>
<li>下载该框架下使用该种数据库的包</li>
<li>在框架中负责数据库的部分调用包中的api完成对数据库的各种操作，比如读、写、删除等。</li>
</ul>
<p>在 Django 中，通常不需要直接使用 SQL 语句来操作 MySQL 数据库，因为 Django 提供了一个强大的 ORM（对象关系映射）系统，允许你通过 Python 代码来操作数据库。这意味着你可以使用 Django 的模型和查询 API 来查询和操作数据，而无需直接编写 SQL 语句。</p>
<p>Django 本身不直接支持 MongoDB，因为它是一个 NoSQL 数据库，与 Django 的 ORM 系统设计理念不同。如果你想在 Django 项目中使用 MongoDB，可以采取以下方法：</p>
<ul>
<li>使用 Djongo： Djongo 是一个将 Django ORM 映射到 MongoDB 的工具。通过 Djongo，你可以在一定程度上使用 Django ORM 的风格来操作 MongoDB。</li>
<li>使用 PyMongo： PyMongo 是 MongoDB 的官方 Python 驱动程序。使用 PyMongo，你可以直接以 Python 代码与 MongoDB 交互，但这意味着你需要手动编写数据库操作逻辑，而不是使用 Django ORM。</li>
</ul>
<p>对于对象存储服务（如 Amazon S3），通常使用的是 RESTful API 而非传统的数据库查询语言。在 Django 项目中使用对象存储通常涉及以下步骤：</p>
<ul>
<li>选择合适的库： 例如，对于 Amazon S3，你可以使用 boto3，这是 AWS 的官方 Python SDK。</li>
<li>进行配置和认证： 通常需要设置认证凭据和相关配置。</li>
<li>使用 SDK 提供的 API： 使用 SDK 提供的方法来上传、下载、列出文件等。</li>
</ul>
<h3 id="JWT可以存放在内存、local-storage和cookie中，这三个存放地各自有优缺点"><a href="#JWT可以存放在内存、local-storage和cookie中，这三个存放地各自有优缺点" class="headerlink" title="JWT可以存放在内存、local storage和cookie中，这三个存放地各自有优缺点"></a>JWT可以存放在内存、local storage和cookie中，这三个存放地各自有优缺点</h3><p>Cookie：<br>优点：自动由浏览器管理，并且可以设置为HttpOnly（无法通过JavaScript访问，增加安全性），支持跨域访问控制（SameSite属性）。<br>缺点：容易受到CSRF（跨站请求伪造）攻击，尽管可以通过适当的防范措施（如使用CSRF Token）来缓解。</p>
<p>LocalStorage：<br>优点：易于使用，可以在浏览器会话间持久存储。<br>缺点：容易受到XSS（跨站脚本攻击）攻击，因为恶意脚本可以访问LocalStorage并窃取令牌。</p>
<p>内存（JavaScript变量）：<br>优点：在浏览器关闭时自动清除，不容易受到XSS攻击（只要不将令牌暴露给恶意脚本）。<br>缺点：不持久，用户刷新页面或关闭浏览器时会丢失，可能需要重新认证。</p>
<p>最佳实践：<br>安全性考虑：通常推荐将JWT存储在HttpOnly的Cookie中，因为这样可以防止JavaScript访问令牌，从而减少XSS攻击的风险。</p>
<p>CSRF防范：如果使用Cookie，应结合CSRF保护机制。</p>
<p>易用性：如果需要在会话间持久保存用户的登录状态，LocalStorage可能更为方便。但是，务必注意XSS攻击的风险，并采取适当的安全措施。</p>
<p>短期使用：对于需要高安全性且可接受在会话结束后用户需要重新登录的场景，可以考虑仅将JWT存储在内存中。</p>
<p>在实践中，选择哪种方式取决于应用的安全需求、用户体验需求以及开发者对相关安全风险的管理能力。在处理任何形式的认证信息时，安全总是首要考虑的因素。<strong>在本项目中，出于安全性和短期使用的考量，我将JWT存储在了内存，即js变量中</strong>。如果没有明确地将JWT存储在Local Storage或Cookie中，那么它们就是存储在内存中。这意味着令牌只在当前页面会话中有效，一旦页面被关闭或刷新，令牌就会丢失。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/21/How-to-Migrate-and-Restart-a-Cloud-Server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/21/How-to-Migrate-and-Restart-a-Cloud-Server/" class="post-title-link" itemprop="url">How to Migrate and Restart a Cloud Server</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-21 19:31:01 / 修改时间：19:35:51" itemprop="dateCreated datePublished" datetime="2024-01-21T19:31:01+00:00">2024-01-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工具使用</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="迁移云服务器"><a href="#迁移云服务器" class="headerlink" title="迁移云服务器"></a>迁移云服务器</h1><h2 id="1、租云服务器，配置其免密登录"><a href="#1、租云服务器，配置其免密登录" class="headerlink" title="1、租云服务器，配置其免密登录"></a>1、租云服务器，配置其免密登录</h2><p>将本地的公钥复制到云服务器的~/.ssh/authorized_keys中，或者使用云服务器平台提供的密钥，在本地的.ssh文件夹中添加密钥在本地的位置<br>第一次登录云服务器（未配置免密登录）的具体流程可以参照以下步骤：</p>
<p>IR_Group_7_project Demo Instruction</p>
<ol>
<li>Login our VM instance<br>Move key to secure location (eg. ~/.ssh in linux), then</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 path/to/shaoxi_key.pem</span><br><span class="line">ssh -i path/to/shaoxi_key.pem shaoxi@52.174.147.101</span><br></pre></td></tr></table></figure>
<h2 id="2、在云服务器中安装docker"><a href="#2、在云服务器中安装docker" class="headerlink" title="2、在云服务器中安装docker"></a>2、在云服务器中安装docker</h2><p>安装步骤参见官网：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a><br>一般安装的版本为20.10.9，使用命令：<code>VERSION_STRING=5:20.10.9~3-0~ubuntu-focal</code><br>查看docker是否安装成功：<code>docker --version</code></p>
<h2 id="3、在云服务器平台开放以下端口"><a href="#3、在云服务器平台开放以下端口" class="headerlink" title="3、在云服务器平台开放以下端口"></a>3、在云服务器平台开放以下端口</h2><p>22， 8000， 443， 80， 20000，协议均为TCP，源和目的地都为任何（0.0.0.0）</p>
<h2 id="4、将本地的C-Users-chen-yi-fan-django-lesson-1-tar上传到云服务器里"><a href="#4、将本地的C-Users-chen-yi-fan-django-lesson-1-tar上传到云服务器里" class="headerlink" title="4、将本地的C:\Users\chen yi fan\django_lesson_1.tar上传到云服务器里"></a>4、将本地的C:\Users\chen yi fan\django_lesson_1.tar上传到云服务器里</h2><p>在powershell中执行的具体的命令为：<br><code>scp .\django_lesson_1.tar azureuser@20.123.135.13:~/</code></p>
<h2 id="5、将镜像xxxx从本地文件xxxx-tar中加载出来"><a href="#5、将镜像xxxx从本地文件xxxx-tar中加载出来" class="headerlink" title="5、将镜像xxxx从本地文件xxxx.tar中加载出来"></a>5、将镜像xxxx从本地文件xxxx.tar中加载出来</h2><p><code>sudo docker load -i xxxx.tar</code></p>
<h2 id="6、查看镜像是否成功加载出来"><a href="#6、查看镜像是否成功加载出来" class="headerlink" title="6、查看镜像是否成功加载出来"></a>6、查看镜像是否成功加载出来</h2><p>查看所有镜像的命令: <code>sudo docker images</code></p>
<h2 id="7、使用镜像重新创建并运行容器"><a href="#7、使用镜像重新创建并运行容器" class="headerlink" title="7、使用镜像重新创建并运行容器"></a>7、使用镜像重新创建并运行容器</h2><p><code>docker run -p 20000:22 -p 8000:8000 -p 80:80 -p 443:443 --name django_server -itd django_lesson:1.1</code></p>
<h2 id="8、登录到容器中"><a href="#8、登录到容器中" class="headerlink" title="8、登录到容器中"></a>8、登录到容器中</h2><p><code>sudo docker attach django_server</code><br>登录为root用户</p>
<h2 id="9、创建非root用户"><a href="#9、创建非root用户" class="headerlink" title="9、创建非root用户"></a>9、创建非root用户</h2><p><code>adduser acs</code><br>赋予其sudo权限：<code>usermod -aG sudo acs</code><br>设置密码</p>
<h2 id="10、配置容器的免密登录"><a href="#10、配置容器的免密登录" class="headerlink" title="10、配置容器的免密登录"></a>10、配置容器的免密登录</h2><p>配置免密登录的过程是：在容器的.ssh/authorized_keys中写入本地的.ssh文件夹（C:\Users\chen yi fan.ssh）中的公钥的内容<br>然后修改本地的.ssh/config文件，添加容器的信息，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host django_azure</span><br><span class="line">    HostName 20.123.135.13</span><br><span class="line">    User acs</span><br><span class="line">    Port 20000</span><br></pre></td></tr></table></figure>
<h2 id="11、从本地-其他云服务器上登录到容器的命令"><a href="#11、从本地-其他云服务器上登录到容器的命令" class="headerlink" title="11、从本地/其他云服务器上登录到容器的命令"></a>11、从本地/其他云服务器上登录到容器的命令</h2><p><code>ssh acs@ip -p 20000</code><br>退出容器时注意不要关闭容器，而是挂起容器：ctrl+p ctrl+q</p>
<h2 id="12、完成容器的一些配置："><a href="#12、完成容器的一些配置：" class="headerlink" title="12、完成容器的一些配置："></a>12、完成容器的一些配置：</h2><p>nginx配置：<br>（1）修改yxc的acapp中的服务器IP<br>（2）将服务器的IP添加到项目的settings.py的ALLOWED_HOSTS中<br>（3）将yxc提供的nginx.conf写入容器的/etc/nginx/nginx.conf文件中<br>（4）将yxc提供的acapp.key写入容器的/etc/nginx/cert/acapp.key文件中<br>（5）将yxc提供的acapp.pem写入容器的/etc/nginx/cert/acapp.pem文件中<br>（6）启动nginx服务：<code>sudo /etc/init.d/nginx start</code><br>（7）启动uwsgi服务：<code>uwsgi --ini scripts/uwsgi.ini</code></p>
<p>redis配置：<br>（1）安装redis：<code>pip install django_redis</code><br>（2）启动redis-server：<code>sudo redis-server /etc/redis/redis.conf</code><br>（3）用<code>top</code>命令看有没有进程叫redis-server</p>
<p>django channels配置：<br>（1）安装channels_redis：<code>pip install channels_redis</code><br>（2）启动django_channels：<br>  在~/acapp目录下执行：<code>daphne -b 0.0.0.0 -p 5015 acapp.asgi:application</code></p>
<p>同时启动https（uwsgi）和wss（daphne）协议的服务后，项目就应该可以正常运行</p>
<h2 id="13、启动https和wss服务"><a href="#13、启动https和wss服务" class="headerlink" title="13、启动https和wss服务"></a>13、启动https和wss服务</h2><p>启动https服务：<code>uwsgi --ini scripts/uwsgi.ini</code></p>
<p>启动wss服务：<code>daphne -b 0.0.0.0 -p 5015 acapp.asgi:application</code></p>
<hr>
<h1 id="重启云服务器"><a href="#重启云服务器" class="headerlink" title="重启云服务器"></a>重启云服务器</h1><p>在云平台暂停云服务器后重新启动服务器并进入容器</p>
<h2 id="1-在云平台启动云服务器"><a href="#1-在云平台启动云服务器" class="headerlink" title="1. 在云平台启动云服务器"></a>1. 在云平台启动云服务器</h2><p>需要等待5-10分钟才能完成重启的过程</p>
<h2 id="2-查看云服务器中已有的容器"><a href="#2-查看云服务器中已有的容器" class="headerlink" title="2. 查看云服务器中已有的容器"></a>2. 查看云服务器中已有的容器</h2><p>运行命令：<code>sudo docker ps -a</code></p>
<h2 id="3-启动被暂停-退出的容器"><a href="#3-启动被暂停-退出的容器" class="headerlink" title="3. 启动被暂停/退出的容器"></a>3. 启动被暂停/退出的容器</h2><p>运行命令：<code>sudo docker start django_server</code></p>
<h2 id="4-进入容器"><a href="#4-进入容器" class="headerlink" title="4. 进入容器"></a>4. 进入容器</h2><p>在vscode上选择django_azure，点击进入即可</p>
<h2 id="5-启动容器中的服务"><a href="#5-启动容器中的服务" class="headerlink" title="5. 启动容器中的服务"></a>5. 启动容器中的服务</h2><p>主要需要启动以下五个服务：</p>
<p>启动nginx服务：<code>sudo /etc/init.d/nginx start</code></p>
<p>启动redis-server：<code>sudo redis-server /etc/redis/redis.conf</code></p>
<p>启动uwsgi（https）服务：<code>uwsgi --ini scripts/uwsgi.ini</code></p>
<p>启动wss服务：<code>daphne -b 0.0.0.0 -p 5015 acapp.asgi:application</code></p>
<p>启动match system服务：<code>./main.py</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/20/Blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/20/Blog/" class="post-title-link" itemprop="url">How to Build and Maintain a Personal Blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-20 05:57:24 / 修改时间：09:58:31" itemprop="dateCreated datePublished" datetime="2024-01-20T05:57:24+00:00">2024-01-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工具使用</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="如何搭建和维护个人博客"><a href="#如何搭建和维护个人博客" class="headerlink" title="如何搭建和维护个人博客"></a>如何搭建和维护个人博客</h1><h2 id="个人博客的实现方式"><a href="#个人博客的实现方式" class="headerlink" title="个人博客的实现方式"></a>个人博客的实现方式</h2><p>使用GitHub Pages和Hexo框架搭建和维护个人博客</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="注意1"><a href="#注意1" class="headerlink" title="注意1"></a>注意1</h3><p>尽量避免在一点不止一行的情况下使用：</p>
<p>的结构，因为这会导致网页上的博客渲染异常。在这种情况下，建议每一点使用一个小标题</p>
<h3 id="注意2"><a href="#注意2" class="headerlink" title="注意2"></a>注意2</h3><p>在线博客的刷新需要几分钟时间，请在更新博客后稍安勿躁。在线博客各部分的更新速度不同，比如博客内容先更新了，但日志还没有更新，这是正常现象，稍稍等待即可</p>
<h3 id="注意3"><a href="#注意3" class="headerlink" title="注意3"></a>注意3</h3><p>由于托管博客的仓库有两个分支，其中的master分支总会在我部署博客时实时更新，因此source分支在发布新博客时更新即可，不需要实时更新</p>
<h3 id="注意4"><a href="#注意4" class="headerlink" title="注意4"></a>注意4</h3><p>使用VSCode在本地编辑博客即可，博客的内容可以复制自Typora，在VSCode中点击md文件左上角的铅笔符号（Edit in VSCode）即可在VSCode中编辑博客内容，每次编辑完后记得运行部署脚本将博客更新部署到网站上</p>
<h2 id="博客结构"><a href="#博客结构" class="headerlink" title="博客结构"></a>博客结构</h2><p>本博客计划同时按照标签页（tags）和分类页（categories）进行分类。分类是更大的范畴，主要分为算法、web开发、工具使用、个人随笔和找工记录五大类。标签页是更小的范畴，有Python, C++, Java, Django, Springboot, Typora, GitHub Pages, Hexo, VsCode, 简历等等。一般一篇文章只隶属于一个category，但可以同时拥有多个标签。</p>
<p>本博客可以通过网址：<br><a target="_blank" rel="noopener" href="https://yfchenkeepgoing.github.io/">https://yfchenkeepgoing.github.io/</a><br>访问，注意由于GitHub Pages是静态网页，因此出现延迟请稍安勿躁。另外，本博客所在的仓库地址为：<a target="_blank" rel="noopener" href="https://github.com/yfchenkeepgoing/yfchenkeepgoing.github.io">https://github.com/yfchenkeepgoing/yfchenkeepgoing.github.io</a><br>其中有两个分支，分别为master和source。master托管了正在运行的博客，其中的内容在每次运行部署脚本后就会被更新。source托管了博客文件夹的所有源文件，需要通过git命令进行更新。博客网页与master分支中的内容进行了绑定。</p>
<h2 id="个人博客的特点和功能"><a href="#个人博客的特点和功能" class="headerlink" title="个人博客的特点和功能"></a>个人博客的特点和功能</h2><ol>
<li>配置站点信息</li>
<li>修改为next主题</li>
<li>进行了next主题的配置，包括样式、favicon、avatar、rss、code、top、reading_process、bookmark、github_banner、pangu、math、pjax</li>
<li>采用gitalk存储并显示评论，需要评论者使用GitHub登录</li>
<li>使用了标签页和分类页</li>
<li>拥有搜索页</li>
</ol>
<h2 id="如何搭建个人博客"><a href="#如何搭建个人博客" class="headerlink" title="如何搭建个人博客"></a>如何搭建个人博客</h2><p>参见知乎链接：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/371995929">https://zhuanlan.zhihu.com/p/371995929</a></p>
<p>其中指导非常详细，但过程较为繁琐，本文不再赘述。本文的重点在于如何维护搭建好的个人博客。</p>
<h2 id="如何维护个人博客"><a href="#如何维护个人博客" class="headerlink" title="如何维护个人博客"></a>如何维护个人博客</h2><h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><p>进入博客的根目录下，然后调用 Hexo 的 generate 命令，将 Hexo 编译生成 HTML 代码，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>然后我们利用 Hexo 提供的 serve 命令把博客在本地运行起来，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo serve</span><br></pre></td></tr></table></figure>
<p>然后通过链接：<a target="_blank" rel="noopener" href="http://localhost:4000/即可访问到渲染出的博客页面。注意：在这种情况下，博客页面只对自己可见，因此上述命令只能用于调试。">http://localhost:4000/即可访问到渲染出的博客页面。注意：在这种情况下，博客页面只对自己可见，因此上述命令只能用于调试。</a></p>
<h3 id="维护在线博客"><a href="#维护在线博客" class="headerlink" title="维护在线博客"></a>维护在线博客</h3><h4 id="增加新的文章并将其分类到特定的tags和categories中"><a href="#增加新的文章并将其分类到特定的tags和categories中" class="headerlink" title="增加新的文章并将其分类到特定的tags和categories中"></a>增加新的文章并将其分类到特定的tags和categories中</h4><p>新建一篇名为HelloWorld的文章，在本地博客的根目录下执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new hello-world</span><br></pre></td></tr></table></figure>
<p>创建的文章会出现在 source/_posts 文件夹下，是 MarkDown 格式。<br>在文章开头通过如下格式添加必要信息：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hello-world # 自动创建，如hello<span class="emphasis">_world</span></span><br><span class="line"><span class="emphasis">date: 日期 # 自动创建，如2024-01-20 02:07:51</span></span><br><span class="line"><span class="emphasis">tags: </span></span><br><span class="line"><span class="emphasis">- 标签1</span></span><br><span class="line"><span class="emphasis">- 标签2</span></span><br><span class="line"><span class="emphasis">- 标签3</span></span><br><span class="line"><span class="emphasis">categories:</span></span><br><span class="line"><span class="emphasis">- 分类1</span></span><br><span class="line"><span class="emphasis">- 分类2</span></span><br><span class="line"><span class="emphasis">- 分类3</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure>
<p>开头下方撰写正文，MarkDown 格式书写即可。这样在下次编译的时候就会自动识别标题、时间、类别等等，另外还有其他的一些参数设置，可以参考文档：<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/writing.html">https://hexo.io/zh-cn/docs/writing.html</a></p>
<h4 id="标签和分类的区别"><a href="#标签和分类的区别" class="headerlink" title="标签和分类的区别"></a>标签和分类的区别</h4><p><strong>Tags（标签）</strong>：<br>标签是用来描述博客文章中的具体细节的关键词。<br>它们是扁平的，不形成层次结构。<br>标签可以非常具体，也可以非常多，用于描述文章的具体内容，如“Python”、“Web开发”、“机器学习”等。<br><strong>一个文章可以有多个标签，标签的数量通常比分类多</strong>。</p>
<p><strong>Categories（分类）</strong>：<br>分类通常用来表示博客文章的主要主题或大的分组。<br>它们是层次性的，可以有子分类，形成一个结构化的树状层次，例如：“技术”可以有子分类如“编程”、“网页设计”等。<br>分类通常较少，更宽泛，用于将文章分配到几个广泛的、互相排斥的主题中。<br><strong>一个博客文章通常只属于一个或少数几个分类</strong>。</p>
<p>使用示例：<br>假设您写了一篇关于Python网络编程的博客文章。您可以将这篇文章归类到“编程”分类下，并给它加上“Python”、“网络编程”、“套接字编程”等标签。</p>
<p><strong>总结：<br>分类用于表示文章的主要主题，是更广泛的分组工具。<br>标签用于详细描述文章的内容和细节，是更具体的关键词。</strong></p>
<h4 id="通过部署脚本部署在线博客"><a href="#通过部署脚本部署在线博客" class="headerlink" title="通过部署脚本部署在线博客"></a>通过部署脚本部署在线博客</h4><p>在根目录下新建一个 deploy.sh 的脚本文件，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>在部署发布的时候只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh deploy.sh</span><br></pre></td></tr></table></figure>
<p>就可以完成博客的更新了，非常方便。</p>
<p>注意，在发布博客时只能执行上述命令，不能执行 <code>./deploy.sh</code>，否则博客无法正常发布。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/20/Typora/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/20/Typora/" class="post-title-link" itemprop="url">How to use Typora</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-20 02:07:51" itemprop="dateCreated datePublished" datetime="2024-01-20T02:07:51+00:00">2024-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-21 17:07:23" itemprop="dateModified" datetime="2024-01-21T17:07:23+00:00">2024-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工具使用</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="（1）标题"><a href="#（1）标题" class="headerlink" title="（1）标题"></a>（1）标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="（2）快捷键"><a href="#（2）快捷键" class="headerlink" title="（2）快捷键"></a>（2）快捷键</h2><p>普通模式和源代码模式：ctrl+/<br>md语法正确显示需要在有文字的一行后面再空一行，把鼠标放在有文字的最后一行的后两行的位置</p>
<p>标题：按下ctrl和+，则当前行变成第六级的标题，每按一次ctrl和+则当前标题的等级提升一级。按下ctrl和-则是按下ctrl和+的逆向操作。</p>
<h2 id="（3）字体"><a href="#（3）字体" class="headerlink" title="（3）字体"></a>（3）字体</h2><p><strong>加粗</strong><br><em>倾斜</em><br><strong><em>斜体加粗</em></strong><br><del>删除线</del> （~<em>2删除线~</em>2）<br>==高亮==<br>我是^上标^<br>我是~下标~       （注意用英文的~）</p>
<h2 id="（4）列表"><a href="#（4）列表" class="headerlink" title="（4）列表"></a>（4）列表</h2><p>无序列表：<br>下一级是加号前面空两格<br>第一级是实心的圆，第二级是空心的圆，第三级开始都是实心的小方框</p>
<ul>
<li>一二三四五<ul>
<li>上山打老虎<ul>
<li>老虎没打到<ul>
<li>打到小松鼠</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有序列表：</p>
<ol>
<li>一二三四五</li>
<li>上山打老虎</li>
<li>老虎没达到</li>
<li>打到小松鼠</li>
</ol>
<h2 id="（5）表格"><a href="#（5）表格" class="headerlink" title="（5）表格"></a>（5）表格</h2><div class="table-container">
<table>
<thead>
<tr>
<th>MON</th>
<th>TUE</th>
<th>WED</th>
<th>THU</th>
<th>FRI</th>
</tr>
</thead>
<tbody>
<tr>
<td>上山</td>
<td>上山</td>
<td>上山</td>
<td>上山</td>
<td>上山</td>
</tr>
<tr>
<td>打老虎</td>
<td>打老虎</td>
<td>打老虎</td>
<td>打老虎</td>
<td>打老虎</td>
</tr>
</tbody>
</table>
</div>
<p>在普通模式下，输入：|MON|TUE|WED|THU|FRI|，再输入回车，即可出现表格，可以增加表格的行和列，以及左右居中等等</p>
<h2 id="（6）引用"><a href="#（6）引用" class="headerlink" title="（6）引用"></a>（6）引用</h2><p>下一级别：加一个&gt;</p>
<blockquote>
<p>一二三四五</p>
<blockquote>
<p>上山打老虎</p>
<blockquote>
<p>老虎没达到</p>
<blockquote>
<p>打到小松鼠</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="（7）分割线"><a href="#（7）分割线" class="headerlink" title="（7）分割线"></a>（7）分割线</h2><p>疯狂打——-即可</p>
<hr>
<h2 id="（7）代码"><a href="#（7）代码" class="headerlink" title="==（7）代码=="></a>==（7）代码==</h2><p><code>我是代码</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="（8）字数和侧边栏"><a href="#（8）字数和侧边栏" class="headerlink" title="（8）字数和侧边栏"></a>（8）字数和侧边栏</h2><p>字数在右下角<br>侧边栏在左侧，可以通过在普通模式中点击左下角的小圆圈呼出<br>大纲也在侧边栏中</p>
<h2 id="（9）插入图片"><a href="#（9）插入图片" class="headerlink" title="（9）插入图片"></a>（9）插入图片</h2><p>将图片放入到图片文件夹中，然后复制图片将其直接粘贴进来即可</p>
<p><img src="D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/Snipaste_2023-12-27_04-15-35.png" alt="Snipaste_2023-12-27_04-15-35"></p>
<p><img src="D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/Snipaste_2023-12-27_04-12-14.png" alt="Snipaste_2023-12-27_04-12-14"></p>
<h2 id="（10）改变字体颜色"><a href="#（10）改变字体颜色" class="headerlink" title="（10）改变字体颜色"></a>（10）改变字体颜色</h2><p>将字体改变为红色：<code>&lt;font color=red&gt;</code>文字 <code>&lt;/font&gt;</code></p>
<p>==平常用高亮即可，不要用红色==</p>
<h2 id="11-diff代码块"><a href="#11-diff代码块" class="headerlink" title="(11) diff代码块"></a>(11) diff代码块</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- 这行被删除了</span></span><br><span class="line"><span class="addition">+ 这行被添加了</span></span><br><span class="line">  这行没有改变</span><br></pre></td></tr></table></figure>
<h2 id="12-enter和shift-enter的区别"><a href="#12-enter和shift-enter的区别" class="headerlink" title="(12) enter和shift enter的区别"></a>(12) enter和shift enter的区别</h2><p>enter: 新起一段（空一行）<br>shift enter: 新起一行</p>
<h2 id="13-markdown-source-code"><a href="#13-markdown-source-code" class="headerlink" title="(13) markdown source code"></a>(13) markdown source code</h2><pre><code>
## （1）标题

# 一级标题

## 二级标题

### 三级标题

#### 四级标题

##### 五级标题

###### 六级标题

## （2）快捷键

普通模式和源代码模式：ctrl+/
md语法正确显示需要在有文字的一行后面再空一行，把鼠标放在有文字的最后一行的后两行的位置

标题：按下ctrl和+，则当前行变成第六级的标题，每按一次ctrl和+则当前标题的等级提升一级。按下ctrl和-则是按下ctrl和+的逆向操作。

## （3）字体

**加粗**
*倾斜*
***斜体加粗***
~~删除线~~ （~*2删除线~*2）
==高亮==
我是^上标^
我是~下标~       （注意用英文的~）

## （4）列表

无序列表：
下一级是加号前面空两格
第一级是实心的圆，第二级是空心的圆，第三级开始都是实心的小方框

+ 一二三四五
  + 上山打老虎
    + 老虎没打到
      + 打到小松鼠

有序列表：

1. 一二三四五
2. 上山打老虎
3. 老虎没达到
4. 打到小松鼠

## （5）表格

| MON    | TUE    | WED    | THU    | FRI    |
| ------ | ------ | ------ | ------ | ------ |
| 上山   | 上山   | 上山   | 上山   | 上山   |
| 打老虎 | 打老虎 | 打老虎 | 打老虎 | 打老虎 |

在普通模式下，输入：|MON|TUE|WED|THU|FRI|，再输入回车，即可出现表格，可以增加表格的行和列，以及左右居中等等

## （6）引用

下一级别：加一个>

> 一二三四五
>
>> 上山打老虎
>>
>>> 老虎没达到
>>>
>>>> 打到小松鼠
>>>>
>>>
>>

## （7）分割线

疯狂打-----即可

---

##==（7）代码==

`我是代码`

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## （8）字数和侧边栏

字数在右下角
侧边栏在左侧，可以通过在普通模式中点击左下角的小圆圈呼出
大纲也在侧边栏中

## （9）插入图片

将图片放入到图片文件夹中，然后复制图片将其直接粘贴进来即可

![Snipaste_2023-12-27_04-15-35](D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/Snipaste_2023-12-27_04-15-35.png)

![Snipaste_2023-12-27_04-12-14](D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/Snipaste_2023-12-27_04-12-14.png)

## （10）改变字体颜色

将字体改变为红色：`<font color=red>`文字 `</font>`

==平常用高亮即可，不要用红色==

## (11) diff代码块

<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- 这行被删除了</span></span><br><span class="line"><span class="addition">+ 这行被添加了</span></span><br><span class="line">  这行没有改变</span><br></pre></td></tr></table></figure>

## (12) enter和shift enter的区别

enter: 新起一段（空一行）
shift enter: 新起一行
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/20/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/20/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-20 00:56:39" itemprop="dateCreated datePublished" datetime="2024-01-20T00:56:39+00:00">2024-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yifan Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Yifan Chen</p>
  <div class="site-description" itemprop="description">主要记录算法和web开发方面的心得体会</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yifan Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  


    </div>
</body>
</html>
