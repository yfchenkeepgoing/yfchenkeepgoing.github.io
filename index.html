<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="主要记录算法和web开发方面的心得体会">
<meta property="og:type" content="website">
<meta property="og:title" content="YifanChen&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="YifanChen&#39;s Blog">
<meta property="og:description" content="主要记录算法和web开发方面的心得体会">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yifan Chen">
<meta property="article:tag" content="C++, Python, Java, Django, Springboot, 算法, web开发">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>YifanChen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YifanChen's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">YifanChen's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个专注技术的新手程序员</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yfchenkeepgoing/yfchenkeepgoing.github.io" class="github-corner" title="YifanChen GitHub" aria-label="YifanChen GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/LeetCode-problems-prepared-for-a-TikTok-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/10/LeetCode-problems-prepared-for-a-TikTok-interview/" class="post-title-link" itemprop="url">LeetCode problems prepared for a TikTok interview</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-10 01:49:53" itemprop="dateCreated datePublished" datetime="2024-05-10T01:49:53+01:00">2024-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-20 05:25:50" itemprop="dateModified" datetime="2024-05-20T05:25:50+01:00">2024-05-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><p>本题是整数二分的加强版。本题的要点为：</p>
<ol>
<li><p>写两个函数，分别寻找target的左边界和右边界。本题的区间定义为左闭右闭。</p>
</li>
<li><p>寻找左边界，说明target在[left, mid]之间，因此在[left, mid]中更新左边界。寻找右边界，说明target在[mid, right]之间，因此在[mid, right]中更新右边界。</p>
</li>
<li><p>寻找左边界，就要在<code>nums[mid] == target</code>的时候更新right，然后将right赋给左边界。寻找右边界，就要在<code>nums[mid] == target</code>的时候更新left，然后将left赋给右边界。</p>
</li>
<li><p>实际上的左右边界是<code>mid</code>，而非<code>right</code>和<code>left</code>，因此在主函数中需要将左边界+1，恢复为<code>mid</code>；将右边界-1，也恢复为<code>mid</code>。也可以直接让左右边界是<code>mid</code>，这样就不需要加1减1，参见我的第二种写法。</p>
</li>
<li><p>target的三种情况：</p>
<ul>
<li>target在数组范围的右边或者左边</li>
<li>target 在数组范围中，且数组中存在target</li>
<li>target 在数组范围中，且数组中不存在target<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 寻找左边界</span></span><br><span class="line">    <span class="comment">// 说明target在[left, mid]之间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLeftBorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftBorder = <span class="number">-2</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 在[left, mid]中更新左边界</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                leftBorder = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找右边界</span></span><br><span class="line">    <span class="comment">// 说明target在[mid, right]之间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRightBorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rightBorder = <span class="number">-2</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 在[mid, right]中更新右边界</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                rightBorder = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftBorder = <span class="built_in">findLeftBorder</span>(nums, target);</span><br><span class="line">        <span class="type">int</span> rightBorder = <span class="built_in">findRightBorder</span>(nums, target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// target在数组范围的右边或者左边</span></span><br><span class="line">        <span class="keyword">if</span> (leftBorder == <span class="number">-2</span> || rightBorder == <span class="number">-2</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// target 在数组范围中，且数组中存在target</span></span><br><span class="line">        <span class="keyword">if</span> (rightBorder - leftBorder &gt; <span class="number">1</span>) <span class="keyword">return</span> &#123;leftBorder + <span class="number">1</span>, rightBorder - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// target 在数组范围中，且数组中不存在target</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>我写出了以下的变式代码。在这个代码里，通过<code>mid</code>来更新左右边界。这样若找到了左右边界，则直接返回左右边界即可，不需要做加1减1的操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 寻找左边界</span></span><br><span class="line">    <span class="comment">// 说明target在[left, mid]之间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLeftBorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftBorder = <span class="number">-2</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 在[left, mid]中更新左边界</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                leftBorder = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找右边界</span></span><br><span class="line">    <span class="comment">// 说明target在[mid, right]之间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRightBorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rightBorder = <span class="number">-2</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 在[mid, right]中更新右边界</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                rightBorder = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftBorder = <span class="built_in">findLeftBorder</span>(nums, target);</span><br><span class="line">        <span class="type">int</span> rightBorder = <span class="built_in">findRightBorder</span>(nums, target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// target在数组范围的右边或者左边</span></span><br><span class="line">        <span class="keyword">if</span> (leftBorder == <span class="number">-2</span> || rightBorder == <span class="number">-2</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// target 在数组范围中，且数组中存在target</span></span><br><span class="line">        <span class="keyword">if</span> (rightBorder - leftBorder &gt;= <span class="number">0</span>) <span class="keyword">return</span> &#123;leftBorder, rightBorder&#125;;</span><br><span class="line">        <span class="comment">// target 在数组范围中，且数组中不存在target</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="278-第一个坏版本"><a href="#278-第一个坏版本" class="headerlink" title="278.第一个坏版本"></a>278.第一个坏版本</h2><p>我独立写出了以下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid) == <span class="number">0</span>) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在本题中，尽管是左闭右闭的写法，但循环的条件应该为<code>left &lt; right</code>，因为当<code>left = right</code>时，实际上就锁定了第一个坏版本，循环就应当结束。这种题目当出现超时，要着重检查是不是循环的条件不对。</p>
<p>和本题同样的题目：输入一个数组，比如<code>[0, 0, 0, 1, 1, 1, 1]</code>，找到第一个为1的数的下标，代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == <span class="number">1</span>) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">firstBadVersion</span>(arr) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><p>本题直接采用（快慢）双指针解法即可。一遍过，但需要注意不要在<code>for</code>循环中重复定义指针<code>j</code>。本题的暴力做法甚至比双指针做法更复杂，也更容易写错。相向双指针做法暂时不用管。</p>
<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p>暴力解法非常简单，也能通过测试。我先在纸上模拟了双指针的过程，然后独立写出了如下的双指针代码，时间和空间复杂度都是$O(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针经典题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = size; i &lt;= j; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &lt;= nums[j] * nums[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                res[size] = nums[j] * nums[j];</span><br><span class="line">                j -- ;</span><br><span class="line">                size -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[size] = nums[i] * nums[i];</span><br><span class="line">                i ++ ;</span><br><span class="line">                size -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>不要追求把代码写得过度简洁，而导致可能的问题，宁可把代码写长一些，也要让代码清楚地表达算法思想。</p>
<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p>一时想不起来具体怎么写了，只记得遍历整个数组的同时，有数划入窗口，该数被累加到和中，有数划出窗口，则该数被从和中减去。看了我自己的笔记后，我独立写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = INT_MAX;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>; <span class="comment">// 滑动窗口的和</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// j为终止位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            s += nums[j]; <span class="comment">// 终止位置划入</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (s &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sub = j - i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (sub &lt; len) len = sub;</span><br><span class="line">                s -= nums[i]; <span class="comment">// 起始位置从和中滑出</span></span><br><span class="line">                i ++ ; <span class="comment">// 起始位置从滑动窗口中滑出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == INT_MAX) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意：</p>
<ul>
<li><p>i为起始位置，j为终止位置</p>
</li>
<li><p>循环中，终止位置先划入。若和大于等于目标值，则先更新最小长度，再将起始位置划出。</p>
</li>
<li><p>起始位置的值需要先从和中滑出，起始位置再从滑动窗口中滑出。顺序不可颠倒。</p>
</li>
<li><p>for循环中是while循环，而非if判断</p>
</li>
<li><p>数组中的每个元素至多被滑入一次再滑出一次，因此时间复杂度是$O(2n)$，即$O(n)$。</p>
</li>
</ul>
<h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><p>我记得本题是个模拟题。但实在记不得怎么做了，看以前的笔记。复习完后，我写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>, cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j ++ )</span><br><span class="line">                res[startx][j] = cnt ++ ;</span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i ++ )</span><br><span class="line">                res[i][j] = cnt ++ ;</span><br><span class="line">            <span class="keyword">for</span> (j = n - offset; j &gt; starty; j -- )</span><br><span class="line">                res[i][j] = cnt ++ ;</span><br><span class="line">            <span class="keyword">for</span> (i = n - offset; i &gt; startx; i -- )</span><br><span class="line">                res[i][j] = cnt ++ ;</span><br><span class="line">            offset ++ ;</span><br><span class="line">            startx ++ ;</span><br><span class="line">            starty ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) res[n / <span class="number">2</span>][n / <span class="number">2</span>] = cnt;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意：</p>
<ol>
<li><p><strong>画图理解（记住本图，就可以写出这道题的代码）</strong>：</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-01-26_06-26-17.png?raw=true" alt="Snipaste_2024-01-26_06-26-17.png"></p>
</li>
<li><p>顺时针转圈，转多少圈可以填满整个二维数组？从(0, 0)的位置开始转圈，终止的位置为中心(n/2, n/2)。每转一圈横纵坐标均加1，因此一共转了n/2圈。</p>
</li>
<li><p>切记遵守循环不变量原则，所有边都是左闭右开的。所以是<code>j &lt; n - offset</code>，且<code>offset</code>的初始值为1，因为右边界是开的。</p>
</li>
<li><p><code>startx</code>, <code>starty</code>, <code>offset</code>每转一圈都要加1。</p>
</li>
<li><p>定义二维数组的方式是将一位数组复制行数遍。</p>
</li>
<li><p>若n为奇数，则最后记得向二维数组的中心填入最后一个数。</p>
</li>
</ol>
<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189.旋转数组"></a>189.旋转数组</h2><p>首先我写出了可以正常运行但会超时的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>不超时的代码我写不出来，看卡尔的讲解。</p>
<p>本题的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题其实原理不难，类似于旋转字符串的题目，总结如下：</p>
<ol>
<li>首先反转整个数组，这样在不考虑顺序的情况下，就将两段数字放在了正确的位置上。</li>
<li>然后反转前k个数，将前k个数的顺序调整正确。</li>
<li>最后反转剩下的数，将剩下的数的顺序调整正确。</li>
<li>需要注意的是，若<code>k &gt; nums.size()</code>，则右移<code>k % nums.size()</code>即可，因为右移<code>nums.size()</code>次相当于没有改变原数组。</li>
<li>不要对nums.end()进行加减操作，nums.end()不指向一个特定的元素（不要下意识地以为其指向最后一个元素后面的紧邻的位置），对其进行加减操作会导致未定义的随机行为。对nums.begin()进行操作就没有这个问题。因此反转的第三步不要写成<code>reverse(nums.end() - k - 1, nums.end())</code>。</li>
</ol>
<h2 id="153-寻找旋转数组中的最小值"><a href="#153-寻找旋转数组中的最小值" class="headerlink" title="153.寻找旋转数组中的最小值"></a>153.寻找旋转数组中的最小值</h2><p>应该是先要将其恢复为有序的数组，然后返回有序数组的第一个元素即可。本题应该结合了二分法和旋转数组。我直接看题解吧。</p>
<p>虽然但是，本题用暴力做法也可以通过：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述算法的时间复杂度是O(nlogn)。用二分法应该可以将时间复杂度优化为O(logn)。</p>
<p>本题的二分做法如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环的终止条件：left = right。此时必然已经找到了数组中的最小值</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 中间数字大于右边数字，比如[3,4,5,1,2]，则左侧是有序上升的，最小值在右侧</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 中间数字小于右边数字，比如[6,7,1,2,3,4,5]，则右侧是有序上升的，最小值在左侧</span></span><br><span class="line">            <span class="comment">// 以[6, 7, 1, 2, 3, 4]为例，mid = 2, right = 2，即恰好在[left, mid]中取到最小值1</span></span><br><span class="line">            <span class="comment">// 若right = mid - 1，则[left, right]会错过最小值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) right = mid;</span><br><span class="line">            <span class="comment">// 中间数字等于右边数字，则说明数组中只有一个元素，返回该元素即可</span></span><br><span class="line">            <span class="comment">// 也可以直接写作else right = mid;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题延续了二分法的思路和代码形式，但细节和二分法略有不同，需要注意复习。</p>
<p>本题的思路：</p>
<ul>
<li><p>本题是左闭右闭写法，区间为<code>[left, right]</code></p>
</li>
<li><p>数组中的最小值要么在数组的右侧，要么在数组的左侧</p>
</li>
<li>数组的最小值在数组右侧的情况：[3, 4, 5, 1, 2]。数组的最小值在数组左侧的情况：[6, 7, 1, 2, 3, 4, 5]</li>
<li>若数组的最小值在数组的右侧，由于<code>nums[mid] &gt; nums[right]</code>，因此<code>nums[mid]</code>必然不可能是数组的最小值，因此<code>left = mid + 1</code></li>
<li>对于剩下的情况，即<code>nums[mid] &lt;= nums[right]</code>，数组的最小值在数组的左侧。由于可能存在<code>nums[mid] = nums[right]</code>的情况，因此<code>nums[mid]</code>可能是最小值，因此有<code>right = mid</code></li>
<li>记住始终是<code>nums[mid]</code>和<code>nums[right]</code>比较。始终是中间和右边比！</li>
</ul>
<p><strong>本题的另一种思路（更推荐这种，因为这种思路可以推广到33）</strong>：</p>
<ul>
<li><code>nums[mid]</code>和<code>nums[right]</code>的关系可以分为大于，等于，小于三种情况</li>
<li><code>nums[mid] == nums[right]</code>时，中间的数字等于最右边的数字，说明数组中只有一个元素，此时返回<code>nums[left]</code>即可，这种情况不需要考虑</li>
<li><code>nums[mid] &gt; nums[right]</code>时，例如[3, 4, 5, 1, 2]。数组的最小值在数组的右侧，<code>nums[mid]</code>必定不为最小值，因此有<code>left = mid + 1</code></li>
<li><code>nums[mid] &lt; nums[right]</code>时，数组的最小值在数组的左侧。例如[6, 7, 1, 2, 3, 4, 5]，也有可能是[6, 7, 1, 2, 3, 4]，此时<code>mid = 2, right = 2</code>，即恰好在[left, mid]中取到最小值1。若<code>right = mid - 1</code>，则[left, right]会错过最小值，因此<code>right = mid</code></li>
</ul>
<h2 id="154-寻找旋转数组中的最小值II"><a href="#154-寻找旋转数组中的最小值II" class="headerlink" title="154.寻找旋转数组中的最小值II"></a>154.寻找旋转数组中的最小值II</h2><p>本题的思路：</p>
<ul>
<li>延续上题的思路，<code>nums[mid]</code>和<code>nums[right]</code>的关系可以分为大于，等于，小于三种情况</li>
<li><code>nums[mid] &gt; nums[right]</code>和<code>nums[mid] &lt; nums[right]</code>的情况同上</li>
<li>由于数组中可以有重复的元素，因此需要考虑<code>nums[mid] == mums[right]</code>的情况，例如[2,3,1,1,1]或者[4,1,2,3,3,3,3]。此时，重复值<code>nums[right]</code>可能是最小值，也可能最小值在重复值的左侧，因此right左移一位：<code>right -= 1</code></li>
</ul>
<p>本题的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// [5, 6, 7, 1, 2]</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// [7, 1, 2, 3, 4]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) right = mid;</span><br><span class="line">            <span class="keyword">else</span> right -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h2><p>我对本题的初步思路：先找到最小的那个点，然后分别对两段单调递增的区间用二分法进行搜索。根据这个原理，我独立写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 二分查找有序数组中的数</span></span><br><span class="line">    <span class="comment">// 左闭右闭写法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchTarget</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先找到最小的数字, 下标为left</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// nums[mid] nums[right], [4, 5, 6, 7, 0, 1, 2]</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftIndex = <span class="built_in">searchTarget</span>(nums, <span class="number">0</span>, left - <span class="number">1</span>, target);</span><br><span class="line">        <span class="type">int</span> rightIndex = <span class="built_in">searchTarget</span>(nums, left, nums.<span class="built_in">size</span>() - <span class="number">1</span>, target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftIndex == <span class="number">-1</span> &amp;&amp; rightIndex == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (leftIndex == <span class="number">-1</span>) <span class="keyword">return</span> rightIndex;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rightIndex == <span class="number">-1</span>) <span class="keyword">return</span> leftIndex;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度也是$O(logn)$。</p>
<p>更简单的写法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 本质是查找target，因此是小于等于。若是查找最小值，则是小于</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一种情况，直接找到</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于第一种情况已经讨论过nums[mid] == target，因此第二三种情况不用再讨论</span></span><br><span class="line">            <span class="comment">// 第二种情况，数组最小值在右侧, [left, mid]为有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// target在[left, mid](有序)内</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// target在无序区间内</span></span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第三种情况，数组最小值在左侧，[mid, right]为有序</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// target在[mid, right]区间内</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// target在无序区间内</span></span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>分三种情况讨论：</p>
<ul>
<li>直接在mid处找到target</li>
<li>数组最小值在右侧, [left, mid]为有序<ul>
<li>target在[left, mid]有序区间内</li>
<li>target在剩余的无序区间内</li>
</ul>
</li>
<li>数组最小值在左侧，[mid, right]为有序<ul>
<li>target在[mid, right]有序区间内</li>
<li>target在剩余的无序区间内</li>
</ul>
</li>
</ul>
<h2 id="81-搜索旋转排序数组II"><a href="#81-搜索旋转排序数组II" class="headerlink" title="81.搜索旋转排序数组II"></a>81.搜索旋转排序数组II</h2><p>本题依然可以用老思路：找到最小值点，将区间划分为两个单调区间，然后分别在两个单调区间中进行搜索。本题实际上不可以这样做，因为本题中数组的元素可以重复，可能存在不止一个最小值点。</p>
<p>看了答案后，发现本题有两种写法，第一种：在循环内部跳过数组左侧和右侧的重复元素：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 跳过数组左侧的重复元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">            <span class="comment">// 跳过数组右侧的重复元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断有序部分</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) &#123;  <span class="comment">// 左侧有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 右侧有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>第二种，在循环外部直接删去数组尾部与数组头部重复的元素：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 移除重复的末尾元素以减少干扰</span></span><br><span class="line">        <span class="comment">// 可以处理如下情况：[1, 0, 1, 1, 1], [1, 2, 2, 2, 2, 0, 1]</span></span><br><span class="line">        <span class="comment">// nums.front() == nums.back()时，可能数组右边有序，也可能左边有序</span></span><br><span class="line">        <span class="comment">// 也可写作nums[0] == nums[nums.size() - 1]</span></span><br><span class="line">        <span class="keyword">while</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; nums.<span class="built_in">front</span>() == nums.<span class="built_in">back</span>()) nums.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// [3, 4, 5, 1, 2]</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 有序区间[left, mid]</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 无序区间[mid, right]</span></span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 有序区间[mid, right]</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 无序区间[left, mid]</span></span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意：需要先移除重复的末尾元素以减少干扰，再给<code>left</code>和<code>right</code>赋值。</p>
<p>建议采用第二种写法，因为第二种写法相当于在33.搜索旋转排序数组的基础上仅仅添加了移除重复的末尾元素的代码。这道题相当与上一题区别在于这道题包含了重复元素，其实影响到的是，当左端点和右端点相等时，无法判断mid在左半边有序数组还是右半边有序数组，所以只需要一直pop直到左端点和右端点不相等就可以了。</p>
<h2 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a>442. 数组中重复的数据</h2><h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h2><p>只有当数字的范围和数组的大小相等，或者有一定偏移关系时，才可以用原地哈希。本题的数字范围1-n，本题的数组中有n个元素，数组下标的范围是0-n-1。这种原地哈希算法适用于和正整数有关，且数字范围和数组长度有关的题目里，映射之后能利用映射关系（下标和值一一对应）来找到解。</p>
<p>对于本题，本质就是将原数组的下标为<code>nums[i] - 1</code>处放上<code>nums[i]</code>，最终希望达到的效果是<code>nums[nums[i] - 1] == nums[i]</code>。本题的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将nums[i]放到下标为nums[i] - 1的位置上</span></span><br><span class="line">        <span class="comment">// 由于原来下标为nums[i] - 1的位置上可能有数，因此需要将该数暂存到nums[i]上</span></span><br><span class="line">        <span class="comment">// 之后可以通过while循环将再将该数放到合适的位置上去</span></span><br><span class="line">        <span class="comment">// 可以举例子来模拟，即可以弄清楚这个过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> tmp = nums[idx];</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若nums[i]上的数字不为i + 1，则说明该数字缺失，将其插入结果集中</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题的精简注释版本如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 确保将nums[i]放到下标为nums[i] - 1的位置上</span></span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> idx = nums[i] - <span class="number">1</span>; <span class="comment">// 即将占用的元素的下标</span></span><br><span class="line">                <span class="type">int</span> tmp = nums[idx]; <span class="comment">// 暂存下标为idx处的元素，因为其即将被nums[i]占用</span></span><br><span class="line">                nums[idx] = nums[i]; <span class="comment">// 将nums[i]放到下标为nums[i] - 1的位置上</span></span><br><span class="line">                nums[i] = tmp; <span class="comment">// 将原来数组中下标为nums[i] - 1的数暂存到位置i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>while循环中的顺序：先写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line">nums[idx] = nums[i];</span><br></pre></td></tr></table></figure></p>
<p>确保nums[i]被放在了下标为nums[i] - 1处。</p>
<p>再将原本下标为idx处的元素缓存下来，暂存到下标i处：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = nums[idx];</span><br><span class="line">nums[i] = tmp;</span><br></pre></td></tr></table></figure></p>
<p>由此构成完整的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tmp = nums[idx];</span><br><span class="line">nums[idx] = nums[i];</span><br><span class="line">nums[i] = tmp;</span><br></pre></td></tr></table></figure></p>
<h2 id="442-数组中重复的数据-1"><a href="#442-数组中重复的数据-1" class="headerlink" title="442. 数组中重复的数据"></a>442. 数组中重复的数据</h2><p>本题依然可以用448的原地哈希法完成，唯一地不同在于，448是将<code>i + 1</code>插入<code>res</code>数组中，本题是将<code>nums[i]</code>插入<code>res</code>数组中，举一个实际的例子即可理解为什么是将<code>nums[i]</code>插入结果集中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> tmp = nums[idx];</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对原地哈希可进行总结：</p>
<ul>
<li><p>情景：数组的长度为<code>n</code>，数组中元素的范围为<code>[1, n]</code></p>
</li>
<li><p>若是找缺失的数字，则插入结果集的是索引下标+1；若是找出现了两遍的数字，则插入结果集的是元素的值<code>nums[i]</code></p>
</li>
<li><p>使用代码块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tmp = nums[idx];</span><br><span class="line">        nums[idx] = nums[i];</span><br><span class="line">        nums[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对数组进行原地哈希后，数组中出现过的数字<code>nums[i]</code>会被重新放置在下标为<code>nums[i] - 1</code>的位置上。范围为<code>[1, n]</code>但数组中没出现过的数字<code>nums[j]</code>，其本来应该放置在下标为<code>nums[j] - 1</code>处，但由于没有出现过，现在下标为<code>nums[j] - 1</code>处放置了原数组中的重复元素。这是因为循环的条件<code>nums[nums[i] - 1] != nums[i]</code>，当未填满的位置填入了重复元素后，while循环也会终止。例如，对<code>[4, 3, 2, 2, 3, 1]</code>进行原地哈希，结果为<code>[1, 2, 3, 4, 3, 2]</code>，原数组中出现过的1, 2, 3, 4被放置在下标为0, 1, 2, 3的位置上，原数组中没有出现过5, 6，因此下标为4，5处放置了原数组中重复的元素2, 3。</p>
</li>
<li><p>原地哈希法的时间复杂度都为O(n)，空间复杂度都为O(1)</p>
</li>
<li><p>为什么是 O(n) 时间复杂度？</p>
<p>每个元素在整个过程中最多被处理两次（一次是放置在正确位置，一次是在最终遍历中检查），因此总体时间复杂度是 O(2n)==O(n)。</p>
</li>
</ul>
<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h2><p>本题的思路和448、442相同，只不过while循环多了限制条件，同时返回值时需要考虑一种特殊情况。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 为避免nums[i] - 1超出索引的范围，需要对nums[i]的大小进行限制</span></span><br><span class="line">            <span class="comment">// 0 &lt;= nums[i] - 1 &lt;= n - 1，因此1 &lt;= nums[i] &lt;= n</span></span><br><span class="line">            <span class="comment">// 不需要对此范围之外的数进行操作，也无法用原地哈希法操作它们，因为它们会超出索引范围</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 这四行代码可以简写为swap(nums[nums[i] - 1], nums[i]);</span></span><br><span class="line">                <span class="type">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> tmp = nums[idx];</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊情况, nums = [1], 上面的循环不会返回结果，此时返回n + 1即可</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题中，数的个数为n个，但数的范围不在<code>[1, n]</code>中。需要返回缺失的第一个正整数。虽然乍一看不完全符合上题总结的原地哈希法的使用条件，但加上限制条件的原地哈希法依然可以被应用于解决本题。</p>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><p>本题不能这样写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ListNode* cur = dummyHead; cur != <span class="literal">NULL</span>; cur = cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;val == val)</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样写会导致删除节点后，<code>cur</code> 指针向后移动到了 <code>cur-&gt;next-&gt;next</code>，从而可能跳过了紧接着的需要删除的节点。比如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 2 -&gt; 3, target = 2</span><br></pre></td></tr></table></figure></p>
<p>上述写法会导致第三个节点2不能被删除。</p>
<p>本题应当用while循环写，对一个节点，如果是目标节点，则将其删除，否则，向后移动一个节点，不能同时既删除节点又后移一位。本题正确的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果既删又后移，则会漏掉节点</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">// 要么删</span></span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;next; <span class="comment">// 要么后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题的完整主函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">remove</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    ListNode* cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// head = [1,2,6,3]</span></span><br><span class="line">    ListNode* node1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* node2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    ListNode* node3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">6</span>);</span><br><span class="line">    ListNode* node4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = node4;</span><br><span class="line"></span><br><span class="line">    ListNode* head = <span class="built_in">remove</span>(node1, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (ListNode* cur = head; cur != <span class="literal">NULL</span>; cur = cur-&gt;next) cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造链表时，也可以采用函数写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">appendNode</span><span class="params">(ListNode*&amp; head, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 头为空，则将新节点作为头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    <span class="comment">// 头不为空，则遍历到链表最后一个节点，将新节点添加到最后一个节点之后</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) cur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">remove</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    ListNode* cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// head = [1,2,6,3]</span></span><br><span class="line">    ListNode* node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">appendNode</span>(node, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">appendNode</span>(node, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">appendNode</span>(node, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">appendNode</span>(node, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ListNode* head = <span class="built_in">remove</span>(node, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (ListNode* cur = head; cur != <span class="literal">NULL</span>; cur = cur-&gt;next) cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在定义链表时，特别要注意下面用来赋值的这句话：<code>ListNode(int x): val(x), next(NULL) &#123;&#125;</code>。</p>
<h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h2><p>本题的细节很多，需要特别注意。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get函数的复杂写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    LinkedList* cur = _dummyHead;</span><br><span class="line">    index ++ ;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        index -- ;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本题的完整代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedList</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedList* next;</span><br><span class="line">        <span class="built_in">LinkedList</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        LinkedList* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index -- ) cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedList* head = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line">        head-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = head;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedList* tail = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) cur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tail;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size) <span class="keyword">return</span>;</span><br><span class="line">        LinkedList* newNode = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index -- ) cur = cur-&gt;next;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index -- ) cur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        _size -- ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LinkedList* _dummyHead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意事项：</p>
<ol>
<li><p>带下划线的变量表示类中的变量，而非局部变量</p>
</li>
<li><p>记得在private中定义类中的变量</p>
</li>
<li><p>注意插入节点时先更新后面的边，再更新前面的边</p>
</li>
<li><p>别忘记_size ++ / _size —</p>
</li>
<li><p>注意对参数index进行判断</p>
</li>
<li><p><code>while (index -- ) cur = cur-&gt;next</code>的意思是，首先判断<code>index</code>是否大于0，是，则<code>index = index - 1</code>，然后执行<code>cur = cur-&gt;next</code></p>
</li>
</ol>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><p>我记得有递归写法，迭代写法，先尝试实现迭代写法，其本质是双指针。记住下面的图，即可写出本题的双指针法的代码：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/leetcode206.png?raw=true" alt="leetcode206.png"></p>
<p>注意：pre从NULL开始，cur在NULL结束。</p>
<p>一个经典的错误：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样写的结果是导致未将列表的最后一个节点（即反转后的头节点）的 <code>next</code> 指针正确设置。</p>
<p>本题的递归写法其实更加好写，但其空间复杂度为O(n)，高于双指针写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* last = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p>首先尝试用双指针做法解决本题。直接看答案，记住本题的方法。其实不需要双指针，本题是一道单纯的模拟题，但要搞清楚循环终止条件。看过博客后，我写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 终止条件：分别对应有偶数个节点和有奇数个节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 存1</span></span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 存3</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// d-&gt;2</span></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 2-&gt;1</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp;</span><br><span class="line">            <span class="comment">// 1-&gt;3</span></span><br><span class="line">            tmp-&gt;next = tmp1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后移两位</span></span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><p>本题的笨办法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 计算节点数目</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            num ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒数第n个节点是正数第num - n个节点</span></span><br><span class="line">        cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; n) <span class="comment">// 不可以写成(num - n) -- </span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            num -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>看博客，复习巧妙解法。本题的巧妙解法是快慢双指针。<strong>快指针先移动n位，然后快慢指针同时移动，直到快指针移动到链表的最后一个节点。此时，慢指针就指向了需要删除的节点</strong>。据此，我写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        <span class="comment">// &amp;&amp; fast可加可不加，因为本题有限制n&lt;=链表长度，若无此限制，则必须加，否则会出现空指针异常</span></span><br><span class="line">        <span class="keyword">while</span> (n -- &amp;&amp; fast) fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next) </span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>也可以让快指针先移动n + 1步，然后快慢指针同时移动，直到快指针移动到链表的NULL节点。</p>
<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h2><p>本题拿到我没什么思路，直接看以前的博客。本题的思路：首先计算两个链表的长度，将较长的链表作为链表a，较短的链表作为链表b。然后a链表从sizea - sizeb处开始, b链表从0处开始遍历，直到找到二者的交汇点。本质上体现的是一种<strong>末尾对齐</strong>的思想。示意图和代码如下所示：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_2.png" alt="面试题02.07.链表相交_2"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* cura = headA, *curb = headB;</span><br><span class="line">        <span class="type">int</span> sizea = <span class="number">0</span>, sizeb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算a的长度</span></span><br><span class="line">        <span class="keyword">while</span> (cura)</span><br><span class="line">        &#123;</span><br><span class="line">            cura = cura-&gt;next;</span><br><span class="line">            sizea ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算b的长度</span></span><br><span class="line">        <span class="keyword">while</span> (curb)</span><br><span class="line">        &#123;</span><br><span class="line">            curb = curb-&gt;next;</span><br><span class="line">            sizeb ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让a为较长的链表, b为较短的链表</span></span><br><span class="line">        <span class="keyword">if</span> (sizea &lt; sizeb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(sizea, sizeb);</span><br><span class="line">            <span class="built_in">swap</span>(headA, headB);</span><br><span class="line">            <span class="built_in">swap</span>(cura, curb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a链表从sizea - sizeb处开始, b链表从0处开始</span></span><br><span class="line">        cura = headA, curb = headB;</span><br><span class="line">        <span class="type">int</span> delta = sizea - sizeb;</span><br><span class="line">        <span class="keyword">while</span> (delta -- ) cura = cura-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cura == curb) <span class="keyword">return</span> cura;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                cura = cura-&gt;next;</span><br><span class="line">                curb = curb-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n + m)，空间复杂度O(1)。</p>
<h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2><p>我记得本题是用快慢指针解决的，快指针一次走两格，慢指针一次走一格，二者必然会在节点处相遇。我还记得公式怎么推导，但具体的思路记不清楚了，看博客。看完博客后，我写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head, * slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fast != NULL保证fast-&gt;next不报空指针异常</span></span><br><span class="line">        <span class="comment">// fast-&gt;next != NULL保证fast-&gt;next-&gt;next不报空指针异常</span></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* node1 = head, * node2 = fast;</span><br><span class="line">                <span class="keyword">while</span> (node1 != node2)</span><br><span class="line">                &#123;</span><br><span class="line">                    node1 = node1-&gt;next;</span><br><span class="line">                    node2 = node2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> node1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题的思路：快慢指针必然会在环中的某处相交，且慢指针在进入环的第一圈中就会和快指针相交。记下交点，让一个指针从起点开始走，另一个指针从交点开始走，二者相交的位置就是环的入口。详细的数学推导和细节见博客。</p>
<p>时间复杂度O(n)，空间复杂度O(1)。</p>
<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><p>本题简单，用数组做哈希，用数组统计一个字符串中各个字母出现的次数，然后遍历另一个字符串，在数组中做减减操作，最后判断数组中的所有元素是否都为0。我独立写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp1 = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            hash[tmp1] ++ ;</span><br><span class="line">            <span class="type">int</span> tmp2 = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            hash[tmp2] -- ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意，数组的长度为26，而非<code>s.size()</code>，因为s和t中只含有26个英文字母。可以不用<code>vector</code>，用<code>int</code>类型的数组即可。</p>
<p>本题更简洁的版本的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            hash[s[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line">            hash[t[i] - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (hash[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p>由于本题数据范围的限制，可以用数组做哈希，也可以用<code>unordered_set</code>做哈希。我首先写出了数组做哈希的写法（数组索引的范围与元素取值的范围相同），数组做哈希非常快：</p>
<h3 id="数组哈希，数组去重"><a href="#数组哈希，数组去重" class="headerlink" title="数组哈希，数组去重"></a>数组哈希，数组去重</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash1[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> hash2[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash1[nums1[i]] ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash2[nums2[i]] ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1010</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash1[i] &amp;&amp; hash2[i]) res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>尝试用<code>unordered_set</code>做本题。我不记得怎么用<code>unordered_set</code>做了，也忘记了<code>unordered_set</code>的基本做法，复习博客。</p>
<h3 id="数组哈希，set去重"><a href="#数组哈希，set去重" class="headerlink" title="数组哈希，set去重"></a>数组哈希，set去重</h3><p>可以将数组和set结合，这样只需要一个数组即可完成本题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res; <span class="comment">// 用于结果集去重</span></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash[nums1[i]] ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (hash[nums2[i]]) res.<span class="built_in">insert</span>(nums2[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的set只是起到了去重的功能，没有起到哈希的功能，哈希的任务还是由数组承担了。注意如何将set转换为vector输出，直接<code>vector&lt;int&gt; (res.begin(), res.end())</code>。</p>
<h3 id="set哈希，set去重"><a href="#set哈希，set去重" class="headerlink" title="set哈希，set去重"></a>set哈希，set去重</h3><p>也可以完全用set做本题，set既用来做哈希，又用来去重，代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全用set做本题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (s1.<span class="built_in">find</span>(nums2[i]) != s1.<span class="built_in">end</span>()) res.<span class="built_in">insert</span>(nums2[i]);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p>我记得本题有个巧妙的做法。本题使用的数据结构应该是set。我直接看博客复习本题的写法。我错误的根本原因还是对本题的算法思路理解不清晰。在明确了思路后，我写下了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 用于存储各位数字的平方和</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> digit = n % <span class="number">10</span>;</span><br><span class="line">                sum += digit * digit;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(sum) != s.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n = sum;</span><br><span class="line">            s.<span class="built_in">insert</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题的思路其实很简单，<strong>关键在于对平方和的计算和分类讨论（分为三类）</strong>。<strong>开一个死循环，计算n的各位数字的平方和。若平方和为1，则是快乐数。若平方和在set中出现过，则说明进入了死循环，不是快乐数。否则，将平方和加入到set中，将sum赋给n，进入下一重循环</strong>。</p>
<p>时间复杂度和空间复杂度都是O(logn)，详情参见博客。</p>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>本题要用map解决。用map的key存储索引，map的value存储nums中的值。首先将数组中的值依次存入map中，然后再在map中搜索<code>target - nums[i]</code>，若找到，则返回一对索引。本题思路我是清楚的，但由于忘了map的一些写法，因此复习博客。</p>
<p>实际上，我对本题的理解还是不够深刻。应该是用map的key存储数组中的值，map的value存储数组中的元素的下标，因为我们的目的是快速查找值是否出现过，被快速查找的对象应该被作为key。</p>
<h3 id="先查再插"><a href="#先查再插" class="headerlink" title="先查再插"></a>先查再插</h3><p>看完博客后，我写出了以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(t) != m.<span class="built_in">end</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(t);</span><br><span class="line">                <span class="keyword">return</span> &#123;i, it-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题的思路为：<strong>先查后插。先查现有的map中有无<code>target - nums[i]</code>，有，则将其索引和i一起加入结果集。无，则将遍历到的元素继续插入map中。这样天然的可以防止同一个元素被取出两次</strong>。</p>
<p>记住map的一些用法：</p>
<ul>
<li><code>m.insert(&#123;nums[i], i&#125;)</code></li>
<li><code>m.find(key) != m.end()</code></li>
<li><code>auto it = m.find(t); int value = it-&gt;second;</code></li>
</ul>
<h3 id="插完再查"><a href="#插完再查" class="headerlink" title="插完再查"></a>插完再查</h3><p>本题更复杂版本的代码，由于没有先查后插，导致要对找到的索引进行判断，其不能等于当前遍历到的索引，否则会导致同一个数字被使用了两次：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            m.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(t);</span><br><span class="line">            <span class="keyword">if</span> (it != m.<span class="built_in">end</span>() &amp;&amp; it-&gt;second != i) <span class="keyword">return</span> &#123;i, it-&gt;second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="压缩字符串（面试真题）"><a href="#压缩字符串（面试真题）" class="headerlink" title="压缩字符串（面试真题）"></a>压缩字符串（面试真题）</h2><p>将<code>aaaabb</code>压缩为<code>a4b2</code>，将<code>abcde</code>保持原样不动。我独立写出了以下的代码，可以通过所有的测试样例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">compress</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">char</span> tmp = s[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        res += tmp;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == s[i - <span class="number">1</span>]) </span><br><span class="line">        &#123;</span><br><span class="line">            i ++ ;</span><br><span class="line">            size ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">1</span>) res += <span class="built_in">to_string</span>(size); <span class="comment">// 也可以写成res += &#x27;0&#x27; + size;</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; s.<span class="built_in">size</span>()) tmp = s[i];</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后一个字符</span></span><br><span class="line">    <span class="keyword">if</span> (s[s.<span class="built_in">size</span>() - <span class="number">1</span>] != s[s.<span class="built_in">size</span>() - <span class="number">2</span>]) res += s[s.<span class="built_in">size</span>() - <span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将aaabb转换为a3b2输出</span></span><br><span class="line">    <span class="comment">// 将abcde原样输出</span></span><br><span class="line">    string s = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    string res = <span class="built_in">compress</span>(s);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实没有必要在for循环中嵌套while循环，直接用一个for循环就可以搞定。以下的写法为推荐写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// aaabb-&gt;a3b2</span></span><br><span class="line"><span class="function">string <span class="title">compress</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span> || s.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">char</span> tmp = s[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 出现相同字母</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>]) size ++ ;</span><br><span class="line">        <span class="comment">// 出现不同字母</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将上一个字符和其出现次数（&gt;1）插入res中</span></span><br><span class="line">            res += tmp;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">1</span>) res += <span class="built_in">to_string</span>(size);</span><br><span class="line">            <span class="comment">// 恢复现场</span></span><br><span class="line">            tmp = s[i];</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理字符串的最后一位</span></span><br><span class="line">    res += tmp;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">1</span>) res += <span class="built_in">to_string</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;aaaanbv&quot;</span>;</span><br><span class="line">    string res = <span class="built_in">compress</span>(s);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>本题的关键在于分两种情况讨论：出现相同的字母/出现不同的字母，最后记得处理字符串的最后一位</strong></p>
<p>通过本题，记住常用操作——将数字转换为字符：<code>to_string(size)</code></p>
<p>可以写出上述操作的逆过程的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isdigit</span><span class="params">(<span class="type">char</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">decompress</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s的第一个元素必为字母，从第二个元素开始可能为数字</span></span><br><span class="line">    <span class="comment">// 一对对处理，先处理字母，再处理数字（可能有，也可能没有）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理字母</span></span><br><span class="line">        <span class="type">char</span> tmp = s[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理数字，计算count</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[i + <span class="number">1</span>])) </span><br><span class="line">        &#123;</span><br><span class="line">            count = count * <span class="number">10</span> + s[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字母加入结果集</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) res += tmp;</span><br><span class="line">        <span class="comment">// 若有数字，则将字母重复数字遍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">while</span> (count -- ) res += tmp; <span class="comment">// 也可调用函数res.append(count, tmp);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;a56b12&quot;</span>;</span><br><span class="line">    string res = <span class="built_in">decompress</span>(s);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>本题的关键在于字母和数字成对出现（当然数字可能没有），成对地处理字母和数字，将它们成对地放入res中。</strong></p>
<h2 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h2><p>本题用哈希做的时间复杂度应该为O(n^2)。先枚举nums1和nums2中所有元素之和的组合，然后再在nums3和nums4中查找所有元素之和为<code>-nums1[i] -  nums2[j]</code>的情况。由于涉及到索引，所以要用map，map的key存数值，map的value存索引。value似乎要存一组索引，比如(i, j)，我忘记怎么写了，看下博客。</p>
<p><strong>实际上，应该是用map的key存储和，map的value存储出现这个和的次数</strong>。据此，我写出了以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">                m[nums1[i] + nums2[j]] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums3.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums4.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.<span class="built_in">find</span>(-nums3[i] - nums4[j]) != m.<span class="built_in">end</span>()) </span><br><span class="line">                    count += m.<span class="built_in">find</span>(-nums3[i] - nums4[j])-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更简洁的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num1: nums1)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num2: nums2)</span><br><span class="line">                m[num1 + num2] ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num3: nums3)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num4: nums4)</span><br><span class="line">                <span class="keyword">if</span> (m.<span class="built_in">find</span>(-num3 - num4) != m.<span class="built_in">end</span>())</span><br><span class="line">                    count += m[-num3 - num4];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>用map的key存储和，map的value存储出现这个和的次数</li>
<li>map的key不可重复，map的value可以重复。本题中的map起到一个将相同的和归拢，并用value统计其出现次数的作用</li>
<li>cpp中的map中的value是支持++操作的，且value可以通过key直接索引到，就像普通的数组那样</li>
<li>时间和空间复杂度均为$O(n^2)$，空间复杂度为$O(n^2)$是两数组的数字各不相同，产生了$n^2$种组合。</li>
</ul>
<h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h2><p>本题用数组做哈希就可以，因为对象就是26个小写英文字母。据此，我写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            cnt[magazine[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ransomNote.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            cnt[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: cnt)</span><br><span class="line">            <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>终极优化版本：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Each letter in magazine can only be used once in ransomNote</span></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> m: magazine)</span><br><span class="line">            cnt[m - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> r: ransomNote)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[r - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">            <span class="keyword">if</span> (cnt[r - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/06/Day-27-Leetcode-93-78-90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/06/Day-27-Leetcode-93-78-90/" class="post-title-link" itemprop="url">Day 27 Leetcode 93, 78, 90</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-06 04:26:30" itemprop="dateCreated datePublished" datetime="2024-05-06T04:26:30+01:00">2024-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-26 07:21:22" itemprop="dateModified" datetime="2024-05-26T07:21:22+01:00">2024-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（回溯算法）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html">93.复原IP地址</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><ol>
<li><p>cpp中的string是有pop_back方法的，用于弹出字符串中的最后一个元素。</p>
</li>
<li><p>字符串中在i的后面插入一个逗点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span> , <span class="string">&#x27;.&#x27;</span>);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>删除特定位置处的逗点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);       </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="93-复原IP地址-1"><a href="#93-复原IP地址-1" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><p>我尝试按照131.分割回文串的思路做本题，也写出了相应的代码，但运行结果和答案相差很大，而且代码非常复杂。我来看看卡尔的解法，看看如何写出正确而简单地处理这种字符串类型的回溯题的代码。</p>
<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h3><p>据卡尔说，子集问题，就是收集树形结构中，每一个节点的结果。 整体代码其实和回溯模板都是差不多的。 对于本题的树形结构，我有一个想法：以1, 2, 3为例，首先选中1前面的空位，则要收集空和123。然后选中1，则要收集1和23。然后选中2，则要收集2和13。然后选中3，则要收集3和12。共有8个子集。但本题的代码我写不出来，直接看卡尔的视频讲解。</p>
<h3 id="90-子集II"><a href="#90-子集II" class="headerlink" title="90.子集II"></a>90.子集II</h3><p>本题是40.组合总和II再加上78.子集。利用40题的去重办法（树层去重，用<code>used</code>数组，即<code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 0)</code>），利用78题的子集问题的解法（主要是在所有节点而不仅仅是叶子节点上收集答案）。据此，我独立写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 树层去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>, used);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 一定记得要对nums排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="93-复原IP地址-2"><a href="#93-复原IP地址-2" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><p>合法的IP地址：</p>
<ul>
<li>每个整数位于 0 到 255 之间组成</li>
<li>数字前不能有0，即不能有先导0</li>
<li>不能出现非0-9的字符</li>
</ul>
<p>因此本题不仅需要对字符串进行切割，还要对子串进行合法性的判断。本题在回溯算法的切割问题中是一道较有难度的题。做了131.分割回文串后，再来做本题，会易于理解一些。使用回溯算法暴力枚举分割的每一种情况。画树形结构图。</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/20201123203735933.png?raw=true" alt="20201123203735933.png"></p>
<p>画出了上述树形图后，写代码还会有疑惑：</p>
<ul>
<li><p>如何模拟切割线</p>
</li>
<li><p>怎么固定切割线，再在剩余的字符串中进行切割</p>
</li>
<li><p>切割出的子串如何表达</p>
</li>
</ul>
<p>接下来写具体的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// startIndex表示下一层递归切割的位置，即切割线</span></span><br><span class="line"><span class="comment">// 一个IP需要有三个逗点进行分割，pointSum用于统计逗点的数量, pointSum决定了树的深度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> startIndex, <span class="type">int</span> pointSum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// 每次加逗点，都是对其前面的子串做合法性判断</span></span><br><span class="line">    <span class="comment">// 此时还需要专门对最后一个子串做合法性判断，最后一个子串合法了，才能将整个IP地址加入结果集中</span></span><br><span class="line">    <span class="comment">// isvalid用于判断一个子串是否合法：数字前不能有0，数字在0-255之间，子串中不能有非法字符</span></span><br><span class="line">    <span class="keyword">if</span> (pointSum == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isvalid</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) <span class="comment">// 左闭右闭</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s); <span class="comment">// s会在后面被修改，具体来说是被切割并加上逗点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 切割后，对产生的第一个子串的合法性进行判断。子串的区间：[startindex, i]</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isvalid</span>(s, startIndex, i))</span><br><span class="line">        &#123;</span><br><span class="line">        	  <span class="comment">// 进入下一层递归前，需要在子串后面加上逗点</span></span><br><span class="line">            <span class="comment">// 将.插入到s.begin() + i的后面，故传入的参数是s.begin() + i + 1</span></span><br><span class="line">            s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            pointSum += <span class="number">1</span>; <span class="comment">// 逗点数量+1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="comment">// 由于给字符串s额外加了一个逗点，因此是i + 2（本来是i + 1）</span></span><br><span class="line">            <span class="built_in">backtracking</span>(s, i + <span class="number">2</span>, pointSum);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>); <span class="comment">// 删除s中插入的逗点</span></span><br><span class="line">            pointSum -= <span class="number">1</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码的精妙之处在于，就是在原来的字符串<code>s</code>的基础上进行修改，修改就是在合适的位置上添加逗点。本题的关键在于如何模拟切割的过程。切割的过程本质上和组合问题的取数的过程是一样的。另外还需要对子串进行合法性的判断，子串是<code>[startIndex, i]</code>。子串合法后再加上逗点。</p>
<p>根据上述核心代码，我独立写出了解决本题的完整的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接在s的基础上添加逗号，得到可能的IP地址</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断区间[start, end]的合法性</span></span><br><span class="line">    <span class="comment">// 三个要求：1. 没有非数字的字符</span></span><br><span class="line">    <span class="comment">// 2. 在0-255之间</span></span><br><span class="line">    <span class="comment">// 3. 没有先导0</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        string tmp = s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先导0</span></span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; tmp[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = tmp.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 非数字的字符</span></span><br><span class="line">            <span class="keyword">if</span> (tmp[i] &lt; <span class="string">&#x27;0&#x27;</span> || tmp[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            sum += (tmp[i] - <span class="string">&#x27;0&#x27;</span>) * d;</span><br><span class="line">            d = d * <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// startIndex为分割线，dotSum为逗点数目</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> startIndex, <span class="type">int</span> dotSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (dotSum == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对第四段(s的最后一段)做合法性判断</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isvalid</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="comment">// 区间[startIndex, i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对区间合法性进行判断</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isvalid</span>(s, startIndex, i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 合法，则插入逗点</span></span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                dotSum ++ ;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递归，本区间终止于i, 故下一个区间开始于i + 2</span></span><br><span class="line">                <span class="built_in">backtracking</span>(s, i + <span class="number">2</span>, dotSum);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);</span><br><span class="line">                dotSum -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>isvalid</code>函数可以写的更简洁更自然：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先导0</span></span><br><span class="line">    <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 非数字字符</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 在0-255之间</span></span><br><span class="line">        num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度: $O(3^4)$，IP地址最多包含4个数字，每个数字最多有3种可能的分割方式（1位，2位，3位）；<strong>则搜索树的最大深度为4，每个节点最多有3个子节点</strong>（对应每个数字可能是1位，2位，3位的情况）。</li>
<li>空间复杂度: $O(n)$，原因如下：<ul>
<li><strong>递归栈</strong>：递归的深度固定，最多为4，因为IP地址由四部分组成。但这并不直接决定空间复杂度，因为递归深度很小。</li>
<li><strong>存储当前解</strong>：在递归过程中，需要存储当前正在构建的IP地址，这需要额外的空间。此外，每次递归调用时，都可能创建字符串的子串来表示IP地址的某一部分。字符串的最大长度为输入字符串的长度n，因此需要额外的空间来存储这些子串。</li>
<li><strong>输出解的集合</strong>：输出的解的数量并不直接影响空间复杂度的理论计算，但实际上会使用额外空间来存储所有可能的IP地址。然而，这些空间通常不计入空间复杂度计算中，因为它不依赖于递归过程中的临时存储需求。</li>
</ul>
</li>
</ul>
<h3 id="78-子集-1"><a href="#78-子集-1" class="headerlink" title="78.子集"></a>78.子集</h3><p>之前讲的组合问题、分割问题，我们都是在树形结构的叶子节点上收获结果，因此在终止条件处收获结果。可以画出如下的树形结构：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png" alt="78.子集"></p>
<p>观察如上树形结构，发现我们想收获的结果其实在每一个节点中。因此不是在终止条件中收获结果，而是每进入一层递归就将单个结果放入结果集中。现在开始对着树形结果写代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维数组存放单个结果</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="comment">// 二维数组作为结果集</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// startIndex：下一层递归从哪里开始取数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每进入一层递归，都要将当前的path放入结果集中</span></span><br><span class="line">    <span class="comment">// 因为要将叶子节点的集合放入结果集中，然后再结束，因此先有本逻辑，再有终止条件</span></span><br><span class="line">    res.<span class="built_in">push_back</span>(path); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 终止条件：走到叶子节点，叶子节点的剩余集合都为空</span></span><br><span class="line">    <span class="comment">// 本终止条件可以不写，因为单层搜索逻辑中的for循环已经对startIndex的大小进行了限制</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每进入一层递归，都要收获当前节点的结果，放入单个结果数组中</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不写终止条件的写法如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="90-子集II-1"><a href="#90-子集II-1" class="headerlink" title="90.子集II"></a>90.子集II</h3><p>与78的区别：给的集合中允许有重复的元素，因此需要对重复子集去重。本题的关键在于去重，本题是子集+组合总和II（树层去重）的结合，并没有新的知识点。</p>
<p>本题的树形结构。<code>used</code>数组用于记录某个元素是否出现过。因为去重要让大小相邻的元素挨在一起，因此需要先对数组进行排序。本题的去重是树层去重（树层上相邻的元素如果相等，则不能重复取，否则会得到重复的子集），树枝不需要去重。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124195411977.png" alt="90.子集II"></p>
<p>现在开始写代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 单个结果</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 结果集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件不需要写，在for循环中实际上已经限制了startIndex的大小</span></span><br><span class="line">    res.<span class="built_in">push_back</span>(path); <span class="comment">// 收获结果，需要在每个节点都收获结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 树层去重, used[i - 1] == 0意味着第i - 1个元素是第i个元素的回溯</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] = <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        used[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>, used);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回溯中的去重逻辑都这么写。本题去重也可以用startIndex和i进行比较来实现，但这种去重写法并不通用，遇到排列问题时依然要用used数组的写法进行去重。去重的写法掌握<code>used</code>数组写法即可。</p>
<p>本题的时间和空间复杂度和78相同。时间复杂度: $O(n\times2^n)$，空间复杂度: $O(n)$。</p>
<p>本题也可以用哈希法去重，但时间复杂度更高，虽然也能够通过所有测试样例且不超时，代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// set去重</span></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(nums[i]) != s.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            s.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// set去重依然需要排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因此，本题的去重写法有三种：</p>
<ul>
<li><code>used</code>数组去重</li>
<li><code>startIndex</code>去重</li>
<li><code>set</code>去重</li>
</ul>
<p>掌握第一种即可。第一种是思路最清晰也最通用的。</p>
<p>本题像78一样，也可以不写终止条件，因为<code>startIndex</code>的大小在for循环中已经得到了限制。精简版本的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>, used);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="93-复原IP地址-3"><a href="#93-复原IP地址-3" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><ol>
<li>本题是131.分割回文串的加强版。因为和131同样是用回溯法求解的分割问题，所以基本原理是相同的，比如<code>startIndex</code>用于作为分割线，分割的区间是<code>[startIndex, i]</code>。</li>
<li>本题的终止条件和131有显著地不同。131的终止条件是<code>startIndex</code>移动到字符串的末尾，而本题的终止条件是添加了3个逗点，且最后一段区间是合法的。3个逗点的终止条件也限制了树的深度。</li>
<li>一般处理字符串的问题都比较复杂。本题对字符串处理的精妙之处在于直接在原本的字符串<code>s</code>上进行修改，添加逗点，作为分隔符从而得到合法的IP地址。本题还用到了两个和字符串有关的STL，分别是<code>insert</code>和<code>erase</code>函数。</li>
<li>本题对区间合法性的判断较为复杂，共有3个要求：<ul>
<li>段位以0为开头的数字不合法</li>
<li>段位里有非正整数字符不合法</li>
<li>段位如果大于255了不合法</li>
<li>段位若大于255，则立即判断为不合法，<code>return false</code>。若完成for循环后再对<code>num</code>进行判断，可能出现整数型变量溢出</li>
</ul>
</li>
<li>本题的时间复杂度：$O(3^4)$，空间复杂度：$O(n)$</li>
<li>本题的细节比较多，比较容易写错，属于回溯法解决分割问题中的难题，需要不断复习。</li>
</ol>
<h3 id="78-子集-2"><a href="#78-子集-2" class="headerlink" title="78.子集"></a>78.子集</h3><ol>
<li>子集是收集树形结构中树的所有节点的结果。而组合问题、分割问题是收集树形结构中叶子节点的结果。</li>
<li>子集也是一种组合问题，因为它的集合是无序的，子集{1,2}和子集{2,1}是一样的。那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始。</li>
<li>先收集结果集，再写终止条件的原因：当递归到叶子节点时，要先将叶子节点的结果放入结果集中，再终止，因此先写收集结果集的逻辑，再写终止条件。否则叶子节点的结果无法被放入结果集中。</li>
<li>本题也可以不写终止条件，因为单层递归逻辑的for循环中实际上限制了<code>startIndex</code>的大小，因此最后<code>return</code>即可。但初学者还是建议写终止条件，和标准的回溯模板保持一致。</li>
<li>本题的时间复杂度: $O(n\times2^n)$，空间复杂度: $O(n)$。时间和空间复杂度的分析同<a target="_blank" rel="noopener" href="https://yfchenkeepgoing.github.io/2024/05/01/Day-24-Theory-of-Backtracking-Algorithms-Leetcode-77/">77.组合</a>。</li>
</ol>
<h3 id="90-子集II-2"><a href="#90-子集II-2" class="headerlink" title="90.子集II"></a>90.子集II</h3><ol>
<li><p>本题是40.组合总和II与78.子集这两题的结合。</p>
</li>
<li><p>40的精华在于去重（树层去重），78的精华在于在每个节点处都收集结果（而不是像组合、分割问题那样在叶子节点，即终止条件处收集结果），而是在递归函数的开始处（进入递归相当于进入一个节点）收集结果。本题结合了两题的精华。</p>
</li>
<li><p>树层去重掌握<code>used</code>数组写法即可，具体代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure></li>
<li>树层去重前，需要对<code>nums</code>数组进行排序。</li>
<li>本题的时间和空间复杂度和上一题（78）相同。</li>
<li>去重共有三种写法，掌握思路最清晰也最通用的<code>used</code>数组写法即可。</li>
<li>本题像78一样，也可以不写终止条件，因为<code>startIndex</code>的大小在for循环中已经得到了限制。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/03/Day-26-Leetcode-39-40-131/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/03/Day-26-Leetcode-39-40-131/" class="post-title-link" itemprop="url">Day 26 Leetcode 39, 40, 131</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-03 05:14:31" itemprop="dateCreated datePublished" datetime="2024-05-03T05:14:31+01:00">2024-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-06 04:27:32" itemprop="dateModified" datetime="2024-05-06T04:27:32+01:00">2024-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（回溯算法）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">39.组合总和</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><p>创建一个和a数组大小相同的b数组，将其中的元素全部置为0。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a.size(), <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><p><code>substr(i, j)</code> 会从索引 <code>i</code> 开始，取长度为 <code>j</code> 的子字符串。</p>
<p><code>void backtracking(const string&amp; s, int startIndex)</code>中使用<code>const</code>的原因：</p>
<ol>
<li><strong>防止修改</strong>：<code>const</code> 关键字确保 <code>s</code> 字符串在 <code>backtracking</code> 函数中不会被修改。这是一种安全措施，可以防止函数意外地更改输入数据，从而保持数据的完整性。在处理函数参数时，尤其是在不应该或不需要修改输入的情况下，使用 <code>const</code> 可以提供这种保护。</li>
<li><strong>接口设计</strong>：在函数原型中使用 <code>const</code> 声明参数可以<strong>向函数的用户清楚地表明这个参数是用来输入数据的，不应该被函数改变</strong>。这有助于提高代码的可读性和可维护性，使得其他开发者更容易理解每个函数的作用和行为。</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h3><p>本题是集合里元素可以用无数次，那么和组合问题的差别，其实仅在于<code>startIndex</code>上的控制。本题若是想不重不漏，则下一层遍历的起始位置应该与上一层取出的数相同。而对于组合问题，下一层遍历的起始位置应该是上一层取出的数的下一个（因为组合问题中的元素不能重复使用）。据此，我写出了以下的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (s == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            s += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, s, i);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            s -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="40-组合总和II-1"><a href="#40-组合总和II-1" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><p>本题我能顺畅地写出不加去重的版本，如下所示。但对去重没有思路。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == target) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            s += candidates[i];</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, s, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            s -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对以下测试样例会出现报错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">candidates =</span><br><span class="line">[10,1,2,7,6,1,5]</span><br><span class="line">target =</span><br><span class="line">8</span><br><span class="line">Output</span><br><span class="line">[[1,2,5],[1,7],[1,6,1],[2,6],[2,1,5],[7,1]]</span><br><span class="line">Expected</span><br><span class="line">[[1,1,6],[1,2,5],[1,7],[2,6]]</span><br></pre></td></tr></table></figure></p>
<p>很明显，上述代码是需要去重的。</p>
<h3 id="131-分割回文串-1"><a href="#131-分割回文串-1" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><p>拿到本题，我没有思路，因为没有做过分割问题，直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="39-组合总和-1"><a href="#39-组合总和-1" class="headerlink" title="39.组合总和"></a>39.组合总和</h3><p>本题与组合问题的区别：集合中的元素可以重复选取，组合中元素的数量不加限定。集合中都是正整数（若有0，则会进入死循环），且集合中没有重复的元素（这意味着不用做去重的操作）。</p>
<p>本题通过和来限制树的深度，而组合问题通过组合中元素的数量来限制树的深度。本题的树形结构如下所示：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-03_08-36-04.png?raw=true" alt="Snipaste_2024-05-03_08-36-04.png"></p>
<p>由于集合中的元素可以重复使用，因此下一层的集合中应该包括本层选取的元素。现在开始写本题的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用sum表示组合的和，也可以不用sum，让target不断做减法，直到target == 0</span></span><br><span class="line"><span class="comment">// startIndex用于设置下一层递归的起点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidate, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == target)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidate.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(candidate[i]);</span><br><span class="line">        sum += candidate[i];</span><br><span class="line">        <span class="comment">// 递归，注意下一层的startIndex是从i开始，因为集合中的元素可以重复选取</span></span><br><span class="line">        <span class="built_in">backtracking</span>(candidate, target, sum, i);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        sum -= candidate[i];</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码和回溯算法的模板是类似的。本题依然可以做剪枝的操作。具体来说，是对for循环进行剪枝。对<code>candidate</code>数组进行排序后，若某个分支的和大于target，那么就没必要对其后面的分支进行搜索了。加入剪枝操作的完整代码如下所示（注意添加了注释的部分，就是实现剪枝的具体代码）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; s + candidates[i] &lt;= target; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            s += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, s, i);</span><br><span class="line">            s -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>剪枝操作总结：<strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]，相当于把下一层组合可能的sum从小到大扫了过去）已经大于target，就可以结束本轮for循环的遍历</strong>。</p>
<ul>
<li><p>时间复杂度: $O(n \times 2^n)$，注意这只是复杂度的上界，因为剪枝的存在，真实的时间复杂度远小于此。本题的时间复杂度分析同77. 组合。</p>
</li>
<li><p>空间复杂度: $O(target)$</p>
</li>
</ul>
<p><strong>为何是$O(target)$:</strong></p>
<ol>
<li><strong>递归栈深度：</strong> 空间复杂度首先取决于递归调用的最大深度，因为这直接影响了调用栈的大小。在组合总和问题中，你可以多次选择同一个数字，直到其和超过目标值 <code>target</code> 或恰好等于 <code>target</code>。最糟糕的情况发生在选择了最小元素直到达到 <code>target</code> 时，这种情况下，递归的最大深度大约是 <code>target / min(candidates)</code>。如果最小的候选数很小，理论上递归的深度可以接近 <code>target</code>。</li>
<li><strong>路径存储：</strong> 在递归过程中，我们还需要存储当前的组合路径（即当前选取的数字集合）。在最坏的情况下，即当所有选取的数字加起来等于 <code>target</code> 时，路径的长度也可以接近于 <code>target / min(candidates)</code>。尽管路径的具体长度依赖于候选数字的大小，但在分析空间复杂度时，我们考虑最坏情况，即多次选取最小值，使得路径长度和递归深度都接近于 <code>target</code>。</li>
</ol>
<h3 id="40-组合总和II-2"><a href="#40-组合总和II-2" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><p>本题差别：本题的集合中有重复的元素（之前的所有组合问题的集合中都没重复元素），<strong>不能有重复的组合</strong>。这说明我们要去重。另外，集合中的元素在组合中只能使用一次，这需要用一个变量进行控制。</p>
<p>一种朴素的想法：用之前的方法搜索组合，搜索出若干组合，其中肯定有重复的。用map或者set进行去重，输出去重后的所有组合。本方法实现起来较麻烦，且特别容易超时。</p>
<p>接下来介绍在搜索的过程中直接去重的方法：使用过的元素不重复使用。为了讲清楚本题的去重过程，卡尔自创了两个词汇：<strong>树层去重，树枝去重</strong>。去重要考虑到这两个维度。接下来画树形图，从两个维度看如何去重。去重前还需要对集合进行排序。去重需要一个数组<code>used</code>来告诉我们哪些元素使用过，哪些元素没用过。用过的元素的下标在<code>used</code>中对应的值为1，没用过的元素的下标在<code>used</code>中对应的值为0。<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/20230310000918.png?raw=true" alt="20230310000918.png"></p>
<p>上述树除去<code>used</code>数组外的基本部分，还是下一层第一个取的数是上一层取的数往后挪一位（即<code>backtracking(candidates, target, s, i + 1)</code>）。这样的目的是避免重复。对于树枝（树往深度方向走），是可以重复取值的，因为取的是一个集合中不同位置的数值相同的元素。对于树层（同一层树往横向走），不可以重复取值，必然会与之前的某个组合重复。对集合排序的目的就是将值相邻的元素放在一起，若同一层的两个分支的值相同，那么靠左边的分支会包含靠右边的分支的所有情况。<strong>因此去重的关键在于树层去重</strong>。具体的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本代码的重点在于树层去重的过程</span></span><br><span class="line"><span class="comment">// used数组用于标记某个元素是否使用过，用过1，没用过0</span></span><br><span class="line"><span class="comment">// 调用本函数前需要对集合做排序，目的是让值相同的元素在位置上相邻，方便做树层去重</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> targetSum, <span class="type">int</span> sum, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt; used)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (sum &gt; targetSum) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == targetSum) </span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">    <span class="comment">// for循环是在同一层遍历各个节点，因此接下来就要写树层去重的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 树层去重, i &gt; 0的目的是让i - 1 &gt;= 0，也可以写作i &gt; startIndex</span></span><br><span class="line">        <span class="comment">// used[i - 1] == 0对应于上面树的情况，就是第1个1没用，直接用了第2个1，此时重复读取，需要树层去重</span></span><br><span class="line">        <span class="comment">// 若nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 1，则说明是树枝的状态，由于不需要树枝去重，所以此时不需要去重</span></span><br><span class="line">        <span class="comment">// 后续在回溯算法中遇到去重问题并使用used数组时，基本都是这种写法</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 收集元素</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        used[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, targetSum, sum, i + <span class="number">1</span>, used);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        sum -= nums[i];</span><br><span class="line">        used[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以用<code>used</code>数组进行去重，也可以用<code>startIndex</code>进行去重，这里不再深入讲解。用<code>startIndex</code>去重比较抽象，因此理解用<code>used</code>数组去重即可，更易于理解且通用。本题的关键在于理解去重的思路。</p>
<p>本题的完整代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == target) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 树层去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            s += candidates[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, s, i + <span class="number">1</span>, used);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">            s -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// used数组用于标记candidates数组中的元素是否使用过，因此used数组大小应该与candidates数组大小保持相同</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(candidates.size(), <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>()); <span class="comment">// 别忘记排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度: $O(n \times 2^n)$。同77.组合和39.组合总和。<br>空间复杂度：$O(n)$。原因：树的最大深度为n（同<code>candidates</code>数组的长度）。</p>
<h3 id="131-分割回文串-2"><a href="#131-分割回文串-2" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><p>aab。有两种分割方案：aa|b和a|a|b。本题要求我们返回所有的分割方案。如何使用回溯算法解决这个问题？</p>
<p>分割问题和组合问题非常相似。例如abcdef，对组合问题，如果选择了a，则在bcdef中选择下一个字母；如果选择了b，则在cdef中选择下一个字母。同理，对于分割问题，如果分割了a，则接下来分割bcdef。再分割b，则接下来分割cdef。接下来画分割问题的树形结构。</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg?raw=true" alt="131.分割回文串.jpg"></p>
<p>切割线到了字符串的末尾，则切割完毕。结果都在叶子节点。画树形结构较为简单，具体的代码实现中有几个难点，现在开始写具体的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; path;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意传入的变量类型是const string，再加上引用</span></span><br><span class="line"><span class="comment">// startIndex控制下一次切割的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// 切割线到字符串的末尾，则终止</span></span><br><span class="line">    <span class="comment">// 切割线用startIndex表示</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将判断是否是回文的逻辑放入单层搜索的逻辑中</span></span><br><span class="line">        <span class="comment">// 因此终止条件中的path都是符合回文条件的</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如何用代码表示切割出的子串</span></span><br><span class="line">        <span class="comment">// 切割的子串：[startIndex, i]，左闭右闭的区间</span></span><br><span class="line">        <span class="comment">// 用于判断是否回文的函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, startIndex, i)) <span class="comment">// 传入字符串，子串的起始位置，子串的终止位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(子串); <span class="comment">// 是回文，则将子串放入path中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>); <span class="comment">// 下一层切割点从上一层切割点的下个位置开始，否则会重复</span></span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>isPalindrome</code>函数用双指针算法可以轻松实现。注意本题的两个细节：</p>
<ul>
<li><p><code>startIndex</code>是切割线</p>
</li>
<li><p>如何表示子串的范围：<code>[startIndex, i]</code></p>
</li>
</ul>
<p>完整的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断[start, end]是否是回文子串</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt;= j; i ++ , j -- )</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 是回文子串，则将其加入path中</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, startIndex, i))</span><br><span class="line">                path.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>时间复杂度: $O(n \times 2^n)$，时间复杂度同77.组合、39.组合总和、40.组合总和II。</p>
</li>
<li><p>空间复杂度: $O(n^2)$，原因解释如下：</p>
<ol>
<li><strong>递归栈的空间</strong>：最深的递归发生在当字符串每个字符都被分割时，因此递归深度最大为$n$（其中$n$是字符串的长度）。每一层递归需要保存当前索引和路径，这些额外的空间可以认为是常数级别的。</li>
<li><strong>路径存储空间</strong> (<code>path</code> 和 <code>res</code>):<ul>
<li><code>path</code> 变量在最坏情况下（每个字符都独立成一个回文串时）会存储$n$个元素。</li>
<li><code>res</code> 变量存储的是所有可能的分割方案。在极端情况下，如输入字符串完全由相同字符组成（例如 “aaaa”），<strong>分割方案的数量和其中每个方案的长度都可能接近$n$</strong>。但通常来说，我们只计算这个变量直接占用的空间，即指针或引用的空间，这通常也是$O(n^2)$，因为每个回文分割的保存都可能需要一个长度为 的$n$字符串的复制。</li>
</ul>
</li>
<li><strong>辅助空间</strong>：<ul>
<li>检查回文所用的额外空间是常量级的，不随输入大小变化。</li>
</ul>
</li>
</ol>
<p>将以上所有考虑结合，整个算法的空间复杂度主要由存储所有分割方案的数组 <code>res</code> 决定。由于每个分割方案可能包含多个字符串，而每个字符串又可能需要$O(n)$的空间，因此在最坏情况下，这部分的空间复杂度为$O(n⋅k)$，其中 $k$是分割方案的数量，这在极端情况下可以达到$O(n^2)$。</p>
</li>
</ul>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="39-组合总和-2"><a href="#39-组合总和-2" class="headerlink" title="39.组合总和"></a>39.组合总和</h3><ol>
<li>本题通过<code>target</code>来限制树的深度，而77. 组合通过组合中元素的个数来限制树的深度。</li>
<li>本题是集合里元素可以用无数次，那么和组合问题的差别，其实仅在于<code>startIndex</code>上的控制。本题若是想不重不漏，则下一层遍历的起始位置应该与上一层取出的数相同。而对于组合问题，下一层遍历的起始位置应该是上一层取出的数的下一个（因为组合问题中的元素不能重复使用）。</li>
<li>本题的时间复杂度：$O(n \times 2^n)$，空间复杂度：$O(target)$。</li>
<li>本题可以进行剪枝操作。具体来说，是对for循环进行剪枝。对<code>candidate</code>数组进行排序后，若某个分支的和大于target，那么就没必要对其后面的分支进行搜索了。体现在代码上，就是对总集合排序之后，如果下一层的sum（就是本层的sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历。<strong>本题的剪枝不好想，要多加注意</strong>。</li>
</ol>
<h3 id="40-组合总和II-3"><a href="#40-组合总和II-3" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><ol>
<li><p>本题的难点：集合有重复元素，但组合不能重复。</p>
</li>
<li><p>本题需要对组合去重，但不能在搜索完整棵树后用哈希法去重，容易超时。需要在搜索的过程中去重，这需要用到<code>used</code>数组。其中用过的元素标记为1，没用过的元素标记为0。</p>
</li>
<li><p>去重：只需要树层去重（树的同一层若两元素值相同，则右侧的值所在的路径必然被包含在左侧的值所在的路径中），不需要树枝去重（集合中的元素值可以相同，每个元素均可以使用一次，因此不需要对树枝去重）。</p>
</li>
<li><p>本题不可忽视的几个细节：</p>
<ul>
<li><p>集合需要进行排序，这是为了将值相同的元素放在集合中相邻的位置，便于树层去重</p>
</li>
<li><p><code>used</code>数组的大小需要与<code>candidates</code>数组保持相同，因为其是用来标记<code>candidates</code>数组中元素的使用情况的</p>
</li>
<li><p>注意树层去重的代码的写法，建议结合实际例子（实现中的图片）进行理解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树层去重</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == 0</code>说明同一树层上相邻的两个元素相同，此时需要进行树层去重</li>
<li><code>used[i - 1] == 1</code>，说明同一树枝上的<code>candidates[i - 1]</code>被使用过（同一树枝从上往下遍历，未进行回溯，因此<code>candidates[i - 1]</code>始终被标记为被使用过，即<code>used[i - 1] = 1</code>）</li>
<li><code>used[i - 1] == 0</code>，说明同一树层上的<code>candidates[i - 1]</code>被使用过（同一树层从左往右经历过回溯的过程：先对<code>candidates[i - 1]</code>所在的树枝从上往下遍历，然后回溯，再对<code>candidates[i]</code>所在的树枝从上往下遍历。在回溯的过程中，<code>candidates[i - 1]</code>被重新标记为未被使用过，即<code>used[i - 1] = 0</code>）</li>
</ul>
</li>
</ul>
</li>
<li><p>本题的去重代码不好写，同时细节较多需要注意。因此本题容易写错，需要时常复习。</p>
</li>
<li><p>后续在回溯算法中遇到去重问题并使用<code>used</code>数组时，基本都是这种写法：<code>if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == 0) continue;</code>。</p>
</li>
<li><p>本题也可以用<code>startIndex</code>进行去重，但比较难理解，因此不要求掌握。</p>
</li>
<li><p>本题可以像39.组合总和一样进行剪枝操作，只需要在for循环中对i加上限制条件：<code>s + candidates[i] &lt;= target</code>即可。</p>
</li>
</ol>
<h3 id="131-分割回文串-3"><a href="#131-分割回文串-3" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><ol>
<li><p>首先，切割问题其实本质和组合问题是相同的。</p>
<p>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…..。接着选取一个b后，再从cdef中再去选取第二个，以此类推。</p>
<p>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…..。接着从b那里切下去，在cded中再去切割第二段，以此类推。</p>
<p>可以观察本题的树形结构图，能够更加直观地理解切割问题和组合问题的相似。</p>
</li>
<li><p>什么是切割线？</p>
<p>递归参数需要传入<code>startIndex</code>，表示下一轮递归遍历的起始位置，这个<code>startIndex</code>就是切割线。</p>
</li>
<li><p>终止条件：切割线<code>startIndex</code>移动到了字符串的末尾，即<code>startIndex &gt;= s.size()</code></p>
</li>
<li><p>如何截取子串？<code>[startIndex, i]</code>之间的字符串就是子串。用<code>substr</code>函数截取即可。需要判断子串是否是回文串，是则放入<code>path</code>中，不是则<code>continue</code>。</p>
</li>
<li><p>使用最简单的双指针算法即可写出判断字符串是否是回文串的函数。</p>
</li>
<li><p>本题的空间复杂度$O(n^2)$。是极端情况下的空间复杂度，原因参见本题的实现部分。</p>
</li>
<li><p>从主函数传入的参数，在定义其他函数时若需要这个参数，则需要将其设置为<code>const</code>类型。目的是防止其他函数对这个参数的修改，同时向函数的用户清楚地表明这个参数是用来输入数据的。不加<code>const</code>不影响代码的正常运行，但加了<code>const</code>后代码更加规范。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/02/Day-25-Leetcode-216-17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/02/Day-25-Leetcode-216-17/" class="post-title-link" itemprop="url">Day 25 Leetcode 216, 17</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-02 02:58:19" itemprop="dateCreated datePublished" datetime="2024-05-02T02:58:19+01:00">2024-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-03 04:54:37" itemprop="dateModified" datetime="2024-05-03T04:54:37+01:00">2024-05-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（回溯算法）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">17.电话号码的字母组合</a></p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h3><p>针对本题，我沿用上题77. 组合的代码，只是在终止条件中添加了条件：<code>sum(path) == n</code>，并在单层搜索逻辑中将终止条件改为<code>i = 9</code>，即可解决本题。据此，我独立写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            s += path[i];</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k &amp;&amp; <span class="built_in">sum</span>(path) == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(k, n, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题应该也是可以进行剪枝优化的。首先的要求当然还是k个数，因此i最大只能取到<code>9 - k + path.size() + 1</code>，即<code>10 - k + path.size()</code>。但这样会导致TLE（超时），原因尚不清楚。直接看卡尔的讲解。</p>
<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><p>本题应该还是属于组合问题的范畴。先尝试画出本题的树形结构。相当于每个数字对应三个字母，第一个数字对应的三个字母和第二个数组对应的三个字母间进行组合。若有n个数字，则有3n个字母，放入一个<code>string a</code>中，第一个字母从<code>a[0]-a[2]</code>中取，第二个字母从<code>a[3]-a[5]</code>中取，以此类推。相当于依然是一个组合问题，只不过每一层递归for循环的开始和结束是不固定的，需要用上述规则进行更新。据此，我尝试独立写出本题的代码框架：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string path;</span><br><span class="line">    string all;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将digits按照数字和字母间的对应关系转换为all字符串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(string digits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: digits)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;2&#x27;</span>) all += <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;3&#x27;</span>) all += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;4&#x27;</span>) all += <span class="string">&quot;ghi&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;5&#x27;</span>) all += <span class="string">&quot;jkl&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;6&#x27;</span>) all += <span class="string">&quot;mno&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;7&#x27;</span>) all += <span class="string">&quot;pqrs&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;8&#x27;</span>) all += <span class="string">&quot;tuv&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> all += <span class="string">&quot;wxyz&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == digits.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= endIndex; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path += all.<span class="built_in">substr</span>(startIndex, endIndex);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(digits, startIndex, endIndex);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path -= all.<span class="built_in">substr</span>(startIndex, endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>遇到的难点：<code>startIndex</code>和<code>endIndex</code>不好确定，因为部分数字不止对应三个字母。直接看卡尔的讲解。果然涉及字符串的题目都不好做啊。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="216-组合总和III-1"><a href="#216-组合总和III-1" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h3><p>[1, 9]。和为n，个数为k的所有组合。本题和上题77. 组合的区别：限制和为n，集合是固定的（1-9），因此相当于在77. 组合的基础上加了一个和的限制。组合不强调元素间的顺序，排列强调元素间的顺序。暴力做法，当k=2时，两层for循环遍历1-9，找到两个相加等于n的数。暴力的想法代码没法写，所有要用回溯算法。回溯算法也是暴力的方式，只不过回溯算法通过递归的方式帮助我们控制for循环的嵌套层数，递归n层即相当于模拟了n层嵌套的for循环。</p>
<p>本题的树形结构如下所示：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-02_03-55-06.png?raw=true" alt="Snipaste_2024-05-02_03-55-06.png"></p>
<p>树的深度为k，树的宽度是当前层的集合中的元素的个数。现在来写具体的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum为当前路径已有的和, 将其与targetSum(即n)做一个比较，相等即符合题目的要求</span></span><br><span class="line"><span class="comment">// 本题的startIndex用途同77. 组合中的startIndex，初始值为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k)</span><br><span class="line">        <span class="keyword">if</span> (targetSum == sum)</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        sum += i;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(targetSum, k, sum, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        sum -= i;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k &amp;&amp; sum == n)</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            sum += i;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(k, n, i + <span class="number">1</span>, sum);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            sum -= i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(k, n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来对上述代码进行剪枝优化。第一个剪枝在于满足targetSum的要求。剪枝代码放在终止条件之前：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum &gt; targetSum)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>还有一个剪枝（满足集合中元素个数的要求），和77.组合中的剪枝是相同的。当前组合中有<code>path.size()</code>个元素，还需要<code>k - path.size()</code>个元素，因此i的最大起始位置为<code>9 - (k - path.size()) + 1</code>。因此：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i ++ )</span><br></pre></td></tr></table></figure></p>
<p>加上完整的剪枝优化后的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 剪枝操作1</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k &amp;&amp; sum == n)</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i ++ ) <span class="comment">// 剪枝操作2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="comment">// if (sum &gt; n) return;也可以放在此处</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(k, n, i + <span class="number">1</span>, sum);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            sum -= i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(k, n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我发现，若仅仅进行剪枝操作2，但不进行剪枝操作1，程序就会报错：TLE。</p>
<p>我还发现，尽管<code>if (sum &gt; n) return;</code>放在<code>sum += i</code>之后，程序可以通过测评。但正统的写法应当为在剪枝前，先把回溯给做了，否则可能会漏掉满足要求的组合（程序没有进行回溯，就试图去寻找新的满足要求的组合了）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当然这个剪枝也可以放在调用递归之前，只不过要记得把回溯操作给做了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) &#123; </span><br><span class="line">    <span class="comment">// 处理节点</span></span><br><span class="line">    sum += i; </span><br><span class="line">    path.<span class="built_in">push_back</span>(i); </span><br><span class="line">    <span class="keyword">if</span> (sum &gt; targetSum) &#123; <span class="comment">// 剪枝操作</span></span><br><span class="line">        sum -= i; <span class="comment">// 剪枝之前先把回溯做了</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 剪枝之前先把回溯做了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="built_in">backtracking</span>(targetSum, k, sum, i + <span class="number">1</span>); </span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    sum -= i; </span><br><span class="line">    path.<span class="built_in">pop_back</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本题的时间和空间复杂度同77.组合的时空复杂度。</p>
<h3 id="17-电话号码的字母组合-1"><a href="#17-电话号码的字母组合-1" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><p>电话拨号盘，每个数字代表一个字符串。首先需要做映射。将输入的字符串（一串数字）映射为对应的字符串。可以用map或者二维数组做映射，这里使用二维数组。数组中的每个元素是字符串。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot; &quot;</span>, <span class="comment">// 0</span></span><br><span class="line">    <span class="string">&quot; &quot;</span>, <span class="comment">// 1</span></span><br><span class="line">    abc, <span class="comment">// 2</span></span><br><span class="line">    def, <span class="comment">// 3</span></span><br><span class="line">    ghi, <span class="comment">// 4</span></span><br><span class="line">    jkl, <span class="comment">// 5</span></span><br><span class="line">    mno, <span class="comment">// 6</span></span><br><span class="line">    pqrs, <span class="comment">// 7</span></span><br><span class="line">    tuv, <span class="comment">// 8</span></span><br><span class="line">    wxyz, <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样拿到<code>digits</code>中的数字，将其作为下标放入字符串，即可得到数字对应的字符串（举例：<code>letterMap[2] = &quot;abc&quot;</code>）。</p>
<p>暴力做法：输入两个数字，则要进行两重for循环。输入n个数字，则要进行n重for循环。此时想到用回溯算法进行暴力求解。回溯算法可通过递归的方式实现对for循环的嵌套。以输入2，3为例，尝试画出本题的树形结构：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-02_22-19-15.png?raw=true" alt="Snipaste_2024-05-02_22-19-15.png"></p>
<p>结果就在树形结构的叶子节点中。树的深度是输入数字的个数，树的宽度由每一个数字对应的字符串的长度控制。现在尝试写本题的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">string s; <span class="comment">// 用于存储单个结果</span></span><br><span class="line">vector&lt;string&gt; res; <span class="comment">// 收获结果集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index用于标识传入的字符串digits在当前递归中遍历到哪一个字符（实际上是数字）了</span></span><br><span class="line"><span class="comment">// startIndex一般用于一个集合中求组合，避免得到重复的组合</span></span><br><span class="line"><span class="comment">// 本题是在多个集合中各取一个元素出来做组合，因此不需要startIndex来帮助控制集合中之前遍历过哪些元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// index指向digits的最后一位的下一位，才终止。若index指向digits的最后一位，其后应该还有处理最后一位的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(s); <span class="comment">// 收获结果</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">    <span class="comment">// 取出digits中的数字</span></span><br><span class="line">    <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 字符转换为数字</span></span><br><span class="line">    <span class="comment">// 找出digit对应的字符串</span></span><br><span class="line">    string letter = letterMap[digit];</span><br><span class="line">    <span class="comment">// 遍历digit对应的字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letter.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        s.<span class="built_in">push_back</span>(letter[i]);</span><br><span class="line">        <span class="comment">// 下一层递归，index后移一位</span></span><br><span class="line">        <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本题看似复杂，但画图理解后逻辑清晰，代码也不长。</p>
<p>可以将代码写得更简洁，递归函数传入三个参数：<code>void backtracking(string digits, int index, string s)</code>，然后单层搜索逻辑的三行代码写成一行：<code>backtracking(digits, index + 1, s + letter[i]);</code>。<code>s</code>的值本身并没有改变，这就是将回溯的过程隐藏在参数中了。</p>
<p>本题完整可运行的程序如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s; <span class="comment">// 存储单个组合</span></span><br><span class="line">    vector&lt;string&gt; res; <span class="comment">// 结果集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储数字和字符串之间的映射关系</span></span><br><span class="line">    vector&lt;string&gt; letterMap = &#123;</span><br><span class="line">        <span class="string">&quot; &quot;</span>, <span class="comment">// 0 </span></span><br><span class="line">        <span class="string">&quot; &quot;</span>, <span class="comment">// 1</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span> <span class="comment">// 9</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index用于标记当前层遍历到了digits中的哪个位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 这个return不能去掉，否则程序会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 取出当前层的数字</span></span><br><span class="line">        string letter = letterMap[digit]; <span class="comment">// 取出当前层需要遍历的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letter.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            s.<span class="built_in">push_back</span>(letter[i]);</span><br><span class="line">            <span class="comment">// 向下一层递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 这个return可要可不要，但为了和回溯法模板保持一致，因此还是加上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> res; <span class="comment">// 必须加上这句话，特判digits为空的情况</span></span><br><span class="line">        <span class="built_in">backtracking</span>(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>简化后的写法（隐藏回溯逻辑）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; all = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits, <span class="type">int</span> index, string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        string letter = all[digit];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letter.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>, s + letter[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits, <span class="number">0</span>, s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>时间复杂度分析</strong></p>
<p>对于每个按键，电话按键可能对应不同数量的字母：</p>
<ul>
<li>按键 2, 3, 4, 5, 6, 8 每个都对应 3 个字母。</li>
<li>按键 7 和 9 对应 4 个字母。</li>
</ul>
<p>如果输入的字符串中有 <code>m</code> 个按键对应 4 个字母，<code>n</code> 个按键对应 3 个字母，那么所有可能的组合数量是 <code>4^m * 3^n</code>。因为这是回溯算法的常见分析模式，每一步选择会进入下一层递归，直到达到输入字符串的长度。在每一层递归中，根据当前按键可能的字母数量，我们有不同的选择分支。</p>
<p>因此，整个算法需要考虑的总路径数或调用次数是 <code>O(4^m * 3^n)</code>。</p>
<p><strong>空间复杂度分析</strong></p>
<p>空间复杂度主要由两部分构成：</p>
<ol>
<li><p><strong>递归调用栈</strong>：最大深度为输入字符串的长度，即 <code>m + n</code>。然而，这通常认为是 O(m+n)，不是主要的空间消耗部分。</p>
</li>
<li><p><strong>输出存储空间</strong>：存储所有可能组合的空间，这是算法的主要空间消耗。每个组合都是一个新的字符串，因此需要的总空间是与生成的组合数量相同，即 <code>O(4^m * 3^n)</code>。</p>
</li>
</ol>
<p>如果空间复杂度中不计入输出存储空间，则空间复杂度是O(m+n)。若计入，则是O(4^m * 3^n)。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="216-组合总和III-2"><a href="#216-组合总和III-2" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h3><ol>
<li>本题的思路和77.组合的完全相同，只不过加了限制条件：组合中所有元素之和为n。</li>
<li>本题有两种写法。第一种是我在初次尝试中的写法，最大限度地沿用了77.组合的代码，只不过另外实现了一个sum函数来统计path数组中所有元素之和，并在终止条件中与n进行比较。这种写法存在一个巨大的缺陷，就是无法进行剪枝。因为只有实现了剪枝操作1：<code>if (sum &gt; n) return;</code>后，才能实现剪枝操作2：<code>for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i ++ )</code>，而写法1的递归函数的参数中没有<code>sum</code>，因此剪枝操作1必然无法实现，这导致剪枝操作2也无法实现（强行添加剪枝操作2，程序直接报错TLE（超时））。</li>
<li>本题的第二种写法更为正统，递归函数传入的参数中包含了<code>sum</code>，即当前path数组中元素之和。需要特别注意的是，处理节点的过程和回溯过程是一一对应的，<code>sum</code>在处理有加，在回溯就要有减。</li>
<li>基于本题的第二种写法，可以对代码进行两种剪枝操作。剪枝操作1：<code>if (sum &gt; n) return;</code>。该操作可以放在终止条件之前，也可以放在单层搜索逻辑中处理节点时对<code>sum</code>的计算之后（具体细节详见实现部分，建议不要纠结这里的细节）。剪枝操作2：<code>for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i ++ )</code>。这和77.组合中的剪枝操作完全相同。</li>
<li>只有实现了剪枝操作1后，才能实现剪枝操作2。若单独实现剪枝操作2，会导致程序超时（TLE）。</li>
</ol>
<h3 id="17-电话号码的字母组合-2"><a href="#17-电话号码的字母组合-2" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><ol>
<li><p>本题的<strong>两大创新之处</strong>：<code>index</code>和<code>letterMap</code>。前者用于表示遍历<code>digits</code>遍历到了哪一位，后者用于表示数字和字符串之间的映射关系。</p>
</li>
<li><p>画出树形结构对于解决回溯法问题的帮助：确定树形结构的宽度，可以确定单层搜索逻辑中的for循环怎么写；确定树形结构的深度，可以确定单层搜索逻辑中的递归部分怎么写。</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-02_22-19-15.png?raw=true" alt="Snipaste_2024-05-02_22-19-15.png"></p>
<p>在本题中，树的当前层中的各个节点是<code>letters</code>中的各个元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">string letters = letterMap[digit];</span><br></pre></td></tr></table></figure>
<p>树的深度是<code>digits.size()</code>，可通过<code>index + 1</code>不断向树的下一层递归。</p>
</li>
<li><p>如果输入的字符串中有 <code>m</code> 个按键对应 4 个字母，<code>n</code> 个按键对应 3 个字母，则本题的时间复杂度和空间复杂度都是$O(4^m \times 3^n)$。</p>
</li>
<li><p>本题看题意较为麻烦，但如果能画出树形结构，同时学会使用<code>vector&lt;string&gt;</code>来存储数字和字符串之间的映射关系，然后通过<code>index</code>来取出特定数字对应的字符串，就可以写出简明而清晰的代码。</p>
</li>
<li><p>写本题代码时，最好参照回溯法的模板代码，不要省略return，否则可能导致报错。另外，在主函数中要特判<code>digits</code>为空的情况。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/01/Day-24-Theory-of-Backtracking-Algorithms-Leetcode-77/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/01/Day-24-Theory-of-Backtracking-Algorithms-Leetcode-77/" class="post-title-link" itemprop="url">Day 24 Theory of Backtracking Algorithms, Leetcode 77</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-01 03:03:05" itemprop="dateCreated datePublished" datetime="2024-05-01T03:03:05+01:00">2024-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-02 03:04:32" itemprop="dateModified" datetime="2024-05-02T03:04:32+01:00">2024-05-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（回溯算法）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">理论基础</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="什么是回溯法"><a href="#什么是回溯法" class="headerlink" title="什么是回溯法"></a>什么是回溯法</h4><p>回溯算法比较抽象，因此较难。</p>
<p><strong>回溯和递归是相辅相成的，有递归就会有回溯</strong>。回溯的逻辑一般隐藏在递归函数的下面。二叉树在递归的过程中会有回溯的操作，只不过有的题目显式地用到了回溯，有的题目没有显式地用回溯。<strong>回溯函数一般指递归函数</strong>，因为没有一个函数可以完全用来回溯。</p>
<p>回溯法的效率：<strong>回溯法是纯暴力的搜索</strong>，并不是一个高效的算法。如果想让回溯法高效一些，可以加一些剪枝的操作。部分题能够用暴搜做出来就不错了，用层层嵌套的for循环都根本搜不出来，要依靠回溯法才能把所有结果搜出来。</p>
<h4 id="使用原因以及解决的问题"><a href="#使用原因以及解决的问题" class="headerlink" title="使用原因以及解决的问题"></a>使用原因以及解决的问题</h4><p>回溯法能解决的问题：</p>
<ul>
<li>组合问题。比如给定集合1234，找出长度为2的组合。</li>
<li>排列问题。<strong>排列强调元素的顺序，而组合不强调元素的顺序</strong>。比如集合12，求其组合，只有12一种组合；但若求其排列，有12/21两种排列。</li>
<li>子集问题。比如给定集合1234，问该集合有多少子集。</li>
<li>切割问题。比如给一个字符串，问有几种切割方式。或者加一些特定的条件，比如给一个字符串，如何切割才能保证它的子串都是回文子串，问有几种切割方式。</li>
<li>棋盘问题。比如N皇后、解数独。</li>
</ul>
<h4 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h4><p>回溯法特别抽象。想要清晰地了解回溯法，<strong>最好将其抽象为一个图形结构</strong>。<strong>所有的回溯法都可以抽象为一个树形结构，确切的说是N叉树</strong>。原因：回溯就是递归的过程，递归有终止。<strong>N叉树的宽度是在回溯法中处理的集合的大小</strong>，一般用for循环遍历。<strong>树的深度是递归的深度</strong>，因为递归必有终止，递归会层层向上返回。后序讲解具体问题时，都会将<strong>具体问题抽象为对应的树形结构</strong>，方便大家理解。</p>
<h4 id="回溯模板"><a href="#回溯模板" class="headerlink" title="回溯模板"></a>回溯模板</h4><p>一般来说，回溯法的递归函数都是没有返回值的，即void。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// backtracking为习惯的起名</span></span><br><span class="line"><span class="comment">// 回溯法的参数一般较多，一开始时一般无法确定所有参数，写具体逻辑时遇到想用的参数，再添加参数即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件。到终止条件时，一般来说就可以收集结果了</span></span><br><span class="line">    <span class="comment">// 除去子集问题和部分棋盘问题，我们一般在叶子节点收集结果</span></span><br><span class="line">    <span class="comment">// 对于子集问题，则需要在每个节点处收集结果</span></span><br><span class="line">    <span class="keyword">if</span> (终止条件)</span><br><span class="line">    &#123;</span><br><span class="line">        (叶子节点处)收集结果 <span class="comment">// 例如将子集12从数组中放入结果集中</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索的逻辑</span></span><br><span class="line">    <span class="comment">// for循环用于遍历本层集合中的每个元素，对应一个节点的所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (集合元素)</span><br><span class="line">    &#123;</span><br><span class="line">        处理节点 <span class="comment">// 例如将子集12放进数组中</span></span><br><span class="line">        递归函数 <span class="comment">// 树形结构往深处走</span></span><br><span class="line">        回溯操作 <span class="comment">// 撤销对节点的处理，例如从子集12中弹出2，再加入3，才能得到新的子集13。同理，还需要撤销3加入4，得到14的组合。没有回溯操作，就会一直加入新的元素，就不会求出所有的组合情况。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每道回溯法的题目都有各自的特点，但最终的代码都离不开上述模板的风格。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>后序会用本期视频讲解的理论知识求解具体问题，就可以加深对本期视频讲解的理论知识的理解。</p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h3><p>根据回溯模板，我写下了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 结果集</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp; <span class="comment">// 暂时存储数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> ()</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            tmp.<span class="built_in">push_back</span>(i);</span><br><span class="line">            k -- ;</span><br><span class="line">            <span class="comment">// 递归函数</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k);</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            k ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>尽管和最终版本的代码已经非常接近，但是我不知道怎么写终止条件，也无法确定传入的参数是否齐全。先来看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="77-组合-1"><a href="#77-组合-1" class="headerlink" title="77. 组合"></a>77. 组合</h3><p>组合中的元素是无序的。给定集合1234，找出所有大小为2的组合。有12，13，14；23，24；34。暴力做法：两层for循环。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j ++ )</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; j &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>两层for循环即可求解k=2下的所有组合。三层for循环即可求解k=3下的所有组合。若k很大，则要嵌套很多层for循环。因此直接用for循环是无法解决本题的，就需要用到回溯算法。</p>
<p>回溯算法也是一个纯暴力的方式，模拟的也是嵌套for循环的过程。回溯算法是利用递归来控制有多少层for循环。递归里的每一层都是一个for循环。<strong>嵌套n层for循环即相当于递归n层</strong>。</p>
<p>所有的回溯法都可以抽象为一个树形结构。以本题为例，画回溯算法搜索的过程。</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-01_19-07-25.png?raw=true" alt="Snipaste_2024-05-01_19-07-25.png"></p>
<p>上述树形结构的叶子节点就是要求的所有组合。第一次取数是从集合中依次取，第二次取数是取第一次取的数的后面一个数，这样才能保证不重不漏。通过传入参数<code>startIndex</code>来实现这点，即控制每次搜索的起始位置。</p>
<p>二叉树的题目有递归三部曲，回溯算法也有回溯三部曲（回溯函数即递归函数，二者不作区分）：</p>
<ul>
<li>递归函数的参数和返回值，返回值一般为void</li>
<li>确定递归的终止条件</li>
<li>单层搜索（递归）的逻辑</li>
</ul>
<p>根据回溯三部曲对着上述图示写组合问题的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个组合存放在一个一维数组中，名为path</span></span><br><span class="line"><span class="comment">// 还需要一个二维数组res，将所有集合放在一起，作为结果集返回</span></span><br><span class="line"><span class="comment">// 上述两个数组可以作为加引用的参数，也可以作为全局变量。但参数不宜过多，会影响代码的可读性，因此将它们放入全局变量中</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n是集合中数的个数，k是组合的大小</span></span><br><span class="line"><span class="comment">// startIndex的作用：本层递归结束后，下一层递归如何知道从哪个数开始取，就要用到startIndex</span></span><br><span class="line"><span class="comment">// startIndex是本层递归搜索的起始位置，初始时为1，即从1开始搜索</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件，到叶子节点时，收集结果并返回</span></span><br><span class="line">    <span class="comment">// path的大小为k，说明找到了大小为k的组合，将之放入结果集并返回</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path); <span class="comment">// 收集结果</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索的逻辑</span></span><br><span class="line">    <span class="comment">// 每层都是一个for循环，起始点从startIndex开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex, i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// 递归过程, i + 1才能让下一层递归从下一个节点开始搜索</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回溯过程。不可以一直往里加，得到一个结果后需要弹出旧的元素</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度：$O(n \times 2^n)$<br>空间复杂度：$O(n)$<br>原因：</p>
<ul>
<li><p>对时间复杂度</p>
<ul>
<li><p><strong>解空间的大小</strong></p>
<p>对于组合问题，如生成一个集合的所有子集，解空间包含了该集合的所有可能子集。对于包含$n$个元素的集合，其子集总数是$2^n$。这是因为每个元素在每个子集中都有出现或不出现两种可能，因此，子集的总数是$2^n$。</p>
</li>
<li><p><strong>每个解的生成时间</strong></p>
<p>虽然生成每个子集看起来很快，但是实际上，为了构建每个子集，可能需要遍历所有元素来决定每个元素是否包含在当前子集中，这需要$O(n)$的时间。因此，对于所有子集，生成时间是每个子集的生成时间与子集总数的乘积，即$O(n \times 2^n)$。</p>
</li>
</ul>
</li>
<li><p>对空间复杂度<br> 在讨论空间复杂度时，我们通常关注的是算法在执行过程中需要额外分配的空间量。<strong>对于回溯算法来说，主要的空间消耗源于两部分：递归调用的栈空间和用于存储当前解的路径</strong>（在此例中为 path）。以下是详细分析：</p>
<ul>
<li><p>递归栈空间<br>在回溯算法中，递归的深度决定了栈空间的使用量。在这个特定的问题中（从 n 中选择 k 个数的组合），递归的最大深度是 k，因为每一层递归对应于选择一个元素，直到选择了 k 个元素。因此，递归栈的空间复杂度是 O(k)。</p>
</li>
<li><p>存储当前解的路径空间<br>path 变量用于存储当前的部分解，即已选择的元素集合。因为一次最多选择 k 个元素，所以 path 的最大长度也是 k。因此，存储 path 所需的空间也是 O(k)。</p>
</li>
<li><p>结果集 result<br>虽然result用来存储所有可能的组合，其大小可以达到组合数$C(n, k)$，<strong>但在分析空间复杂度时，我们通常不把输出空间计算在内，因为这部分空间是用来存储算法的最终结果，而非算法执行过程中的临时数据</strong>。如果包括result的空间，空间复杂度确实是$O(C(n, k))$，但这不是额外的空间，而是算法结果的必要空间。</p>
</li>
</ul>
</li>
</ul>
<p>本题的完整代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 结果集</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 存放一个集合</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path); <span class="comment">// 收集结果</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 递归函数，下一层搜索从i + 1开始</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题的代码并不复杂，基本是按照回溯法的模板来的。本题还可以做剪枝。回溯法是一个纯暴力的算法，想优化就要做剪枝。<strong>接着详细讲如何做剪枝，以及回溯算法常见的剪枝套路</strong>。</p>
<h3 id="组合问题的剪枝操作"><a href="#组合问题的剪枝操作" class="headerlink" title="组合问题的剪枝操作"></a>组合问题的剪枝操作</h3><p>回溯算法是一种纯暴力的算法，优化就是做剪枝，但也改变不了其暴力算法的本质。如何做剪枝操作？</p>
<p>以n=4, k = 4为例。</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-01_21-14-10.png?raw=true" alt="Snipaste_2024-05-01_21-14-10.png"></p>
<p>对取2，取3和取4的分支，可以做剪枝。若不做剪枝，回溯算法会搜索整个树形结构，因此剪枝的效果非常明显。剪枝的代码该怎么写？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剪枝操作在单层搜索逻辑中</span></span><br><span class="line"><span class="comment">// for循环的逻辑在当前层的节点上，i对应于节点的每一个孩子，即for循环遍历了当前节点的所有孩子</span></span><br><span class="line"><span class="comment">// 要对节点的子孩子进行剪枝，因此对for循环的范围里进行优化即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点</span></span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>); <span class="comment">// 沿着当前分支继续往下搜索</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在的具体问题是：如何缩小i的范围？<br>总共要选取k个元素，当前选取了<code>path.size()</code>个元素，还剩下<code>k - path.size()</code>个元素有待选取。因此i至多从<code>n - (k - path.size()) + 1</code>开始。加1的原因是起始位置包括了<code>startIndex</code>。也可以举具体的例子。以<code>n=4, k=3, path.size()=0</code>为例，i至多从2开始枚举（这意味着i可以从1开始枚举，也可以从2开始枚举，但若从3开始枚举，则必然搜索不到大小为3的组合）。因此对上述代码修改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i ++ )</span><br></pre></td></tr></table></figure>
<p>这样可以确保在搜索的范围中可以找到大小为k的组合。剪枝的操作改动本处即可，代码其他地方不需要做改动。</p>
<p>上述剪枝操作在回溯算法的剪枝操作中特别常见。<strong>大部分回溯算法的剪枝操作都是在i的范围里做文章，即缩小i的范围</strong>。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="77-组合-2"><a href="#77-组合-2" class="headerlink" title="77. 组合"></a>77. 组合</h3><ol>
<li>本题的一个直接的想法是用k层for循环暴力解决，然而由于k的大小不确定，有待输入，因此需要用回溯法。回溯算法也是一个纯暴力的方式，模拟的也是嵌套for循环的过程。回溯算法是利用递归来控制有多少层for循环。递归里的每一层都是一个for循环。<strong>嵌套n层for循环即相当于递归n层</strong>。</li>
<li>所有回溯法的题目都可以抽象为一个树形结构，本题的树形结构参加实现部分。</li>
<li>基于本题的树形示意图，以及回溯法的模板代码，就可以写出本题的具体代码。需要特别注意的是，本题的递归函数需要传入三个参数，除去n和k外，还需要传入<code>startIndex</code>。这是因为每层递归的起始点都需要在上一层递归起始点的基础上加1，因此需要一个参数来标明当前这层递归的起始点。</li>
<li>本题可以进行剪枝优化。</li>
</ol>
<h3 id="组合问题的剪枝操作-1"><a href="#组合问题的剪枝操作-1" class="headerlink" title="组合问题的剪枝操作"></a>组合问题的剪枝操作</h3><ol>
<li><p>可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。<strong>如果for循环选择的起始位置之后的元素个数已经不足我们需要的元素个数了，那么就没有必要搜索了</strong>。</p>
</li>
<li><p>注意代码中i，就是for循环里选择的起始位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) </span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来看一下优化过程如下（可以画<strong>线段图</strong>理解）：</p>
<ul>
<li>已经选择的元素个数：<code>path.size()</code>;</li>
<li>还需要的元素个数为: <code>k - path.size()</code>;</li>
<li>在集合n中至多要从该起始位置: <code>n - (k - path.size()) + 1</code>，开始遍历。若i超过了这个最大的起始位置，则组合中凑不齐k个元素</li>
</ul>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
<p>举个例子，<code>n = 4，k = 3</code>， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p>
</li>
<li><p>上述剪枝操作在回溯算法的剪枝操作中特别常见。<strong>大部分回溯算法的剪枝操作都是在i的范围里做文章，即缩小i的范围</strong>。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/Day-23-Leetcode-669-108-538-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/24/Day-23-Leetcode-669-108-538-summary/" class="post-title-link" itemprop="url">Day 23 Leetcode 669 108 538 summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-24 09:09:27" itemprop="dateCreated datePublished" datetime="2024-04-24T09:09:27+01:00">2024-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 10:26:03" itemprop="dateModified" datetime="2024-04-26T10:26:03+01:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（二叉树）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">669. 修剪二叉搜索树</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">108.将有序数组转换为二叉搜索树</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html">538.把二叉搜索树转换为累加树 </a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html">总结篇 </a></p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a>669. 修剪二叉搜索树</h3><p>本题据说比增加和删除节点更难，我拿到后没有思路，直接看卡尔的讲解。</p>
<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><p>虽然这是道简单题，但我也没想出来怎么做。</p>
<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h3><p>本题的基本思路是：累加树中的新节点（除叶子节点外）是其本身加上其右子树的所有节点之和。叶子节点如果是他父节点的左孩子，则值为他的父节点的新值减去原本父节点的值。叶子节点若是他父节点的右孩子，则值为他的父节点的新值加上叶子节点原本的旧值。要计算右子树的值，应当用双指针算法加上中序遍历。</p>
<p>本题还有另一种思路，更加简单粗暴。直接将二叉搜索树转换为一个递增的数组。然后某个节点的新值就是从其本身到数组末尾的所有元素之和。根据上述原理，我写下了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将二叉搜索树通过中序遍历转换为有序的数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left); <span class="comment">// 左</span></span><br><span class="line">        nums.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新节点的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; root-&gt;val)</span><br><span class="line">                root-&gt;val += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过层次遍历，遍历每个节点，依次更新所有节点的值</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">sum</span>(node);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>虽然从原理上来说，上述做法应该是没有问题的，但因为并发修改之类的问题，上述代码的实际运行结果和预期就是不同。我搞不清楚为什么，暂且记录下来。直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="669-修剪二叉搜索树-1"><a href="#669-修剪二叉搜索树-1" class="headerlink" title="669. 修剪二叉搜索树"></a>669. 修剪二叉搜索树</h3><p>给二叉搜索树，给定范围，在范围内修剪二叉搜索树，使得二叉搜索树中所有节点的数值都在范围内。本题不仅要删除不止一个节点，还要改变树的结构。</p>
<p>450.删除二叉搜索树中的节点的原理：通过递归，从当前层往上一层返回值，上一层的左/右孩子来接住返回值，达到删除节点的效果。</p>
<p>常见的误区：常见的错误代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回修剪后二叉树的根节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 修剪二叉搜索树</span></span><br><span class="line">    <span class="comment">// 当前遍历的节点不在[low, high]的范围内</span></span><br><span class="line">    <span class="comment">// 这样写很明显是错误的，若根节点的两个子节点都返回NULL，那么二叉树就只剩下根节点了，其他节点全部被删除</span></span><br><span class="line">    <span class="comment">// 实际上根节点的两棵子树中都可能有范围内的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; low || root-&gt;val &gt; high) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(root-&gt;left, low, high);</span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(root-&gt;right, low, high);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正确的思路</strong>为：若发现某个节点小于范围的左边界，那么该节点的右子树中可能有范围内的节点，因为该节点中右子树的值都要大于该节点的值。因此尽管要删除这个节点，但还需要继续在其右子树中遍历，来挑出其中符合条件的节点。现在来写正确的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回修剪后二叉树的根节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 本题的终止条件和删除二叉搜索树中的节点的终止条件类似，分类讨论，先发现要删除的节点然后完成删除操作</span></span><br><span class="line">    <span class="comment">// 终止条件1</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 终止条件2</span></span><br><span class="line">    <span class="comment">// root节点的值小于左边界，但其右子树中可能有符合要求的节点，故应该继续向右遍历</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; low)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// root节点的右子树在修剪后的根节点</span></span><br><span class="line">        TreeNode* right = <span class="built_in">traversal</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">return</span> right; <span class="comment">// 向上返回该根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 终止条件3</span></span><br><span class="line">    <span class="comment">// root节点的值大于右边界，但其左子树中可能有符合要求的节点，故应该继续向左遍历</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// root节点的左子树在修剪后的根节点</span></span><br><span class="line">        TreeNode* left = <span class="built_in">traversal</span>(root-&gt;left, low, high);</span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// 向上返回该根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑，分别修剪根节点的左右子树，然后将修剪后的左右子树接上去</span></span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(root-&gt;left, low, high);</span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(root-&gt;right, low, high);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// root在终止条件中处理了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题的代码其实不复杂，特别是相比于450.删除二叉搜索树中的节点。那题的终止条件需要分5种情况讨论，本题的终止条件只需要分3种情况讨论。本题也有迭代写法。本题掌握递归法即可。本题代码量不多，但很考察大家对二叉树移除节点和二叉搜索树特性的理解。</p>
<p>我独立写下了精简注释版本的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件1</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件2，root节点的值小于左边界</span></span><br><span class="line">        <span class="comment">// 此时root节点的右子树中依然可能有符合要求的节点在，因此还需对右子树进行修剪</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; low)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件3，root节点的值大于右边界</span></span><br><span class="line">        <span class="comment">// 此时root节点的左子树中依然可能有符合要求的节点在，因此还需对左子树进行修剪</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="comment">// 用来接住3个终止条件的返回值</span></span><br><span class="line">        root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题的迭代法代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保root在[low, high]的区间内</span></span><br><span class="line">        <span class="comment">// 以下写法可以避免死循环</span></span><br><span class="line">        <span class="keyword">while</span> (root &amp;&amp; (root-&gt;val &lt; low || root-&gt;val &gt; high))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &lt; low) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保cur的左子树中没有小于low的节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val &lt; low)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;left = cur-&gt;left-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = root; <span class="comment">// 恢复cur</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接着检查cur的右子树中没有大于high的节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &gt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;right = cur-&gt;right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>迭代法原理不复杂，但代码非常容易写错，因此不推荐迭代写法。</p>
<h3 id="108-将有序数组转换为二叉搜索树-1"><a href="#108-将有序数组转换为二叉搜索树-1" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><p>要构造的二叉搜索树是平衡二叉树。做这个要求的原因是任何有序数组都能够轻易构造成链式的二叉搜索树。</p>
<p><strong>构造二叉树的一般思路</strong>：在数组中选取一个中间节点，将数组分为左区间和右区间。递归遍历左区间，构成左子树。递归遍历右区间，构成右子树。</p>
<p>解题思路：root节点选取为数组中间位置的节点。因为只有这样选才可以保证左右区间中节点的数量相同，构造的二叉树才是平衡二叉树。再根据二叉搜索树的性质：中节点的值大于左子节点，小于右子节点来构造二叉搜索树。构造出的二叉搜索树的结构不唯一。对于数组中有偶数个元素的情况，root节点可以选取为中间偏左那个节点，也可以选取为中间偏右那个节点。代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意引用&amp;。如果每层递归不用引用，就需要在内存空间中重复复制数组，导致程序的性能很差</span></span><br><span class="line"><span class="comment">// 使用引用后，递归遍历时都在同一个内存地址里操作数组</span></span><br><span class="line"><span class="comment">// 区间左右边界的定义很重要，此处对区间的定义是左闭右闭</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件：非法区间</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">// 数组下标相加不可能爆内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造二叉树的根节点</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]); </span><br><span class="line">    <span class="comment">// 利用左区间构造左子树</span></span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(nums, left, mid - <span class="number">1</span>); <span class="comment">// 因为是左闭右闭的区间，所以right = mid - 1</span></span><br><span class="line">    <span class="comment">// 同理，利用右区间构造右子树</span></span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(nums, mid + <span class="number">1</span>, right); <span class="comment">// 因为是左闭右闭的区间，所以left = mid + 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 区间定义左闭右闭，因此right = nums.size() - 1</span></span><br><span class="line">    TreeNode* root = <span class="built_in">traversal</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本代码并不复杂。本题也可用迭代法实现，但较为复杂。本题优先掌握递归法即可。</p>
<p>本题的精简版本代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 区间左闭右闭</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造root节点</span></span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造左子树</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 构造右子树</span></span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        TreeNode* root = <span class="built_in">traversal</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="538-把二叉搜索树转换为累加树-1"><a href="#538-把二叉搜索树转换为累加树-1" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h3><p>换个思路：给一个有序的数组，将其变成一个累加数组。<strong>倒序遍历</strong>即可，将前一个节点加到本节点中。倒序遍历有序数组，<strong>本质就是按照右中左的顺序遍历二叉搜索树</strong>。将前一个节点的值加到本节点中，就需要用到<strong>双指针</strong>。pre指针指向前一个节点，cur指针指向当前节点。现在开始写递归法的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pre = <span class="number">0</span>; <span class="comment">// 记录前一个节点的数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于要遍历整个二叉树，在遍历的过程中去更新节点数值即可，因此不需要返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑：右中左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line">    cur-&gt;val += pre; <span class="comment">// 中</span></span><br><span class="line">    pre = cur-&gt;val; <span class="comment">// 移动pre</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在对二叉搜索树的遍历不够熟悉的情况下，可以将二叉搜索树想象成一个有序的数组。</p>
<p>将pre定义为指针也是可行的，代码会略微复杂，因为要判断指针是否为空：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (pre) cur-&gt;val += pre-&gt;val;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题用迭代法也可以做，而且是迭代法的模板题，但我用迭代法写本题总是容易写错。因此还是推荐递归法。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="669-修剪二叉搜索树-2"><a href="#669-修剪二叉搜索树-2" class="headerlink" title="669. 修剪二叉搜索树"></a>669. 修剪二叉搜索树</h3><ol>
<li>本题乍一看非常简单，结果就是掉进常见误区中，即发现一个节点不在区间内，就直接返回NULL。这样的问题在于以该节点为根节点的子树中可能有满足条件的节点。如果直接返回NULL，相当于把可能满足条件的节点一并删除了。</li>
<li><p>从常见误区中爬出来，又会觉得本题非常难，因为似乎要调整二叉树的结构。其实本题不需要像450.删除二叉搜索树中的节点那样分五种情况讨论来调整二叉树的结构。本题只需要在终止条件中分出三种情况讨论：</p>
<ul>
<li>root节点为空，则返回空</li>
<li>root节点小于区间左边界，则root节点的右子树中可能存在符合要求的节点。此时调用递归函数对root节点的右子树进行修剪，将修剪后右子树的头节点向上返回。</li>
<li>root节点大于区间右边界，则root节点的左子树中可能存在符合要求的节点。此时调用递归函数对root节点的左子树进行修剪，将修剪后左子树的头节点向上返回。</li>
</ul>
<p>最后在单层递归逻辑中，分别让root节点的左右指针接住修剪后的左右子树即可。终止条件负责返回，单层递归逻辑负责接收。</p>
</li>
<li>本题的基本原理和450.删除二叉搜索树中的节点相同，都是通过递归函数的返回值来移除节点，然后在单层递归逻辑中接住上一层递归的返回值。</li>
<li>本题的迭代法思路简单（终止条件-&gt;确保root在[low, high]的区间内-&gt;确保cur的左子树中没有小于low的节点-&gt;接着检查cur的右子树中没有大于high的节点），但代码非常容易写错（while循环中套着while，循环条件写得不对容易出现死循环），因此不推荐。还是建议老老实实地用递归法完成本题。</li>
</ol>
<h3 id="108-将有序数组转换为二叉搜索树-2"><a href="#108-将有序数组转换为二叉搜索树-2" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><ol>
<li>构造二叉树的一般思路：取数组最中间的元素作为二叉树的root节点。利用数组的左区间构造root节点的左子树，利用数组的右区间构造root节点的右子树。</li>
<li>在数组中元素个数为偶数时，数组最中间的元素有两个。此时，选取这两个元素中的任意一个作为root节点都可以。这样会构造出两棵不同的二叉搜索树，因此本题的结果不唯一。</li>
<li>本题递归函数的传入参数为数组和左右下标。在构造二叉树的时候尽量不要重新定义左右区间数组，而是用下标来操作原数组。</li>
<li><p><code>int mid = (left + right) / 2</code>最好写成<code>int mid = left + (right - left) / 2</code>。原因是两个整数相加可能会超出整数的最大范围。本题虽然采取第一种写法没事，但要有清醒的意识，避免出事。</p>
</li>
<li><p>注意循环不变量原则：区间要么一直保持为左闭右闭，要么一直保持为左闭右开。这关乎到终止条件的具体写法、递归时传入的区间下标以及主函数中调用递归函数时传入的下标。</p>
</li>
<li>本题的递归写法思路非常简单：先写终止条件，再取数组最中间的元素作为二叉树的root节点，再利用数组的左区间构造root节点的左子树，最后利用数组的右区间构造root节点的右子树，最后返回root节点即可。</li>
<li>本题的迭代写法代码比较复杂，不要求掌握。还是优先掌握递归写法。</li>
</ol>
<h3 id="538-把二叉搜索树转换为累加树-2"><a href="#538-把二叉搜索树转换为累加树-2" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h3><ol>
<li>先想如何把有序（递增）数组变为累加数组：<strong>倒序遍历数组，然后用双指针算法即可</strong>，即当前元素的新值等于当前元素的旧值加上前一个元素的值。根据这个思路解决本题。二叉搜索树通过中序遍历可以转换为有序数组，倒序遍历数组即相当于<strong>反中序遍历二叉搜索树</strong>。对树中节点值的累加也是通过<strong>双指针</strong>实现的。</li>
<li>本题的<strong>递归函数不需要返回值</strong>，原因：由于要遍历整个二叉树，在遍历的过程中去更新节点数值即可，因此不需要返回值。</li>
<li>本题的pre指针可以是整数类型的变量，也可以是指针类型的变量。若采用整数类型的变量，可以避免对指针是否为空的判断（整数的初始值为0），因此采用整数类型的变量作为pre更加方便。</li>
<li>本题是迭代的模板题，但我用迭代法写本题总是容易写错。因此还是推荐递归法。</li>
</ol>
<h3 id="总结篇"><a href="#总结篇" class="headerlink" title="总结篇"></a>总结篇</h3><ol>
<li><p>解决二叉树类题目的基本方法是递归法。一般使用了<strong>递归三部曲</strong>来分析题目，看到二叉树，看到递归，都应该想：返回值、参数是什么？终止条件是什么？单层逻辑是什么？</p>
</li>
<li><p>大多数题也都有迭代解法，但是一般代码更长也更容易写错，可以用于提升自己。</p>
</li>
</ol>
<p>二叉树类的题目可以分为以下几类：</p>
<h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>深度优先遍历<br>   二叉树：前中后序递归法：递归三部曲初次亮相<br>   二叉树：前中后序迭代法（一）：通过栈模拟递归<br>   二叉树：前中后序迭代法（二）统一风格</p>
<p>广度优先遍历<br>   二叉树的层序遍历：通过队列模拟</p>
<h4 id="求二叉树的属性"><a href="#求二叉树的属性" class="headerlink" title="求二叉树的属性"></a>求二叉树的属性</h4><p>二叉树：是否对称<br>递归：后序，比较的是根节点的左子树与右子树是不是相互翻转</p>
<p>二叉树：求最大深度<br>递归：后序，求根节点最大高度就是最大深度，通过递归函数的返回值做计算树的高度<br>迭代：层序遍历</p>
<p>二叉树：求最小深度<br>递归：后序，求根节点最小高度就是最小深度，注意最小深度的定义<br>迭代：层序遍历</p>
<p>二叉树：求有多少个节点<br>递归：后序，通过递归函数的返回值计算节点数量<br>迭代：层序遍历</p>
<p>二叉树：是否平衡<br>递归：后序，注意后序求高度和前序求深度，递归过程判断高度差</p>
<p>二叉树：找所有路径<br>递归：前序，方便让父节点指向子节点，涉及回溯处理根节点到叶子的所有路径</p>
<p>二叉树：递归中如何隐藏着回溯<br>详解二叉树：找所有路径中递归如何隐藏着回溯</p>
<p>二叉树：求左叶子之和<br>递归：后序，必须三层约束条件，才能判断是否是左叶子。</p>
<p>二叉树：求左下角的值<br>递归：顺序无所谓，优先左孩子搜索，同时找深度最大的叶子节点。<br>迭代：层序遍历找最后一行最左边</p>
<p>二叉树：求路径总和<br>递归：顺序无所谓，递归函数返回值为bool类型是为了搜索一条边，没有返回值是搜索整棵树。</p>
<h4 id="二叉树的修改与构造"><a href="#二叉树的修改与构造" class="headerlink" title="二叉树的修改与构造"></a>二叉树的修改与构造</h4><p>翻转二叉树<br>递归：前序，交换左右孩子</p>
<p>构造二叉树<br>递归：前序，重点在于找分割点，分左右区间构造</p>
<p>构造最大的二叉树<br>递归：前序，分割点为数组最大值，分左右区间构造</p>
<p>合并两个二叉树<br>递归：前序，同时操作两个树的节点，注意合并的规则</p>
<h4 id="求二叉搜索树的属性"><a href="#求二叉搜索树的属性" class="headerlink" title="求二叉搜索树的属性"></a>求二叉搜索树的属性</h4><p>二叉搜索树中的搜索<br>递归：二叉搜索树的递归是有方向的<br>迭代：因为有方向，所以迭代法很简单</p>
<p>是不是二叉搜索树<br>递归：中序，相当于变成了判断一个序列是不是递增的</p>
<p>求二叉搜索树的最小绝对差<br>递归：中序，双指针操作</p>
<p>求二叉搜索树的众数<br>递归：中序，清空结果集的技巧，遍历一遍便可求众数集合</p>
<p>二叉搜索树转成累加树<br>递归：中序，双指针操作累加</p>
<h4 id="二叉树公共祖先问题"><a href="#二叉树公共祖先问题" class="headerlink" title="二叉树公共祖先问题"></a>二叉树公共祖先问题</h4><p>二叉树的公共祖先问题<br>递归：后序，回溯，找到左子树出现目标值，右子树节点目标值的节点。</p>
<p>二叉搜索树的公共祖先问题<br>递归：顺序无所谓，如果节点的数值在目标区间就是最近公共祖先</p>
<h4 id="二叉搜索树的修改与构造"><a href="#二叉搜索树的修改与构造" class="headerlink" title="二叉搜索树的修改与构造"></a>二叉搜索树的修改与构造</h4><p>二叉搜索树中的插入操作<br>递归：顺序无所谓，通过递归函数返回值添加节点</p>
<p>二叉搜索树中的删除操作<br>递归：前序，想清楚删除非叶子节点的情况</p>
<p>修剪二叉搜索树<br>递归：前序，通过递归函数返回值删除节点</p>
<p>构造二叉搜索树<br>递归：前序，数组中间节点分割</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/23/Day-22-Leetcode-235-701-450/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/23/Day-22-Leetcode-235-701-450/" class="post-title-link" itemprop="url">Day 22 Leetcode 235 701 450</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-23 04:30:05" itemprop="dateCreated datePublished" datetime="2024-04-23T04:30:05+01:00">2024-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-24 09:22:15" itemprop="dateModified" datetime="2024-04-24T09:22:15+01:00">2024-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（二叉树）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">235. 二叉搜索树的最近公共祖先</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html">701.二叉搜索树中的插入操作</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">450.删除二叉搜索树中的节点</a></p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h3><p>拿到本题，我发现这道题和236. 二叉树的最近公共祖先基本相同，只不过二叉树的条件被增强为二叉搜索树。我首先尝试用236题的思路和代码解决本题。据此，我独立写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件1</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 终止条件2</span></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (left) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (right) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后尝试利用二叉搜索树的特性来进行优化。我想到的优化是：用双指针后序遍历二叉搜索树，若pre和cur分别指向两个目标节点，那么cur就是两节点的最近公共祖先。直接看卡尔的讲解吧。</p>
<h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h3><p>本题应该充分利用二叉搜索树的性质就可以求解。若插入节点的值大于当前节点，则向当前节点的右子树插。若插入节点的值小于当前节点，则向当前节点的左子树插。我选择的策略是尽量往叶子节点那一层插入。根据这个思路，我写下了如下的代码（迭代写法，实际上就是枚举将val节点插入二叉搜索树的各种可能）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root为空，则直接返回由val创建的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后序移动cur指针，不要直接移动root</span></span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cur无左子节点的情况，则条件合适就将val节点作为cur的左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; val &lt; cur-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* insert = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                cur-&gt;left = insert;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// cur无右子节点的情况，则条件合适就将val节点作为cur的右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right == <span class="literal">NULL</span> &amp;&amp; val &gt; cur-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* insert = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                cur-&gt;right = insert;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则继续走到叶子节点位置，在叶子节点之下插入val节点</span></span><br><span class="line">            <span class="keyword">if</span> (val &gt; cur-&gt;val) cur = cur-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; cur-&gt;val) cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* insert = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                <span class="keyword">if</span> (val &gt; cur-&gt;val) cur-&gt;right = insert;</span><br><span class="line">                <span class="keyword">else</span> cur-&gt;left = insert;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 必须随便返回一个东西，虽然必然不会执行这行代码，但不返回一个东西本程序就会报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，<strong>上述写法一定要区分cur指针和root节点</strong>。在写出了迭代写法后，应该也可以根据相同的原理写出递归写法。递归的写法其实非常简单，我尝试了一段时间后写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要插入的节点的值小于root节点的值，则将其插入root节点的左子树</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val)  root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="comment">// 要插入的节点的值大于root节点的值，则将其插入root节点的右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h3><p>本题的难点在于删除二叉搜索树中的节点后，要调整二叉树的结构，甚至要改变root节点。我想到的办法就是中序遍历时使用双指针。当cur指针找到要删去的节点时，cur指针再向后移动一位，然后直接用cur指针指向pre指针，就完成了对要删去节点的删除。根据这个算法思路，我尝试写代码，但写不出来，直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="235-二叉搜索树的最近公共祖先-1"><a href="#235-二叉搜索树的最近公共祖先-1" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h3><p>基于236. 二叉树的最近公共祖先，要好好利用二叉搜索树的特性。<strong>思路</strong>：从上往下遍历二叉树，若当前遍历的节点的值大于p和q的值，则p和q的最近公共祖先一定在当前节点的左子树中，此时从当前遍历的节点开始向左遍历。若当前遍历的节点的值小于p和q的值，则p和q的最近公共祖先一定在当前节点的右子树中，此时从当前遍历的节点开始向右遍历。若当前遍历的节点的值在p和q之间，则当前节点就是p和q的公共节点。</p>
<p>现在的问题是，当前节点是否是p和q的最近公共祖先？其实是的。因为p和q分别在当前节点的左右子树中，如果从当前节点开始继续向下遍历，那么不是错过p就是错过q。接下来开始写递归法的代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑</span></span><br><span class="line">    <span class="comment">// 本题不用涉及前中后序，因为二叉搜索树本身是有序的，只要有左和右即可，中在哪里都可以</span></span><br><span class="line">    <span class="comment">// 若当前遍历的节点的值大于p和q的值，则p和q的最近公共祖先一定在当前节点的左子树中，此时从当前遍历的节点开始向左遍历</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* left = <span class="built_in">traversal</span>(cur-&gt;left, p, q);</span><br><span class="line">    	  <span class="comment">// 在向左遍历的过程中找到了p和q的最近公共祖先，则返回之</span></span><br><span class="line">    		<span class="keyword">if</span> (left != <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若当前遍历的节点的值小于p和q的值，则p和q的最近公共祖先一定在当前节点的右子树中，此时从当前遍历的节点开始向右遍历</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* right = <span class="built_in">traversal</span>(cur-&gt;right, p, q);</span><br><span class="line">        <span class="comment">// 在向右遍历的过程中找到了p和q的最近公共祖先，则返回之</span></span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剩下的情况：当前节点的值在p和q之间，则当前节点就是p和q的最近公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本题迭代法的代码也比较简单，原因是二叉搜索树确定了搜索的方向。迭代法代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) cur = cur-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) cur = cur-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 一定不要忘记这句话，否则函数会因为没有返回值报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于二叉搜索树的题目，迭代法似乎比递归法还更简单。</p>
<h3 id="701-二叉搜索树中的插入操作-1"><a href="#701-二叉搜索树中的插入操作-1" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h3><p>插入新节点的方式有多种，得到的二叉搜索树不唯一。<strong>必然可以在二叉搜索树的叶子节点处插入新的节点</strong>。若在二叉搜索树的其他位置处插入节点，则改变了二叉搜索树的结构，将本题做复杂了。递归法代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// 卡尔的理解：遍历到空节点（叶子节点的左子节点或右子节点）时，将val节点作为叶子节点的左子节点或者右子节点</span></span><br><span class="line">    <span class="comment">// 此时将val节点向上返回给叶子节点</span></span><br><span class="line">    <span class="comment">// 卡尔的理解方式比较复杂，不如直接理解为传入一个空的树，返回根据val创建的新节点即可</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 卡尔的理解：在val节点作为叶子节点的左子节点时，当前节点的左指针指向val节点</span></span><br><span class="line">    <span class="comment">// 在val节点作为叶子节点的右子节点时，当前节点的右指针指向val节点</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="built_in">insert</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">if</span> (val &gt; root-&gt;val) root-&gt;right = <span class="built_in">insert</span>(root-&gt;right, val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>卡尔相当于是从叶子节点开始，自下往上讲解递归法的原理。我的理解方式是从root节点开始，自上而下的理解递归的思路。我的理解方式要简单一些，有利于快速写出本题的递归版本的代码</strong>。本题也可以用迭代法，由于是二叉搜索树明确了搜索的方向，所以迭代法的代码也会比较简单。</p>
<p>看了代码随想录的讲解后，我独立写出了正统的迭代法的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用cur节点作为当前遍历到的节点，用parent节点作为cur节点的父节点</span></span><br><span class="line">        <span class="comment">// 因为最后是在叶子节点下插入新节点，因此cur节点必定会遍历到空节点，此时需要利用parent节点来指向新节点</span></span><br><span class="line">        TreeNode* parent = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cur == NULL时终止循环</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// parent节点随着cur节点移动，但始终落后一步，因此parent节点是当前节点的上一个节点（父节点）</span></span><br><span class="line">            parent = cur; </span><br><span class="line">            <span class="comment">// 根据二叉搜素树的有序性移动cur节点</span></span><br><span class="line">            <span class="keyword">if</span> (val &lt; cur-&gt;val) cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最终在二叉搜索树的叶子节点下插入新节点，这就需要用到parent节点，因为cur节点已经为空</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; parent-&gt;val) parent-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">else</span> parent-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>正统的迭代法采取的是<strong>双指针</strong>的思路，需要两个节点，一个是cur节点，其是遍历二叉搜索树时的当前节点。另一个是parent节点，其是当前节点的上一个节点（父节点）。</p>
<h3 id="450-删除二叉搜索树中的节点-1"><a href="#450-删除二叉搜索树中的节点-1" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h3><p>删除节点后，要保证二叉树依然是二叉搜索树。<strong>本题比较难，因为要修改二叉树的结构</strong>。删除节点后的二叉树结构不唯一，只要符合二叉搜索树的定义即可。下面开始分析可能的情况。</p>
<ul>
<li>没找到要删除的节点</li>
<li>要删除的节点是叶子节点，左为空，右也为空（此时删除节点较为简单，因为不需要改变二叉树的结构）</li>
<li>要删除的节点左不为空，右为空。则让该节点的父节点直接指向该节点的左子节点</li>
<li>要删除的节点左为空，右不空。则让该节点的父节点直接指向该节点的右子节点</li>
<li>要删除的节点左不空，右不空。本情况最复杂，因为要大幅调整二叉搜索树的结构。拿以下二叉树为例：<br><img src="D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/tstmp_20240424064451.gif" alt="tstmp_20240424064451"></li>
</ul>
<p>例如删去节点7。<strong>让7的右子树继位</strong>，那么7的左子树应该放在右子树的哪里。<strong>7的左子树应该放在右子树中的左下角（右子树中的最小值）</strong>。让7的左子树继位也可以，原理相同。</p>
<p>接下来开始写代码（代码不多但不好理解）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不写cpp中需要释放内存的逻辑，只写核心代码</span></span><br><span class="line"><span class="comment">// 返回新二叉树的根节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">delete</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// 不需要遍历整个二叉树，找到要删除的点就是终止条件</span></span><br><span class="line">    <span class="comment">// 找到要删除的点后就要删除该点，因此删除该点的操作在终止条件中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没找到要删除的节点/传入的二叉树为空</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要删除的节点是叶子节点，左为空，右也为空</span></span><br><span class="line">        <span class="comment">// return NULL的意思是该节点的父节点指向NULL</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要删除的节点左不为空，右为空</span></span><br><span class="line">        <span class="comment">// 将要删除的节点的左孩子直接向上返回即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要删除的节点左为空，右不空</span></span><br><span class="line">        <span class="comment">// 将要删除的节点的右孩子直接向上返回即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要删除的节点左不空，右不空</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* cur = root-&gt;right; <span class="comment">// 要删除节点的右子树</span></span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;left) cur = cur-&gt;left; <span class="comment">// 让cur指向右子树的左下角</span></span><br><span class="line">            cur-&gt;left = root-&gt;left; <span class="comment">// 将要删除节点的左子树嫁接到右子树的左下角</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移除要删除的节点，此时要删除的节点左为空右不为空，因为直接向上返回其右孩子即可</span></span><br><span class="line">            <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归</span></span><br><span class="line">    <span class="comment">// 二叉搜素树确定了搜索的方向</span></span><br><span class="line">    <span class="comment">// root的左子树在删去节点后，左子树的新根节点嫁接到root-&gt;left上</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;val) root-&gt;left = <span class="built_in">delete</span>(root-&gt;left, key); </span><br><span class="line">    <span class="comment">// root的右子树在删去节点后，右子树的新根节点嫁接到root-&gt;left上</span></span><br><span class="line">    <span class="keyword">if</span> (key &gt; root-&gt;val) root-&gt;right = <span class="built_in">delete</span>(root-&gt;right, key);</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 看似没有处理root，但实际上已经在终止条件中处理了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码不算复杂，但是很难想。注意：删除节点的操作是通过返回值来进行的，然后让本层递归的上一层去接住本层递归的返回值。本题也可以用迭代法实现。本题的进阶版本：在一般的二叉树中删除节点，更难。吃透本题即可。</p>
<p>本题精简的注释版本如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件，分为五种情况</span></span><br><span class="line">        <span class="comment">// 情况1：找不到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 情况2，要删除的节点左右都为空</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 情况3，要删除的节点左为空右不空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            <span class="comment">// 情况4，要删除的节点左不空右为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            <span class="comment">// 情况5，要删除的节点左不空右不空</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* cur = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span> (cur-&gt;left) cur = cur-&gt;left;</span><br><span class="line">                cur-&gt;left = root-&gt;left;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">else</span> root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="235-二叉搜索树的最近公共祖先-2"><a href="#235-二叉搜索树的最近公共祖先-2" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h3><ol>
<li>本题和236的区别在于，本题的条件得到了强化，不仅是二叉树，而且是二叉搜索树。</li>
<li>由于二叉搜索树的方向性，本题不需要回溯，自上往下查找目标区间即可。</li>
<li>本题的核心思路：从上往下遍历二叉树，若当前节点的值大于p和q节点的值，则p和q的最近公共祖先在当前节点的左子树中，从当前节点开始向左遍历。若当前节点的值小于p和q节点的值，则p和q的最近公共祖先在当前节点的右子树中，从当前节点开始向右遍历。若当前节点的值在<code>[p-&gt;val, q-&gt;val]</code>的范围内，则当前节点就是p和q的最近公共祖先。注意区间是左闭右闭，因为存在p为q的父节点的情况。</li>
<li>为什么当前节点的值在<code>[p-&gt;val, q-&gt;val]</code>的范围内，就可以确定当前节点就是p和q的最近公共祖先，而不仅仅是一个普通的公共祖先？这个原因在于：当前节点的值&gt;<code>p-&gt;val</code>，则说明p在当前节点的左子树中；当前节点的值&lt;<code>q-&gt;val</code>，则说明q在当前节点的左子树中。因此若从当前节点开始向下移动到下一个节点处，那么不是错过p就是错过q。因此当前节点就是p和q的最近公共祖先。</li>
<li>因为二叉搜索树的有序性，本题的迭代写法也非常简单，甚至比递归解法更简单。</li>
</ol>
<h3 id="701-二叉搜索树中的插入操作-2"><a href="#701-二叉搜索树中的插入操作-2" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h3><ol>
<li>本题可以采用递归法和迭代法。但递归法的代码较为简单，因此推荐使用递归法。迭代法的代码略微复杂，但采用的双指针思路也非常清晰，因此也可以掌握迭代法。</li>
<li>插入新节点的方式有多种，得到的二叉搜索树不唯一。但必然可以在二叉搜索树的叶子节点处插入新的节点。因此不用改变二叉搜索树的结构，就可以实现插入操作。这是本题简单易解的根本所在。</li>
<li><p>本题递归法的思路：</p>
<ul>
<li>递归函数的返回值：返回插入新节点后二叉搜索树的根节点。也可以返回空，但那样写比较麻烦。</li>
<li>终止条件：root节点为空时，说明输入的二叉树为空，因此直接返回val节点即可。</li>
<li>单层递归逻辑：若<code>val &gt; root-&gt;val</code>，说明val节点应该被插入在root节点的右子树中，因此有<code>root-&gt;right = insert(root-&gt;right, val)</code>（<code>insert(root-&gt;right, val)</code>返回了root的右子树在插入新节点后的头节点，用root的右节点指向该头节点即可）。若<code>val &lt; root-&gt;val</code>，说明val节点应该被插入在root节点的左子树中，因此有<code>root-&gt;left = insert(root-&gt;left, val)</code>。最终返回root即可。</li>
</ul>
</li>
<li><p>卡尔相当于是从叶子节点开始，自下往上讲解递归法的原理。我的理解方式是从root节点开始，自上而下的理解递归的思路。我的理解方式要简单一些，有利于快速写出本题的递归版本的代码。</p>
</li>
<li><p>本题的迭代写法思路也非常清晰。迭代法采取的是<strong>双指针</strong>的思路，需要两个节点，一个是cur节点，其是遍历二叉搜索树时的当前节点。另一个是parent节点，其是当前节点的上一个节点（父节点）。我在初次尝试中实现的迭代法代码复杂且由于要考虑多种情况，非常容易写错。因此建议如果要写迭代法，就采用基于双指针思路的迭代法。</p>
</li>
</ol>
<h3 id="450-删除二叉搜索树中的节点-2"><a href="#450-删除二叉搜索树中的节点-2" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h3><ol>
<li><p>本题相比于在二叉搜索树中插入节点，复杂得多，原因是删除二叉搜索树中的节点且保持该二叉树仍为二叉搜索树，会改变二叉搜索树原本的结构。</p>
</li>
<li><p>本题的第一个难点在于分析出删除一个节点的五种情况。</p>
<ul>
<li><p>找不到要删除的节点</p>
</li>
<li><p>要删除的节点的左右子节点均为空</p>
</li>
<li><p>要删除的节点的左空右不空</p>
</li>
<li><p>要删除的节点的左不空右空</p>
</li>
<li><p>要删除的节点的左右均不空</p>
</li>
</ul>
<p>由于在终止条件中要找到需要删除的节点，因此删除节点的操作也在终止条件中完成。</p>
</li>
<li><p>本题的第二个难点在于实现第五种情况的代码。我直接附上相应的代码并进行解释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* cur = root-&gt;right;</span><br><span class="line"><span class="keyword">while</span> (cur-&gt;left) cur = cur-&gt;left;</span><br><span class="line">cur-&gt;left = root-&gt;left;</span><br><span class="line"><span class="keyword">return</span> root-&gt;right;</span><br></pre></td></tr></table></figure>
<p>先找到要删除的节点root，然后让cur指针指向root的右子节点。接着用cur遍历root的右子树，直到cur指向右子树的左下角。将root的左子树嫁接到右子树的左下角，最后返回root的右子节点。以root的右子节点为根节点的二叉树就是一棵二叉搜索树。可以举例子画图理解上述构造二叉搜索树的操作。</p>
</li>
<li><p>本题的基本原理在于：删除节点的操作是通过返回值进行的，然后让本层递归的上一层去接住本层递归的返回值。</p>
</li>
<li>删除一般的二叉树中的节点要采用另外的算法，因此不要求掌握。</li>
<li>本题也有迭代写法，需要用到双指针算法，代码也更加复杂，因此不要求掌握。</li>
<li>按理来说，cpp中需要显式地释放被删除节点占用的内存。但不释放也不会对代码的正常运行造成影响。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/21/Day-20-Leetcode-530-501-236/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/21/Day-20-Leetcode-530-501-236/" class="post-title-link" itemprop="url">Day 20 Leetcode 530 501 236</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-21 09:49:51" itemprop="dateCreated datePublished" datetime="2024-04-21T09:49:51+01:00">2024-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-23 04:31:34" itemprop="dateModified" datetime="2024-04-23T04:31:34+01:00">2024-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（二叉树）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html">530.二叉搜索树的最小绝对差</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html">501.二叉搜索树中的众数</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. 二叉树的最近公共祖先</a></p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h3><p>本题虽然是个easy题，但我想不出来怎么做。唯一的思路是双指针，至于怎么递归，按照怎样的顺序，我想不出来。</p>
<h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h3><p>本题显然又要充分利用二叉搜索树的特性：中序遍历二叉搜索树，得到的数组是递增的，统计数组中出现频次最高的元素即可。本题我目前发现了两个需要注意的点：</p>
<ol>
<li>出现频次最高的元素可能不止一个，因此需要返回一个数组。</li>
<li>本二叉搜索树的性质为：左子树中的所有节点<strong>小于等于</strong>根节点，右子树中的所有节点<strong>大于等于</strong>根节点。</li>
</ol>
<p>本题似乎也应该采用双指针的做法。若<code>pre-&gt;val</code>和<code>cur-&gt;val</code>相等，则<code>cnt</code>数组（用于统计元素值出现的次数）中<code>pre-&gt;val</code>的值加1。但这里有两个问题：</p>
<ul>
<li>节点的值可能为负数，因此不能将节点的值直接映射为数组的下标</li>
<li>若出现次数最多的元素不止一个，该如何返回数组</li>
</ul>
<p>上述两个问题都不好解决，我直接看卡尔的讲解吧。</p>
<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h3><p>本题比较难，我拿到后没有什么想法，猜测可能要用到回溯。直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="530-二叉搜索树的最小绝对差-1"><a href="#530-二叉搜索树的最小绝对差-1" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h3><p>目标：求任意两节点间的最小绝对差。由于是二叉搜索树，用中序遍历会成为一个有序的序列，据此思路尝试解出此题。我独立写出了本题的第一种解法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> min = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>() - <span class="number">1</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; vec[i + <span class="number">1</span>] - vec[i]) min = vec[i + <span class="number">1</span>] - vec[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>和98.验证二叉搜索树相同，本题应该也可以用<code>maxvalue</code>法和双指针法。这两种方法本质上都是不用额外的数组，直接在中序遍历时计算两个相邻节点的差值，然后选取最小的差值。现在我来尝试这两种解法。这两种解法我还是想不出来，看卡尔的讲解。</p>
<p>接下来讲解如何在中序遍历时利用两个指针直接得出最小绝对差，而不用把二叉树转变为数组。难点：中序遍历二叉树时前后指针如何移动（控制）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res = INT_MAX;</span><br><span class="line"></span><br><span class="line">TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回二叉树的某一特性或者二叉树节点的某个数值，才需要返回值。本题的情况不需要返回值</span></span><br><span class="line"><span class="comment">// 确切来说，一找到就需要立刻去返回的才需要返回值。需要遍历整棵二叉树且用全局变量来记录返回结果的，函数就不需要返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑：中序遍历</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">    <span class="comment">// 中</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) res = <span class="built_in">min</span>(res, cur-&gt;val - pre-&gt;val);</span><br><span class="line">    pre = cur;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移动pre和cur的核心在于：cur由中序遍历来移动，pre由赋值移动。cur是当前节点，pre是当前节点的上一个节点。</p>
<p>根据上述核心代码，我写下了本题的完整代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = INT_MAX;</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; cur-&gt;val - pre-&gt;val &lt; res)</span><br><span class="line">            res = cur-&gt;val - pre-&gt;val;</span><br><span class="line">        <span class="comment">// 也可写作</span></span><br><span class="line">        <span class="comment">// if (pre != NULL) res = min(res, cur-&gt;val - pre-&gt;val);</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题也可以用迭代法，但不推荐。</p>
<h3 id="501-二叉搜索树中的众数-1"><a href="#501-二叉搜索树中的众数-1" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h3><p>二叉搜索树中可能有重复的元素。众数可能不止一个，因此输出众数的集合。暴力做法：对一棵普通的二叉树，遍历二叉树，用map统计每个元素出现的频次，然后将map转换为vector，对vector进行排序，然后在数组中求众数。</p>
<p>如何利用二叉搜索树的特性去求众数的集合？遍历顺序：中序遍历。中序遍历得到的数组中的所有元素是单调递增的。<strong>求众数的具体方法：先遍历一遍二叉树，记录下所有元素出现的最高频率。再遍历一遍二叉树，将出现频率为最高频率的元素放入结果集中。</strong>其实可以不遍历两遍二叉树，遍历一遍二叉树即可，需要用到一些代码技巧。</p>
<p>双指针算法的思路：用count来统计当前元素出现的次数。当<code>pre-&gt;val == cur-&gt;val</code>时，当前元素出现的次数加1。当<code>pre-&gt;val != cur-&gt;val</code>，则count归一。初始时，pre指向NULL，count指向左叶子节点，count也为一。当<code>count == maxcount</code>时，将当前元素放入结果集中。</p>
<p>这里有个问题：如果不事先遍历一遍二叉树，怎么知道<code>maxcount</code>一定是真正的最高频率？后面的具体代码实现中会处理这个问题。现在开始写具体的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 当前元素出现的频率</span></span><br><span class="line"><span class="type">int</span> maxcount = <span class="number">0</span>; <span class="comment">// 整个二叉树中（已经遍历过的节点）的元素出现的最高频率</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 结果集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历整个二叉树，结果放入全局变量中，因此递归函数不需要返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层的递归逻辑</span></span><br><span class="line">    <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">    <span class="comment">// 中：处理逻辑</span></span><br><span class="line">    <span class="comment">// 统计count</span></span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) count = <span class="number">1</span>; <span class="comment">// 双指针的初始位置：pre为NULL，cur指向左叶子节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) count += <span class="number">1</span>; <span class="comment">// 当前元素出现的次数+1</span></span><br><span class="line">    <span class="keyword">else</span> count = <span class="number">1</span>; <span class="comment">// 双指针指向的节点的值不相等，则count又回到1</span></span><br><span class="line">    pre = cur; <span class="comment">// pre跟随cur移动</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若当前节点的出现次数等于整个二叉树中元素出现的最大次数，则将其放入结果集中</span></span><br><span class="line">    <span class="keyword">if</span> (count == maxcount) res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时存在问题：maxcount不是真正的maxcount，因此需要代码去更新res数组</span></span><br><span class="line">    <span class="comment">// 实时更新res数组，就不需要遍历两遍二叉树了</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; maxcount) </span><br><span class="line">    &#123;</span><br><span class="line">        maxcount = count; <span class="comment">// 更新maxcount</span></span><br><span class="line">        <span class="comment">// maxcount都被更新了，原先的结果集中的结果全废了，清空res</span></span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 将当前节点的数值放入结果集中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我也写出了遍历两次二叉树的代码，如下所示。需要特别注意的是，<code>getmaxcount</code>后需要重置pre和count。遍历两次二叉树的代码显得很冗余，因为基本相同的逻辑写了两遍。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次遍历二叉树，得到maxcount</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getmaxcount</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">getmaxcount</span>(cur-&gt;left);</span><br><span class="line">        <span class="comment">// 中节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> count = <span class="number">1</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxcount) maxcount = count;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">getmaxcount</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次遍历二叉树，得到结果集</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> count = <span class="number">1</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span> (count == maxcount) res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">getmaxcount</span>(root);</span><br><span class="line">        pre = <span class="literal">NULL</span>; <span class="comment">// getmaxcount后重置pre</span></span><br><span class="line">        count = <span class="number">0</span>; <span class="comment">// getmaxcount后重置count</span></span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题也可以采用迭代法，基本上是迭代的模板加上递归法对中节点的处理逻辑。但本题推荐掌握递归法即可。</p>
<h3 id="236-二叉树的最近公共祖先-1"><a href="#236-二叉树的最近公共祖先-1" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h3><p>找两个节点p和q的最近公共祖先。条件：二叉树中所有节点的值都是不同的，二叉树中一定存在p和q。根节点是任何两个节点的公共祖先，所以求公共祖先没有意义，求最近公共祖先才有意义。简单的想法：找到节点p和节点q后，从下往上去遍历，直到找到公共的节点。但对二叉树，一般大家熟悉的是从根节点开始从上往下去遍历，实际上也无法从下往上去遍历，但处理顺序可以是从下往上的。<strong>回溯的过程就可以让我们去从下往上地处理结果</strong>。具体来说，可以判断某个节点的左子树是否出现过p，右子树是否出现过q，如果都出现了，就将该节点向上返回。看该节点的父节点，若父节点的左子树中没出现p，或者右子树中没出现q，则说明该节点是p和q的最近公共祖先。父节点继续将最近公共祖先节点的值向上返回，直到返回到根节点。</p>
<p>从下往上传递p和q节点的最近公共祖先的逻辑写在回溯过程中。<strong>想在回溯过程中达到从下往上处理的效果，一定要用后序遍历</strong>。后序遍历是左右中，中：处理逻辑。<strong>中的具体处理逻辑</strong>：判断某个节点的左子树是否出现过p，右子树是否出现过q。即在终止条件中，如果遇到了p或者q，就往上返回。如果一个节点的左子树的返回值不为空，则左子树中出现了p或者q；如果一个节点的右子树的返回值不为空，则右子树中出现了p或者q。<strong>如果当前中节点的左右子树的返回值都不为空，则当前的中节点就是p和q最近的公共祖先</strong>。还有一种情况。即p就是q的公共祖先。但本情况的处理逻辑和上面是相同的。</p>
<p>具体的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回最近的公共祖先</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件1</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 终止条件2：遇到节点p或者q，则将它们向上返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归的逻辑：后序遍历</span></span><br><span class="line">    <span class="comment">// 左：可以告诉我们左子树中是否出现过p或者q</span></span><br><span class="line">    TreeNode* left = <span class="built_in">traversal</span>(root-&gt;left, p, q);</span><br><span class="line">    <span class="comment">// 右：可以告诉我们右子树中是否出现过p或者q</span></span><br><span class="line">    TreeNode* right = <span class="built_in">traversal</span>(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">// 中</span></span><br><span class="line">    <span class="comment">// 左右子树中出现了p和q，则root是最近公共祖先，将root返回</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 左子树中没有p和q，右子树为最近公共祖先，则继续将right（即最近公共祖先）向上返回，可以参见下面的实例</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="comment">// 左子树为最近公共祖先，右子树中没有p和q，则继续将left(即最近公共祖先)向上返回，和上面一行代码同理</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="comment">// 左右子树都为空，则return NULL</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 7, q = 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<p>以上面的二叉树为例，2的左子树返回7，右子树返回4，则2是最近公共祖先。5的左子树返回空，右子树返回2，2是7和4的最近公共祖先，则将2继续向上返回。</p>
<p>为什么上述代码将另一种情况也包含了？以上图为例，若p=7, q=2，则q就是最近的公共祖先。<strong>一旦遇到q就返回，就不继续向下遍历了</strong>。最终就将q返回到root节点，作为结果了。因此另一种情况不需要特别考虑。</p>
<p>本题的难点：</p>
<ul>
<li>回溯的过程可以将结果逐层从下往上返回。</li>
<li>从下往上返回结果需要用到后序遍历。先进行左右子树的判断逻辑，再进行中节点的逻辑。只有左右子树的返回值不为空，才将中节点作为最近公共祖先返回。</li>
<li>可以举实例画图理解本题的回溯过程和后序遍历中节点的处理（返回）逻辑。</li>
<li>情况2的处理逻辑包含于情况1中。</li>
</ul>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="530-二叉搜索树的最小绝对差-2"><a href="#530-二叉搜索树的最小绝对差-2" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h3><ol>
<li>遇到二叉搜索树，首先需要注意其在中序遍历后得到的数组是递增的这一特性。</li>
<li>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值。</li>
<li><strong>我之所以一开始没有写出本题的双指针解法，原因在于</strong>忘记了如何确定递归函数的返回值。对于本题，需要遍历整棵二叉树且用全局变量来记录返回结果，因此递归函数不需要返回值。</li>
<li>本题的双指针法的思路和98.验证二叉搜索树相同，但两题的区别在于本题的递归函数没有返回值，而98题的递归函数返回值为bool类型。</li>
<li>移动pre和cur的核心在于：cur由中序遍历来移动，pre由赋值移动。cur是当前节点，pre是当前节点的上一个节点。</li>
</ol>
<h3 id="501-二叉搜索树中的众数-2"><a href="#501-二叉搜索树中的众数-2" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h3><ol>
<li>本题虽然是easy难度，但其实是<strong>比较难</strong>的。</li>
<li>若是一般的二叉树，而非二叉搜索树，则本题的思路为：首先遍历二叉树，用map统计每个元素出现的次数。然后对map按照value进行排序，将排序后的map的(key, value)中最大的一个（或几个）value对应的key放入结果集中。原理不复杂，但代码实现起来比较麻烦。</li>
<li>本题是二叉搜索树，因此想要充分利用了其性质的话，肯定要采用<strong>中序遍历</strong>。本题的核心思路依然是<strong>双指针算法</strong>。需要一个<code>count</code>来存储当前节点出现的次数，一个<code>maxcount</code>来存储整棵二叉树中出现次数最多的节点出现的次数。如果采用两次遍历的做法，那么需要先遍历一遍二叉树得到<code>maxcount</code>，然后再遍历一遍二叉树，将<code>count == maxcount</code>的节点的值存入结果集中。但实际上，遍历一遍二叉树即可完成上述操作。</li>
<li>遍历一遍二叉树的做法：初始时，<code>count = 1</code>；<code>pre-&gt;val == cur-&gt;val</code>时，<code>count += 1</code>；否则，<code>count = 1</code>。若<code>count == maxcount</code>，则将当前节点的值放入结果集中。此时出现问题：<code>maxcount</code>不一定是整棵二叉树出现次数最多的节点出现的次数。可以用一个简单的办法解决这个问题：若<code>count &gt; maxcount</code>，则更新<code>maxcount</code>，清空结果集，然后再往结果集中插入当前节点的值。通过这样的操作，就可以动态地去更新结果集，从而避免了对二叉树的两次遍历。</li>
</ol>
<h3 id="236-二叉树的最近公共祖先-2"><a href="#236-二叉树的最近公共祖先-2" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h3><ol>
<li><p>本题需要自下往上处理节点，自然而然想到用<strong>回溯</strong>的思想。</p>
</li>
<li><p><strong>后序遍历</strong>（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。因此本题采用后序遍历。</p>
</li>
<li><p>理解以下的示意图就理解了本题：<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151125844.png" alt="236.二叉树的最近公共祖先1"></p>
</li>
<li><p>本题的代码实际上非常简单而清晰，可以根据代码来理解上面的图片，本题的核心代码为中节点的处理逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终止条件1</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 终止条件2：遇到节点p或者q，则将它们向上返回，对应于节点6和5将它们自身向节点7返回的过程</span></span><br><span class="line"><span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单层递归的逻辑：后序遍历</span></span><br><span class="line"><span class="comment">// 左：可以告诉我们左子树中是否出现过p或者q</span></span><br><span class="line">TreeNode* left = <span class="built_in">traversal</span>(root-&gt;left, p, q);</span><br><span class="line"><span class="comment">// 右：可以告诉我们右子树中是否出现过p或者q</span></span><br><span class="line">TreeNode* right = <span class="built_in">traversal</span>(root-&gt;right, p, q);</span><br><span class="line"><span class="comment">// 中</span></span><br><span class="line"><span class="comment">// 左右子树中出现了p和q，则root是最近公共祖先，将root返回，对应于节点7将其自身向节点10返回的过程</span></span><br><span class="line"><span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"><span class="comment">// 左子树中没有p和q，右子树为最近公共祖先，则继续将right（即最近公共祖先）向上返回</span></span><br><span class="line"><span class="comment">// 对应于节点10将节点7向节点8返回的过程</span></span><br><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="comment">// 左子树为最近公共祖先，右子树中没有p和q，则继续将left(即最近公共祖先)向上返回，和上面一行代码同理</span></span><br><span class="line"><span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line"><span class="comment">// 左右子树都为空，则return NULL</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>用文字来描述，本题的关键代码实现了以下功能：</p>
<ul>
<li>遇到节点p或q，就将其向上返回</li>
<li>某个节点的左右子树中包含p和q，则该节点就是p和q的最近公共祖先，将该节点向上返回</li>
<li>某个节点的左右子节点中的一个的返回值不为空，则说明那个返回值不为空的左/右节点为p和q的最近公共祖先，将该节点进一步向上返回</li>
<li>其他情况下均返回空即可</li>
</ul>
</li>
<li><p>还有一种情况，即p是q的父节点，此时遍历到p的父节点时，p的父节点就会向上返回p，而不会继续遍历p和其下面的子树。因此本情况也包含在上述代码的逻辑中。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/19/Day-19-Leetcode-654-617-700-98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/19/Day-19-Leetcode-654-617-700-98/" class="post-title-link" itemprop="url">Day 19 Leetcode 654 617 700 98</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-19 05:22:38" itemprop="dateCreated datePublished" datetime="2024-04-19T05:22:38+01:00">2024-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-22 03:36:45" itemprop="dateModified" datetime="2024-04-22T03:36:45+01:00">2024-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（二叉树）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html">654.最大二叉树</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html">617.合并二叉树</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">700.二叉搜索树中的搜索</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">98.验证二叉搜索树</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h3><p><strong>什么是二叉树搜索树？</strong>其根节点要比左子树里所有节点的数值大，根节点要比右子树里所有节点的数值小。同理，左右子树也符合这个规则。二叉搜索树的上述规则确定了遍历顺序（既不是前序，也不是中序、后序），而二叉搜素树的上述规则也让本题的迭代写法特别简单。</p>
<p><code>if (node != NULL)</code> 可以简写为<code>if (node)</code>。</p>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p>中序遍历一棵二叉搜索树，得到的数组中的元素是有序的。</p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h3><p>本题延续106.从中序与后序遍历序列构造二叉树的思路。步骤可以分为：</p>
<ol>
<li><p>找到nums数组中的最大值，作为root</p>
</li>
<li><p>找到root在nums中的下标</p>
</li>
<li><p>将nums按照root分为左数组和右数组</p>
</li>
<li><p>递归处理左数组和右数组，得到左右子树</p>
</li>
</ol>
<p>我独立写出了以下的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件：数组为空，构造不出树，返回NULL</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到nums数组中的最大值，作为root</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到root在nums中的下标</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j; j &lt; nums.<span class="built_in">size</span>(); j ++ ) </span><br><span class="line">            <span class="keyword">if</span> (nums[j] == max)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> rootvalue = nums[j];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组分为左数组和右数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ml</span><span class="params">(nums.begin(), nums.begin() + j)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mr</span><span class="params">(nums.begin() + j + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归处理左数组和右数组，得到左右子树</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(ml);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(mr);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">traversal</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3><p>对于本题，我也采用前序遍历的方法，独立写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 应该采用前序遍历，先中节点，再左节点，再右节点</span></span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">NULL</span> &amp;&amp; root2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root1 == <span class="literal">NULL</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root2 == <span class="literal">NULL</span>) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootvalue = root1-&gt;val + root2-&gt;val;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左节点</span></span><br><span class="line">        <span class="keyword">if</span> (root1-&gt;left != <span class="literal">NULL</span> &amp;&amp; root2-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root1-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root2-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;left = <span class="built_in">mergeTrees</span>(<span class="literal">NULL</span>, root2-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="keyword">if</span> (root1-&gt;right != <span class="literal">NULL</span> &amp;&amp; root2-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root1-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root2-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;right = <span class="built_in">mergeTrees</span>(<span class="literal">NULL</span>, root2-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由上述代码可知，对左右节点的处理都分了三类讨论，这与终止条件中的三类相对应，这是上述代码可以正确运行的基础。本题应该也可以用层序遍历去做。</p>
<h3 id="700-二叉搜索树中的搜索-1"><a href="#700-二叉搜索树中的搜索-1" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h3><p>哈哈哈这题又给我用前序遍历的写法做出来了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历搜索整棵树</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == val) <span class="keyword">return</span> root; <span class="comment">// 中节点</span></span><br><span class="line">        TreeNode* left = <span class="built_in">searchBST</span>(root-&gt;left, val); <span class="comment">// 左节点：在左子树中搜索值为val的节点</span></span><br><span class="line">        TreeNode* right = <span class="built_in">searchBST</span>(root-&gt;right, val); <span class="comment">// 右节点：在右子树中搜索值为val的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left; <span class="comment">// 在左子树中找到目标节点，则返回之</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right; <span class="comment">// 在右子树中找到目标节点，则返回之</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 左右子树中都没找到，则返回空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题用层序遍历应该也可以做。层序遍历的写法我也独立写出来了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(); <span class="comment">// 取出一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;val == val) <span class="keyword">return</span> node; <span class="comment">// 判断其是否为目标节点，是，则返回之</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 继续往队列中加入当前节点的非空左右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left); </span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若最后没有找到目标节点，则返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="98-验证二叉搜索树-1"><a href="#98-验证二叉搜索树-1" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p>本题我觉得应该采用中序遍历，先验证左子树是否符合要求，再验证中节点是否符合要求，最后验证右子树是否符合要求，根据这个思路，我尝试独立写出本题的代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有root节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 左子树为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt;= root-&gt;right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &lt;= root-&gt;left-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树都不为空</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &lt;= root-&gt;left-&gt;val || root-&gt;val &gt;= root-&gt;right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> res1 = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">                <span class="type">bool</span> res2 = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (res1 &amp;&amp; res2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述代码分了4种情况讨论：只有root节点；左子树为空；右子树为空；左右子树都不为空。但忽略了一种情况：<br>当<code>root = [5,4,6,null,null,3,7]</code>时，二叉树如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A((5)) --&gt; B((4))</span><br><span class="line">    A --&gt; C((6))</span><br><span class="line">    C --&gt; F((3))</span><br><span class="line">    C --&gt; G((7))</span><br></pre></td></tr></table></figure>
<p>此时虽然[5, 4, 6]是二叉搜索树，[6, 3, 7]也是二叉搜素树，但[6, 3, 7]中存在元素3小于root的5，因此整体并不是一棵二叉搜索树。这种局部都是二叉搜索树，但整体不是二叉搜索树的情况，在我的代码中并没有进行特判。因此我只能通过77/85个测试样例。这也是本题的坑之所在。直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="654-最大二叉树-1"><a href="#654-最大二叉树-1" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h3><p>规则：在数组中选取最大的元素作为root，最大元素的左区间用于构造左子树，规则同上；最大元素的右区间用于构造右子树，规则同上。</p>
<p>例如，321605，根据以上规则得到以下的最大二叉树：<br><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img"></p>
<p>遍历方式：前序遍历。<strong>凡是涉及构造二叉树的题目，都要用到前序遍历</strong>。原因：前序遍历顺序是中左右，先构造root节点，再去构造左子树和右子树。</p>
<p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回二叉树的root节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">construct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 确定递归的终止条件</span></span><br><span class="line">    <span class="comment">// 数组中只有一个元素，则唯一一个元素就是root节点</span></span><br><span class="line">    <span class="comment">// 本题题目中对数组的要求是非空，因此不需要考虑数组为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归的逻辑</span></span><br><span class="line">    <span class="comment">// 中节点的逻辑</span></span><br><span class="line">    <span class="comment">// 找到数组中的最大值和其下标</span></span><br><span class="line">    <span class="type">int</span> maxvalue = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxvalue)</span><br><span class="line">        &#123;</span><br><span class="line">            maxvalue = nums[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据最大值定义root节点</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(maxvalue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左子树的逻辑</span></span><br><span class="line">    <span class="comment">// 根据index切割原数组，将其分为左右数组</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) <span class="comment">// 保证左区间中至少有一个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), nums.begin() + index)</span></span>; <span class="comment">// 左区间，左闭右开</span></span><br><span class="line">        root-&gt;left = <span class="built_in">construct</span>(l); <span class="comment">// 递归构造左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右子树的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="comment">// 保证右区间中至少有一个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(nums.begin() + index + <span class="number">1</span>, nums.end())</span></span>; <span class="comment">// 右区间，左闭右开</span></span><br><span class="line">        root-&gt;right = <span class="built_in">construct</span>(r); <span class="comment">// 递归构造右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码严格按照前序遍历构造二叉树。本代码冗余，且效率低，效率低的原因是每次分割时都构造了两个新的数组。<strong>对本代码的优化是每次分割数组时不用构造新的数组，操作下标即可</strong>。</p>
<p>还有一个重要问题：左右子树的逻辑中要加上if判断。写不写if关键在于终止条件。终止条件保证了数组中至少要有一个元素，因此在左右子树的逻辑中需要加上if判断，也就是保证左右区间中至少有一个元素。当然在左右子树的逻辑中不写if也可以，那就需要在leetcode的主函数外另写一个函数。</p>
<p>完整的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历：中节点</span></span><br><span class="line">        <span class="comment">// 找到root的值和下标</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(max);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左节点</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), nums.begin() + index)</span></span>; <span class="comment">// 左区间</span></span><br><span class="line">            root-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(l); <span class="comment">// 递归构造左子树</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(nums.begin() + index + <span class="number">1</span>, nums.end())</span></span>; <span class="comment">// 右区间</span></span><br><span class="line">            root-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(r); <span class="comment">// 递归构造右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>左右子树中不加if判断的写法（关键在于终止条件<code>nums.size() == 0</code>），这也是我在初次尝试中的写法，是最不容易写错的写法。因为思路直接继承自106.从中序与后序遍历序列构造二叉树，且不需要在左右子树处加if判断。<strong>推荐这个写法</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历：中节点</span></span><br><span class="line">        <span class="comment">// 找到root的值和下标</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(max);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), nums.begin() + index)</span></span>; <span class="comment">// 左区间</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(nums.begin() + index + <span class="number">1</span>, nums.end())</span></span>; <span class="comment">// 右区间</span></span><br><span class="line">        root-&gt;left = <span class="built_in">construct</span>(l); <span class="comment">// 递归构造左子树</span></span><br><span class="line">        root-&gt;right = <span class="built_in">construct</span>(r); <span class="comment">// 递归构造右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">construct</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在本写法的基础上进一步进行优化。不在分割数组时创建新的数组，只改变数组的下标。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件，区间是左闭右开的，因此是begin &gt;= end</span></span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全部操作下标，不需要操作元素的值</span></span><br><span class="line">        <span class="type">int</span> index = begin;</span><br><span class="line">        <span class="comment">// 从begin + 1开始搜索，i = begin时，index = i = begin，不需要写入循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin + <span class="number">1</span>; i &lt; end; i ++ ) </span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[index])</span><br><span class="line">                index = i;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左节点</span></span><br><span class="line">        <span class="comment">// 左闭右开</span></span><br><span class="line">        <span class="type">int</span> leftbegin = begin;</span><br><span class="line">        <span class="type">int</span> leftend = index;</span><br><span class="line">        root-&gt;left = <span class="built_in">construct</span>(nums, leftbegin, leftend); <span class="comment">// 递归构造左子树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="type">int</span> rightbegin = index + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightend = end;</span><br><span class="line">        root-&gt;right = <span class="built_in">construct</span>(nums, rightbegin, rightend); <span class="comment">// 递归构造右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要下面这句话，因为已经在construct函数中通过begin == end处理了nums.size() == 0的情况</span></span><br><span class="line">        <span class="comment">// if (nums.size() == 0) return NULL;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">construct</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本版本代码在处理左右节点时不需要进行if判断，原因是若左右区间为空，在递归调用construct函数时会因为<code>begin == end</code>直接返回<code>NULL</code>，而不会出现直接创建数组写法中的空数组的现象（终止条件中未考虑空数组的情况，因此若数组为空不能触发终止条件，会导致程序报错）。因此我也可以在终止条件中考虑空数组的情况，而不在构建左右子树时加上if判断，代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件1</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 终止条件2</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历：中节点</span></span><br><span class="line">        <span class="comment">// 找到root的值和下标</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(max);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左节点，不需加if判断，由于有终止条件1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), nums.begin() + index)</span></span>; <span class="comment">// 左区间</span></span><br><span class="line">        root-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(l); <span class="comment">// 递归构造左子树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点，不需加if判断，由于有终止条件1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(nums.begin() + index + <span class="number">1</span>, nums.end())</span></span>; <span class="comment">// 右区间</span></span><br><span class="line">        root-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(r); <span class="comment">// 递归构造右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="617-合并二叉树-1"><a href="#617-合并二叉树-1" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3><p>将两个二叉树合并为一个二叉树。有相同的节点则将两个节点数值相加，作为新节点。对于一棵树上有而另一棵树上没有的节点，将新的节点补充过来。难点：同时操作两个二叉树。本题使用前序遍历最易理解，顺序是中左右。中序和后序也可，但不太符合直观上合并两棵二叉树的过程。本题也可使用迭代法。接下来写递归的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// 遍历到t1树的某个位置为空后，需要返回t2树上相同位置的节点（遍历两树是同步的），这样才能将t2树上的该节点的子树加入到合并后的二叉树中</span></span><br><span class="line">    <span class="comment">// 已经包含了两树都为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑，前序遍历</span></span><br><span class="line">    <span class="comment">// 直接改tree1的结构，而不重新定义一棵二叉树</span></span><br><span class="line">    t1-&gt;val += t2-&gt;val; <span class="comment">// 中节点</span></span><br><span class="line">    t1-&gt;left = <span class="built_in">mergeTree</span>(t1-&gt;left, t2-&gt;left); <span class="comment">// 左节点</span></span><br><span class="line">    t1-&gt;right = <span class="built_in">mergeTree</span>(t1-&gt;right, t2-&gt;right); <span class="comment">// 右节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> t1; <span class="comment">// 返回合并后的二叉树，即t1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本题采用中序/后序遍历也可以，把单层递归逻辑的三行代码调整顺序即可。按照前序遍历的思路想即可，这符合我们正常合并二叉树的习惯。本题除了在t1上修改，也可以定义一棵新的二叉树，写法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">root-&gt;val = t1-&gt;val + t2-&gt;val;</span><br><span class="line">root-&gt;left = <span class="built_in">mergeTree</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">root-&gt;right = <span class="built_in">mergeTree</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></p>
<p>上述写法空间复杂度是O(n)。</p>
<p>本题的迭代写法如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* r1, TreeNode* r2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="literal">NULL</span>) <span class="keyword">return</span> r2;</span><br><span class="line">        <span class="keyword">if</span> (r2 == <span class="literal">NULL</span>) <span class="keyword">return</span> r1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代写法，常用队列</span></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(r1); q.<span class="built_in">push</span>(r2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* n1 = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* n2 = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// n1和n2都不为空</span></span><br><span class="line">            n1-&gt;val += n2-&gt;val;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若n1和n2的左子树都不为空，则将它们加入队列中</span></span><br><span class="line">            <span class="keyword">if</span> (n1-&gt;left != <span class="literal">NULL</span> &amp;&amp; n2-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(n1-&gt;left);</span><br><span class="line">                q.<span class="built_in">push</span>(n2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若n1和n2的右子树都不为空，则将它们加入队列中</span></span><br><span class="line">            <span class="keyword">if</span> (n1-&gt;right != <span class="literal">NULL</span> &amp;&amp; n2-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(n1-&gt;right);</span><br><span class="line">                q.<span class="built_in">push</span>(n2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若n1的左子树为空，则将n2的左子树赋到n1上</span></span><br><span class="line">            <span class="keyword">if</span> (n1-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">                n1-&gt;left = n2-&gt;left;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 若n1的右子树为空，则将n2的右子树赋到n1上</span></span><br><span class="line">            <span class="keyword">if</span> (n1-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                n1-&gt;right = n2-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="700-二叉搜索树中的搜索-2"><a href="#700-二叉搜索树中的搜索-2" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h3><p>在二叉树中找到数值为目标值的节点然后返回。</p>
<p><strong>什么是二叉树搜索树？</strong>其根节点要比左子树里所有节点的数值大，根节点要比右子树里所有节点的数值小。同理，左右子树也符合这个规则。二叉搜索树的上述规则确定了遍历顺序，而二叉搜素树的上述规则也让本题的迭代写法特别简单。递归法的代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">search</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 两个终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;val == val) <span class="keyword">return</span> root; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归的逻辑</span></span><br><span class="line">    TreeNode* res = <span class="literal">NULL</span>; <span class="comment">// res用于存递归函数的返回值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据二叉搜索树的特性，若val &lt; root的值，则向root的左子树中去遍历</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) res = <span class="built_in">search</span>(root-&gt;left, val);</span><br><span class="line">    <span class="comment">// 根据二叉搜索树的特性，若val &gt; root的值，则向root的右子树中去遍历</span></span><br><span class="line">    <span class="keyword">if</span> (val &gt; root-&gt;val) res = <span class="built_in">search</span>(root-&gt;right, val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比于我在初次尝试中的写法，上述写法代码更简洁，效率也更高。因为我在初次尝试中的写法没有利用二叉搜索树的特性，只是单纯地先搜索root节点，再递归搜索root节点的左子树和右子树。而卡尔的写法先搜索root节点，然后根据<code>root-&gt;val</code>和<code>val</code>的大小对比，决定是在root节点的左子树中继续搜索还是在其右子树中继续搜索。卡尔的写法并不涉及前中后序，因为二叉搜索树本身的性质已经帮我们确定了遍历的顺序。</p>
<p>本题迭代法的代码也并很简单。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">search</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向左子树中搜索</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val) root = root-&gt;left;</span><br><span class="line">        <span class="comment">// 向右子树中搜索</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) root = root-&gt;right;</span><br><span class="line">        <span class="comment">// 相等，说明找到了目标节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 树中无目标节点，则返回空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迭代法中搜索的方向也由二叉搜索树的特性决定。上述迭代写法也比我在初次尝试中写的迭代写法更为简洁且效率更高，因为卡尔<strong>充分利用了二叉搜索树的特性</strong>，知道想要找到目标值应该朝着什么方向走。</p>
<h3 id="98-验证二叉搜索树-2"><a href="#98-验证二叉搜索树-2" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p>判断给定的二叉树是否是二叉搜索树。二叉搜索树的定义：左子树中的所有元素都小于root节点，右子树中的所有元素都大于root节点，左右子树都符合这个规则。<strong>中序遍历这棵二叉树，其元素是有序的</strong>。例如对以下二叉树：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[5] --&gt; B[3]</span><br><span class="line">    B[3] --&gt; H[1]</span><br><span class="line">    B[3] --&gt; I[NULL]</span><br><span class="line">    A --&gt; C[10]</span><br><span class="line">    C --&gt; F[6]</span><br><span class="line">    C --&gt; G[11]</span><br></pre></td></tr></table></figure></p>
<p>按照中序遍历，就是[1, 3, 5, 6, 10, 11]，数组是有序的。<strong>验证二叉树是否是二叉搜索树，就是验证中序遍历后得到的数组是否是单调递增的</strong>。开始写具体的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 空二叉树是二叉搜索树</span></span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">// 存放树中序遍历后的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="built_in">isvalid</span>(root-&gt;left); <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中：将遍历到的元素放入数组中</span></span><br><span class="line">    <span class="built_in">isvalid</span>(root-&gt;right); <span class="comment">// 右</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断vec是否有序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上述思路，我写下了能够运行的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">// 全局变量，用于存放中序遍历二叉树的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于中序遍历二叉树的辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断数组是否是单调递增的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>() - <span class="number">1</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[i + <span class="number">1</span>] &lt;= vec[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其实不需要将二叉树转换为数组，可以直接在遍历二叉树的过程中判断元素是否是单调递增的。接下来看如何不使用数组来判断二叉树是否是二叉搜索树。本题也可以用迭代法实现，但主要关注递归法。</p>
<p>代码误区：<code>if (root-&gt;val &gt; root-&gt;left-&gt;val &amp;&amp; root-&gt;val &lt; root-&gt;right-&gt;val) return true;</code>。实际上这样写是错误的。因为二叉搜索树要求的是root要大于左子树中的所有值，root要小于右子树中的所有值。这个错误我在初次尝试部分已经讨论过了。</p>
<p>现在开始写不额外定义数组的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -2^31 &lt;= Node.val &lt;= 2^31 - 1，因此maxval要小于int的最小值，因此maxval要取为long long的最小值</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> maxval = LONG_MIN; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> left = <span class="built_in">isvalid</span>(root-&gt;left); <span class="comment">// 左：左子树是否是二叉搜索树</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中</span></span><br><span class="line">    <span class="comment">// 若二叉树是二叉搜索树，在中序遍历的情况下，元素是递增的，root-&gt;val会持续大于maxval</span></span><br><span class="line">    <span class="comment">// maxval相当于记录了遍历过程中当前节点的前一个节点的数值</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; maxval)</span><br><span class="line">    &#123;</span><br><span class="line">        maxval = root-&gt;val; <span class="comment">// 更新maxval</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若元素不是递增的，则return false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右：右子树是否是二叉搜索树</span></span><br><span class="line">    <span class="type">bool</span> right = <span class="built_in">isvalid</span>(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right; <span class="comment">// 要求左右子树同时符合条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以二叉树为例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[5] --&gt; B[3]</span><br><span class="line">    B[3] --&gt; H[1]</span><br><span class="line">    B[3] --&gt; I[NULL]</span><br><span class="line">    A --&gt; C[10]</span><br><span class="line">    C --&gt; F[6]</span><br><span class="line">    C --&gt; G[11]</span><br></pre></td></tr></table></figure></p>
<p>在判断6是否合法时，拿5（root，也是maxvalue）和6进行比较了，因此不会进入初次尝试中提到的误区。若左叶子为<code>INT_MIN</code>，且<code>maxval = INT_MIN</code>，则<code>root-&gt;val == maxval</code>，就会直接返回false。因此要让<code>maxval</code>小于<code>INT_MIN</code>。</p>
<p>上述方法存在问题，若左叶子为<code>LONG_MIN</code>（改变输入节点数值的范围），则<code>maxval</code>就无法取更小的值了。我们可以对上述方法进行优化，<strong>不额外定义一个变量，而是直接让二叉树的前一个节点和后一个节点进行比较</strong>。写下如下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* pre = <span class="literal">NULL</span>; <span class="comment">// pre记录当前节点的前一个节点, root可以和pre进行比较</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> left = <span class="built_in">isvalid</span>(root-&gt;left); <span class="comment">// 左</span></span><br><span class="line">    <span class="comment">// 中</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 前一个节点的值大于当前节点，则return false</span></span><br><span class="line">    pre = root; <span class="comment">// 将pre从NULL移到root，即从前一个节点移到当前节点</span></span><br><span class="line">    <span class="type">bool</span> right = <span class="built_in">isvalid</span>(root-&gt;right); <span class="comment">// 右</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上方法被称为双指针优化。其实原理非常简单，就是在中序遍历的过程中一直去判断root（当前节点）和pre（前一个节点）之间的大小关系。root指针是由中序遍历的过程去移动的，pre指针是通过直接赋值去移动的。本题是二叉搜索树中的基础题。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="654-最大二叉树-2"><a href="#654-最大二叉树-2" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h3><ol>
<li><p>本题的思路和106.从中序与后序遍历序列构造二叉树的思路非常类似，理解了那题就可以顺畅的写出本题的代码。</p>
</li>
<li><p>本题的单层递归核心逻辑如下：</p>
<ol>
<li><p>找到nums数组中的最大值，作为root</p>
</li>
<li><p>找到root在nums中的下标</p>
</li>
<li><p>将nums按照root分为左数组和右数组</p>
</li>
<li><p>递归处理左数组和右数组，得到左右子树</p>
</li>
</ol>
</li>
<li><p>本题的终止条件可以写两个也可以写一个。若只有终止条件：<code>if (nums.size() == 1) return new TreeNode(nums[0]);</code>，则需要在构造左右子树时加上if判断，保证左右区间不为空。若再加上终止条件：<code>if (nums.size() == 0) return NULL;</code>，则就不需要在构造左右子树时加上if判断了。加上第二个终止条件的原因并非是为了防止传入的nums数组为空（题目限制了传入的数组中至少有1个元素），而是为了在递归时出现数组为空的情况下顺利退出递归过程。</p>
</li>
<li><p>在实现中，给出了本题的4种写法。写法1和写法4的区别在于：1有1个终止条件，有if判断。4有2个终止条件，无if判断。<strong>最推荐的写法</strong>（初学者不易写错，且可直接由106演化而来）<strong>是写法2</strong>。效率最高的写法是写法3（只操作数组下标，而不新建数组，也不操作数组中的元素）。我将在下面附上写法2的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到root的值和下标</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(max);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), nums.begin() + index)</span></span>; <span class="comment">// 左区间</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(nums.begin() + index + <span class="number">1</span>, nums.end())</span></span>; <span class="comment">// 右区间</span></span><br><span class="line">        root-&gt;left = <span class="built_in">construct</span>(l); <span class="comment">// 递归构造左子树</span></span><br><span class="line">        root-&gt;right = <span class="built_in">construct</span>(r); <span class="comment">// 递归构造右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">construct</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>本题的优化写法是只操作下标，不新建数组，也不操作数组中元素的值。这样可以降低时间和空间复杂度（我感觉时间复杂度基本没变，但空间复杂度由于不需要新建数组，大大降低了）。注意区间始终要保持左闭右开（基于循环不变量原则）。</p>
</li>
</ol>
<h3 id="617-合并二叉树-2"><a href="#617-合并二叉树-2" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3><ol>
<li>本题虽然涉及到同时操作两棵二叉树，但代码的思路和实现都非常简单。</li>
<li>本题的递归写法的思路：<ul>
<li>终止条件：若一棵树的root节点为空，则返回另一棵树的root节点</li>
<li>单层递归：前序遍历。先合并中节点的值，然后再递归处理左子树和右子树。在树1的基础上，将树1修改为合并后的树。也可定义一棵新的树作为合并后的树。</li>
</ul>
</li>
<li>本题的迭代写法较为复杂，没必要掌握。</li>
</ol>
<h3 id="700-二叉搜索树中的搜索-3"><a href="#700-二叉搜索树中的搜索-3" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h3><ol>
<li>通过本题可以了解二叉搜索树的性质：其根节点要比左子树里所有节点的数值大，根节点要比右子树里所有节点的数值小。同理，左右子树也符合这个规则。二叉搜索树的上述规则确定了遍历顺序（既不是前序，也不是中序、后序），而二叉搜素树的上述规则也让本题的迭代写法特别简单。</li>
<li>我在初次尝试中的递归写法和迭代写法并没有利用二叉搜索树的性质，因此代码较长且运行效率较低，相当于初次尝试中的代码是执行了在一般的二叉树中搜索节点的过程。而在实现中卡尔的递归写法和迭代写法则充分利用了二叉搜索树的性质，因此代码较为简洁且运行效率高。</li>
<li>本题的迭代写法尤其简单，原因是：一般二叉树遍历的迭代法，需要使用栈来模拟深度遍历，使用队列来模拟广度遍历。但对于二叉搜索树，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用辅助栈或者队列就可以写出迭代法。对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支。而<strong>对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。</strong></li>
<li>本题推荐的写法是卡尔的写法，因为充分利用了二叉搜索树的性质。但如果想不起来卡尔的写法，或者题目中的二叉树并非二叉搜索树，而是一般的二叉树，我在初次尝试中的两种写法不失为一种具有普适性的写法。</li>
</ol>
<h3 id="98-验证二叉搜索树-3"><a href="#98-验证二叉搜索树-3" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><ol>
<li>本题的递归解法有三个版本，分别是直接判断中序遍历得到的数组是否递增、<code>maxvalue</code>法和双指针法。其中最简单最直观的方法是方法1，但其也是效率最低的。因此一定要掌握方法1，接着尽力掌握方法3，最后掌握方法2即可。</li>
<li><strong>本题利用的基本原理：中序遍历一棵二叉搜索树，得到的数组中的元素是有序（递增）的</strong>。</li>
<li><code>maxvalue</code>法和双指针法本质都是在中序遍历二叉树的过程中，不用额外的数组去存储二叉树中的所有元素，而是直接判断当前节点是否大于前一个节点。但<code>maxvalue</code>法具有<code>maxvalue</code>的初始值必须小于节点的最小值的问题，因此若节点的最小值可以取到long long的最小值，则<code>maxvalue</code>的初始值无法确定（cpp不提供超出long long范围的整数类型）。<strong>因此双指针法更为完美</strong>。</li>
<li><code>maxvalue</code>法和双指针法在代码实现上略有区别。二者的单层递归逻辑都是中序遍历，但在对中节点的处理逻辑上有差异。<code>maxvalue</code>法是当元素递增时，更新<code>maxvalue</code>的值，否则返回false。双指针法则是当元素不是递增时，返回false，否则更新pre指针。</li>
<li>本题的迭代解法要用到栈，代码也比较复杂，不要求掌握。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/12/Day-18-Leetcode-513-112-106/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/12/Day-18-Leetcode-513-112-106/" class="post-title-link" itemprop="url">Day 18 Leetcode 513, 112, 106</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-12 15:14:06" itemprop="dateCreated datePublished" datetime="2024-03-12T15:14:06+00:00">2024-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-19 06:42:46" itemprop="dateModified" datetime="2024-04-19T06:42:46+01:00">2024-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（二叉树）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html">513.找树左下角的值</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">112. 路径总和，113. 路径总和ii</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html">106.从中序与后序遍历序列构造二叉树，105.从前序与中序遍历序列构造二叉树</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h3><p><code>vector&lt;int&gt; lm(inorder.begin(), inorder.begin() + i);</code>创建了一个左闭右开的区间。在C++中，<code>std::vector</code>的这个构造函数接受两个迭代器作为参数，分别表示要复制的范围的开始和结束。这个范围遵循左闭右开的原则，即包括开始位置的元素，但不包括结束位置的元素。</p>
<p><strong>注意：不可以写作<code>vector&lt;int&gt; lm(0, i)</code>。传入数字的功效和传入迭代器的功效是完全不同的，传入数字的写法无法运行出正确的结果。只有传入两个迭代器的写法是表示创建了一个左闭右开的区间。</strong></p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h3><p>拿到本题后，我先复习了层序遍历的代码，然后先拿层序遍历法尝试一下。本题果然可以简单地用层序遍历解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面两行代码可以简写为return res.back().front();</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans = res.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在尝试用递归做本题。首先需要考虑前/中/后序遍历。发现确实不好写，不知道该采用怎样的遍历顺序，且终止条件也不知道该怎么写，直接看卡尔的讲解。</p>
<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h3><p>本题用层序遍历肯定不好做，因为涉及到从root节点到叶子节点。我尝试用递归解决本题。本题肯定涉及到回溯，搜索完一条root节点到叶子节点的和之后，若没找到targetSum，还需要返回root节点，寻找到新的叶子节点的路径。我不会做此题，直接看卡尔的讲解。</p>
<h3 id="113-路径总和ii"><a href="#113-路径总和ii" class="headerlink" title="113. 路径总和ii"></a>113. 路径总和ii</h3><p>本题我尝试用112的方法独立完成，但是没有成功，其实我写的代码离能成功运行的代码已经很接近了，思路没错就是部分细节不对。本题的方法应该和112相同，但代码实现上会复杂一些。</p>
<h3 id="106-从中序与后序遍历序列构造二叉树-1"><a href="#106-从中序与后序遍历序列构造二叉树-1" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h3><p>本题是二叉树中的难题，我没有什么思路，直接来看卡尔的视频。</p>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h3><p>本题的核心思路和106完全一致，我独立写出了本题的代码。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="513-找树左下角的值-1"><a href="#513-找树左下角的值-1" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h3><p>树左下角的值：树的最后一行最靠左侧的值（不一定是左孩子）。本题用层序遍历（迭代法）最合适，目标值就是最后一层的第一个值。<strong>本题用迭代法比用递归法更简单直观</strong>。现在主要讲解递归法。</p>
<p>如何用递归法找到树左下角的值？深度最大的叶子节点一定在最后一行。因为本题不需要处理中节点，只需要先遍历左节点即可，<strong>因此本题使用前中后序遍历都可</strong>。<strong>只要保证先遍历左节点，且得到的是深度最大的节点</strong>，找到的就是最后一行最靠左侧的节点。现在开始写代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录二叉树最大深度的全局变量</span></span><br><span class="line"><span class="type">int</span> maxDepth = INT_MIN; <span class="comment">// 初始化为int中的最小值</span></span><br><span class="line"><span class="type">int</span> res; <span class="comment">// 若当前深度大于maxDepth，则更新res为当前节点的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// depth用于记录当前遍历的节点的深度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件：遍历到叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若当前深度大于maxDepth，则更新res为当前节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; maxDepth) </span><br><span class="line">        &#123;</span><br><span class="line">            maxDepth = depth;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 单层递归的逻辑，前中后序遍历皆可，本题不需要中节点的处理逻辑</span></span><br><span class="line">    <span class="comment">// 左节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        depth ++ ;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, depth); <span class="comment">// 递归</span></span><br><span class="line">        depth -- ; <span class="comment">// 回溯，即回退到左节点的父节点，然后遍历父节点的右节点，不回溯则会一直向左遍历</span></span><br><span class="line">        <span class="comment">// 以上三行代码可以简写为traversal(root-&gt;left, depth + 1)</span></span><br><span class="line">        <span class="comment">// 因为depth + 1并没有改变depth的值，相当于在traversal中+1，在traversal之后复原</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 右节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        depth ++ ;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, depth);</span><br><span class="line">        depth -- ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题的递归解法同样显示地展现了回溯。根据上述核心代码，我写出了本题递归解法的完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth = INT_MIN; <span class="comment">// 直接int maxDepth = 0也可以</span></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件，遍历到叶子节点</span></span><br><span class="line">        <span class="comment">// 若当前深度大于最大深度，则需要更新最大深度和结果</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth &gt; maxDepth)</span><br><span class="line">            &#123;</span><br><span class="line">                res = root-&gt;val;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归的逻辑</span></span><br><span class="line">        <span class="comment">// 左节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            depth ++ ;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;left, depth);</span><br><span class="line">            depth -- ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            depth ++ ;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;right, depth);</span><br><span class="line">            depth -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root, <span class="number">1</span>); <span class="comment">// root节点的深度一般被规定为1，当然规定为0也可以</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题的层序遍历解法其实也有更简便的写法，不需要浪费空间复杂度来存储树中的所有元素的值。代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) res = node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="112-路径总和-1"><a href="#112-路径总和-1" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h3><p>题意：有无从root节点到叶子节点的一条路径，路径上所有元素之和等于目标和。推荐使用递归法。本题使用前中后序遍历皆可，因为不涉及中节点的处理逻辑，因此中节点放在哪里都可以。规则看似简单，但代码不好写。现在开始写代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值为bool类型，找到一条符合条件的路径，立即从下（叶子节点）往上（根节点）返回true</span></span><br><span class="line"><span class="comment">// cnt：计数器，在主函数中传入目标值</span></span><br><span class="line"><span class="comment">// 如果传入0，从上往下遍历每遍历到一个节点就加上这个节点的值，看遍历到叶子节点时cnt是否等于target，这样代码更复杂，不如直接传入target，每次遍历到一个节点就在target中减去该节点的值，看到叶子节点时cnt是否为0</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> cnt)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件：遇到叶子节点且cnt=0</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span> &amp;&amp; cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span> &amp;&amp; cnt != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 单层递归逻辑</span></span><br><span class="line">    <span class="comment">// 左节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt -= node-&gt;left-&gt;val; <span class="comment">// 从cnt中减去左节点的值</span></span><br><span class="line">        <span class="comment">// 若返回true，则说明node的左孩子到叶子节点的路径中有符合题目要求的路径</span></span><br><span class="line">        <span class="comment">// 此时目标值为cnt -= node-&gt;left-&gt;val</span></span><br><span class="line">        <span class="comment">// 此时应该继续向上返回true，这样才能一层层将true的结果返回给根节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">traversal</span>(node-&gt;left, cnt)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 回溯，遍历到叶子节点后，需要回退到根节点去遍历一条新的路径，因此需要回溯</span></span><br><span class="line">        <span class="comment">// 若不回溯，则cnt一直做减法，则遍历完左子树后，遍历右子树时根本不可能找到符合条件的路径</span></span><br><span class="line">        cnt += node-&gt;left-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 右节点，逻辑同上</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt -= node-&gt;right-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">traversal</span>(node-&gt;right, cnt)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        cnt += node-&gt;right-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一直不return true, 则return false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码没有对中节点的处理逻辑，因此前中后序都可以。对左右节点的处理逻辑可以简写为一句话，我以左节点为例：<code>if (traversal(node-&gt;left, cnt -= node-&gt;left-&gt;val)) return true;</code>，但不建议这样写，因为无法清晰地看到回溯的逻辑。</p>
<p>本题的完整代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件：遍历到叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span> &amp;&amp; cnt == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL &amp;&amp; cnt != 0)</span></span><br><span class="line">        <span class="comment">//     return false;</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 左节点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt -= node-&gt;left-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(node-&gt;left, cnt)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            cnt += node-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt -= node-&gt;right-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(node-&gt;right, cnt)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            cnt += node-&gt;right-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="113-路径总和ii-1"><a href="#113-路径总和ii-1" class="headerlink" title="113. 路径总和ii"></a>113. 路径总和ii</h3><p>本题由于要遍历整棵树，找到所有路径，因此递归函数不要返回值，遍历完整棵树后，在函数外定义好的 <code>path</code>和 <code>res</code>中自然会被递归函数写入应有的结果。如果只是要找树中符合条件的一条路径，那么递归函数就要返回值，一旦遍历到叶子节点时找到了合适的路径，就立即返回true，要是一直找不到符合条件的路径，再返回false。</p>
<p>本题的代码相较于上一题要复杂一些，但<strong>核心思路其实是相同的</strong>。以下几点是与112的主要差异。</p>
<ul>
<li>首先定义一个 <code>vector&lt;int&gt; path</code>来存放一条符合条件的路径，再定义一个 <code>vector&lt;vector&lt;int&gt;&gt; res</code>来存放树中所有符合条件的路径。</li>
<li>在针对左右节点的操作中，需要回溯，但与112不同的是，本题中的回溯不仅需要回溯 <code>cnt</code>，还需要回溯 <code>path</code>中的元素（先将左右节点放入path中，回溯时又从path中弹出左右节点）。</li>
<li>由于本题的递归函数没有返回值，因此只需要返回空即可，即 <code>return;</code>。</li>
<li>本题需要在主函数中在path中事先插入根节点的值，作为启动的引线（可以想想极端情况，树中只有一个节点，即根节点，如果不在path中事先插入根节点的值，那么即使根节点的值等于 <code>targetSum</code>，res中也不会存有根节点的值）。</li>
</ul>
<p>本题的具体代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 本题的递归函数不需要返回值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span> &amp;&amp; node-&gt;left == <span class="literal">NULL</span> &amp;&amp; cnt == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span> &amp;&amp; node-&gt;left == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左节点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(node-&gt;left-&gt;val);</span><br><span class="line">            cnt -= node-&gt;left-&gt;val;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;left, cnt); <span class="comment">// 递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">            cnt += node-&gt;left-&gt;val; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(node-&gt;right-&gt;val);</span><br><span class="line">            cnt -= node-&gt;right-&gt;val;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;right, cnt); <span class="comment">// 递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">            cnt += node-&gt;right-&gt;val; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 事先把根节点放进路径</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root, targetSum - root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="106-从中序与后序遍历序列构造二叉树-2"><a href="#106-从中序与后序遍历序列构造二叉树-2" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h3><p>任务：从中序和后序数组中构造出一棵唯一的二叉树。思路：如何用两个数组构造二叉树？<br>中序：左中右，例：9 3 15 20 7<br>后序：左右中，例：9 15 7 20 3<br>由于需要确定根节点，根节点是中节点，而根据中序数组无法确定出根节点的位置，这时就需要后序数组。后序数组的最后一个元素一定是中节点，也就是根节点。以上述两数组为例，根节点就是3。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[3]</span><br></pre></td></tr></table></figure>
<p>再看中序数组，root是3，则左节点是9，右节点是15，20，7。这一步操作就是利用后序数组中找到的root节点在中序数组中完成切割的任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[3] --&gt; B[9];</span><br><span class="line">    A --&gt; C[x];</span><br></pre></td></tr></table></figure>
<p>再利用中序数组中切割出的两部分在后序数组中完成切割。由上一步知，左节点是9，右节点是15，20，7。结合后序数组知，右节点是15，7，20。右节点中最后一个元素是20，因此20是右子树的中节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[3] --&gt; B[9];</span><br><span class="line">    A --&gt; C[20];</span><br></pre></td></tr></table></figure>
<p>再利用后序数组去切割中序数组。20是右子树的中节点，中序数组中的右区间为15，20，7，因此左节点是15，右节点是7。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[3] --&gt; B[9];</span><br><span class="line">    A --&gt; C[20];</span><br><span class="line">    C --&gt; F[15];</span><br><span class="line">    C --&gt; G[7];</span><br></pre></td></tr></table></figure>
<p>关键：先通过后序数组找到root节点，再利用root节点切割中序数组，再利用中序数组切割出的左右区间切割后序数组，交替进行。可以具体为以下六步：</p>
<ol>
<li>后序数组为空，说明无root节点，返回空的树</li>
<li>后序数组最后一个元素作为root</li>
<li>寻找中序数组中root的位置作为切割点</li>
<li>切割中序数组，切为左右区间</li>
<li>根据切割中序数组得到的左右区间切割后序数组</li>
<li>递归处理，构造下一层子树</li>
</ol>
<p>现在开始写本题的伪代码（注重整体思路而非细节）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确定递归函数的参数和返回值</span></span><br><span class="line"><span class="comment">// 返回值：二叉树的根节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt; inorder, vector&lt;<span class="type">int</span>&gt; postorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件：后序数组为空</span></span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 后序数组的最后一个元素为root节点的值</span></span><br><span class="line">    <span class="type">int</span> rootvalue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 优化：若postorder中只有一个元素，则该元素必为叶子节点（root节点也是叶子节点）</span></span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 单层递归的逻辑</span></span><br><span class="line">    <span class="comment">// 寻找中序数组中root的位置作为切割点</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 返回中序数组中root的index</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 根据root切中序数组，得到一个左中序数组和一个右中序数组</span></span><br><span class="line">    <span class="comment">// 切后序数组，拿上一步得到的左中序数组来切出后序数组的左区间和右区间，得到一个左后序数组和一个右后序数组</span></span><br><span class="line">    <span class="comment">// 递归处理左区间和右区间，即递归构建root的左右子树</span></span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(左中序, 左后序);</span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(右中序, 右后序);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>切中序数组和切后序数组时需要有统一的区间定义。要么都坚持左闭右开，要么都坚持左闭右闭。</li>
<li>先切中序数组，再切后序数组。因为中序数组中的左区间和后序数组中的左区间一定相同。</li>
<li>建议debug时打印切中序数组得到的左中序和右中序数组，打印切后序数组的左后序和右后序数组。</li>
</ul>
<p>中序和前序数组也可以唯一地确定一棵二叉树。前序数组是中左右，拿着前序数组的第一个元素，即为root元素，拿去切中序数组。剩下的思路是相同的。</p>
<p>中序和后序数组可以唯一地确定二叉树，中序和前序数组也可以唯一地确定二叉树，<strong>但后序和前序数组不能唯一地确定二叉树</strong>。原因：前序数组和后序数组都可以直接知道root在哪里，但前序和后序数组的左右区间的分割点我们找不到。中序数组的重要性在于其把左右区间给分隔开了。举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[1] --&gt; B[2];</span><br><span class="line">    B[2] --&gt; C[3]</span><br><span class="line">    B[2] --&gt; E[null]</span><br><span class="line">    A --&gt; D[null];</span><br></pre></td></tr></table></figure>
<p>对以上二叉树，前序数组：123，后序数组：321</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[1] --&gt; B[null];</span><br><span class="line">    A[1] --&gt; C[2]</span><br><span class="line">    C[2] --&gt; D[null]</span><br><span class="line">    C[2] --&gt; E[3]</span><br></pre></td></tr></table></figure>
<p>对以上二叉树，前序数组：123，后序数组：321<br>虽然两棵二叉树的前序数组和后序数组完全一致，但这两棵二叉树完全不同，<strong>因此仅靠前序和后序数组不能唯一地确定二叉树</strong>。</p>
<p>本题是二叉树中的难题、复杂题，需要经常复习。以上笔记cover了易错点。</p>
<p>根据上述原理，我写出了以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootvalue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到inorder中root的下标</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将inorder根据i分为左中数组和右中数组</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; lm;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            lm.<span class="built_in">push_back</span>(inorder[j]); </span><br><span class="line">            cout &lt;&lt; inorder[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 打印lm数组中的所有元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; inorder.<span class="built_in">size</span>(); j ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            rm.<span class="built_in">push_back</span>(inorder[j]); </span><br><span class="line">            cout &lt;&lt; inorder[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 打印rm数组中的所有元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将postorder根据上一步的结果分为左后数组和右后数组</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; lb;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rb;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; lm.<span class="built_in">size</span>(); l ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            lb.<span class="built_in">push_back</span>(postorder[l]); </span><br><span class="line">            cout &lt;&lt; postorder[l] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 打印lb数组中的所有元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = lm.<span class="built_in">size</span>(); l &lt; postorder.<span class="built_in">size</span>(); l ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            rb.<span class="built_in">push_back</span>(postorder[l]); </span><br><span class="line">            cout &lt;&lt; postorder[l] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 打印rb数组中的所有元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(lm, lb);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rm, rb);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该代码可以通过201 / 202个测试样例，但有一个测试样例超时了，这就需要对上述代码进行优化。写出上述代码时，我犯了一个错误。在将 <code>postorder</code>根据 <code>inorder</code>的结果分为左后数组和右后数组的过程中，我的第一版代码采用了以下的写法（逻辑：把左中数组的最后一个元素作为分界点，在后序数组中查询之，并以此分界点将后序数组划分为左后数组和右后数组）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; lb;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rb;</span><br><span class="line"><span class="type">int</span> value = lm[lm.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; lm.<span class="built_in">size</span>(); k ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (postorder[k] == value)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;k=&quot; &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; k; l ++ ) </span><br><span class="line">&#123;</span><br><span class="line">    lb.<span class="built_in">push_back</span>(postorder[l]);</span><br><span class="line">    cout &lt;&lt; postorder[l] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = k + <span class="number">1</span>; l &lt; postorder.<span class="built_in">size</span>(); l ++ ) </span><br><span class="line">&#123;</span><br><span class="line">    rb.<span class="built_in">push_back</span>(postorder[l]);</span><br><span class="line">    cout &lt;&lt; postorder[l] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>当左中序数组 <code>lm</code>为空时，<code>int value = lm[lm.size() - 1];</code>会访问 <code>lm[-1]</code>。该元素显然不存在，故会报错：index error。因此不能这样写，应该采用按照左中序数组的元素数量分割后序数组的写法。</p>
<p>我对上述代码进行简易的优化后（将resize函数改为pop_back函数，时间复杂度略微降低），就可以通过本题，代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootvalue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; lm, rm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ ) lm.<span class="built_in">push_back</span>(inorder[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; inorder.<span class="built_in">size</span>(); j ++ ) rm.<span class="built_in">push_back</span>(inorder[j]);</span><br><span class="line"></span><br><span class="line">        postorder.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; lb, rb;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; lm.<span class="built_in">size</span>(); j ++ ) lb.<span class="built_in">push_back</span>(postorder[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = lm.<span class="built_in">size</span>(); j &lt; postorder.<span class="built_in">size</span>(); j ++ ) rb.<span class="built_in">push_back</span>(postorder[j]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(lm, lb);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rm, rb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，还有进一步优化的空间，代码也可以写得更为简洁。我写下了如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件1：postorder中为空</span></span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 终止条件2：postorder中只有一个元素，即为root</span></span><br><span class="line">        <span class="type">int</span> rootvalue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// postorder中的最后一个元素为root，在inorder中找到root的下标</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 将inorder以root作为分割点分割为左中序数组和右中序数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lm</span><span class="params">(inorder.begin(), inorder.begin() + i)</span></span>; <span class="comment">// 左中序数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rm</span><span class="params">(inorder.begin() + i + <span class="number">1</span>, inorder.end())</span></span>; <span class="comment">// 右中序数组</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 删去postorder的最后一个元素（即root）</span></span><br><span class="line">        <span class="comment">// 也可写作postorder.resize(postorder.size() - 1);</span></span><br><span class="line">        postorder.<span class="built_in">pop_back</span>();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 将postorder以上一步分割得到的左中序数组分割为左后序数组和右后序数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lb</span><span class="params">(postorder.begin(), postorder.begin() + lm.size())</span></span>; <span class="comment">// 左后序数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rb</span><span class="params">(postorder.begin() + lm.size(), postorder.end())</span></span>; <span class="comment">// 右后序数组</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 递归构建root的左子树和右子树</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(lm, lb); <span class="comment">// 构建左子树，传入的参数为左中序数组和左后序数组</span></span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rm, rb); <span class="comment">// 构建右子树，传入的参数为右中序数组和右后序数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 中序数组或后序数组为空，则树不存在，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码的运行时间基本可以减半，我觉得主要原因是 <code>vector&lt;int&gt; lm(inorder.begin(), inorder.begin() + i);</code>这种写法的时间复杂度要优于遍历数组然后赋值。</p>
<p>本题的下标索引写法（能大大降低空间复杂度，不需要每层递归产生新的数组，只需要对索引重新赋值即可，本写法的代码逻辑和上面的写法完全一致）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> inbegin, <span class="type">int</span> inend, <span class="type">int</span> postbegin, <span class="type">int</span> postend)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postend == postbegin) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="type">int</span> rootvalue = postorder[postend - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">        <span class="keyword">if</span> (postend - postbegin == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inorder中找到root</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = inbegin; i &lt; inend; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// root分割inorder为左中序数组和右中序数组</span></span><br><span class="line">        <span class="type">int</span> leftinorderbegin = inbegin;</span><br><span class="line">        <span class="type">int</span> leftinorderend = i;</span><br><span class="line">        <span class="type">int</span> rightinorderbegin = i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightinorderend = inend;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序数组删去root</span></span><br><span class="line">        postend -- ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将postorder分割为左后序数组和右后序数组</span></span><br><span class="line">        <span class="type">int</span> leftpostorderbegin = postbegin;</span><br><span class="line">        <span class="type">int</span> leftpostorderend = postbegin + leftinorderend - leftinorderbegin;</span><br><span class="line">        <span class="type">int</span> rightpostorderbegin = postbegin + leftinorderend - leftinorderbegin;</span><br><span class="line">        <span class="type">int</span> rightpostorderend = postend;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(inorder, postorder, leftinorderbegin, leftinorderend, leftpostorderbegin, leftpostorderend);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(inorder, postorder, rightinorderbegin, rightinorderend, rightpostorderbegin, rightpostorderend);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), <span class="number">0</span>, postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="105-从前序与中序遍历序列构造二叉树-1"><a href="#105-从前序与中序遍历序列构造二叉树-1" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h3><p>本题的代码思路和上题完全一致，我独立一遍写出了本题的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题类似于106：利用中序数组和后序数组构造二叉树</span></span><br><span class="line"><span class="comment">// 本题关键思路：前序数组第一位是root</span></span><br><span class="line"><span class="comment">// 在inorder中查找root</span></span><br><span class="line"><span class="comment">// 以root作为分割点，将inorder分为左中序数组和右中序数组</span></span><br><span class="line"><span class="comment">// 根据上一步结果，将preorder分为左前序数组和右前序数组</span></span><br><span class="line"><span class="comment">// 递归处理左右子树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootvalue = preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在inorder中查找root</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以root作为分割点，将inorder分为左中序数组和右中序数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lm</span><span class="params">(inorder.begin(), inorder.begin() + i)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rm</span><span class="params">(inorder.begin() + i + <span class="number">1</span>, inorder.end())</span></span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 删去preorder的头元素（即root元素）</span></span><br><span class="line">        <span class="built_in">reverse</span>(preorder.<span class="built_in">begin</span>(), preorder.<span class="built_in">end</span>());</span><br><span class="line">        preorder.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(preorder.<span class="built_in">begin</span>(), preorder.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据上一步结果，将preorder分为左前序数组和右前序数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lf</span><span class="params">(preorder.begin(), preorder.begin() + lm.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rf</span><span class="params">(preorder.begin() + lm.size(), preorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归处理左右子树</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(lf, lm);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rf, rm);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">0</span> || inorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题的下标索引写法如下所示。用下标索引写法，本题删去前序数组中的第一个元素（root）就非常简单，只需要 <code>prebegin ++</code>即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> prebegin, <span class="type">int</span> preend, <span class="type">int</span> inbegin, <span class="type">int</span> inend)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prebegin == preend) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootvalue = preorder[prebegin];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">        <span class="keyword">if</span> (prebegin - preend == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inorder中找root</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = inbegin; i &lt; inend; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用root划分inorder</span></span><br><span class="line">        <span class="type">int</span> leftinbegin = inbegin;</span><br><span class="line">        <span class="type">int</span> leftinend = i;</span><br><span class="line">        <span class="type">int</span> rightinbegin = i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightinend = inend;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// preorder中删去root</span></span><br><span class="line">        prebegin ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用划分inorder的结果划分preorder</span></span><br><span class="line">        <span class="type">int</span> leftprebegin = prebegin;</span><br><span class="line">        <span class="type">int</span> leftpreend = prebegin + leftinend - leftinbegin;</span><br><span class="line">        <span class="type">int</span> rightprebegin = prebegin + leftinend - leftinbegin;</span><br><span class="line">        <span class="type">int</span> rightpreend = preend;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(preorder, inorder, leftprebegin, leftpreend, leftinbegin, leftinend);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(preorder, inorder, rightprebegin, rightpreend, rightinbegin, rightinend);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">0</span> || inorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(preorder, inorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>(), <span class="number">0</span>, inorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="513-找树左下角的值-2"><a href="#513-找树左下角的值-2" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h3><ol>
<li>本题用层序遍历法解决更简单，用递归法解决更麻烦。</li>
<li>本题的层序遍历解法不需要浪费空间复杂度来存储整棵二叉树中的元素值或者二叉树中某一层的元素值。直接存储每一层最左侧元素的值，然后一层层从上往下遍历即可，最后自然会更新为树左下角的值。</li>
<li>本题的递归解法的核心在于：保证优先左边搜索，然后记录深度最大的叶子节点，此时得到的节点就是树的最后一行最左边的节点。</li>
<li><p>递归三部曲：</p>
<ul>
<li>确定函数的返回值和传入的参数<br>本题可以用全局变量记录树的最大深度和结果，这样traversal函数就不需要返回值，只需要在函数中更新记录结果的全局变量即可。传入的参数为根节点和当前节点的深度。</li>
<li>确定终止条件<br>当遍历到叶子节点时，终止。若叶子节点的深度大于最大深度，则更新最大深度和结果。</li>
<li>单层递归逻辑<br>前中后序遍历都可以，只需要保证优先遍历左节点即可。注意要显式地回溯，这样遍历完父节点的左节点后才能回到父节点，然后接着遍历父节点的右节点。否则会一直向左遍历。</li>
</ul>
</li>
</ol>
<h3 id="112-路径总和-2"><a href="#112-路径总和-2" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h3><ol>
<li>本题推荐用递归解，因为不需要处理中节点，所以前中后序遍历都可。</li>
<li>本题的递归函数的返回值为bool类型。因为一旦找到一条符合条件的路径，要立即从下（叶子节点）往上（根节点）返回true，因此递归函数需要返回值。</li>
<li>本题传入递归函数的参数除去node外，还需要传入cnt。cnt直接是targetSum（确切来说是 <code>targetSum - root-&gt;val;</code>），遍历到一个节点就减去该节点的值（从根节点开始遍历，因此传入时就要减去根节点的值），观察遍历到叶子节点时cnt是否为0即可。</li>
<li><p>递归三部曲：</p>
<ul>
<li>确定函数的返回值和传入的参数：返回值bool，传入的参数node和cnt</li>
<li>确定终止条件：遍历到叶子节点且cnt == 0，则返回true</li>
<li><p>单层递归逻辑</p>
<p>先处理左节点，首先cnt值减去左孩子的值，然后递归判断左孩子到叶子节点的路径中是否有满足条件的路径，若有，则需要从下往上返回true。然后再回溯，将减去的cnt值加回来。若不回溯，cnt就一直减小，导致右孩子到叶子节点的路径中不可能有满足条件的路径。对右节点的处理也是类似的。</p>
</li>
</ul>
</li>
<li>本题需要特别注意：调用递归函数时，传入的参数是 <code>targetSum - root-&gt;val</code>，而不是 <code>targetSum</code>。原因是在递归函数的终止条件中，若二叉树中只有root节点不为NULL，且cnt为零时，就返回true，因此本处的cnt应该已经将root节点的值排除在外了。若cnt不把root节点的值排除在外，则在二叉树只有root节点的情况下，永远不可能返回true，因为cnt不可能为0。</li>
</ol>
<h3 id="113-路径总和ii-2"><a href="#113-路径总和ii-2" class="headerlink" title="113. 路径总和ii"></a>113. 路径总和ii</h3><ol>
<li>本题和112的基本思路完全一致，但应当关注和112的差异，主要有以下5点差异。</li>
<li>本题需要在函数外先定义一个 <code>vector&lt;int&gt; path</code>来存放一条符合条件的路径，再定义一个 <code>vector&lt;vector&lt;int&gt;&gt; res</code>来存放树中所有符合条件的路径。</li>
<li>本题的递归函数不需要返回值，112的递归函数需要返回值。具体原因见本题的实现部分。</li>
<li>由于本题的递归函数不需要返回值，因此本题的递归函数在返回时只需要写 <code>return;</code>。</li>
<li>在处理左右节点的逻辑中，需要对 <code>cnt</code>操作并将左右节点的值放入 <code>path</code>中，然后再调用递归函数。因此在回溯时，也需要同时恢复 <code>cnt</code>的值和 <code>path</code>数组。</li>
<li>本题需要在主函数中在path中事先插入根节点的值，作为启动的引线。</li>
</ol>
<h3 id="106-从中序与后序遍历序列构造二叉树-3"><a href="#106-从中序与后序遍历序列构造二叉树-3" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h3><ol>
<li><p>本题的具体操作过程可以举一个具体的例子来展现，参见本题的实现部分。</p>
</li>
<li><p>本题的核心思路在于以下五步：</p>
<ul>
<li>根据后序数组找到root（后序数组中的最后一位）</li>
<li>在中序数组中查找root的下标</li>
<li>以root为分割点，将中序数组分割为左中序数组和右中序数组</li>
<li>在后序数组中找到与左中序数组相同的一段，即为左后序数组，剩下的后序数组为右后序数组</li>
<li>递归构建root的左右子树（根据左右中序数组和左右后序数组）</li>
</ul>
</li>
<li><p>本题的调试方法：打印出左右中序数组和左右后序数组，观察它们是否符合预期</p>
</li>
<li><p>中序和后序数组可以唯一地确定一棵二叉树，前序和中序数组也可以唯一地确定一棵二叉树，但前序和后序数组不可以唯一地确定一棵二叉树，我在实现部分举出了反例。原因：前序数组和后序数组都可以直接知道root在哪里，但前序和后序数组的左右区间的分割点我们找不到。中序数组的重要性在于其把左右区间给分隔开了。</p>
</li>
<li><p>本题和下一题的更佳写法是下标索引写法，即每次用下标索引来分割。虽然时间复杂度基本保持不变，但空间复杂度相比于传统写法大大降低了，因为不需要每层递归产生新的数组，只需要对索引重新赋值即可。</p>
</li>
<li><p>下标索引写法挺容易出错的，特别是在确定左右区间的边界上，搞不定的话就采用简单直接的普通写法。</p>
</li>
<li><p>我写的下标索引写法，还可以做进一步优化，若将划分postorder的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftpostorderbegin = postbegin;</span><br><span class="line"><span class="type">int</span> leftpostorderend = postbegin + leftinorderend - leftinorderbegin;</span><br><span class="line"><span class="type">int</span> rightpostorderbegin = postbegin + leftinorderend - leftinorderbegin;</span><br><span class="line"><span class="type">int</span> rightpostorderend = postend;</span><br></pre></td></tr></table></figure>
<p>直接写作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftpostorderbegin = postbegin;</span><br><span class="line"><span class="type">int</span> leftpostorderend = postbegin + i - inbegin;</span><br><span class="line"><span class="type">int</span> rightpostorderbegin = postbegin + i - inbegin;</span><br><span class="line"><span class="type">int</span> rightpostorderend = postend - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>即将</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postend -- ;</span><br><span class="line"><span class="type">int</span> leftinorderbegin = inbegin;</span><br><span class="line"><span class="type">int</span> leftinorderend = i;</span><br><span class="line"><span class="type">int</span> rightinorderbegin = i + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> rightinorderend = inend;</span><br></pre></td></tr></table></figure>
<p>直接代入划分postorder的代码中，时间复杂度可以进一步降低。对于106题的下标索引写法也是如此。</p>
</li>
</ol>
<h3 id="105-从前序与中序遍历序列构造二叉树-2"><a href="#105-从前序与中序遍历序列构造二叉树-2" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h3><ol>
<li><p>本题的核心思路和上题完全相同，也是在于以下五步：</p>
<ul>
<li>前序数组第一位是root</li>
<li>在inorder中查找root</li>
<li>以root作为分割点，将inorder分为左中序数组和右中序数组</li>
<li>根据上一步结果，将preorder分为左前序数组和右前序数组</li>
<li>递归处理左右子树</li>
</ul>
</li>
<li>本题和上题的不同之处在于，上题在分割出左右中序数组后，需要删去后序数组的最后一个元素，即root元素。本题则是在分割出左右中序数组后，需要删去前序数组的第一个元素，即root元素。删去数组的最后一个元素的操作相对简单，只需要 <code>pop_back</code>即可，但删去数组的第一个元素的操作相对复杂。我想到的办法是翻转数组，删去数组最后一个元素，再翻转数组。</li>
<li>用下标索引写法，本题删去前序数组中的第一个元素（root）就非常简单，只需要 <code>prebegin ++</code>即可。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yifan Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Yifan Chen</p>
  <div class="site-description" itemprop="description">主要记录算法和web开发方面的心得体会</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">76</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yifan Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  


    </div>
</body>
</html>
