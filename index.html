<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="主要记录算法和web开发方面的心得体会">
<meta property="og:type" content="website">
<meta property="og:title" content="YifanChen&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="YifanChen&#39;s Blog">
<meta property="og:description" content="主要记录算法和web开发方面的心得体会">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yifan Chen">
<meta property="article:tag" content="C++, Python, Java, Django, Springboot, 算法, web开发">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>YifanChen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YifanChen's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">YifanChen's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个专注技术的新手程序员</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yfchenkeepgoing/yfchenkeepgoing.github.io" class="github-corner" title="YifanChen GitHub" aria-label="YifanChen GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/15/Day-15-Leetcode-Breadth-first-traversal-226-101/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/15/Day-15-Leetcode-Breadth-first-traversal-226-101/" class="post-title-link" itemprop="url">Day 15 | Leetcode Breadth-first traversal, 226, 101</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-15 22:06:40" itemprop="dateCreated datePublished" datetime="2024-02-15T22:06:40+00:00">2024-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-17 18:01:26" itemprop="dateModified" datetime="2024-02-17T18:01:26+00:00">2024-02-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（二叉树）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">层序遍历</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html">226.翻转二叉树</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html">101. 对称二叉树</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>二叉树的层序遍历相当于图论中的广度优先搜索。leetcode 102：层序输出二叉树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[6] --&gt; B[4];</span><br><span class="line">    A --&gt; C[7];</span><br><span class="line">    B --&gt; D[1];</span><br><span class="line">    B --&gt; E[3];</span><br><span class="line">    C --&gt; F[5]</span><br><span class="line">    C --&gt; G[8]</span><br></pre></td></tr></table></figure>
<p>上述二叉树，一层放在一个数组里，返回的是二维数组。只依赖二叉树本身的结构，无法层序保存二叉树中的节点。需要借助另一种数据结构：队列，用于保存每一层遍历过的元素。图论中的广度优先搜索也是依赖队列实现的。</p>
<p>模拟过程：根节点6加入队列，记录队列大小（size=1）。size表示这层二叉树中有几个元素。接下来弹出当前层的元素6，将6加入到结果数组中，开始处理下一层。再将6的左右孩子4和7加入队列中，此时size=2，第二层的元素个数为2，接下来弹出size（2）个元素，先弹出4，将4的左右孩子1和3加入队列。再弹出7，size归0，第二层遍历结束。弹出7后，再将7的左右孩子5和8加入队列。此时size=4，说明第三层中元素个数为4。接着队列中再弹出size(4)个元素，加入结果数组。上述过程如下图所示。<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-02-16_02-48-16.png?raw=true" alt="Snipaste_2024-02-16_02-48-16.png"></p>
<p>我尝试根据上述模拟过程独立写出代码，但不知道怎么写while循环结束的条件。直接看卡尔的讲解。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">queue&lt;TreeNode*&gt; q;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历的终止条件：队列中无元素</span></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = q.<span class="built_in">size</span>(); <span class="comment">// 记录当前层节点的数量</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">// 存放一层的节点的值</span></span><br><span class="line">    <span class="comment">// 队列中弹出size个节点，加入到vec中</span></span><br><span class="line">    <span class="keyword">while</span> (size -- )</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将弹出节点的左右孩子加入到队列中</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p>
<p>上述代码也是图论中广度优先搜索的模板。leetcode上有10道题都可以用本模板解决，只需要改动不超过三行代码。</p>
<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="226-翻转二叉树-1"><a href="#226-翻转二叉树-1" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><p>我能想到的办法是层序遍历二叉树，然后将每一层的输出数组翻转。但这样做需要将数组还原回到二叉树，比较麻烦。随后有产生想法，让一个节点的左指针指向其右节点，右指针指向其左节点即可，可能需要一个中间变量来存放左节点或者右节点。直接看卡尔的视频。</p>
<h3 id="101-对称二叉树-1"><a href="#101-对称二叉树-1" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h3><h4 id="107-二叉树的层次遍历II"><a href="#107-二叉树的层次遍历II" class="headerlink" title="107.二叉树的层次遍历II"></a>107.二叉树的层次遍历II</h4><p>只需要在最后翻转res数组即可：<code>reverse(res.begin(), res.end());</code>。翻转一个二维数组，二维数组中所有元素（一维数组）的顺序都会颠倒，但一维数组本身（即一维数组内部的顺序不会改变）。reverse函数可以用双指针算法手动实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = res.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>; i &lt; len / <span class="number">2</span>; i ++ , j -- )</span><br><span class="line">    <span class="built_in">swap</span>(res[i], res[j]);</span><br></pre></td></tr></table></figure></p>
<p>似乎手动实现的速度要快于调用现成的reverse函数。</p>
<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i == size - <span class="number">1</span>) res.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 将一层最右边的节点的值加入到结果数组中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum / size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                Node* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;children.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[i]) q.<span class="built_in">push</span>(node-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a>515.在每个树行中找最大值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> max = <span class="number">-2147483648</span>; <span class="comment">// Node.val的最小值，可简写为int max = INT_MIN;</span></span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                max = node-&gt;val &gt; max ? node-&gt;val: max; <span class="comment">// 注意问号表达式的用法</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            Node* node0, *node; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 取出一层的头结点</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    node0 = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                 <span class="comment">// 本句话的目的：当一层只有头节点时，可以让该头节点在弹出的同时继续在队列中行插入其左右子节点</span></span><br><span class="line">                    node = node0; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 本层前一个节点next指向本节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// node0和node交替前进</span></span><br><span class="line">                    node = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    node0-&gt;next = node;</span><br><span class="line">                    node0 = node;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本层最后一个节点指向NULL</span></span><br><span class="line">            node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="117-填充每个节点的下一个右侧节点指针II"><a href="#117-填充每个节点的下一个右侧节点指针II" class="headerlink" title="117.填充每个节点的下一个右侧节点指针II"></a>117.填充每个节点的下一个右侧节点指针II</h4><p>本题代码和116完全相同。116题目中的条件：完整二叉树实际上是多余的。不管是不是完整二叉树，都可以用同样的代码解题。</p>
<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res ++ ;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：只有当某个节点的左右孩子都为空，这个节点才在二叉树的底部。一旦遇到这样的节点，立即跳出循环，返回res。根据这个思路，我将上述代码做了简化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> ++ res;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="226-翻转二叉树-2"><a href="#226-翻转二叉树-2" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><p>面试中的常考题。本质是交换每个节点的左右孩子，交换的是指针而非数值。这道题显然用递归解比较简单，但要想清楚用哪种遍历顺序。<strong>本题用前序和后序是最直接的，用中序遍历代码比较难写</strong>。迭代和层序遍历也可以做此题，但不要求掌握。</p>
<p>递归三部曲：</p>
<ul>
<li><p>确定递归函数的返回值和参数: <code>TreeNode* invertTree(root)</code></p>
</li>
<li><p>确定函数的终止条件：<code>if (root == NULL) return root</code></p>
</li>
<li><p>具体的处理逻辑：前序遍历——中左右</p>
<p> 对中节点，需要交换中节点的左右孩子: <code>swap(root-&gt;left, root-&gt;right)</code></p>
<p> 左节点：<code>invertTree(root-&gt;left);</code></p>
<p> 右节点：<code>invertTree(root-&gt;right);</code></p>
<p> 将swap函数放在处理逻辑的最后，就是左右中，就是后续遍历。因此前序和后续遍历皆可解本题。但中序遍历不可以，举个例子：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[4] --&gt; B[2];</span><br><span class="line">    A --&gt; C[7];</span><br><span class="line">    B --&gt; D[1];</span><br><span class="line">    B --&gt; E[3];</span><br><span class="line">    C --&gt; F[6]</span><br><span class="line">    C --&gt; G[9]</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[4] --&gt; B[2];</span><br><span class="line">    A --&gt; C[7];</span><br><span class="line">    B --&gt; D[3];</span><br><span class="line">    B --&gt; E[1];</span><br><span class="line">    C --&gt; F[6]</span><br><span class="line">    C --&gt; G[9]</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[4] --&gt; B[7];</span><br><span class="line">    A --&gt; C[2];</span><br><span class="line">    B --&gt; D[6];</span><br><span class="line">    B --&gt; E[9];</span><br><span class="line">    C --&gt; F[3]</span><br><span class="line">    C --&gt; G[1]</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[4] --&gt; B[7];</span><br><span class="line">    A --&gt; C[2];</span><br><span class="line">    B --&gt; D[6];</span><br><span class="line">    B --&gt; E[9];</span><br><span class="line">    C --&gt; F[1]</span><br><span class="line">    C --&gt; G[3]</span><br></pre></td></tr></table></figure>
<p> 相当于原先根节点的左子树被处理了两次，原先根节点的右子树没被处理。对中序遍历的写法，具体的逻辑应该为：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">invertTree</span>(root-&gt;left); <span class="comment">// 处理左子树</span></span><br><span class="line"><span class="built_in">swap</span>(root-&gt;left, root-&gt;right); <span class="comment">// 交换左右子树，原先的右子树变为了现在的左子树，原先的左子树变为了现在的右子树</span></span><br><span class="line"><span class="built_in">invertTree</span>(root-&gt;left); <span class="comment">// 原先的左子树已经被处理过了，现在需要处理原先的右子树，就是现在的左子树</span></span><br></pre></td></tr></table></figure>
<p> 不建议绕弯子去写中序，很容易出错。</p>
</li>
</ul>
<p>前序遍历：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中左右</span></span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>后序遍历写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右中</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>中序遍历写法(<strong>绕，理解即可，不要写</strong>)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左中右</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="101-对称二叉树-2"><a href="#101-对称二叉树-2" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="层序遍历-2"><a href="#层序遍历-2" class="headerlink" title="层序遍历"></a>层序遍历</h3><ol>
<li>本题（leetcode102）的模板需要熟记，可以用来解决10道leetcode。</li>
<li>本题的关键在于用队列来保存每一层遍历过的元素。</li>
<li><strong>本题的思路可以概括为</strong>：将二叉树的一层加入到队列中，记录队列的大小为size。然后弹出size个节点，用数组收集弹出的节点，并在弹出节点的同时插入弹出的节点的左右子节点。弹完size个节点后，数组中就是当前层的所有元素，而队列中则是下一层的所有节点。</li>
<li>本题不需要用指针来遍历整棵树，只需要对维护和操作队列即可。</li>
<li>本题收获最终结果的退出条件为队列为空；二叉树的一层遍历完毕的退出条件为size = 0。</li>
<li><p>二叉树的右视图这题需要特别注意，以下写法是错误的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因是：对于以下的二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[6] --&gt; B[4];</span><br><span class="line">    A --&gt; C[NULL];</span><br></pre></td></tr></table></figure>
<p>尽管6只有左子节点，没有右子节点，但站在二叉树的右边看这颗二叉树，看到的结果是[6, 4]，如果按照上面的写法，则返回的结果是[6]，4作为左子节点不会被加入到队列中，也不会出现在结果数组中。</p>
</li>
<li><p>N叉树的层序遍历需要注意：新定义的N叉树的名字叫Node，不要下意识地写成TreeNode。在队列中更新N叉树下一层的节点时，注意需要用for循环遍历一遍当前node的孩子数组，因为N叉树中的一个节点不仅有左右孩子，而是有一个孩子数组。</p>
</li>
<li><p>二叉树的最大深度的解题关键在于：层序遍历二叉树，每遍历完一层记录层数的变量+1。</p>
</li>
<li><p>二叉树的最大/最小深度这两道题，<code>res ++</code>放在第二重while循环之后和之前都可以。我在实现中的写法都是把<code>res ++</code>放在了第二重while循环之后，但实际上放在第二重while循环之前写出的代码更简洁易懂，可以参考代码随想录上给出的代码。</p>
</li>
<li><p>注意复习填充每个节点的下一个右侧节点指针，这道题第一遍没有写出来。本题的关键在于特判一层的头节点，以及node0和node交替前进。</p>
</li>
<li><p>116和117题的代码完全相同。差别只在于116题题目说是完整二叉树，117题目则没有这个说明。</p>
</li>
</ol>
<h3 id="226-翻转二叉树-3"><a href="#226-翻转二叉树-3" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><ol>
<li><p>注意：本题中的root是指遍历的每个节点，而非特指根节点。</p>
</li>
<li><p>记住前序和后续的写法即可，swap要么写在左右的上面，要么写在左右的下面。抛弃中序写法，太绕！</p>
</li>
<li><p>记得最后要<code>return root</code>。因为终止条件：<code>if (root == NULL) return root</code>，只会返回一个为空的节点。大多数情况下不会触发这个终止条件，而是触发最后一个<code>return root</code>。</p>
</li>
<li><p>可以定义一个cur节点遍历二叉树的每个节点，这样就不会与根节点root产生混淆。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中左右</span></span><br><span class="line">        <span class="built_in">swap</span>(cur-&gt;left, cur-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(cur-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(cur-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="101-对称二叉树-3"><a href="#101-对称二叉树-3" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/11/Day-14-Leetcode-Recursive-traversal-Iterative-traversal-Unified-iteration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/11/Day-14-Leetcode-Recursive-traversal-Iterative-traversal-Unified-iteration/" class="post-title-link" itemprop="url">Day 14 | Leetcode Recursive traversal, Iterative traversal, Unified iteration</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-11 20:18:31" itemprop="dateCreated datePublished" datetime="2024-02-11T20:18:31+00:00">2024-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-13 06:27:42" itemprop="dateModified" datetime="2024-02-13T06:27:42+00:00">2024-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（二叉树）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">理论基础</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">递归遍历</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">迭代遍历</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">统一迭代</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h4><p>解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树（完全二叉树包含满二叉树，满二叉树一定是完全二叉树）</p>
<p>“度”是指一个节点拥有的子节点的数量</p>
<h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。也可以说深度为k，有2^k-1个节点的二叉树。</p>
<h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p>完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且<strong>最下面一层的节点都集中在该层最左边的若干位置</strong>。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。</p>
<p>之前我们刚刚讲过优先级队列其实是一个堆，<strong>堆就是一棵完全二叉树</strong>，同时保证父子节点的顺序关系。</p>
<h5 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h5><p>前面介绍的树，都是没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。搜索的时间复杂度是O(logn)。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均<strong>小于</strong>它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均<strong>大于</strong>它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树<h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5>平衡二叉树（Balanced Binary Tree）是一种特殊的二叉树，它满足以下性质：对于树中的每一个节点，其左子树和右子树的高度差的绝对值不超过1。这个条件确保了<strong>树的高度大致保持在log(n)级别</strong>，其中n是树中节点的数量。由于这种高度平衡，平衡二叉树可以在对数据进行插入、删除和查找操作时提供较好的性能，特别是保持操作的时间复杂度接近于<code>O(logn)</code>。<h5 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h5>平衡二叉搜索树：又被称为AVL树。具有以下性质：<strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1</strong>，并且左右两个子树都是一棵平衡二叉树。</li>
</ul>
<p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn。map的key和set中的元素是有序的，因为它们的底层实现是平衡二叉搜索树，而平衡二叉搜索树是有序的。</p>
<h4 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h4><p>二叉树可以链式存储，也可以顺序（线性）存储。那么链式存储方式就用指针， 顺序存储的方式就是用数组。顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p>
<p>用数组来存储二叉树如何遍历的呢？如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。但是用链式表示的二叉树，更有利于我们理解，所以<strong>一般我们都是用链式存储二叉树</strong>。</p>
<p>代码构造二叉树：创造一个头节点，其左指针指向左子节点，右指针指向右子节点，然后向函数中传入头节点即可。</p>
<h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>二叉树主要有两种遍历方式：</p>
<ol>
<li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li>
<li>广度优先遍历：一层一层的去遍历。</li>
</ol>
<p>从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p>
<ol>
<li>深度优先遍历（一般用递归法）</li>
</ol>
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
<ol>
<li>广度优先遍历<br>层次遍历（迭代法）</li>
</ol>
<p>这里前中后，<strong>其实指的就是中间节点的遍历顺序</strong>（但是所有遍历顺序都是先左后右）。<br>左指左子树，右指右子树。在左右子树中继续按照规则搜索。<br>前序遍历：中左右<br>中序遍历：左中右<br>后序遍历：左右中</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806191109896.png" alt="img"></p>
<p>每个子树和整棵树都遵循中左右/左中右/左右中。</p>
<p>最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用<strong>递归</strong>的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。<strong>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助<strong>栈</strong>使用递归的方式来实现的。</p>
<p>而广度优先遍历的实现一般使用<strong>队列</strong>来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p>
<h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>链式存储的二叉树节点的定义方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>二叉树的定义和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针，有两个指针，指向左右孩子。</p>
<h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>针对leetcode上的三道题目，分别是前序、中序、后序遍历，题号是144，145和94。按照三步来思考，才能保证写出正确的递归代码。所有二叉树的题目都用递归三部曲进行分析。本章节主要讲如何写出递归的代码，不关注底层实现机制。</p>
<p>三部曲：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
<li>确定终止条件</li>
<li>确定单层递归的逻辑</li>
</ol>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序：中左右</p>
<ol>
<li><p>确定递归函数的参数和返回值</p>
<p>没必要一次性确定，可以在写递归函数时根据需要来填充参数。一般参数为根节点和数组，后者用来存放遍历的结果。返回值一般是void，因为我们把想要的结果放在了参数的数组中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> <span class="comment">// 参数为根节点和结果数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定终止条件（搞不好会出现栈溢出等问题）。深度优先搜索是遇到NULL时返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定单层递归的逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 中</span></span><br><span class="line"><span class="built_in">treversal</span>(cur-&gt;left, vec); <span class="comment">// 左</span></span><br><span class="line"><span class="built_in">treversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br></pre></td></tr></table></figure>
<p>注意在前序遍历中上面三行代码的顺序不可改变。</p>
</li>
</ol>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>左中右。只需要改变第三步：确定单层递归的逻辑的代码。三行代码的顺序不可改变。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">treversal</span>(cur-&gt;left, vec); <span class="comment">// 左</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 中</span></span><br><span class="line"><span class="built_in">treversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br></pre></td></tr></table></figure></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>左右中。同样只需要改变第三步：确定单层递归的逻辑的代码。三行代码的顺序不可改变。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">treversal</span>(cur-&gt;left, vec); <span class="comment">// 左</span></span><br><span class="line"><span class="built_in">treversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 中</span></span><br></pre></td></tr></table></figure></p>
<h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><h4 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>非递归的方式：迭代法，如何实现二叉树的前中后序遍历。通常对简单的递归逻辑，要求写出相应的迭代（非递归）写法。最基础的就是用迭代法实现前中后序遍历。使用迭代法模拟递归，也需要使用到栈这种数据结构。理论上，所有递归都可以用栈模拟出来。</p>
<p>以下面的二叉树为例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[5] --&gt; B[4];</span><br><span class="line">    A --&gt; C[6];</span><br><span class="line">    B --&gt; D[2];</span><br><span class="line">    B --&gt; E[1];</span><br></pre></td></tr></table></figure>
<p>前序遍历上述二叉树，顺序为中左右，输出结果为54216。用栈来辅助遍历上述二叉树。首先将5加入栈中，然后弹出5，将其放入结果数组中。接着处理5的左右孩子，先把6加入栈中，再把4加入栈中（栈是先进后出的），然后弹出4，将其放入结果数组中。接着处理4的左右孩子，依旧是先放右孩子1，再放左孩子2，然后弹出2，加入结果数组中，因为2已经是叶子节点了，接着弹出1，加入结果数组中，最后弹出6，加入结果数组中。结果数组中是54216，符合预期。关键点是先将右孩子放入栈中，再将左孩子放入栈中，这样弹出时就会先弹出左孩子。<strong>弹出时还要关注弹出的节点是否是叶子节点。是，则不需要继续向栈中加入元素；否，则需要向栈中继续加入弹出节点的左右孩子</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">function</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; st; <span class="comment">// 栈</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 结果数组</span></span><br><span class="line">    </span><br><span class="line">    st.<span class="built_in">push</span>(root); <span class="comment">// 中节点入栈</span></span><br><span class="line">    <span class="comment">// 栈不为空，则执行以下逻辑</span></span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将中节点从栈中弹出，加入到结果数组中</span></span><br><span class="line">        TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) <span class="comment">// 特判：中节点是否为空</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>; <span class="comment">// 若中节点为空，进入下一次循环</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将中节点的左右孩子放入栈中，先将右孩子入栈，再将左孩子入栈，这样出栈时才是先左后右的顺序</span></span><br><span class="line">        st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右</span></span><br><span class="line">        st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归模拟前序遍历，本来前序遍历的顺序应该是中左右，但由于栈先进后出的特性，代码中实际的顺序是中右左。</p>
<h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历是左右中。实现后序遍历的原理如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[前序遍历：中左右] --&gt;|颠倒左右| B[中右左]</span><br><span class="line">    B --&gt;|翻转结果数组| C[左右中]</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">function</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    st.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        	res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        st.<span class="built_in">push</span>(root-&gt;left); <span class="comment">// 左</span></span><br><span class="line">        st.<span class="built_in">push</span>(root-&gt;right); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历无法在前序遍历的基础上通过交换某几行代码的顺序来实现。遍历节点和处理节点是两种逻辑。前序和后序遍历中，遍历的节点和要处理的节点是一个顺序，才能写出上述比较简洁的代码。但在中序遍历中，遍历节点的顺序与和处理节点的顺序不同。后面会继续介绍中序遍历的写法，以及如何像递归写法那样更改几行代码的顺序来实现前中后序遍历的迭代写法。</p>
<p>处理二叉树时有两步操作，一步是访问节点，一步是处理节点。访问节点是从根节点开始，一个节点一个节点地去访问。处理节点是把访问到的节点中的元素放入结果数组中。</p>
<p>以下面的二叉树为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[5] --&gt; B[4];</span><br><span class="line">    A --&gt; C[6];</span><br><span class="line">    B --&gt; D[1];</span><br><span class="line">    B --&gt; E[2];</span><br></pre></td></tr></table></figure>
<p>对于中序遍历，先访问的节点是5，但先处理的节点应该是1（先把1放入结果数组中）。我们要处理1节点，需要先访问节点5、4、1。这就造成了访问的顺序和处理的顺序不同。因此中序遍历需要另一套写法。</p>
<p>下面模拟中序遍历迭代法的过程。需要一个指针帮助我们遍历二叉树，同时用栈记录遍历过的顺序，然后逆向输出即可。指针一路向左访问，指针先指向5，5入栈；指针再指向4，4入栈；指针再指向1，1入栈。到叶子节点了（叶子节点的左指针为空），便从栈中取出元素，从栈中弹出1并加入到结果数组中。看1的右孩子，为空，故再从栈中弹出4并加入到结果数组中，看4的右孩子，不为空，4的右孩子2入栈。2的左孩子为空，故将2从栈中弹出，加入到结果数组中。再看2的右孩子，为空，故从栈中弹出5并加入到结果数组中。5的右孩子为6，不为空，6入栈。6的左孩子为空，故6出栈，加入结果数组中。6的右孩子为空，本该从栈中弹出元素，但此时栈为空，故结束。结果数组为14256，符合中序遍历的顺序。</p>
<p><strong>总结</strong>：用指针遍历节点，用栈来记录遍历过的节点，再从栈中弹出元素放入结果数组中。指针一路向左访问，若某个节点的左指针为空，则从栈中取出该节点并放入结果数组中。若某个节点的右指针为空，则从栈中弹出顶部元素并放入结果数组中，若某个节点的右指针不为空，则将右指针指向的节点入栈。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">traversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode* cur = root; <span class="comment">// 用于遍历二叉树的指针，一开始指向根节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cur为空且栈也为空时，遍历终止</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 栈用于记录指针访问过的元素</span></span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left; <span class="comment">// 指针一路向左访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针一路向左，遇到某个节点的左指针为空</span></span><br><span class="line">        <span class="comment">// 则从栈中取出该节点并放入结果数组中</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cur = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 看当前指针的右孩子是否为空</span></span><br><span class="line">            <span class="comment">// 若为空，则从栈中弹出顶部节点，并将其加入到结果数组中</span></span><br><span class="line">            <span class="comment">// 若不为空，则将右孩子入栈</span></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前迭代法的前中后序遍历没有像递归那样统一起来，其实也是可以统一起来的。统一的写法：用一个栈完成遍历节点和处理节点的过程，但栈中要加入空节点做标记，标记正在遍历的节点和处理的节点。</p>
<h3 id="统一迭代"><a href="#统一迭代" class="headerlink" title="统一迭代"></a>统一迭代</h3><p>对前中后序这三种遍历方式，使用迭代法是可以写出统一风格的代码。以中序遍历为例，我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p>
<h4 id="中序遍历-2"><a href="#中序遍历-2" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点非空才将其放入栈中</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环条件：栈不为空</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// node不为空，则按照右中左的顺序访问节点</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(node); <span class="comment">// 中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只有遇到空节点的时候，才处理节点（将下一个节点放进结果集）</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将空节点弹出，重新取出栈中的元素</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于前序和后序遍历，只需要改变node不为空时访问节点的顺序即可。前序遍历原本的顺序是中左右，考虑到栈先入后出的特性，调整为右左中。后续遍历原本的顺序是左右中，考虑到栈先入后出的特性，调整为中右左。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="递归遍历-1"><a href="#递归遍历-1" class="headerlink" title="递归遍历"></a>递归遍历</h3><h4 id="144-前序遍历二叉树"><a href="#144-前序遍历二叉树" class="headerlink" title="144. 前序遍历二叉树"></a>144. 前序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 前序遍历递归写法的核心函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> <span class="comment">// 递归函数的参数和返回值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 确定终止条件</span></span><br><span class="line">        </span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, vec); <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于主函数，调用核心函数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root, res); <span class="comment">// 调用核心函数</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>完整的，带有测试样例的代码为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建树的示例代码，需要根据实际情况调整</span></span><br><span class="line">    TreeNode* node3 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    TreeNode* node2 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>, node3, <span class="literal">nullptr</span>);</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>, <span class="literal">nullptr</span>, node2);</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = solution.<span class="built_in">preorderTraversal</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : res) &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放分配的内存（在实际使用中，考虑使用智能指针自动管理内存）</span></span><br><span class="line">    <span class="keyword">delete</span> node3;</span><br><span class="line">    <span class="keyword">delete</span> node2;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="145-后序遍历二叉树"><a href="#145-后序遍历二叉树" class="headerlink" title="145. 后序遍历二叉树"></a>145. 后序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, res); <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, res); <span class="comment">// 右</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="94-中序遍历二叉树"><a href="#94-中序遍历二叉树" class="headerlink" title="94. 中序遍历二叉树"></a>94. 中序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, res); <span class="comment">// 左</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, res); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="迭代遍历-1"><a href="#迭代遍历-1" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><h4 id="144-前序遍历二叉树-1"><a href="#144-前序遍历二叉树-1" class="headerlink" title="144. 前序遍历二叉树"></a>144. 前序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序为中左右，因为栈的先入后出的特性，所以代码顺序调整为中右左</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st; <span class="comment">// 用栈实现迭代，模拟递归</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 结果数组</span></span><br><span class="line"></span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右</span></span><br><span class="line">            st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="145-后序遍历二叉树-1"><a href="#145-后序遍历二叉树-1" class="headerlink" title="145. 后序遍历二叉树"></a>145. 后序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历：左右中。前序遍历：中左右 </span></span><br><span class="line"><span class="comment">// 中左右-&gt;中右左-&gt;左右中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左</span></span><br><span class="line">            st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="94-中序遍历二叉树-1"><a href="#94-中序遍历二叉树-1" class="headerlink" title="94. 中序遍历二叉树"></a>94. 中序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历的迭代写法，参见总结部分的精髓即可写出以下的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件：指针和栈都为空</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 指针不为空，则将指针指向的节点放入栈中，指针向左走</span></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指针为空，则将栈顶元素弹出并放入结果数组中，指针向右走</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="统一迭代-1"><a href="#统一迭代-1" class="headerlink" title="统一迭代"></a>统一迭代</h3><h4 id="94-中序遍历二叉树-2"><a href="#94-中序遍历二叉树-2" class="headerlink" title="94. 中序遍历二叉树"></a>94. 中序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将非空的头节点插入栈中</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环终止条件：栈为空</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若node不为空，则按照右中左的顺序访问节点</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 访问右节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(node); <span class="comment">// 访问中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 只访问没处理，在中结点上面添加NULL来标记</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 访问左节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若node为空，则处理该节点下面的节点，将其加入到res中</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="144-前序遍历二叉树-2"><a href="#144-前序遍历二叉树-2" class="headerlink" title="144. 前序遍历二叉树"></a>144. 前序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// node不为空，访问节点</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左</span></span><br><span class="line">                st.<span class="built_in">push</span>(node); <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点后面插入NULL</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// node为空，处理节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="145-后序遍历二叉树-2"><a href="#145-后序遍历二叉树-2" class="headerlink" title="145. 后序遍历二叉树"></a>145. 后序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统一迭代写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 节点不为空，则访问节点，顺序为中右左</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(node);</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 节点为空，则处理节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="递归遍历-2"><a href="#递归遍历-2" class="headerlink" title="递归遍历"></a>递归遍历</h3><ol>
<li>记住递归三部曲：<ul>
<li>确定递归函数的参数和返回值</li>
<li>确定终止条件</li>
<li>确定单层递归的逻辑</li>
</ul>
</li>
<li>前序、中序、后序遍历的代码只有单层递归的逻辑部分有所不同。更确切地说，只是三行代码的顺序发生了改变。</li>
<li>递归的核心函数返回值为void，结果数组以引用的方式作为参数传入，经过核心函数的改变后，改变后的数组会被传出，在主函数中调用其即可。</li>
<li>易错点：核心函数中忘记加上引用<code>&amp;</code>，插入数组时没有取root指针的值(<code>root-&gt;val</code>)，而是直接将root指针传入了。</li>
<li>注意如何写出完整的带有测试样例的代码，这涉及到如何写<code>struct TreeNode</code>和<code>main</code>函数。</li>
<li>熟悉几个英文单词：<ul>
<li>遍历：traversal</li>
<li>前序：pre-order、中序：in-order、后序：post-order、层序：level-order</li>
<li>二叉树：binary tree</li>
<li>递归：Recursion  迭代：Iteration</li>
</ul>
</li>
</ol>
<h3 id="迭代遍历-2"><a href="#迭代遍历-2" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><ol>
<li>迭代遍历的本质是用栈来模拟递归，用结果数组来收集结果。由于栈的先入后出的特性，前序遍历的顺序本来应该是中左右，迭代写法的顺序调整为中右左。后序遍历是在前序遍历的基础上颠倒右和左的顺序，再翻转结果数组（前序遍历=中左右-&gt;中右左-&gt;左右中=后序遍历）。</li>
<li>中序遍历的迭代写法不能像后序遍历那样从前序遍历迭代写法的基础上直接进行改造。这是因为在中序遍历中，遍历节点的顺序与和处理节点的顺序不同。</li>
<li>中序遍历的迭代写法需要一个指针来遍历所有节点，一个栈用于记录遍历过的节点，一个数组用于存放结果。</li>
<li><strong>中序遍历迭代写法的精髓</strong>：当指针不为空时，用栈记录指针遍历过的元素，指针持续向左走。当指针为空时，从栈中弹出顶部的节点并将其放入结果数组中，然后指针向右走。当指针为空且栈为空时，终止。</li>
<li>统一迭代的写法可以将前中后序遍历的迭代写法统一起来。</li>
<li>迭代写法确实更复杂些，注意事项也更多，也更容易写错。了解思路即可，可以放过。</li>
</ol>
<h3 id="统一迭代-2"><a href="#统一迭代-2" class="headerlink" title="统一迭代"></a>统一迭代</h3><ol>
<li>统一迭代的思路其实比较清晰：当头节点非空时，头节点入栈。在栈非空时，不断循环。弹出栈顶节点，若该节点不为空，则按照顺序访问节点，并在访问中节点之后插入NULL，作为标记（说明该节点只被访问过，没有被处理过）；若该节点为空，则处理当前的栈顶节点（原本的栈顶节点已被弹出），将其放入结果数组中，并将其弹出。</li>
<li>对于前序、中序和后序遍历，只需要改变node不为空时访问节点的顺序即可。<strong>考虑到栈先入后出的特性</strong>：前序遍历原本的顺序是中左右，调整为右左中。中序遍历原本的顺序是左中右，调整为右中左。后续遍历原本的顺序是左右中，调整为中右左。</li>
<li>统一迭代思路清晰且对于前中后序遍历能够保持一致的写法，建议用迭代法遍历二叉树时，优先采用统一迭代的写法。前面的迭代遍历的一般写法虽然较为简单，但只能在前序和后序遍历时保持统一，在中序遍历时需要重新写。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/06/Day-13-Leetcode-239-347-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/06/Day-13-Leetcode-239-347-summary/" class="post-title-link" itemprop="url">Day 13 | Leetcode 239, 347, summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-06 21:22:26" itemprop="dateCreated datePublished" datetime="2024-02-06T21:22:26+00:00">2024-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-09 05:30:39" itemprop="dateModified" datetime="2024-02-09T05:30:39+00:00">2024-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（栈与队列）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">239. 滑动窗口最大值</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html">347.前 K 个高频元素</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93.html">栈与队列总结</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><h3 id="栈与队列总结"><a href="#栈与队列总结" class="headerlink" title="栈与队列总结"></a>栈与队列总结</h3><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="239-滑动窗口最大值-1"><a href="#239-滑动窗口最大值-1" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p>本题应该有些类似于滑动窗口的经典题目：209.长度最小的子数组。本题的思路：用一个长度始终为3的队列，滑过数组。每次算出队列中的最大值，然后存入数组中。我打算另写一个函数来返回三个值中的最大值。但是应该是有办法在队列进出元素的时候顺便维护其中的最大值。</p>
<p>我根据暴力做法的思路，写下了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 得出队列中的最大值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">queuemax</span><span class="params">(queue&lt;<span class="type">int</span>&gt; q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> max = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> tmp = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (max &lt; tmp) max = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &lt; k) q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q.<span class="built_in">size</span>() == k)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">queuemax</span>(q));</span><br><span class="line">                q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">queuemax</span>(q));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述代码在输入数组不大时可以正常运行，但输入数组太大时会超时，测试样例通过了37 / 51。上述暴力做法的时间复杂度是O(n * k)。看代码随想录的视频讲解吧。</p>
<h3 id="347-前-K-个高频元素-1"><a href="#347-前-K-个高频元素-1" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><p>拿到这道题，我的第一想法是拿哈希去做。但发现哈希不能解决本题，因为对统计频率的数组排序后，数组的下标（即输入数组的元素）被打乱了。直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="239-滑动窗口最大值-2"><a href="#239-滑动窗口最大值-2" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p>本题是第一道hard。难点：如何求窗口中的最大值？暴力做法时间复杂度O(n <em> k)。需要一个特殊的队列，实现pop, push和getMaxValue（返回当前队列中的最大值）这三个操作。还可以用一个优先级队列。<strong>cpp中的优先级队列就是大顶堆（单调递减）或者小顶堆（单调递增）</strong>。大顶堆本质就是一个排序后的二叉树，最大的元素在上面。始终维护大顶堆，让大顶堆不断插入元素和弹出元素，大顶堆最前面的元素就是滑动窗口的最大值。<em>*但是用大顶堆是不行的</em></em>，因为无法正确地弹出元素（大顶堆内部自动做了排序，打乱了原来元素的顺序）。</p>
<p>因此用优先队列是不行的，需要我们自行实现一个<strong>单调队列</strong>来解决问题。需要维持队列中的元素是单调递增或单调递减的，同时需要保证pop操作的正确。<strong>单调队列中只需要维护有可能成为最大值的元素，而不需要维护k个元素</strong>。</p>
<p>模拟单调队列：<br>假设输入数组为13-1-35321。首先在队列中加入元素1，再加入3，若队列的前面有小于3的元素，则将这些元素全部弹出。这样做可以让队列的出口处就是最大值。<strong>由于随着滑动窗口的移动，本身就会舍弃第1个1，因此没必要维护3之前比3小的元素</strong>。接着在队列中加入-1。此时队列的前面没有小于-1的元素，故-1可以保留在队列中。此时取队首元素3，就是最大值。接着加入-3，队列前面的元素都大于-3，故保留-3，此时队列的最大值还是3。接着加入5，由于5比队列前面的元素都大，因此需要pop掉除5以外的全部元素，此时取队列的最大值，即队首元素，是5。接着放入3，3&lt;5，放入3，此时队列的最大值还是5。接着加入2，2&lt;5&amp;&amp;2&lt;3，因此放入2，此时队列的最大值还是5。再向后移动，需要把最大值5pop掉，加入1，1&lt;2 &amp;&amp; 1&lt;3，因此队列中加入1，此时队列的最大值是队首元素3。</p>
<p>单调队列在数组中移动的规则：除去常规的移动窗口的pop和push操作外，若push进来的元素比队列前面的元素都大，那前面的元素都要pop出去，直到队列前面的元素都大于push进来的元素为止。本方法的好处在于<code>getMaxValue</code>时取队首元素即可。</p>
<p>根据原理，我画出了如下的示意图，可以帮助理解（下图中打x的元素是因为单调队列的特殊规则：<code>若push进来的元素比队列前面的元素都大，那前面的元素都要pop出去</code>而被提前被删去的元素）。<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-02-07_13-50-29.png?raw=true" alt="Snipaste_2024-02-07_13-50-29.png"></p>
<p>根据上述原理，我尝试写出相应的代码，但是有一个问题我始终无法解决：根据规则：<code>若push进来的元素比队列前面的元素都大，那前面的元素都要pop出去</code>，有时原本的队首元素已经被更新为最大的元素了，意味着滑动窗口本身最前面的元素已经被弹出了，但有时，滑动窗口本身最前面的元素还没有被弹出，它仍作为队首元素，需要手动弹出。如何判断是否需要手动弹出队首元素。我来看看卡尔的代码实现，看他是如何解决这个问题的。</p>
<p>卡尔写了单调队列的三个关键函数。单调队列是在双向队列的基础上实现的，双向队列的首尾都可以出入元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// cpp中队列默认用deque双向队列来实现，双向队列的首尾都可以出元素和入元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 只有当需要pop的元素和队首元素（单调队列中目前的最大值）相同时，才弹出队首元素</span></span><br><span class="line">    <span class="comment">// 例如上图的倒数第二行到最后一行的操作（532-&gt;321）</span></span><br><span class="line">    <span class="comment">// 若需要pop的元素小于队首元素，那么在push时该元素已经被删除了</span></span><br><span class="line">    <span class="comment">// 例如上图中的-1-35-&gt;-353，本来需要手动删除-1，但由于-1&lt;5，因此在push(5)时-1已经被删除了</span></span><br><span class="line">    <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val == que.<span class="built_in">front</span>())</span><br><span class="line">        que.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当队列不为空且要插入的值val &gt; 队列中的最后一个元素时，持续从队尾弹出元素</span></span><br><span class="line">    <span class="comment">// 例如上图中的3-1-3-&gt;-1-35，要插入5，持续从队尾弹出比5小的元素，然后再插入5</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val &gt; que.<span class="built_in">back</span>()) que.<span class="built_in">pop_back</span>();</span><br><span class="line">    que.<span class="built_in">push_back</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">(deque&lt;<span class="type">int</span>&gt; que)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述关键代码的基础上，我写下了解决本题的完整代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">            <span class="comment">// 单调队列中只维护当前队列中的最大值，作为队首元素</span></span><br><span class="line">            <span class="comment">// 故窗口滑动时只需要在滑出最大值时手动删除最大值即可</span></span><br><span class="line">            <span class="comment">// 其他值都会在push时被删除</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val == que.<span class="built_in">front</span>()) que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保证单调队列从队首到队尾是单调递减的</span></span><br><span class="line">            <span class="comment">// 新插入的元素若大于当前队列中的最大值，则删除当前队列，将插入的元素放在队列的首部</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val &gt; que.<span class="built_in">back</span>()) que.<span class="built_in">pop_back</span>();</span><br><span class="line">            que.<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前队列中的最大值为队首元素，故返回队首元素即可</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]);</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="347-前-K-个高频元素-2"><a href="#347-前-K-个高频元素-2" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><p>两个难点：</p>
<ul>
<li><p>如何求数组中每个元素的频率</p>
</li>
<li><p>如何对这个频率进行排序，并求前k个高频的元素</p>
</li>
</ul>
<p>用map来进行排序，key用来存放元素，value用来存放元素出现的次数。接着以value为基准做从大到小的排序（不好做，因为map默认是按照key的顺序来进行排序的），最后输出value对应的key即可。时间复杂度<code>O(nlogn)</code>。</p>
<p>求前k个高频的元素，只需维护k个有序的集合，没必要对所有元素都进行排序。经典的数据结构：大顶堆、小顶堆。堆擅长在很大的数据集中求前k个高/低频的元素。大顶堆的根节点是最大的元素，小顶堆的根节点是最小的元素。</p>
<p>如何用堆解决这个问题？用堆去遍历map中的所有元素（以value为基准进行统计），堆中维持k个元素，遍历完map中的所有元素后，堆中的k个元素就是前k个高频元素。<strong>大/小顶堆？</strong>用大顶堆遍历map中的所有元素时，遇到新元素时，将其插入到大顶堆中，会弹出堆顶的元素（最大的元素），<strong>用大顶堆遍历完map后，堆中剩下的元素是前k个低频的元素</strong>。<strong>因此要用小顶堆</strong>。小顶堆每次在push进来元素时，弹出堆顶元素（最小的元素），堆中剩下的就是最大的元素。最后输出前k个最大的value对应的key。时间复杂度：遍历数组O(n)，每次堆中元素调整O(logk)（堆中有k个元素，堆是树状结构），总时间复杂度为O(nlogk)。在数组很大，k较小的情况下，本做法的性能明显优于对整个map进行排序的性能。优先级队列的底层实现是堆，<strong>因此用优先级队列即可</strong>。可自行实现大顶堆和小顶堆。</p>
<p>参考代码随想录的代码，我写下了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">compare</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="comment">// 为定义小顶堆重载运算符，这里的函数名为operator()，而非operator</span></span><br><span class="line">        <span class="comment">// 对大顶堆，本来应该是右边的元素&gt;左边的元素，对小顶堆，则与此相反</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; lhs, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rhs)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second; <span class="comment">// 比较的是元素出现的次数，而非元素的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nums[i]作为key, 出现此处作为value存入map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            map[nums[i]] ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义小顶堆，其中的元素类型是pair&lt;int, int&gt;，底层实现是vector&lt;pair&lt;int, int&gt;&gt;</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, compare&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map，不断将map中的元素插入小顶堆中，小顶堆不断弹出根节点处最小的元素</span></span><br><span class="line">        <span class="comment">// 最后剩下的k个元素是出现频次最高的k个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; k) q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点处是最小的元素，越往下元素越大，因此将小顶堆中的k个元素倒着插入res中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = q.<span class="built_in">top</span>().first; <span class="comment">// 插入res的是key, 即nums[i]</span></span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="239-滑动窗口最大值-3"><a href="#239-滑动窗口最大值-3" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><ol>
<li>单调队列需要手动实现，cpp标准库中没有现成可用的单调队列。</li>
<li>单调队列的好处在于能够将当前队列中的最大值放在队首，且不改变其他值的排列顺序（即其他值在单调队列中的排列顺序和它们在输入数组中的排列顺序相同）。</li>
<li>单调队列的特殊规则：若push进来的元素比队列前面的元素都大，那前面的元素都要pop出去。</li>
<li>定义一个类，在双向队列的基础上实现单调队列，而不要试图在主函数中对<code>queue&lt;int&gt;</code>做加工。</li>
<li>本题的详细模拟流程见实现中的图片。</li>
<li><p>单调队列中定义了三个函数：pop, push和getMaxValue。<br>对pop函数（负责模拟窗口的滑动，删除队首的最大值），需要注意：</p>
<ul>
<li>单调队列中只维护当前队列中的最大值，作为队首元素</li>
<li>故窗口滑动时只需要在滑出最大值时手动删除最大值即可</li>
<li>其他值都会在push时被删除</li>
</ul>
<p>对push函数（负责向单调队列中插入元素，同时调整队列中元素的顺序，将最大值置于队首），需要注意：</p>
<ul>
<li>保证单调队列从队首到队尾是单调递减的</li>
<li>新插入的元素若大于当前队列中的最大值，则删除当前队列，将插入的元素放在队列的首部</li>
<li>当前队列中的非最大值会在不断调用push函数的过程中被删除，最大值则需要pop函数来删除</li>
</ul>
</li>
<li>时间复杂度: O(n) 空间复杂度: O(k)<br>输入数组中的每个元素在单调队列中最多也就被插入和弹出各一次，没有任何多余操作，所以整体的时间复杂度还是O(n)。空间复杂度因为我们定义一个辅助队列，所以是O(k)。</li>
<li>本题之所以选择在双向队列的基础上加工出单调队列,是因为双向队列可以方便地在队首和队尾插入和删除元素。</li>
<li><p>注意类的写法、双向队列的<code>push_back</code>, <code>push_front</code>, <code>pop_back</code>, <code>pop_front</code>以及单调队列的<code>push</code>, <code>pop</code>等方法，不要写错或者混淆。</p>
<h3 id="347-前-K-个高频元素-3"><a href="#347-前-K-个高频元素-3" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3></li>
<li><p>本题的大致思路：用map来存储元素的值和出现次数，用一个小顶堆遍历map，最终获取出现次数最高的k个元素。<br><strong>map-&gt;priority_queue-&gt;vector</strong></p>
</li>
<li>本题的思路：用map的key存储元素的值，value存储元素出现的次数。定义一个小顶堆。遍历map，不断将map中的元素插入到小顶堆中，不断弹出小顶堆根节点处的元素，最后小顶堆中剩下的k个元素就是出现次数最高的k个元素。将这k个元素倒着插入结果数组中即可。</li>
<li>为什么使用小根堆：小跟堆根节点处的元素最小，每次弹出元素也是从根节点处弹出，因此用大小为k的小根堆遍历完map后，小根堆中的k个元素是出现次数最高的k个元素，较小的元素在遍历的过程中就已经被弹出了。</li>
<li>注意小顶堆的定义方式：在优先级队列的基础上，传入的参数分别为小顶堆中存储的元素类型，小顶堆的底层实现，自定义的compare类（用于实现小顶堆根节点是最小元素的特性）。</li>
<li>注意如何写compare类，关键在于重载运算符。</li>
<li>注意vector数组是可以定义大小的，定义方式为<code>vector&lt;int&gt; res(k)</code>，vector元素定义了大小之后，就能像普通数组那样用索引给元素赋值：<code>res[i]</code>，插入元素的push_back函数并不是必须的。</li>
<li>根据小根堆的特点，res数组需要倒着插入，即从下标<code>k - 1</code>处开始插入。</li>
<li>定义类是，要记得在类中的函数前加上public，否则无法正常调用类中的函数。</li>
<li>本算法的时间复杂度是O(nlogk)，好于对map全部排序的O(nlogn)，在n较大，k较小时性能提升尤为明显。</li>
</ol>
<h3 id="栈与队列总结-1"><a href="#栈与队列总结-1" class="headerlink" title="栈与队列总结"></a>栈与队列总结</h3><ol>
<li>栈和队列的理论基础：栈先入后出，队列先入先出</li>
<li>用两个栈实现队列，用一个队列实现栈</li>
<li>栈的应用：栈的应用相对较为简单且单一。栈特别适合处理对相邻字符需要做特殊判断的一些问题。比如相邻的括号匹配（20. 有效的括号）、相邻字符的消除（删除字符串中的所有相邻重复项）和后缀表达式中相邻数字的计算（逆波兰表达式求值）。</li>
<li>队列的应用：队列的应用更为复杂且多样，包括手动实现单调队列（239. 滑动窗口最大值）和手动实现大/小顶堆（优先级队列）347. 前k个高频元素）。对于队列的应用要多复习，这两题写起来都较为复杂。</li>
<li>单调队列不是一成不变的，而是不同场景不同写法。不要以为239. 滑动窗口最大值中的单调队列实现就是固定的写法。</li>
<li><p>栈里面的元素在内存中是连续分布的么？</p>
<p>这个问题有两个陷阱：</p>
<ul>
<li>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。</li>
<li>陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。</li>
</ul>
</li>
<li>拓展题：71. 简化路径</li>
<li>优先级队列就是大/小顶堆，名字虽为队列（因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列），但本质是完全二叉树。大顶堆（堆头是最大元素），小顶堆（堆头是最小元素）。从小到大排就是小顶堆，从大到小排就是大顶堆。大小顶堆和大小根堆是相同的。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/05/Day-11-Leetcode-20-1047-150/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/05/Day-11-Leetcode-20-1047-150/" class="post-title-link" itemprop="url">Day 11 | Leetcode 20, 1047, 150</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-05 16:14:50" itemprop="dateCreated datePublished" datetime="2024-02-05T16:14:50+00:00">2024-02-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-09 05:06:33" itemprop="dateModified" datetime="2024-02-09T05:06:33+00:00">2024-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（栈与队列）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html">20. 有效的括号</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">1047. 删除字符串中的所有相邻重复项</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html">150. 逆波兰表达式求值</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><ol>
<li>cpp中，将一个个字母存储在stack中，用<code>stack&lt;int&gt;</code>或者<code>stack&lt;char&gt;</code>都是一样的。若是<code>stack&lt;int&gt;</code>，则字符以ascii码的形式存储。</li>
<li><p>在Linux系统中，cd（change directory）命令用于更改当前工作目录。它确实可以借助栈的概念来理解路径的导航，尤其是处理相对路径时。</p>
<p>考虑命令<code>cd a/b/c/../../</code>，这里我们可以将目录路径视作一个栈的操作序列：</p>
<p><code>cd a</code>：进入目录a，相当于将a压入栈。<br><code>cd b</code>：进入子目录b，相当于将b压入栈中a的上面。<br><code>cd c</code>：进入子目录c，相当于将c压入栈中b的上面。<br>此时栈的状态为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>然后遇到<code>..</code>，这代表上一级目录，相当于从栈中弹出最上面的元素。第一个<code>..</code>将c弹出。<br>栈的状态更新为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>第二个<code>..</code>将b弹出。<br>最终栈的状态为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<p>所以，最后当前工作目录是a。<strong>在这个过程中，我们可以将每个目录视为栈中的一个元素，每进入一个新的子目录就相当于压入一个元素，而每次使用<code>..</code>就相当于弹出一个元素，回到上一级目录</strong>。这就是栈数据结构在文件系统路径解析中的一个应用。</p>
</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="20-有效的括号-1"><a href="#20-有效的括号-1" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p>不知道怎么做，直接看卡尔的讲解视频。</p>
<h3 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><p>本题应该是一道用栈解决的经典问题。以输入s = “abbaca”为例，定义一个栈，遍历字符串，遍历到第一个字符时，判断栈顶元素是否与之相同，是，则弹出栈顶元素，否，则插入该字符。对后面的字符也是这样处理的。根据这个思路，我独立写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == st.<span class="built_in">top</span>()) st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        string out;</span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            out += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(out.<span class="built_in">begin</span>(), out.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要特别注意：</p>
<ul>
<li>对栈做top操作时需要保证其非空，否则会报访问未知地址，导致程序非法访问内存的错误</li>
<li>将栈中的一个个元素弹出并插入到一个字符串中后，需要将字符串颠倒顺序，输出才是正确的顺序</li>
</ul>
<h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p>我看题后，暂时还没有解题思路。先看视频，了解本题的解题思路。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="20-有效的括号-2"><a href="#20-有效的括号-2" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p>本题是用栈来解决的经典题目。栈的应用：编译器做词法分析、linux系统的命令。</p>
<p>不匹配的场景共有三个：</p>
<ol>
<li>多出左括号</li>
<li>括号的类型不匹配</li>
<li>多出右括号</li>
</ol>
<p>各种不匹配的场景都可被归为以上三类。</p>
<p>如何用栈结构解决三类不匹配的情形？</p>
<p>对1，从字符串的左边向右边遍历，遇到左括号，就将一个对应的右括号加入到栈中。当遍历到字符串的右括号时，若栈顶元素和右括号相同，则弹出栈顶元素。如果字符串遍历完了，但栈不为空，栈中还剩余右括号，就说明字符串中的左括号多了，不匹配。</p>
<p>对2，从左往右遍历字符串，遇到左括号，就在栈中加入一个对应的右括号。遇到右括号，将其与栈顶的元素比较，若不相同，则说明不匹配。</p>
<p>对3，从左往右遍历字符串，遇到左括号，就在栈中加入一个对应的右括号。遇到右括号，将其与栈顶的元素比较，相同则弹出栈顶的元素。若字符串还没遍历完，栈就空了，说明字符串的前面没有左括号与后面的右括号对应，说明多出了右括号，也不匹配。</p>
<p>字符串遍历完之后，栈是空的，就说明全都匹配了。</p>
<p>剪枝：字符串长度为奇数，一定会有不匹配的括号，直接return false即可。</p>
<p>看了卡尔的视频后，我写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// stack&lt;int&gt;和stack&lt;char&gt;都可以</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝：字符串长度为奇数，一定不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="comment">// 不匹配的两种情况：多出右括号和括号类型不匹配</span></span><br><span class="line">            <span class="comment">// 两个判据不可颠倒，否则可能会出现栈为空但依然试图取栈顶元素的情况，编译器会报错</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || s[i] != st.<span class="built_in">top</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 栈不为空且栈的顶元素和s[i]相同，则弹出st的顶元素，两两抵消</span></span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不匹配的情况：多出左括号</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="1047-删除字符串中的所有相邻重复项-1"><a href="#1047-删除字符串中的所有相邻重复项-1" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><p>本题用栈解决非常简单，用其他数据结构比较复杂。本题和20. 有效的括号是同一类问题。本题的主要思路：相邻的字母相同，就做消除的动作。</p>
<p>栈用来存遍历过的元素，同时帮助我们完成消除的动作。<strong>本题可以用一个字符串来模拟栈的行为</strong>，这样在输出时就不需要再把栈转换为字符串了。<strong>用字符串模拟栈时，可以让字符串的尾部作为栈顶，字符串的头部作为栈底</strong>，这样字符串中字符的顺序就是正确的。</p>
<p>根据以上原理，我写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (out.<span class="built_in">empty</span>()) out.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == out.<span class="built_in">back</span>()) out.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">else</span> out.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以将上述代码写的更为精简（将两种需要push_back()的情况合并为一种）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 字符串为空或者字符串尾部的元素与s[i]不同时，直接在字符串的尾部插入s[i]</span></span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">empty</span>() || res.<span class="built_in">back</span>() != s[i]) res.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            <span class="comment">// 否则，意味着字符串尾部的元素和s[i]相同，则两两抵消，弹出字符串尾部的元素</span></span><br><span class="line">            <span class="keyword">else</span> res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>相比于我在初次尝试中空间复杂度为O(n)的做法，上面的做法空间复杂度是O(1)，因为返回值不计空间复杂度。</p>
<h3 id="150-逆波兰表达式求值-1"><a href="#150-逆波兰表达式求值-1" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p>什么是逆波兰表达式：是后缀表达式。后缀表达式是方便计算机来做运算的一种表达式。我们正常易于阅读的表达式是中缀表达式。例如(1+2)x(3+4)。画成二叉树的形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[x] --&gt; B[+];</span><br><span class="line">    A --&gt; C[+];</span><br><span class="line">    B --&gt; D[1];</span><br><span class="line">    B --&gt; E[2];</span><br><span class="line">    C --&gt; F[3];</span><br><span class="line">    C --&gt; G[4];</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>后缀表达式就是上述二叉树的后序遍历</strong>。<strong>后续遍历的顺序是左右中</strong>。因此后缀表达式是：12+34+x。二叉树的中序表达式是1+2x3+4。中序表达式若要得到正确的结果，需要加上括号。但后缀表达式我们不需要加任何括号，从头到尾遍历我们就可以计算出正确的结果。<strong>计算机只需顺序处理后缀表达式，即可得到计算结果，而不必担心括号优先级，这就是为什么说后缀表达式是方便计算机来做运算的一种表达式</strong>。</p>
<p>计算机如何顺序处理后缀表达式？用栈。遍历后缀表达式时，遇到数字就将数字加入栈中，遇到运算符就从栈中取出元素来做运算，再把运算结果加入栈中。以上面的后缀表达式为例，先将1和2加入栈中，遇到+，则弹出2和1，算2+1=3，将3加入栈中。再将3和4加入栈中，遇到+，则弹出4和3，算4+3=7，将7加入栈中。遇到x，栈中弹出7和3，算7x3=21。最后将21加入栈中。后缀表达式的结果就是栈中最后的元素。</p>
<p>总结：两个数字遇到一个操作符时，也做消除操作，将合成的数字加入到栈中。栈适合做相邻字符的消除操作。</p>
<p>根据以上原理，我参照代码随想录的代码写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&quot;+&quot;</span> || s[i] == <span class="string">&quot;-&quot;</span> || s[i] == <span class="string">&quot;*&quot;</span> || s[i] == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 注意采用long long类型</span></span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 注意是先num2再num1</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(num2 + num1);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">                <span class="keyword">else</span> st.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoll</span>(s[i])); <span class="comment">// stoi可以将字符串转换为int, stoll可以将字符串转换为long long</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>(); <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题关于数字的变量类型全部用int而不用long long，也可以通过评测。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="20-有效的括号-3"><a href="#20-有效的括号-3" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><ol>
<li>本题的思路：在字符串中遇到左括号就在栈中插入右括号，在字符串中遇到右括号则判断其能否与栈顶元素相消。</li>
<li>不匹配的三种情况：多出右括号、多出左括号、括号类型不匹配。</li>
<li>本题利用了栈的性质：后插入的元素先弹出，这与本题字符串中后出现的左括号必然有先出现的右括号与之匹配的题意相符。</li>
<li><code>st.empty()</code>和<code>s[i] != st.top()</code>这两个判据顺序不可颠倒，否则会出现栈为空但依然试图取栈顶元素的情况，编译器会报错。</li>
<li>本题可以做剪枝优化：字符串长度为奇数，则必然不匹配。</li>
<li>栈用<code>stack&lt;int&gt;</code>或者<code>stack&lt;char&gt;</code>都可以。前者就是将字符存储为ascii码。</li>
</ol>
<h3 id="1047-删除字符串中的所有相邻重复项-2"><a href="#1047-删除字符串中的所有相邻重复项-2" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><ol>
<li>栈特别适合处理对相邻字符需要做特殊判断的一些问题。比如相邻的括号匹配和消除。</li>
<li>字符串类型的变量也有empty, back, pop_back, push_back等函数。</li>
<li>本题可以用字符串来模拟栈，这样返回时不需要将栈转换回字符串，且可以通过让字符串头部对应栈底，字符串尾部对应栈顶的方式，来让输出的字符串不需要调整顺序（即不需要reverse）</li>
<li>本题需要考虑三种情况：栈为空/栈顶元素和字符串中元素相同/不相同</li>
<li>函数的递归调用需要用到栈</li>
<li>一个函数的返回值不会被计入这个函数的空间复杂度，额外的空间占用才会被计入空间复杂度</li>
</ol>
<h3 id="150-逆波兰表达式求值-2"><a href="#150-逆波兰表达式求值-2" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><ol>
<li>栈适合用于做相邻两个字符的消除操作。</li>
<li>逆波兰表达式即为二叉树的后缀表达式。</li>
<li>后缀表达式由二叉树的后序遍历（按左右中的顺序）得到。</li>
<li>本题思路：遇到数字则将其插入栈中，遇到运算符就弹出栈中的两个数字，计算并将计算结果插入栈中。</li>
<li>注意：运算时先num2（后弹出的数字，二叉树的左子节点）后num1（先弹出的数字，二叉树的右子节点）。</li>
<li>stoi可以将字符串转换为int，stoll可以将字符串转换为long long。</li>
<li>本题无需采用long long类型变量，用int类型变量就可以通过测评。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/04/Day-10-Leetcode-232-225/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/04/Day-10-Leetcode-232-225/" class="post-title-link" itemprop="url">Day 10 | Leetcode 232, 225</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-04 16:32:14" itemprop="dateCreated datePublished" datetime="2024-02-04T16:32:14+00:00">2024-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-05 16:12:30" itemprop="dateModified" datetime="2024-02-05T16:12:30+00:00">2024-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（栈与队列）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">栈与队列理论基础</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html">232.用栈实现队列</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html">225. 用队列实现栈</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="栈与队列理论基础"><a href="#栈与队列理论基础" class="headerlink" title="栈与队列理论基础"></a>栈与队列理论基础</h3><p>顾名思义，<strong>队列是先进先出，栈是先进后出</strong>（可以从顶部添加元素，也可以从顶部移除元素，但是不能从中间或底部添加或移除元素）。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235346563.png" alt="栈与队列理论1"></p>
<p>栈和队列是STL（C++标准库）里面的两个数据结构。STL有多个版本，其中有三个版本最为普遍。我们介绍的栈和队列是三个版本中的SGI STL里面的数据结构。知道版本才确定其底层实现。</p>
<p>栈：先进后出<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235434905.png" alt="栈与队列理论2"></p>
<p>栈提供push和pop等等接口，时间复杂度都是O(1)，所有元素必须符合先进后出规则（只能在顶部添加和移除元素），所以<strong>栈不提供走访功能，也不提供迭代器(iterator)</strong>。 不像是set 或者map提供迭代器iterator来遍历所有元素。</p>
<p><strong>我们可以用多种容器来实现栈的功能</strong>，栈的底层实现可以是vector，deque（双端队列），list（双向链表）都是可以的， 主要就是数组和链表的底层实现。</p>
<p>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构（deque是容器）。deque是一个双向队列，<strong>只要封住一段，只开通另一端就可以实现栈的逻辑了</strong>。<strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的</strong>。也可以指定vector为栈的底层实现，初始化语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数int：指定了栈中元素的类型</span></span><br><span class="line"><span class="comment">// 第二个参数std::vector&lt;int&gt;：指定了底层容器的类型及其元素类型。即使用一个整型向量来存储栈中的元素。</span></span><br><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure>
<p>通过允许指定底层容器，<code>std::stack</code>提供了灵活性，可以根据不同的性能需求或使用场景来选择最合适的容器类型。例如，<code>std::vector</code>提供了随机访问的能力，但是在容器前端添加或删除元素可能较慢，而<code>std::deque</code>在容器的前端和后端添加或删除元素都较快，但不支持快速随机访问。选择哪种底层容器取决于你的具体需求。</p>
<p>队列是先进先出的数据结构，<strong>同样不允许有遍历行为，不提供迭代器,  SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p>
<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>
<p>STL队列和栈都不被归类为容器，而被归类为container adapter（容器适配器）。<strong>因为可以用不同的容器来实现栈和队列的功能，因此栈和队列不对应于某个特定的容器</strong>。</p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p>yxc讲过的应该是用数组来实现栈和队列，并没有见过怎么用栈来实现队列。直接看卡尔的讲解。</p>
<h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h3><p>我想了想，没想出什么好办法，听卡尔讲吧。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="232-用栈实现队列-1"><a href="#232-用栈实现队列-1" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p>不涉及具体的算法，考察对栈和队列的基本操作。向队列中插入元素123，则队列吐出元素的顺序是123。向栈中插入元素123，则栈吐出元素的顺序是321。若想用栈实现队列，就需要两个栈，一个栈用于存储元素，<strong>另一个栈用于改变第一个栈中元素出栈的顺序</strong>。第一个栈吐出元素的顺序是321，将它们依次插入第二个栈中，则第二个栈吐出元素的顺序是123。第一个栈被称为入栈，第二个栈被称为出栈。</p>
<p><img src="D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/tstmp_20240205061240.gif" alt="tstmp_20240205061240"></p>
<p>入栈中不要有滞留元素的行为，<strong>一旦需要弹出元素，就把入栈中的所有元素全部放入出栈中</strong>，让出栈实现元素的弹出。如果没有把入栈中的所有元素全部放入出栈，则出栈中弹出元素的顺序会与队列弹出元素的顺序不同。</p>
<p>本题pop函数的实现需要特别注意。若出栈为空，则将入栈中的所有元素加入到出栈中。peek和pop方法大部分代码都是重复的，可以在peek中直接调用pop方法：<code>result = this-&gt;pop();</code>。此时第一个元素被获取的同时也被弹出了，因此需要将其插入回去：<code>stackOut.push(result)</code>（peek方法只需要查询元素的数值，不需要像pop函数那样弹出元素）。参考视频讲解中的伪代码，我写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; inStack; <span class="comment">// 入栈</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; outStack; <span class="comment">// 出栈</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向入栈中插入元素即可</span></span><br><span class="line">        inStack.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若出栈为空，则将入栈中的所有元素全部加入到出栈中</span></span><br><span class="line">        <span class="comment">// 如果没有把入栈中的所有元素加入到出栈中，则弹出元素的顺序会发生错误</span></span><br><span class="line">        <span class="comment">// 若出栈不为空，则跳过if判断部分，直接执行本函数最后三行代码</span></span><br><span class="line">        <span class="keyword">if</span> (outStack.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (inStack.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp = inStack.<span class="built_in">top</span>();</span><br><span class="line">                inStack.<span class="built_in">pop</span>();</span><br><span class="line">                outStack.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回出栈顶部的元素并将该元素弹出</span></span><br><span class="line">        <span class="type">int</span> res = outStack.<span class="built_in">top</span>();</span><br><span class="line">        outStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 复用上面实现的pop函数</span></span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 由于pop函数弹出了出栈顶部的元素，peek函数只需要查询出栈顶部的元素，不需要弹出</span></span><br><span class="line">        <span class="comment">// 因此将该元素插入回出栈中</span></span><br><span class="line">        outStack.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 入栈和出栈同时为空时，队列才为空</span></span><br><span class="line">        <span class="comment">// 若只有入栈为空，则出栈中依然有元素没有弹出，说明队列还可以弹出元素，不为空</span></span><br><span class="line">        <span class="comment">// 若只有出栈为空，则入栈中依然有元素可以加入出栈中，之后出栈还可以继续弹出元素，故队列也不为空</span></span><br><span class="line">        <span class="keyword">if</span> (inStack.<span class="built_in">empty</span>() &amp;&amp; outStack.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="225-用队列实现栈-1"><a href="#225-用队列实现栈-1" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h3><p>两个栈才能实现一个队列。<strong>虽然两个队列可以模拟栈，但重点讲一个队列模拟栈的进元素和出元素</strong>。</p>
<p>用两个队列模拟栈：假设栈中先后插入元素123，则栈弹出元素的顺序为321。那么我们可以在队列1中先插入123，然后将1和2放入队列2中，然后从队列1中弹出元素3。接着若想让队列1弹出元素2，则将队列2中的元素2放入队列1中即可。详细讲解见代码随想录网站。</p>
<p>用一个队列模拟栈：在队列中先加入123，然后取出元素1，加入队列中；再取出元素2，加入队列中，此时队列弹出的元素就是3。<strong>推广：队列中有size个元素，先弹出(size - 1)个元素，再将它们加入队列中，再弹出队列中剩余的最后一个元素即可</strong>。</p>
<p>根据上述原理，我独立写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">       q.<span class="built_in">push</span>(x); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = q.<span class="built_in">size</span>(); <span class="comment">// 队列中有size个元素</span></span><br><span class="line">        <span class="comment">// 循环(size - 1)次</span></span><br><span class="line">        <span class="comment">// 先弹出队首的元素，再将其加入到队尾中</span></span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(tmp); </span><br><span class="line">            count -- ;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 弹出队首的元素，即为最后插入的元素</span></span><br><span class="line">        <span class="type">int</span> res = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复用pop函数，但是由于本函数只需要实现查询元素的功能，要记得将弹出的元素插入回去</span></span><br><span class="line">    <span class="comment">// 也可直接return q.back()。因为栈顶的元素就是队列尾部的元素（队列中，从front弹出元素，从back插入元素）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 队列为空，则栈也为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>更简洁的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        size -- ;</span><br><span class="line">        <span class="keyword">while</span> (size -- )</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用</strong>，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。据此原理，我写下了如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将除去队尾的元素的其他元素全部加入到q2中</span></span><br><span class="line">        <span class="type">int</span> size = q1.<span class="built_in">size</span>();</span><br><span class="line">        size -- ;</span><br><span class="line">        <span class="keyword">while</span> (size -- )</span><br><span class="line">        &#123;</span><br><span class="line">            q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 收获答案</span></span><br><span class="line">        <span class="type">int</span> res = q1.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// 将q2赋给q1</span></span><br><span class="line">        q1 = q2;</span><br><span class="line">        <span class="comment">// 清空q2</span></span><br><span class="line">        <span class="keyword">while</span> (q2.<span class="built_in">size</span>()) q2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>() &amp;&amp; q2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="232-用栈实现队列-2"><a href="#232-用栈实现队列-2" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><ol>
<li>注意stack内置的pop函数不会返回被移除的元素的值。</li>
<li>实现pop函数时：出栈为空，则插入入栈中的所有元素；出栈不为空，则直接弹出出栈中的首元素。</li>
<li>一旦需要弹出元素，就把入栈中的所有元素全部放入出栈中，否则出栈中弹出元素的顺序会与队列弹出元素的顺序不同。</li>
<li>入栈和出栈都为空时，模拟的队列才为空。</li>
<li>取出栈顶元素再弹出栈顶元素的实现，都是先<code>int tmp = stack.top()</code>，再<code>stack.pop()</code>。</li>
</ol>
<h3 id="225-用队列实现栈-2"><a href="#225-用队列实现栈-2" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h3><ol>
<li>本题的关键在于如何弹出元素。</li>
<li>队列中，从front弹出元素，从back插入元素。取出队列尾部的元素：<code>queue.back()</code>，取出队列头部的元素：<code>queue.front()</code>。</li>
<li>掌握一个队列实现栈的方法即可，两个队列实现栈更加复杂。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/03/Day-9-Leetcode-28-459-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/03/Day-9-Leetcode-28-459-summary/" class="post-title-link" itemprop="url">Day 9 | Leetcode 28, 459, summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-03 07:51:26" itemprop="dateCreated datePublished" datetime="2024-02-03T07:51:26+00:00">2024-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-04 16:30:28" itemprop="dateModified" datetime="2024-02-04T16:30:28+00:00">2024-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（字符串）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">28. 实现 strStr()</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html">459.重复的子字符串</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html">字符串：总结篇</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93.html">双指针总结篇</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="KMP算法理论"><a href="#KMP算法理论" class="headerlink" title="KMP算法理论"></a>KMP算法理论</h3><h4 id="KMP与解决的问题"><a href="#KMP与解决的问题" class="headerlink" title="KMP与解决的问题"></a>KMP与解决的问题</h4><p>KMP：发明本算法的三位学者的英文名首字母</p>
<p>应用：字符串匹配问题</p>
<p>经典例子：</p>
<ul>
<li><p>给出文本串: aabaabaaf</p>
</li>
<li><p>给出模式串: aabaaf<br>求在文本串中是否出现过模式串</p>
</li>
</ul>
<h4 id="暴力方法与KMP"><a href="#暴力方法与KMP" class="headerlink" title="暴力方法与KMP"></a>暴力方法与KMP</h4><p>暴力解法：两重for循环，先遍历文本串，再遍历模式串，挨个匹配。从文本串的首位开始，若模式串不匹配文本串，则将模式串后移一位，直到匹配上。时间复杂度O(m * n)，m和n分别是文本串和模式串的长度。</p>
<p>KMP算法：跳到之前已匹配的地方，继续匹配。</p>
<h4 id="前缀表的由来"><a href="#前缀表的由来" class="headerlink" title="前缀表的由来"></a>前缀表的由来</h4><p>KMP算法如何知道我们之前已匹配过哪些，且跳到已匹配的内容后面继续匹配？</p>
<p>前缀表有什么特性，可以让我们找到之前已匹配过的内容？</p>
<p>在f处不匹配，找到f前面子串的后缀是aa，找到与该后缀相等的前缀的后面开始匹配。故我们要求一个字符串中的最长相等前后缀，重新匹配时跳到最长前缀之后开始匹配。</p>
<h4 id="前缀与后缀"><a href="#前缀与后缀" class="headerlink" title="前缀与后缀"></a>前缀与后缀</h4><p>前缀：包含首字母，不包含尾字母的所有子串。</p>
<p>后缀：包含尾字母，不包含首字母的所有子串。</p>
<h4 id="最长相等前后缀"><a href="#最长相等前后缀" class="headerlink" title="最长相等前后缀"></a>最长相等前后缀</h4><p>最长相等的前缀和后缀的长度。以模式串aabaaf为例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>子串</th>
<th>前缀</th>
<th>后缀</th>
<th>最长相等的前缀和后缀的长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>无</td>
<td>无</td>
<td>0</td>
</tr>
<tr>
<td>aa</td>
<td>a</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>aab</td>
<td>a, aa</td>
<td>b, ab</td>
<td>0</td>
</tr>
<tr>
<td>aaba</td>
<td>a, aa, aab</td>
<td>a, ba, aba</td>
<td>1</td>
</tr>
<tr>
<td>aabaa</td>
<td>a, aa, aab, aaba</td>
<td>a, aa, baa, abaa</td>
<td>2</td>
</tr>
<tr>
<td>aabaaf</td>
<td>a, aa, aab, aaba, aabaa</td>
<td>f, af, aaf, baaf, abaaf</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>得到模式串的前缀表：010120。</p>
<h4 id="使用前缀表的匹配过程"><a href="#使用前缀表的匹配过程" class="headerlink" title="使用前缀表的匹配过程"></a>使用前缀表的匹配过程</h4><p>模式串 aabaaf<br>前缀表 010120<br>发现f不匹配，要找f前的最长相等前后缀，由前缀表得到最长相等前后缀为2。2意味着有一个后缀aa，前面也有一个与之相等的前缀aa。在后缀aa的后面不匹配了，就要从与后缀相等的前缀的后面继续开始匹配。最长相等前后缀为2，故从<code>s[2] = &#39;b&#39;</code>处开始重新匹配。</p>
<h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><p>next/prefix都可以用来表示前缀表。在遇到不匹配的地方，next数组告诉我们要回退到哪里。前缀表为010120，对其的处理包括：右移/统一减一。不处理前缀表，就将其作为next数组，依然可以完成KMP算法。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>KMP算法-&gt;能解决哪些问题-&gt;为什么KMP算法匹配失败后可以跳到某个位置-&gt;前缀表-&gt;前缀表的特性及如何求取前缀表-&gt;用前缀表完成一次匹配的操作-&gt;实现KMP算法时，有时对前缀表统一减一，有时右移，这不设计KMP算法原理性的东西，只是实现上方法不同而已。</p>
<h3 id="KMP算法的代码实现"><a href="#KMP算法的代码实现" class="headerlink" title="KMP算法的代码实现"></a>KMP算法的代码实现</h3><h4 id="next数组不同的实现方式"><a href="#next数组不同的实现方式" class="headerlink" title="next数组不同的实现方式"></a>next数组不同的实现方式</h4><p>模式串：aabaaf</p>
<p>文本串：aabaabaaf</p>
<p>前缀表：010120，用next数组表示。</p>
<p>如何求next数组？</p>
<ul>
<li>有人会把前缀表右移，第一位放上-1，得到-101012，作为next数组。</li>
<li>有人会把前缀表整体-1，得到-10-101-1，作为next数组。</li>
<li>有人会直接拿前缀表做Next数组。<br>上述实现方式都可以，但具体处理逻辑会略有差别。</li>
</ul>
<p>模式串与文本串在模式串的最后一位f处发生了冲突，<strong>看f的前一位的前缀表的值是多少</strong>，发现是2，于是跳转到下标为2的位置，即b。如果next数组是前缀表右移得到，<strong>就直接比较f对应的next数组的值</strong>，发现是2，于是也跳转到b的位置。若next数组是前缀表-1得到，那么就把f的前一位的next数组的值+1，依然跳转到b的位置。</p>
<p>next数组的核心：遇到冲突向前回退。<strong>本节我们就拿前缀表作为next数组</strong>。</p>
<h4 id="求Next数组的具体代码"><a href="#求Next数组的具体代码" class="headerlink" title="求Next数组的具体代码"></a>求Next数组的具体代码</h4><p>共4步：</p>
<ol>
<li>初始化</li>
<li>处理前后缀不相同的情况</li>
<li>处理前后缀相同的情况</li>
<li>更新next数组的值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的参数：next数组，我们需要对其进行赋值，模式串s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(vector&lt;<span class="type">int</span>&gt; next, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 指针i：指向后缀末尾位置</span></span><br><span class="line">    <span class="comment">// 指针j：指向前缀末尾位置，还代表着i之前（包括i）的子串的最长相等前后缀的长度</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 前缀从0开始</span></span><br><span class="line">    <span class="type">int</span> next[N]; </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// next数组初始位置为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较前后缀所对应的字符是否相等，故i从1开始，这样i和j才能进行比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理前后缀末尾不相同的情况</span></span><br><span class="line">        <span class="comment">// 因为在一次循环中，i相当于是固定不动的，所以此时j回退</span></span><br><span class="line">        <span class="comment">// j回退到next[j - 1]指向的位置，即遇见冲突，就看next数组（即前缀表）的前一位</span></span><br><span class="line">        <span class="comment">// 不止回退一步，而要连续回退，不能写if，而要写while</span></span><br><span class="line">        <span class="keyword">while</span> ( j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = next[j - <span class="number">1</span>]; <span class="comment">// 因为要求j - 1 &gt;= 0，因此要求j &gt; 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理前后缀相同的情况</span></span><br><span class="line">        <span class="comment">// j代表着i之前（包括i）的子串的最长相等前后缀的长度</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) j ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新next数组，在其中存储i之前（包括i）的子串的最长相等前后缀的长度</span></span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模拟运行过程"><a href="#模拟运行过程" class="headerlink" title="模拟运行过程"></a>模拟运行过程</h4><p>当j指向s[1]，i指向s[2]时，前后缀不匹配，此时next[j - 1] = next[0] = 0，j回退到s[0]，再次比较前后缀是否匹配，发现仍不相同，此时j无法继续回退，我们就更新next数组的值，next[2] = 0，这就代表i = 2之前包括i的子串的最长相等前后缀为0，这与表格中的结果相同。此时i后移一位，指向s[3]，有s[3] == s[0]，j ++，j = 1，next[3] = 1，说明aaba的最长相等前后缀长度是1，这与表格中的结果相同。进入下一轮循环，i = 4，同理。最终用getNext函数完成了对next数组的求值。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>用上述函数，求得了next数组，即前缀表。</p>
<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p>求next数组的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的参数：next数组，我们需要对其进行赋值，模式串s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(vector&lt;<span class="type">int</span>&gt; next, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 前缀从0开始</span></span><br><span class="line">    <span class="type">int</span> next[N]; </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// next数组初始位置为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较前后缀所对应的字符是否相等，故i从1开始，这样i和j才能进行比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = next[j - <span class="number">1</span>]; <span class="comment">// 因为要求j - 1 &gt;= 0，因此要求j &gt; 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) j ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新next数组，在其中存储i之前（包括i）的子串的最长相等前后缀的长度</span></span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用next数组做匹配的代码（文本串s，模式串t）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 因为next数组里记录的起始位置为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// i从0开始，遍历文本串</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != t[j]) &#123; <span class="comment">// 不匹配, j - 1 &gt;= 0 =&gt; j &gt; 0</span></span><br><span class="line">        j = next[j - <span class="number">1</span>]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == t[j]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">        j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了</span></span><br><span class="line">    <span class="keyword">if</span> (j == t.<span class="built_in">size</span>()) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">        <span class="comment">// 返回当前在文本串匹配模式串的位置i-模式串的长度 + 1，就是文本串字符串中出现模式串的第一个位置（位置从0开始）</span></span><br><span class="line">        <span class="keyword">return</span> (i - t.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况，模式串长度为0，则返回0，本处是一个易错点</span></span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义next数组</span></span><br><span class="line">        <span class="type">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="comment">// 填充next数组</span></span><br><span class="line">        <span class="built_in">getNext</span>(next, needle);</span><br><span class="line">        <span class="comment">// 用next数组做匹配</span></span><br><span class="line">        <span class="comment">// j指向模式串，i指向文本串</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 模式串匹配不上文本串，则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>n为文本串长度，m为模式串长度</p>
<ul>
<li>时间复杂度: 生成next数组，时间复杂度是O(m)；根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)。所以总共的时间复杂度为O(n + m)</li>
<li>空间复杂度: 开辟空间用于存储next数组，即模式串的前缀表，因此是O(m)</li>
</ul>
<h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>枚举所有的子串，看能否构成字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 子串结束位置</span><br><span class="line">	<span class="keyword">for</span> 子串与主串比较</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n^2)。目标子串的开始位置必然是主串最前面的元素，因此只需要枚举子串的结束位置即可。</p>
<h4 id="移动匹配"><a href="#移动匹配" class="headerlink" title="移动匹配"></a>移动匹配</h4><p>设一个可由重复的子串构成的字符串为s，那么两个s拼接起来，前一个s的后半部分和后一个s的前半部分又可以构成一个新的字符串s。s由重复子串构成的判据：两个s相加起来，若其中出现了s，那么s就是由重复子串构成的。</p>
<p>注意：在(s + s)中去搜索s时，一定要把(s + s)的首元素和尾元素删去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ss = s + s;</span><br><span class="line">        ss.<span class="built_in">erase</span>(ss.<span class="built_in">begin</span>());</span><br><span class="line">        ss.<span class="built_in">erase</span>(ss.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// string::npos 是 std::string 类型的一个静态成员常量，表示字符串中不存在匹配的位置。在 find() 函数中，如果没有找到匹配的子串，则返回 string::npos。这个值通常是一个很大的无符号整数，表示找不到匹配的位置。</span></span><br><span class="line">        <span class="keyword">if</span> (ss.<span class="built_in">find</span>(s) != string::npos)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>find函数的实现其实就是28. 实现strStr()。若用KMP实现find函数，那么时间复杂度是O(m + n)，find函数的其他实现方法时间复杂度大抵也是O(m + n)。</p>
<h4 id="KMP解法"><a href="#KMP解法" class="headerlink" title="KMP解法"></a>KMP解法</h4><p>KMP算法的应用场景：模式串是否在文本串中出现过，即上面的find函数的一种实现方式。</p>
<p>前缀：不包含尾字母，一定包含首字母的所有子串。<br>后缀：包含尾字母，不包含首字母的所有子串。</p>
<p>结论：若s由重复子串组成，那么它的最小重复单位就是它的最长相等前后缀不包含的那个子串。后缀不包含和前缀不包含的部分是相同的，都是最小重复子串。</p>
<p>举例：abababab，最长相等前缀是ababab，最长相等后缀是ababab，剩余的部分ab即为最小重复子串。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728205249.png" alt="图三"></p>
<p>推导：设原字符串是s，标出其下标；设最长相等前缀是t，最长相等后缀是f，也分别标出下标。利用最长相等前缀和最长相等后缀的下标之间的对应关系和最长相等前后缀和原字符串下标之间的对应关系推导即可。</p>
<p>实现：设s存在最小重复单位，len为s的长度，则<code>next[len - 1]</code>为s的最长相等前后缀的长度，最小重复单位的长度为：<code>len - next[len - 1]</code>，若该长度能被原字符串的长度整除：<code>len % (len - next[len - 1]) == 0</code>，那么return true。有如下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求next数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span> <span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 处理前后缀不相同的情况</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理前后缀相同的情况</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新next数组</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span> <span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next, s);</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 核心代码</span></span><br><span class="line">        <span class="keyword">if</span> (next[len - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; len % (len - (next[len - <span class="number">1</span>] )) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="28-实现-strStr-1"><a href="#28-实现-strStr-1" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p>直接听卡尔讲，尝试去理解，不要求独立写出代码。</p>
<h3 id="459-重复的子字符串-1"><a href="#459-重复的子字符串-1" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><p>直接听卡尔讲，尝试去理解，不要求独立写出代码。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="28-实现-strStr-2"><a href="#28-实现-strStr-2" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p>因为KMP算法很难，大家别奢求一次就把kmp全理解了，大家刚学KMP一定会有各种各样的疑问，先留着，别期望立刻啃明白，第一遍了解大概思路，二刷的时候，再看KMP会懂很多。或者说大家可以放弃一刷可以不看KMP，今天来回顾一下之前的算法题目就可以。</p>
<p>因为大家算法能力还没到，细扣很难的算法，会把自己绕进去，就算别人给解释，只会激发出更多的问题和疑惑。所以大家先了解大体过程，知道这么回事， 等自己有算法基础和思维了，在看多看几遍视频，慢慢就理解了。</p>
<h3 id="459-重复的子字符串-2"><a href="#459-重复的子字符串-2" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><p>本题算是KMP算法的一个应用，不过对KMP了解不够熟练的话，理解本题就难很多。 </p>
<p>建议是 <strong>KMP和本题，一刷的时候 ，可以适当放过，了解怎么回事就行，二刷的时候再来硬啃</strong></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="28-实现-strStr-3"><a href="#28-实现-strStr-3" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><ol>
<li>我觉得KMP算法很想一种特殊的双指针算法。一个指针i用于遍历文本串，另一个指针j用于根据next数组的指引在模式串中移动。这种双指针算法可以把时间复杂度从暴力算法的O(n * m)优化为O(n + m)。</li>
<li>代码分为独立的两部分，第一部分是求next数组（即前缀表），第二部分是同时在两个字符串中移动指针并使用next数组。</li>
<li>当模式串为空时，应当返回0。因为空字符串被认为是任何字符串的子串，所以文本串中最开始与模式串匹配的字符的索引就是0。如果文本串中不存在与之匹配的模式串，则返回 -1。</li>
</ol>
<h3 id="459-重复的子字符串-3"><a href="#459-重复的子字符串-3" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><ol>
<li>本题有两种解法：移动匹配和KMP解法。如果忘记了KMP算法的next数组怎么写，可以使用移动匹配方法（最难写的KMP部分可以用find函数来代劳）。</li>
<li>注意string中find函数的用法：在 find() 函数中，如果没有找到匹配的子串，则返回 string::npos。</li>
<li>本题的KMP解法的关键在于结论：若s由重复子串组成，那么它的最小重复单位就是它的最长相等前后缀不包含的那个子串。</li>
</ol>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><h3 id="字符串总结"><a href="#字符串总结" class="headerlink" title="字符串总结"></a>字符串总结</h3><p>常见题型和常用方法：</p>
<ol>
<li>花式反转字符串（整体&amp;局部反转，有时还要搭配双指针算法删除空格）</li>
<li>后续处理字符串</li>
<li>KMP算法（匹配模式串和文本串）</li>
<li>移动匹配（核心也是KMP算法，只不过核心由库函数find实现）</li>
</ol>
<p>小知识：</p>
<ol>
<li>substr，split，reverse, erase这四个库函数的时间复杂度都是O(n)，在循环中使用会使得程序的时间复杂度达到O(n^2)。此时需要双指针算法等进行优化。</li>
<li>字符串本质为字符数组，数据结构基本等用于普通数组，因此普通数组中常用的双指针算法也常用于字符串中。</li>
</ol>
<h3 id="双指针总结"><a href="#双指针总结" class="headerlink" title="双指针总结"></a>双指针总结</h3><p>双指针应用于：</p>
<ol>
<li>数组：移除元素</li>
<li>字符串：反转字符串、替换数字、翻转字符串里的单词</li>
<li>链表：反转链表、环形链表II</li>
<li><p>哈希表章节：三数之和、四数之和，两数之和若要求返回两数的值而非索引，也可以用双指针做，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 存储结果</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 先排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] + nums[right] &gt; target) right -- ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) left ++ ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;nums[left], nums[right]&#125;); <span class="comment">// 收获答案</span></span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left ++ ;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right -- ;</span><br><span class="line">            <span class="comment">// 寻找新的答案</span></span><br><span class="line">            left ++ ;</span><br><span class="line">            right -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码本质上就是三数之和、四数之和的一部分（for循环中的while循环）。相比于两数之和的哈希写法，新增了值去重的功能。</p>
<p>双指针的题目中，以三数、四数之和以及反转链表最容易写错，一定要多复习。三数、四数之和的易错点在于剪枝、去重和求四数之和时的int类型变量的溢出。反转链表的易错点在于搞错了tmp, cur-&gt;next, prev和cur更新的先后顺序。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/01/Day-8-Leetcode-344-541-k54-151-k55/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/01/Day-8-Leetcode-344-541-k54-151-k55/" class="post-title-link" itemprop="url">Day 8 | Leetcode 344, 541, k54, 151, k55</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-01 07:17:56" itemprop="dateCreated datePublished" datetime="2024-02-01T07:17:56+00:00">2024-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-03 07:49:42" itemprop="dateModified" datetime="2024-02-03T07:49:42+00:00">2024-02-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（字符串）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">344.反转字符串</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">541. 反转字符串II</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/kama54.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html">卡码网：54.替换数字</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">151.翻转字符串里的单词</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/kama55.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html">卡码网：55.右旋转字符串</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p>一般来说，编程语言自己实现的库函数都是左闭右开的，因此<code>reverse(s, i, i + k)</code>表示的是反转字符串s的第i位到第i + k位，不包含第i + k位。</p>
<h3 id="卡码网：54-替换数字"><a href="#卡码网：54-替换数字" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><ol>
<li>注意，cpp中比较大小不能写作<code>48 &lt;= s[i] &lt;= 57</code>，而是要写作<code>s[i] &gt;= 48 &amp;&amp; s[i] &lt;= 57</code>。表达式<code>48 &lt;= s[i] &lt;= 57</code>实际上会先计算<code>48 &lt;= s[i]</code>，这个表达式的结果是一个布尔值<code>true</code>或<code>false</code>，在C++中，这个布尔值会被隐式转换为整数，<code>true</code>转换为<code>1</code>，<code>false</code>转换为<code>0</code>。然后，该整数（<code>0</code>或<code>1</code>）会与<code>57</code>进行比较，所以条件几乎总是为真（除非<code>s[i]</code>是字符<code>&#39;0&#39;</code>）。</li>
<li>扩容字符串的函数为<code>resize</code>函数。</li>
<li>cpp中是可以不遍历字符串中的每个字符，就直接cout输出整个字符串的。</li>
<li>字符串和数组的区别（摘自代码随想录）：<br>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，接下来我来说一说C/C++中的字符串。<br>在C语言中，把一个字符串存入一个数组时，也把结束符 ‘\0’存入数组，并以此作为该字符串是否结束的标志。<br>在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，<strong>就不用’\0’来判断是否结束</strong>。<br>那么vector&lt; char &gt; 和 string 又有什么区别呢？<br>其实在基本操作上没有区别，但是<strong>string提供更多的字符串处理的相关接口</strong>，例如string 重载了+，而vector却没有。所以想处理字符串，我们还是会定义一个string类型。</li>
<li>若要求某个字符在0-9之间，既可以写<code>s[i] &gt;= 48 &amp;&amp; s[i] &lt;= 57</code>（’0’的ascii码是48，’1’的ascii码是57），也可以写<code>s[i] &gt;= &#39;0&#39; &amp;&amp; s[i] &lt;= &#39;9&#39;</code>。</li>
</ol>
<h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><ol>
<li>erase函数的时间复杂度是O(n)</li>
<li>本题可以用split函数来从字符串中分割出单词，但那样就失去了意义</li>
<li>若给一个函数传入的参数加上引用<code>&amp;</code>，那么在函数中对这个参数进行了修改，调用该函数后该参数也会被修改。</li>
</ol>
<h3 id="卡码网：55-右旋转字符串"><a href="#卡码网：55-右旋转字符串" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h3><ol>
<li>注意：若在ACM模式中调用<code>reverse</code>函数，必须<code>#include &lt;algorithm&gt;</code>，否则会报错。但若调用<code>swap</code>函数，不需要引用任何头文件，直接使用即可。</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>先尝试用reverse函数秒杀，顺便复习reverse函数的用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>reverse函数相当于把字符串反转以后，将新的字符串存入了旧的字符串中。</p>
<p>我曾经做过反转链表的题，猜测用双指针可以解决这道题。写下了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = s.<span class="built_in">size</span>() - <span class="number">1</span>; l &lt; r; l ++ , r -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// swap(s[l], s[r]);</span></span><br><span class="line">            <span class="type">int</span> tmp = s[l];</span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>直接用swap函数或者手写swap函数都是可以的。<code>l &lt; r</code>或者<code>l &lt;= r</code>都可以。因为字符串中字符的个数为奇数时，中间那个字符交换不交换都一样；字符个数为偶数时，交换最后两个成对的字符即可。</p>
<h3 id="541-反转字符串II-1"><a href="#541-反转字符串II-1" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p>拿到这道题，我的第一想法是分类讨论。设字符串的长度是<code>len</code>。若<code>len &lt; k</code>，则全部反转；若<code>k &lt;= len &lt; 2k</code>，则反转前k个字母；若<code>len &gt;= 2k</code>，则按照题意反转。本题在反转的逻辑上没有困难，但问题在于如何分割出需要反转的子字符串。我没想出来什么好办法，写的逻辑太复杂又容易出错。</p>
<h3 id="卡码网：54-替换数字-1"><a href="#卡码网：54-替换数字-1" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><p>我先输入字符串s，然后定义每个元素由char类型变量组成的vector。遍历字符串s，若其中的某个字符的ascii码在48-57之间，说明该字符是数字0-9，那么向vector中依次插入number这6个字符。其他情况下，向vector中插入原始字符即可。据此思路写下以下的代码，可以通过评测。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="number">48</span> &amp;&amp; s[i] &lt;= <span class="number">57</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            out.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; out.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        cout &lt;&lt; out[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="151-翻转字符串里的单词-1"><a href="#151-翻转字符串里的单词-1" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p>这道题yxc应该讲过,要么通过流的方式读入为一个个单词，样例代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span> <span class="comment">// 引入 stringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line); <span class="comment">// 使用 getline 读取一整行</span></span><br><span class="line"></span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(line)</span></span>; <span class="comment">// 使用 stringstream 来分割字符串</span></span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; word) &#123; <span class="comment">// 从 stringstream 中读取单词，直到结束</span></span><br><span class="line">        cout &lt;&lt; word &lt;&lt; endl; <span class="comment">// 输出单个单词</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>要么通过双指针算法找出一个个单词并存储之。然后再将一个个单词逆序拼接为字符串并输出。我先尝试后一种方法。但没有做出来。</p>
<h3 id="卡码网：55-右旋转字符串-1"><a href="#卡码网：55-右旋转字符串-1" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h3><p>本题我下意识地使用substr来写，得到如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    string s1 = s.<span class="built_in">substr</span>(s.<span class="built_in">size</span>() - k, s.<span class="built_in">size</span>()); <span class="comment">// 后面k个字符</span></span><br><span class="line">    string s2 = s.<span class="built_in">substr</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - k); <span class="comment">// 字符串在后面k个字符前的字符</span></span><br><span class="line">    cout &lt;&lt; s1 + s2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>向substr中传入的区间是左闭右开的。</p>
<p>若不借助库函数，我还有一个想法。先拿一个字符串保存输入字符串的后面k个字符。然后在输入字符串的基础上，从尾部倒着插入前面的那些字符，最后再将另一个字符串保存的原字符串的后面k个字符插到新字符串的前面去。其实倒着插入和顺着插入也没什么区别。</p>
<p>我还想到一种做法。受到151. 翻转字符串里的单词启发，首先反转整个字符串，然后反转字符串的前k位，最后反转字符串的后(n - k)位。由此写出了两个版本的代码，第一版是直接调用reverse函数，第二版是手动实现reverse函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + k);</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + k, s.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动实现reverse函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(string &amp;s, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = i, b = j; a &lt; b; a ++ , b -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = s[a];</span><br><span class="line">        s[a] = s[b];</span><br><span class="line">        s[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverseString</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverseString</span>(s, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverseString</span>(s, k, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="344-反转字符串-1"><a href="#344-反转字符串-1" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>在算法的思路上，字符串和数组非常类似。本题应用双指针法即可：首尾交换，再次一级交换，以此类推。因此首尾各有一个指针，两指针交换，然后两指针同时向中间移动。若库函数直接把题目解决了，就不要用库函数。若库函数是题目的一部分，且我们知道库函数的大体实现逻辑和时间复杂度，那就可以用。代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>() / <span class="number">2</span>; i ++ , j -- )</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>swap函数有两种方法，一种是常见的交换数值，另一种是位运算，可参见代码随想录。</p>
<h3 id="541-反转字符串II-2"><a href="#541-反转字符串II-2" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p>模拟题，模拟复杂的规则下，如何反转字符串。题意：每2k段的前k个字符进行反转，尾部如果剩下的字符超过长度超过k，则反转k个字符，剩下的不动。尾部如果剩下的字符长度小于k，则全部反转。本题的代码可以很简洁。</p>
<p>本题每次取2k段，因此按照2k来遍历：<code>for (int i = 0; i &lt; s.size(); i += 2k)</code>。然后在for循环中操作前k个字符即可。边界条件想不明白可以带一个具体的例子来试。代码和注释如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每隔2k个字符跳转一次，即每次取出2k个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += <span class="number">2</span> * k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对2k个字符的前k个字符进行反转</span></span><br><span class="line">            <span class="comment">// 由于每次取2k，取若干次后。字符串的尾部剩下的字符长度l可能l &lt; k 或 k &lt;= l &lt; 2k</span></span><br><span class="line">            <span class="comment">// 对前一种情况，需要将尾部全部反转，对后一种情况，需要反转尾部剩下字符的前k个字符</span></span><br><span class="line">            <span class="comment">// 先处理后一种情况，注意加上条件i + k &lt;= s.size()，这可以避免对索引超出范围的元素进行反转</span></span><br><span class="line">            <span class="comment">// 至于i + k是否能取到s.size()，可以举例子：k = 3, s = &#123;a, b, c&#125;，由此可见可以取等于</span></span><br><span class="line">            <span class="comment">// 也可以从理论上分析，由于reverse的区间是左闭右开的，因此s.begin() + i + k实际上取不到，因此可以让i + k = s.size() </span></span><br><span class="line">            <span class="comment">// 处理完后continue即可，除去反转2k个字符中的前k个字符的一般情况，尾部剩下的字符的长度的第一种情况和第二种情况只可能有一种发生</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k); <span class="comment">// 左闭右开</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再处理前一种情况，当剩余的字符长度l &lt; k时，反转剩余的全部字符</span></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>也可以不用continue，直接采用if-else写法，参见代码随想录的写法（代码随线录的注释也更加简洁明了）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="卡码网：54-替换数字-2"><a href="#卡码网：54-替换数字-2" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><p>本题的最佳解法不需要额外的辅助空间。首先扩充原字符串到每个数字字符替换成 “number” 之后的大小。然后用<strong>双指针算法</strong>，指针i指向旧字符串的末尾，指针j指向新字符串的末尾。用指针i遍历旧字符串，若遇到字母，则原样填入指针j指向的位置；若遇到数字，则从后往前将number填入到指针j指向的位置。直到i和j都指向新旧字符串的开头为止。这里的新旧字符串其实是扩容之后和扩容之前的同一字符串，只是为了方便区分称它们为新旧字符串。根据这个思路，我写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// count为字符串中数字的数量</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="number">48</span> &amp;&amp; s[i] &lt;= <span class="number">57</span>)</span><br><span class="line">            count ++ ;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> oldSize = s.<span class="built_in">size</span>();</span><br><span class="line">    s.<span class="built_in">resize</span>(oldSize + count * <span class="number">5</span>); <span class="comment">// 字符串扩容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双指针算法，i指向旧字符串，j指向新字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = oldSize - <span class="number">1</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &lt; <span class="number">48</span> || s[i] &gt; <span class="number">57</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            s[j] = s[i];</span><br><span class="line">            i -- ;</span><br><span class="line">            j -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[j] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">3</span>] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">4</span>] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">5</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">            i -- ;</span><br><span class="line">            j -= <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以直接写作cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        cout &lt;&lt; s[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码随想录的代码本质上和我写的是一样的，但他写的更见简洁一些，我写的更易于理解一些。</p>
<p>我的写法中，必须让<code>i &gt;= 0</code>，不能写成<code>i &gt; 0</code>，否则答案错误。例子，输入1，输出本来应该为number，若for循环的条件为<code>i &gt; 0</code>，则不会进入for循环，直接输出1，这显然是不对的。但对于代码随想录的写法：<code>for (int i = sNewSize - 1, j = sOldSize - 1; j &lt; i; i--, j--)</code>，则<code>j &lt; i</code>是正确的，若首字符为字母，则j = i时两指针均以指向首字符，首字符保留即可，不需要处理；若首字符为数字，则逻辑也可以正确执行。若<code>j &lt;= i</code>，则反而会出现越界的问题，因为当j和i都指向首字符后，for循环的条件依然满足，此时完成当前循环后，i和j继续-1，再次判断时，i依然等于j，再次进入循环，此时s[i]和s[j]就不存在了（s[-1]不存在）。</p>
<h3 id="151-翻转字符串里的单词-2"><a href="#151-翻转字符串里的单词-2" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p>是字符串中操作比较复杂的题目，给的字符串中在开头、中间、结尾都可能有空格。反转字符串里的单词后，要将多余的空格都删掉。</p>
<p>整体思路：先让单词的顺序和目标相同，即将整个字符串都反转。再对每个单词做反转，就得到了目标字符串。<strong>将原字符串整体反转，再将每一个单词反转</strong>。</p>
<p>难点：如何删去多余的空格。要求空间复杂度O(1)，即不能申请新的字符串来放置删去多余空格后的字符串。且不能使用库函数。使用快慢双指针算法，删除多余空格的时间复杂度为O(n)。<strong>快指针用于遍历旧字符串，慢指针用于依次指向新字符串中的各个元素</strong>。（新字符串在旧字符串的基础上修改，并不需要另外创建字符串来存储新字符串）。双指针的用法同数组章节的移除元素。</p>
<p>根据上述思路，我写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpace</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; s.<span class="built_in">size</span>(); fast ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[fast] != <span class="string">&#x27; &#x27;</span>) <span class="comment">// 去除字符串开头的空格</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每复制完一个单词后，加一个空格</span></span><br><span class="line">                <span class="comment">// 这句话不可以放在while循环后，否则会在最后一个单词后面增加一个多余的空格</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow ++ ] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将旧字符串的非空部分复制到新字符串中</span></span><br><span class="line">                <span class="keyword">while</span> (fast &lt; s.<span class="built_in">size</span>() &amp;&amp; s[fast] != <span class="string">&#x27; &#x27;</span>) s[slow ++ ] = s[fast ++ ];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpace</span>(s); <span class="comment">// 删去所有多余的空格</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); <span class="comment">// 反转整个字符串，注意reverse函数是左开右闭的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转每个单词</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) i ++ ; <span class="comment">// 找到空格</span></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + start, s.<span class="built_in">begin</span>() + i); <span class="comment">// 反转start到空格之间的单词</span></span><br><span class="line">            start = i + <span class="number">1</span>; <span class="comment">// 更新start</span></span><br><span class="line">            i = start; <span class="comment">// 更新i</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>代码随想录中的反转每个单词的写法和我的略有不同，他用的是for循环，但本质是一样的。</p>
<h3 id="卡码网：55-右旋转字符串-2"><a href="#卡码网：55-右旋转字符串-2" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h3><p>我在初次尝试中已经给出了空间复杂度为O(1)的最优解法，下面两幅图（对应两种等效的方法）可以帮助理解：</p>
<ol>
<li><p>先反转整个字符串，再反转两个子串</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20231106172058.png" alt="img"></p>
</li>
<li><p>先反转子串，再反转整个字符串</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20231106172534.png" alt="img"></p>
</li>
</ol>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="344-反转字符串-2"><a href="#344-反转字符串-2" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>两种for循环的写法：<code>for (int i = 0, j = s.size() - 1; i &lt; s.size() / 2; i ++ , j -- )</code>和<code>for (int l = 0, r = s.size() - 1; l &lt; r; l ++ , r -- )</code>都可以。</p>
<h3 id="541-反转字符串II-3"><a href="#541-反转字符串II-3" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><ol>
<li>for循环每次以2k为长度去跳转</li>
<li><p>本题反转字符的<strong>三种情况</strong>：</p>
<ul>
<li>每隔 2k 个字符的前 k 个字符进行反转</li>
<li>剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</li>
<li>剩余字符少于 k 个，则将剩余字符全部反转</li>
</ul>
<p>三种情况每次只可能出现一种，即出现了一种情况，另外两种情况就不会出现了。据此，我写出了<strong>结构分明的三段式代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += <span class="number">2</span> * k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 情况1</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">2</span> * k &lt;= s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 可以省略</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 可以省略</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况3</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>情况1和情况2可以合并（即剩余字符的长度l满足l &gt;= k时，都是反转剩下字符的前k个；只有当l满足l &lt; k时，才要反转剩下的所有字符），因此产生了实现部分中的第二版代码。每次思考时应该先想到三种情况，再写出结构分明的三段式代码，然后对其进行简化。<strong>能够写出三段式代码即可，虽然不简洁但思路清晰简单、不容易出错</strong>。</p>
</li>
<li>如果要求一段段地操作字符串或数组，那么for循环中的i变量是可以一段段增加的，而没必要每次+1</li>
</ol>
<h3 id="卡码网：54-替换数字-3"><a href="#卡码网：54-替换数字-3" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><ol>
<li>本题注意使用<strong>双指针做法</strong>。代码推荐参考我在实现中的写法，虽然和代码随想录的代码略有差别，但本质是完全一样的。</li>
<li>本题注意考虑边界条件，在我的写法中，是<code>i &gt;= 0</code>而非<code>i &gt; 0</code>；在代码随想录的写法中，是<code>j &lt; i</code>而非<code>j &lt;= i</code>。如果边界条件写得不对会导致发生指针异常或者部分样例无法通过。考虑边界条件时，可以举特例，也可以让代码先运行，若发生错误则修改相应的边界条件。</li>
<li><p><strong>很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong>对于线性数据结构，填充或者删除，后序处理会高效的多。</p>
<p>这么做有两个好处：</p>
<ol>
<li>不用申请新数组。算法的空间复杂度从O(N)降到了O(1)。</li>
<li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。算法的时间复杂度从O(n^2)降到了O(n)。</li>
</ol>
</li>
</ol>
<h3 id="151-翻转字符串里的单词-3"><a href="#151-翻转字符串里的单词-3" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><ol>
<li>本题的总体思路：移除多余的空格-&gt;反转整个字符串-&gt;反转字符串中的每个单词</li>
<li>利用快慢双指针移除多余的空格有两种写法，一种较为复杂，需要分别移除字符串前面的空格和字符串中间和最后的连续的不止一个的空格，最后再移除字符串最后可能存在的一个空格。<strong>另一种较为简单，思路和<a target="_blank" rel="noopener" href="https://programmercarl.com/0027.移除元素.html">27.移除元素</a>是相同的</strong>。<strong>快指针用于遍历旧字符串，慢指针用于依次指向新字符串中的各个元素</strong>。时间复杂度O(n)</li>
<li><strong>推荐使用较为简单的双指针写法</strong>。除去从旧字符串中复制每个单词到新字符串中的代码，还需要加上用于在新字符串中添加每个单词尾部的空格的代码。<strong>注意这两行代码的顺序不能写反，必须是先有添加空格的代码，再有复制单词的代码，否则会导致在新字符串的末尾多添加一个空格</strong>。</li>
<li>上面提到的新旧字符串只是有时间上的先后，没有空间上的拷贝。新字符串就是在旧字符串的基础上利用双指针算法通过删除和改动部分元素得到的。因此空间复杂度为O(1)。</li>
</ol>
<h3 id="卡码网：55-右旋转字符串-3"><a href="#卡码网：55-右旋转字符串-3" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h3><ol>
<li>本题加上限制条件：不能申请额外空间，只能在本串上操作（对cpp）。</li>
<li>可以先反转总串，再反转子串；也可以先反转子串，再反转总串。</li>
<li>右旋转字符串和左旋转字符串方法完全相同，就是反转的区间不同。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/31/Day-7-Leetcode-454-383-15-18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/31/Day-7-Leetcode-454-383-15-18/" class="post-title-link" itemprop="url">Day 7 | Leetcode 454, 383, 15, 18</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-31 02:07:29" itemprop="dateCreated datePublished" datetime="2024-01-31T02:07:29+00:00">2024-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-04 16:25:39" itemprop="dateModified" datetime="2024-02-04T16:25:39+00:00">2024-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（哈希表）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">454.四数相加II</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">383. 赎金信</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15. 三数之和</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">18. 四数之和</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%BB%E7%BB%93.html">哈希表总结篇</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><p>cpp中的map中的value是支持++操作的，且value可以通过key直接索引到，就像普通的数组那样。</p>
<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><ol>
<li><p>不仅对vector可以用范围遍历，对string类型的变量和普通的数组也可以用范围遍历的写法来简化代码。似乎范围遍历的速度要稍快于普通的for循环遍历。</p>
</li>
<li><p>cpp中，可以用erase函数来删除string类型变量的第j个字符，有两种写法：<br><code>string.erase(j, 1);</code><br><code>string.erase(s.begin() + j);</code></p>
</li>
<li><p>cpp中，如果想使用变量类型来给变量命名，需要使用std，有如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set; <span class="comment">// 使用 &quot;set&quot; 作为变量名</span></span><br><span class="line">    set.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    set.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>set</code>是作为<code>std::set&lt;int&gt;</code>类型的变量名使用的。由于<code>std::set</code>是在<code>std</code>命名空间中定义的，而变量<code>set</code>是在局部作用域中定义的，所以编译器能够区分这两者。</p>
</li>
</ol>
<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><ol>
<li>将四数之和由int类型转换为long类型：<code>(long) nums[i] + nums[j] + nums[l] + nums[r] &gt; target</code></li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="454-四数相加II-1"><a href="#454-四数相加II-1" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><p>这道题肯定是要用map做哈希的，且map的key用来存储元素的值，map的value用来存储元素的索引。此题和两数之和为target有较多的相同点，但也有些不同。若四个数相加为0，则其中的数两两互为相反数。但这种想法是不对的，可以存在2, 4, -3, -3的情况。对这题的算法我暂时想不出来什么好主意。</p>
<h3 id="383-赎金信-1"><a href="#383-赎金信-1" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p>看着就是242.有效的字母异位词的变式，若前面那个字符串可以由后面那个字符串中的字母构成，则返回true，否则返回false。本质就是看后面的字符串是否包含前面的字符串。因为两个字符串都只是由小写字母构成，因此用数组做哈希足矣。根据这个思路，我写出了如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本题的本质是判断后面的字符串是否包含前面的字符串，即后面的字符串中出现的所有字符是否在前面的字符串中出现过</span></span><br><span class="line">        <span class="type">int</span> N[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ransomNote.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            N[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            N[magazine[i] - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 数组N中有元素大于0，说明ransomNote中出现了magazine中未出现的字母</span></span><br><span class="line">        <span class="comment">// 说明前者不能完全由后者组成，返回false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (N[i] &gt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>采用范围遍历的方法，可以把上述代码写得更简洁：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ransomNote &lt; magazine return true</span></span><br><span class="line">        <span class="comment">// else return false</span></span><br><span class="line">        <span class="type">int</span> N[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> r: ransomNote)</span><br><span class="line">            N[r - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> m: magazine)</span><br><span class="line">            N[m - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: N)</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><p>这道题的题目我都不太理解，什么叫答案中不可以包含重复的三元组。直到我看到了示例1，明白了这个意思是可能存在情况：两个三元组，它们的索引组成的三元组可能不同，但这两个三元组本身的数值是完全相同的（忽略顺序），此时这两个三元组只能算作一个。这道题应该可以用哈希法，但需要去重。本题我认为有三个难点：</p>
<ul>
<li>枚举完一个数，怎么去寻找另外两个数</li>
<li>用什么数据结构维护另外两个数</li>
<li>如何去重</li>
</ul>
<h3 id="18-四数之和-1"><a href="#18-四数之和-1" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><p>本题应该依然是双指针算法。但需要注意去重的操作。我的思路是先对数组进行排序，然后让<code>a = i, b = i + 1, c = i + 2, d = nums.size() - 1</code>。然后一边向后移动a, b和c，一边对a,b和c去重，一边向前移动d，一边对d去重。根据以上思路，我写下了以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="comment">// 对i去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 对j去重</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left = j + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[left] + nums[right] &gt; target) right -- ;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[left] + nums[right] &lt; target) left ++ ;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对left和right进行去重</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left ++ ;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right -- ;</span><br><span class="line">                        left ++ ;</span><br><span class="line">                        right -- ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码测试样例通过了229 / 294，可见思路是对的，但细节仍不完美。我将在实现部分进一步优化细节。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="454-四数相加II-2"><a href="#454-四数相加II-2" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><p>四数相加和四数之和题目看起来相似，但前者是哈希表中的经典题目，后者用哈希表的方法不太合适。其实只需要知道有多少对四数之和为0，不需要知道每一对的具体数值。</p>
<p><strong>本题不需要去重</strong>，因此相对简单，四数之和则需要考虑去重。举例：四个数组，每个数组中都有n个0，则返回的结果是n。</p>
<p><strong>思路</strong>：遍历数组A和B，将从这两个数组取出的元素a + b放入map中；再遍历数组C和D，求得c + d，再判断map中有无我们想要的元素-(c + d)，有则count += -(c+d)出现过的次数（即map中key为-(c+d)的元素的value）。</p>
<p>本题的数据范围很大，因此用数组来做哈希不可取，只能考虑set/map。<strong>因为不仅需要将a + b放入哈希结构中，还需要统计a + b出现过多少次，因此用map</strong>。用map的key存a + b的值，用map的value存a + b出现的次数。</p>
<p>时间复杂度：<code>O(n^2) + O(n^2)</code>，还是<code>O(n^2)</code>。如果先遍历一个数组，再遍历三个数组，则时间复杂度是O(n^3)。</p>
<p>我知道上述思路后，尝试写代码，出现一个问题：不知道如何统计数组A和数组B中各取一个元素求和后的值出现的次数。我把简单的问题想复杂了，map中的value是支持++操作的，且value可以通过key索引到，因此直接：<code>map[num1 + num2] ++ ;</code>即可，这个代码的意思是：若<code>num1 + num2</code>的值出现过，则其<code>value += 1</code>；若没出现过，则相当于：<code>map.insert(&#123;num1 + num2, 1&#125;)</code>。写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历nums1和nums2数组，将两个数组各取一个值的和作为key，和出现的次数作为value存入map中</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num1: nums1)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num2: nums2)</span><br><span class="line">                sum[num1 + num2] ++ ; <span class="comment">// 和为num1 + num2的值的出现次数 + 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历nums3和nums4数组，设两个数组各取一个值的和是c + d</span></span><br><span class="line">        <span class="comment">// 若map中出现了-(c + d)，则count += value</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num3: nums3)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num4: nums4)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> s = num3 + num4;</span><br><span class="line">                <span class="keyword">auto</span> it = sum.<span class="built_in">find</span>(-s);</span><br><span class="line">                <span class="keyword">if</span> (it != sum.<span class="built_in">end</span>())</span><br><span class="line">                    count += it-&gt;second; <span class="comment">// it-&gt;second也可以写作sum[-s]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>更简洁的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num1: nums1)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num2: nums2)</span><br><span class="line">                map[num1 + num2] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num3: nums3)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num4: nums4)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> target = -(num3 + num4);</span><br><span class="line">                <span class="keyword">if</span> (map.<span class="built_in">find</span>(target) != map.<span class="built_in">end</span>())</span><br><span class="line">                    count += map[target];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="383-赎金信-2"><a href="#383-赎金信-2" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p>注意，本题的题干中虽然强调了<code>Each letter in magazine can only be used once in ransomNote</code>，但这个条件在写代码时实际上并不需要考虑。这应该只是生成测试样例时需要遵守的规则。</p>
<p>本题用暴力做法也可以过，但暴力做法的代码写起来似乎还更麻烦一点。暴力做法就是两重for循环，若ransomNote中出现了magazine中出现过的字符，则从ransomNote中移除该字符，最后判断ransomNote的长度是否为0即可。暴力做法的代码可以参见代码随想录。</p>
<p>至于时间复杂度为O(n)的哈希解法，我在初次尝试中写的就已经很完美了。若想进一步优化，可以加上判断：若ransomNote的长度大于magazine的长度，则可以直接return false。若在遍历字符串时就对数组中元素的正负进行判断，那需要注意：只能在ransomNote中对数组中元素的正负进行判断，为负则说明赎金信中有magazine中没有的字符。若在magazine中对数组中元素的正负进行判断，可能存在问题：数组中的元素为正不一定代表赎金信中有magazine中没有的字符，可能仅仅是因为尚未遍历完成，数组中的元素还没被减到负数。因此，下面的代码是错误的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> r: ransomNote)</span><br><span class="line">            N[r - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> m: magazine)</span><br><span class="line">        &#123;</span><br><span class="line">            N[m - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">            <span class="keyword">if</span> (N[m - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以通过测试样例轻而易举地看出上述解法的漏洞，比如<br>ransomNote =”aa”<br>magazine =”aab”<br>Output false<br>Expected true<br>而代码随想录上的哈希解法的代码是正确的。</p>
<p>若想避免上述问题，最直接的办法就是等到N数组中的元素全部计算完成后，另开一个循环来判断其中是否有为正的元素。</p>
<h3 id="15-三数之和-1"><a href="#15-三数之和-1" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><p>本题可以用哈希法做，但比较复杂。本题需要返回的三元组，其中的元素是数组中元素的值，而非下标。<strong>注意：三元组是去重的。本题相较于两数之和的难点就在于去重</strong>。</p>
<p>哈希法的大致思路：用两重for循环，第一重确定a，第二重确定b，然后看-(a + b)是否在map中出现过。但这里的难点在于：需要同时对a, b和c（-a - b）去重。去重的细节太多了，基本上都会遇到小问题，难以一次想周全。<strong>因此推荐使用更易于理解的双指针法</strong>。</p>
<p>双指针法的思路：<strong>使用双指针法之前需要对数组进行排序</strong>。for循环遍历数组，得到a；left指针从数组的第2个位置开始向后移动，得到b；right指针从数组的最后一个位置开始向前移动，得到c。若<code>num[i] + num[left] + num[right] &gt; 0</code>，说明三数之和大了，i是固定的（for循环从头开始遍历），因此应当让<code>right --</code>。若<code>num[i] + num[left] + num[right] &lt; 0</code>，说明三数之和小了，应该让其变大，则应当让<code>left ++</code>。若三数之和为0，则将三者放入二维数组res中。注意细节：去重。num[i], num[left], num[right]三个数都需要去重，因为res中不能有重复的三元组。</p>
<p>伪代码：（注：<code>a = num[i], b = num[left], c = num[right]</code>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 存储结果</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 排序后，若最小值仍大于0，说明不存在三数之和等于0的情况，返回现有的res即可</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// nums[i]即a，需要对a去重</span></span><br><span class="line">    <span class="comment">// 三元组之间不可重复，但三元组内部可以有重复的数字，比如000</span></span><br><span class="line">    <span class="comment">// 去重是nums[i] == nums[i + 1] continue还是nums[i] == nums[i - 1] continue</span></span><br><span class="line">    <span class="comment">// 应该是后者。若是前者，由于left指针指向nums[i + 1]，因此若b和a相同，则会跳过这个结果集，这显然是错误的</span></span><br><span class="line">    <span class="comment">// 因为三元组内部是可以有重复的数字的</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 当前三元组的a和上一个三元组的a重复，则进入下一个循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 求三个数，因此是left &gt; right。若left = right，则三个数变为了两个数</span></span><br><span class="line">    <span class="keyword">while</span> (right &gt; left)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right -- ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left ++ ;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;); <span class="comment">// 三者之和等于0.则放入结果数组中，收获结果</span></span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">        		<span class="keyword">while</span> (right &gt; left &amp;&amp; right[i] == right[i - <span class="number">1</span>]) right -- ; <span class="comment">// 对c去重</span></span><br><span class="line">        		<span class="keyword">while</span> (right &gt; left &amp;&amp; left[i] == left[i + <span class="number">1</span>]) left ++  ; <span class="comment">// 对b去重</span></span><br><span class="line">            <span class="comment">// 收获一个结果后，left和right都向着数组的中间位置移动</span></span><br><span class="line">            left ++ ;</span><br><span class="line">            right -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<p>细节：</p>
<ul>
<li><p>如何对a去重：<code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</code></p>
</li>
<li><p>如何对b和c去重：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (right &gt; left &amp;&amp; right[i] == right[i - <span class="number">1</span>]) right -- ; <span class="comment">// 对c去重</span></span><br><span class="line"><span class="keyword">while</span> (right &gt; left &amp;&amp; left[i] == left[i + <span class="number">1</span>]) left ++  ; <span class="comment">// 对b去重</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对b和c去重的代码放在哪里<br> 必须先收获结果，再去重。否则若出现数组中全是0的情况，就会一直运行去重的逻辑，而不收获结果。</p>
</li>
</ul>
<p>根据上述伪代码，我独立写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 用双指针算法前需要先排序</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 二维数组，存放结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三元组&#123;a, b, c&#125;，i指向a, left指向b, right指向c</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若最小的a都大于0，则三数之和不可能等于0，不需要继续循环，返回现有的res即可</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对a去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right -- ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left ++ ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;); <span class="comment">// 收获结果</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 对b和c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left ++ ;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right -- ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 移动left和right指针</span></span><br><span class="line">                    left ++ ;</span><br><span class="line">                    right -- ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="18-四数之和-2"><a href="#18-四数之和-2" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><p>和三数之和思路相同，但多一重for循环。共有i, j, left, right四个指针，前三者初始时分别指向数组的前三个元素，right指向数组最后一个元素。left和right向中心靠拢，使得<code>nums[i] + nums[j] + nums[left] + nums[right] = target</code>。</p>
<p>细节：剪枝和去重。</p>
<ul>
<li>一级剪枝：不能延续三数之和的剪枝操作：<code>if(nums[i] &gt; target) return res;</code>。这没有考虑到数组中可能有负数的情况，若数组中有负数，几个元素相加是越加越小的，因此即使最小的数大于target，通过加上一些负数，四数之和依然可能为target。正确的剪枝操作应该为：<code>if (nums[i] &gt; target &amp;&amp; nums[i] &gt; 0 &amp;&amp; target &gt; 0) break;</code>。其实这里写break（即最后返回）和写return res都是可以的，并不会影响运行结果。</li>
<li>二级剪枝：<code>if (nums[i] + nums[j] &gt; target &amp;&amp; nums[i] + nums[j] &gt; 0 &amp;&amp; target &gt; 0) break;</code><strong>二级剪枝完成后只能写break，写return res会有几个测试样例无法通过</strong>。原因：一级剪枝条件时直接return res，相当于结束所有循环，返回结果，不会漏掉部分四元组；二级剪枝时直接return res，同样相当于结束所有循环，返回结果，此时就会漏掉部分四元组。<strong>正确的做法应该是结束第二重循环，继续进行第一重循环</strong>。</li>
</ul>
<p>其实还有一个细节需要注意，在求四数之和<code>nums[i] + nums[j] + nums[left] + nums[right]</code>时，若四个数都是10亿，加起来就会超过int的限制（大约21亿），因此需要把四数之和转化为<code>long</code>类型：<code>(long) nums[i] + nums[j] + nums[l] + nums[r] &gt; target</code>。如果不将int转换为long，会报错：整数溢出，同时有几个测试样例无法通过。代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a = i, b = j(i + 1), c = l(i + 2), d = r(nums.size() - 1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target &amp;&amp; target &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; <span class="comment">// 一级剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 一级去重</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] &gt; target &amp;&amp; target &gt; <span class="number">0</span> &amp;&amp; nums[i] + nums[j] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; <span class="comment">// 二级剪枝</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 二级去重</span></span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> l = j + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[j] + nums[l] + nums[r] &gt; target) r -- ;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[j] + nums[l] + nums[r] &lt; target) l ++ ;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[l], nums[r]&#125;);</span><br><span class="line">                        <span class="comment">// 对l和r去重</span></span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) l ++ ;</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) r -- ;</span><br><span class="line">                        l ++ ;</span><br><span class="line">                        r -- ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="454-四数相加II-3"><a href="#454-四数相加II-3" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><ol>
<li><p>本题的大体思路？<br>遍历前两个数组A和B，将a + b的值存入map<br>再遍历后两个数组C和D，在map中查找-(c + d)的值</p>
</li>
<li><p>为什么选择map做哈希？<br>因为不仅需要存储a + b的值，还需要存储这个值出现的次数(<code>map[a + b] ++</code>)，用于在4中统计元组的个数</p>
</li>
<li><p>map中的key放什么？value放什么？<br>map中的key放a + b的值，map中的value放这个值出现的次数</p>
</li>
<li><p>如何统计元组的个数？<br><code>count += map[-(c + d)]</code></p>
</li>
<li><p>如何统计a和b的和出现的次数？<br><code>map[a + b] ++</code></p>
</li>
</ol>
<h3 id="383-赎金信-3"><a href="#383-赎金信-3" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p>代码随想录上的哈希解法不如我在初次尝试部分写的哈希解法简洁，而且代码随想录的哈希解法在颠倒遍历两个字符串的顺序时容易出错。<strong>本题的最佳解法是我在初次尝试部分写的第二个版本的代码</strong>。</p>
<h3 id="15-三数之和-2"><a href="#15-三数之和-2" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><ol>
<li>采用双指针法，不要用哈希法，哈希法写起来复杂，去重麻烦、难以做剪枝操作，故效率显著低于双指针法</li>
<li>双指针法思路简单，但要注意去重的细节</li>
<li>排序的目的是方便剪枝，且一个三元组只会有唯一的顺序</li>
<li><strong>双指针法只适用于返回的结果是数而不是索引的题目</strong>，因为双指针法使用前必须对数组进行排序，排序后索引会被打乱，因此返回的结果不能是索引。若两数之和要求返回的结果是数，那么也可以用双指针算法。这不禁让我思考，若本题要求返回的结果是索引，那么也只能用哈希法。但如果要求返回的结果是索引，那么就不需要有复杂的去重操作，因此实际上是简化了本题。</li>
<li>对于<code>nums[i]</code>（即a）去重的代码，可以用if判断写：<code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</code>，也可以用while循环写：<code>while (i &lt; nums.size() &amp;&amp; i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) i ++ ;</code>。一般在写while循环时，都需要加上<strong>对数组索引不可越界的限制</strong>：<code>i &lt; nums.size()</code>。如果出现报错：<code>Runtime Error: AddressSanitizer</code>，大概率是因为数组索引越界了，此时需要检查是否加上了限制条件<code>i &lt; nums.size()</code>和<code>i &gt; 0</code>。</li>
</ol>
<h3 id="18-四数之和-3"><a href="#18-四数之和-3" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><ol>
<li>本题思路和三数之和相同，但需要注意剪枝的细节</li>
<li>还需要注意在求四数之和时将int类型转换为long类型，避免整数溢出。</li>
<li>若采用双指针算法，三数之和的时间复杂度是<code>O(n^2)</code>，四数之和的时间复杂度是<code>O(n^3)</code>。用暴力做法的时间复杂度则分别为<code>O(n^3)</code>和<code>O(n^4)</code>。</li>
<li>本题相比于四数相加，由于要考虑去重问题，所以更加复杂，因此无法（不推荐）使用哈希法，推荐使用双指针算法。</li>
<li>剪枝方面可以做进一步的优化，但属实没有必要。</li>
<li>本题写剪枝统一用break，不要用return res，以免方式意外的错误</li>
<li>本题如果有几个测试样例总是过不了，可以直接删去剪枝的代码，一般就可以通过了。剪枝是优化，即使不加，依然可以轻松通过。剪枝部分是易错点。</li>
</ol>
<h2 id="哈希表总结"><a href="#哈希表总结" class="headerlink" title="哈希表总结"></a>哈希表总结</h2><ol>
<li>哈希表的使用场景：快速判断一个元素是否在集合中出现过。</li>
<li>哈希的三重境界：普通数组-&gt;set-&gt;map。</li>
<li>目前哈希中用到的set和map实际上是unordered_set和unordered_map，相对于set和map中的另外两种数据结构（set, multiset, map, multimap），unordered_set和unordered_map的查询效率和增删效率都是最高的。选择set类型的三种数据结构时，若我们不需要数据有序，且需要去重，且希望效率高，则用unordered_set。选择map类型的三种数据结构时，若我们不需要key有序，且希望效率高，则用unordered_map。</li>
<li>遇到哈希问题时，首先想想能不能用数组做哈希（比如题目中提到字符串中全是小写英文字母，就果断用数组做哈希）。用数组做哈希最直接，运行速度也最快，用set做哈希速度更慢，但遇到大规模的索引，数组放不下时，只能用set。</li>
<li>什么时候用map做哈希？当对一个元素需要同时存储两个值时，就必须用map做哈希。这两个值一个作为key，一个作为value存入map中。key中一般存储的是元素的值（便于查询），value中可以存放元素的索引（如1. 两数之和），也可以存放元素出现的次数（如454.四数相加II）。</li>
<li>map可以当作普通数组一样使用，忘了STL的用法可以复习知识部分。</li>
<li>哈希表部分的八道算法题，前六道都使用的是正统的哈希法，最后两道（三树之和&amp;四数之和）并非不可以使用哈希法，但使用哈希法需要进行复杂的去重操作，代码容易写错，且运行效率低下，因此推荐使用双指针算法。</li>
<li>三数之和&amp;四数之和的易错点在于剪枝和去重。每重for循环都需要剪枝和去重，while循环进行去重即可，但其实剪枝是一种优化，并不是必须的。但去重是必须的！</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/30/How-to-Understand-an-Open-Source-Project/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/30/How-to-Understand-an-Open-Source-Project/" class="post-title-link" itemprop="url">How to Understand an Open Source Project</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-30 11:16:31 / 修改时间：12:08:37" itemprop="dateCreated datePublished" datetime="2024-01-30T11:16:31+00:00">2024-01-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">web开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="快速了解项目"><a href="#快速了解项目" class="headerlink" title="快速了解项目"></a>快速了解项目</h2><p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-01-30_11-45-52.png?raw=true" alt="Snipaste_2024-01-30_11-45-52.png"></p>
<p>从0带读Java小说项目。项目：<a target="_blank" rel="noopener" href="https://novel.xxyopen.com/">小说精品屋</a></p>
<p>首先看代码的简介（README），然后看代码的更新频率（几年没更新的就不用看了）。</p>
<p>接着看项目的介绍，看项目的技术栈和我们自己的技术栈是否匹配。</p>
<p>接着看包结构（项目结构）。</p>
<p>看技术选型。高级的技术：ShardingSphere-JDBC（数据库分库分表支持）、分布式缓存支持、搜索引擎服务、开源消息中间件、文件存储、对象存储。</p>
<p>接着看<strong>核心：项目如何安装，如何启动</strong>。</p>
<h2 id="了解项目依赖"><a href="#了解项目依赖" class="headerlink" title="了解项目依赖"></a>了解项目依赖</h2><p>通过github1s（在线查看项目的工具）看项目。</p>
<p>==看项目从整体到局部，先看项目的架构及关键配置文件==</p>
<p>比如assets放静态文件，sql放SQL语句。根目录下的pom.xml定义了父工程的配置。在父工程的配置中又定义了子模块，可以达到多包同时编译的效果。</p>
<p>dockerfile：可以用其来生成一个docker镜像</p>
<p>Java的项目主要分为两部分：resources放一些资源文件和配置，另一部分是java的核心代码。</p>
<p>看resources/application.yml：跑起这个项目需要启动哪些服务。</p>
<p>resources/mybatis：放一些SQL语句</p>
<p>resources/static：放前端的文件，比如javascript, css等等。</p>
<p>resources/templates：用的是thymeleaf，拓展标签可以动态地把一些后台数据渲染到页面。</p>
<p>resources/application-dev.yml：是项目的开发环境的配置。</p>
<p>resources/application-prod.yml：是项目生成环境的配置。</p>
<p>resources/logback.yml：日志</p>
<h2 id="了解项目结构"><a href="#了解项目结构" class="headerlink" title="了解项目结构"></a>了解项目结构</h2><p>现在java项目的目录结构比较清晰和规范。都是mvc结构：model view controller。</p>
<p>controller：控制层，接收用户的请求，给予一些响应，业务逻辑一般不写在其中</p>
<p>core：项目核心的类</p>
<p>mapper：mybatis的映射文件，在这个文件中定义操作数据库的方法</p>
<p>page：控制页面的返回。用户请求一个地址，请求发送到controller，会响应并返回某个页面给用户，和前端的模板有关联。</p>
<p>service：编写业务的逻辑</p>
<p>vo：返回给页面的数据</p>
<p>springboot的启动类，会自动帮助我启动一个tomcat服务器</p>
<h2 id="追踪请求（了解分层）"><a href="#追踪请求（了解分层）" class="headerlink" title="追踪请求（了解分层）"></a>追踪请求（了解分层）</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13q4y1U7JU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bf2f8cedefdf16acd0e7a14d8e4669fd">带你读懂一个开源项目，学习通用套路！程序员阅读项目源码技巧、Java 编程项目分享</a></p>
<p><a target="_blank" rel="noopener" href="https://www.code-nav.cn/">编程导航</a></p>
<p><a target="_blank" rel="noopener" href="https://novel.xxyopen.com/">小说精品屋</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/29/Day-6-Leetcode-242-349-202-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/29/Day-6-Leetcode-242-349-202-1/" class="post-title-link" itemprop="url">Day 6 | Leetcode 242, 349, 202, 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-29 07:48:25" itemprop="dateCreated datePublished" datetime="2024-01-29T07:48:25+00:00">2024-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-30 11:13:39" itemprop="dateModified" datetime="2024-01-30T11:13:39+00:00">2024-01-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（哈希表）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">哈希表理论基础</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">202. 快乐数</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1. 两数之和</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h3><p>哈希表-&gt;哈希函数-&gt;哈希碰撞-&gt;拉链法/线性探测法-&gt;常见的三种哈希结构-&gt;set &amp; map及如何选取-&gt;总结</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表是根据关键码的值而直接进行访问的数据结构。举例：其实数组就是一张哈希表。哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。</p>
<p>哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数：哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。如果hashCode得到的数值大于哈希表的大小了，也就是大于tableSize了，此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。</p>
<p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。接下来<strong>哈希碰撞</strong>登场。</p>
<h4 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h4><p>小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p>
<h4 id="拉链法-线性探测法"><a href="#拉链法-线性探测法" class="headerlink" title="拉链法/线性探测法"></a>拉链法/线性探测法</h4><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放冲突的数据了。</p>
<h4 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h4><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p>
<ul>
<li>数组</li>
<li>set （集合）</li>
<li>map(映射)</li>
</ul>
<h4 id="set-amp-map及如何选取"><a href="#set-amp-map及如何选取" class="headerlink" title="set &amp; map及如何选取"></a>set &amp; map及如何选取</h4><p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-01-29_09-29-58.png?raw=true" alt="Snipaste_2024-01-29_09-29-58.png"></p>
<p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<p><img src="https://raw.githubusercontent.com/yfchenkeepgoing/image/main/image.png" alt="img"></p>
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>
<p>两个unordered都是哈希表实现的,其他四个都是红黑树实现的。三类set和三类map性质上是类似的。</p>
<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>
<p>那么再来看一下map ，在map 是一个key-value 的数据结构，map中，对key是有限制，因为key的存储方式使用红黑树实现的，对value没有限制。</p>
<p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下，==当我们遇到了<strong>要快速判断一个元素是否出现集合里</strong>的时候，就要考虑哈希法==。哈希法的查询速度很快：O(1)。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h4><ol>
<li>将一个数组中的元素全部置为0：<code>int hash[26] = &#123;0&#125;;</code>。实际上，直接写<code>int hash[26]</code>也可以，不给数组中的值赋值，数组中的值默认为0。</li>
<li>求字符串<code>string s</code>的长度，可以用<code>s.size()</code>，也可以用<code>s.length()</code>。</li>
<li><code>s[i] - &#39;a&#39;</code>：编译器会自动用ascii码进行计算，不需要手动将变量类型转换为整数。</li>
<li>一个有返回值的函数，如果执行了return语句，函数直接结束，不需要再break。</li>
<li>定义一个常量大小的数组，空间复杂度是O(1)。</li>
</ol>
<h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h4><ol>
<li>set, multiset, unordered_set。前两者底层实现是红黑树，最后一个的底层实现是哈希值直接映射。unordered_set就是一个可以无限存装的数组。本题用unordered_set，因为其做映射和取值时效率最高，前两者的底层实现是树，因此取值是还要有查找的过程。unordered_set中的元素不可重复，相当于自动帮我们做去重；而multiset中的元素可以重复。</li>
<li>可以直接将set类型的数据转换为vector类型：<code>return vector&lt;int&gt;(set.begin(), set.end())</code>。</li>
<li>cpp中的vector中既有insert方法，又有push_back方法，前者需要指定插入元素的具体位置，后者直接将元素插入到vector的末尾。cpp的set（包括set, multiset, unordered_set）中只有insert方法，传入的参数为要插入的值，不需要指定插入元素的具体位置。</li>
<li>将vector转换为unordered_set: <code>unordered_set&lt;int&gt; nums1_set(nums1.begin(), nums1.end())</code>。</li>
<li>在unordered_set中查找元素：<code>nums1_set.find(nums2[i])</code>，返回的结果是一个迭代器（指针）。如果找到该值，<code>find</code>返回一个指向该元素的迭代器；如果未找到，则返回一个指向<code>unordered_set</code>末尾的迭代器，即<code>end()</code>迭代器。</li>
</ol>
<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h4><ol>
<li>返回一个vector可以直接将vector的内容写入大括号中，然后返回，比如<code>return &#123;a[i], b[i]&#125;</code>，返回一个空数组可以直接写成<code>return &#123;&#125;</code>，而不用定义一个vector再利用push_back方法向其中插入数，然后再返回这个vector。</li>
<li>定义的<code>vector&lt;int&gt; a</code>，若不给其赋值，则该vector长度为0。可见vector是动态地被分配内存，如果不给其赋值，则其长度为0，不占用内存，这与普通数组需要在定义时声明长度有所不同。</li>
<li>定义unordered_map的方式：<code>unordered_map&lt;int, int&gt; map</code>；unordered_map中有insert函数和find函数，用法同unordered_set；遍历这些STL容器都要用迭代器，相当于是一种加强版的指针；访问unordered_map的key和value：<code>map-&gt;first</code>和<code>map-&gt;second</code>。</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="242-有效的字母异位词-1"><a href="#242-有效的字母异位词-1" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p>想到一个办法，用两个数组分别统计两个字符串中出现的字母和字母出现的频次，然后判断两个数组是否完全相同。代码如下所示，可以成功运行：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash1[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> hash2[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash1[s[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash2[t[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (hash1[i] != hash2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>稍微麻烦了点，实际上用一个数组就够了。</p>
<h3 id="349-两个数组的交集-1"><a href="#349-两个数组的交集-1" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p>暂时还不会用set做哈希，因此先尝试用数组做哈希。我写下了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash1[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> hash2[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计两个数组nums1和nums2中每个数值出现的频次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash1[nums1[i]] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash2[nums2[i]] ++ ;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若一个数同时在nums1和nums2数组中出现的频次&gt;=1，则该数是两数组的重叠，放入结果数组res中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash1[i] &amp;&amp; hash2[i])</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题其实是使用set的好题，但是后来力扣改了题目描述和测试用例，添加了 0 &lt;= nums1[i], nums2[i] &lt;= 1000 条件，所以使用数组也可以了，不过建议大家忽略这个条件。 尝试去使用set。</p>
<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p>尽管说这道题和上一道题原理上差不多，只是套了快乐数的壳子，但我看不出这题怎么用set来进行哈希。直接看讲解吧。</p>
<h3 id="1-两数之和-1"><a href="#1-两数之和-1" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>看到的第一想法是类似滑动窗口，但滑动窗口（209.长度最小的子数组）返回的是长度最小的子数组的长度，这道题却要返回两个整数的下标，因此还是有很大不同的。如果要快速在集合中查找一个元素是否出现过，那么应该采用哈希表的方法。我产生了一个想法，将nums数组中的所有数一对一对不重不漏地取出，将每一对数的和作为索引（key），将它们的下标作为（value）存入map中，然后通过查询map的索引来找到目标对，进而返回目标对的下标。实现起来有两个难点：</p>
<ul>
<li>如何不重不漏地枚举所有的数对？</li>
<li>如何将两个下标存入一个value里？</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="242-有效的字母异位词-2"><a href="#242-有效的字母异位词-2" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p><strong>判断两个字符串是否由相同的字母组成</strong>，但字母的位置可以不同。两个完全一样的字符串也是有效异位词。由于字符串中都是小写字母，因此a可以对应数组中索引为0的位置，z可以对应数组中索引为25的位置。用数组hash[26]统计第一个数组中每个字母出现的频率，然后第二个字符串中每个字母出现的频率再在hash数组中做对应的减法，若最后数组中所有元素均为0，则说明两个字符串互为有效的字母异位词。</p>
<p><strong>什么时候用数组/set/map：当哈希值较小，且范围也较小且可控；若哈希值很大，则用set；若是key-value对，则用map</strong>。</p>
<p>根据上述思路，我独立写出了代码，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 数组中的元素全部初始化为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash[s[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            hash[t[j] - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (hash[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="349-两个数组的交集-2"><a href="#349-两个数组的交集-2" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p>返回两个数组的交集。注意要去重。虽然可以用数组哈希，但还是建议用set。若保持之前的题目描述，让两个数组中的数值可能非常大，比如上亿，此时就必须要用set了，因为数组下标放不下那么大的数，同时会浪费很多存储空间。</p>
<p>哈希表善于解决判断一个元素是否在一个集合中出现过的题目。<strong>集合中的数值很大时，或者集合中的元素数量很少但数值很分散时，用数组不合适，要用set</strong>。先将数组nums1中的所有数值放到哈希表中，再遍历num2，查看其中的元素的数值是否在哈希表中出现过，出现过则放入res集合中。</p>
<p>因为要<strong>去重</strong>，所以定义unordered_set来存储result。哈希表也用unordered_set。直接将nums1转化为unordered_set的存储结构。接着遍历nums2，看哈希表中是否出现了nums2中的元素，出现了则将其放入result中。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220707173513.png" alt="set哈希法"></p>
<p>代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储答案的unordered_set，因为是unordered_set所以自动去重</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将nums1从vector转换为unordered_set</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums1_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在nums1_set中查找nums2中的数据，如果出现过，则将其插入res中</span></span><br><span class="line">        <span class="comment">// 也可以用范围遍历for (int num: nums2)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1_set.<span class="built_in">find</span>(nums2[i]) != nums1_set.<span class="built_in">end</span>())</span><br><span class="line">                res.<span class="built_in">insert</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将res从unordered_set类型转换回vector类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<br>构建<code>nums_set</code>：O(n)<br>遍历<code>nums2</code>并检查元素是否在<code>nums_set</code>中：O(m)<br>构建结果向量：O(k)，其中k是结果集中元素的数量<br>综上所述，总的时间复杂度是O(n + m + k)。但是由于k（结果集的大小）是由n和m决定的，并且在大多数情况下k会小于n和m，所以可以近似地认为时间复杂度主要由n和m决定，即O(n + m)。</p>
<p>如果用数组做哈希的话，除了我在初次尝试中写的那种方式，其实还有另一种方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res; <span class="comment">// 存储结果，去重</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nums1中出现过的数，则将其在哈希数组中的值标记为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums1)</span><br><span class="line">            hash[num] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若nums2中的数在nums1中出现过，则将其插入res中  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums2)</span><br><span class="line">            <span class="keyword">if</span> (hash[num] == <span class="number">1</span>)</span><br><span class="line">                res.<span class="built_in">insert</span>(num);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// unordered_set-&gt;vector</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="202-快乐数-1"><a href="#202-快乐数-1" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p>题目中说：Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.本题本来是一个数学问题，可以得到严格的数学证明，但我们不需要懂数学，可以用编程的思维去解决它。</p>
<p>因此，一个数进行如题的操作后，要么会陷入死循环，要么会在某个时刻等于1并保持。因此，可以写一个循环来持续对输入的数进行如题的操作，如果某次操作的结果在之前出现过，那么该数就不是快乐数；如果操作的结果为1，那么该数就是快乐数。要快速判断一个元素是否在集合中出现过，就应该用一个set将集合中的所有元素维护起来。代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 用于求一个数每一位的平方之和的函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSumofDigits</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            s += (n % <span class="number">10</span>) * (n % <span class="number">10</span>); <span class="comment">// 求每一位的平方</span></span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; loop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 持续循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">getSumofDigits</span>(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 结束循环，是快乐数</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 若发现出现死循环，则立即返回不是快乐数</span></span><br><span class="line">                <span class="keyword">if</span> (loop.<span class="built_in">find</span>(s) != loop.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 尚未出现死循环，则继续</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    loop.<span class="built_in">insert</span>(s);</span><br><span class="line">                    n = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以将上述代码写得更见简练，更好理解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            s += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">getSum</span>(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 退出条件1，是快乐数</span></span><br><span class="line">            <span class="keyword">if</span> (set.<span class="built_in">find</span>(s) != set.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 退出条件2，不是快乐数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不满足两个退出条件，则继续循环</span></span><br><span class="line">            n = s;</span><br><span class="line">            set.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里主要处理的是数字 n 的每一位，一个数字n它的位数可以认为是logn（一个d位的数大约是10的d次方，n = 10^d =&gt; d = logn）。每次进行快乐数的判断会执行一次该计算操作，但是因为快乐数的范围有限，总体来看不会超过 logn 的常数倍，因此时间复杂度是O(log n)。</p>
<p>所以随着<code>n</code>的增加，存储在<code>unordered_set</code>中的不同可能结果的数量实际上是有限的。事实上，随着<code>n</code>的增长，这个数量的增长速度接近于对数增长。换句话说，即使<code>n</code>非常大，经过<code>getSum</code>处理后的结果仍然是一个相对较小的数字集合。因此空间复杂度为<code>O(logn)</code>。至于为什么是<code>logn</code>，我认为原因是其增长速度最慢，这比<code>sqrt(n)</code>等其他形式更符合n较大时set中存储的元素的数量接近一个常数的事实。</p>
<h3 id="1-两数之和-2"><a href="#1-两数之和-2" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>本题需要用map解决。判断一个元素是否在一个集合中出现过：用哈希法。假设target = 9，当遍历到元素3时，我们需要去寻找元素6是否被遍历过。把遍历过的元素加到一个集合（哈希表结构）中，每次遍历新元素a时，判断(target - a)是否在集合中出现过。若出现过，我们需要知道其下标，因此集合中既要存储元素的值，又要存储元素的下标。此时想到用map，存储元素的值用map的key，存储元素的下标用map的value（因为要查找元素是否出现过，因此以元素的值作为key，map能以最快的速度找到这个key是否在这个map中出现过）。</p>
<p>看完上述思路后，我独立写出了以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; store;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有元素的值作为key，索引作为value存入map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            store.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每遍历到一个元素nums[i]，查找target - nums[i]是否在map中</span></span><br><span class="line">        <span class="comment">// 是则返回结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = store.<span class="built_in">find</span>(t);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意除去第一个条件外，还需要保证查找到的元素并非当前元素本身</span></span><br><span class="line">            <span class="comment">// 否则会出现target = 两倍当前元素而导致的误判</span></span><br><span class="line">            <span class="keyword">if</span> (it != store.<span class="built_in">end</span>() &amp;&amp; it-&gt;second != i)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继续听讲解，<strong>map用于存放遍历过的元素的值和索引</strong>。本题使用unordered_map，其存和读的效率是最高的。因此写出了以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; store;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每遍历到一个元素nums[i]，查找target - nums[i]是否在map中</span></span><br><span class="line">        <span class="comment">// 是则返回结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = store.<span class="built_in">find</span>(t);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若找到了target - nums[i]，则将其索引和当前遍历的元素的索引返回</span></span><br><span class="line">            <span class="keyword">if</span> (it != store.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将已经遍历过的元素的值作为key，索引作为value存入map中</span></span><br><span class="line">            store.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我的第一版代码在store中存储了数组中所有元素的值和索引，因此需要保证查找到的元素并非当前元素本身。第二版代码在store中存储的是已经遍历过的元素，故天然满足查找到的元素并非当前元素本身的条件。两版代码都是对的，但后者更为简洁。最简洁版本的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// 用于存储已遍历过的元素的值和索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 用于查找map中是否有目标元素</span></span><br><span class="line">            <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="comment">// 有，则返回两个索引构成的vector</span></span><br><span class="line">            <span class="keyword">if</span> (it != map.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123;i, it-&gt;second&#125;;</span><br><span class="line">            <span class="comment">// 无，则将当前元素的值和索引插入map中，然后开始循环的下一轮</span></span><br><span class="line">            map.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成循环后还没找到两个索引，则返回空vector</span></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="242-有效的字母异位词-3"><a href="#242-有效的字母异位词-3" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><ol>
<li>本题的本质是判断两个字符串是否由相同的字母组成。</li>
<li>本题用数组实现哈希。</li>
<li>遇到哈希问题时，首先想想能不能用数组做哈希。用数组做哈希最直接，运行速度也最快，用set做哈希速度更慢，但遇到大规模的索引，数组放不下时，只能用set。</li>
</ol>
<h3 id="349-两个数组的交集-3"><a href="#349-两个数组的交集-3" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><ol>
<li>本题本来不改测试数据，数组中的数值可能很大时，只能用set做哈希。现在对数组中的数值做了限制，最大不超过1000，则可以用数组做哈希。</li>
<li>用数组做哈希比用set做哈希效率更高，因为用set的话每次往里Insert一个值，都需要对这个值做一次哈希运算，同时还要开辟一个新的空间。用数组的下标做哈希映射永远是最快的。</li>
<li>本题适合用来衔接用数组做哈希和用set做哈希。</li>
<li>本题用set做哈希时，要记住set的各种用法：vector和unordered_set互相转化，在unordered_set中查找元素。这些用法归纳在知识中。</li>
<li>本题有三种解法：一种是用set哈希，另外两种是用数组做哈希。用数组做哈希建议采用我在初次尝试中的做法，只需要用到数组，不需要用到unordered_set去重。</li>
<li>采用范围遍历的写法可以简化代码。</li>
</ol>
<h3 id="202-快乐数-2"><a href="#202-快乐数-2" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p>这道题的逻辑其实非常简单。若各个位上的平方和为1，则退出循环，返回是快乐数；若平方和之前出现过，则说明进入了死循环，也退出循环，返回不是快乐数；其他情况下，继续循环。由于本题的<code>1 &lt;= n &lt;= 2^31 - 1</code>，各个位的平方和的数据范围非常大，因此必须用set做哈希，不能再用数组做哈希。注意本题时间复杂度和空间复杂度的分析。时间复杂度和空间复杂度不存在<code>sqrt(n)</code>等表达式，要么是1, 要么是logn，要么是n，要么nlogn或者更大。</p>
<h3 id="1-两数之和-3"><a href="#1-两数之和-3" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>四个重要问题：</p>
<ol>
<li>为什么用哈希法：快速查找一个元素（目标元素）是否在集合（unordered_map存放已遍历过的元素）中出现过。</li>
<li>为什么要用map（unordered_map）：因为既需要存储元素的值，也需要存储元素的索引。这道题目中并不需要key有序，选择unordered_map 效率更高。</li>
<li>map的作用：存储<strong>已遍历过</strong>的元素的值和索引。</li>
<li>map中的key存了元素的值（便于查询），value存了元素的索引（作为结果返回）。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yifan Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Yifan Chen</p>
  <div class="site-description" itemprop="description">主要记录算法和web开发方面的心得体会</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yifan Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  


    </div>
</body>
</html>
