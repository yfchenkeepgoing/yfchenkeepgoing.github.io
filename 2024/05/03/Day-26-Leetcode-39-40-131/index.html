<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="链接39.组合总和40.组合总和II131.分割回文串 知识40.组合总和II创建一个和a数组大小相同的b数组，将其中的元素全部置为0。12vector&lt;int&gt; a;vector&lt;int&gt; b(a.size(), 0); 131.分割回文串substr(i, j) 会从索引 i 开始，取长度为 j 的子字符串。 void backtracking(const string">
<meta property="og:type" content="article">
<meta property="og:title" content="Day 26 Leetcode 39, 40, 131">
<meta property="og:url" content="http://example.com/2024/05/03/Day-26-Leetcode-39-40-131/index.html">
<meta property="og:site_name" content="YifanChen&#39;s Blog">
<meta property="og:description" content="链接39.组合总和40.组合总和II131.分割回文串 知识40.组合总和II创建一个和a数组大小相同的b数组，将其中的元素全部置为0。12vector&lt;int&gt; a;vector&lt;int&gt; b(a.size(), 0); 131.分割回文串substr(i, j) 会从索引 i 开始，取长度为 j 的子字符串。 void backtracking(const string">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-03_08-36-04.png?raw=true">
<meta property="og:image" content="https://github.com/yfchenkeepgoing/image/blob/main/20230310000918.png?raw=true">
<meta property="og:image" content="https://github.com/yfchenkeepgoing/image/blob/main/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg?raw=true">
<meta property="article:published_time" content="2024-05-03T04:14:31.000Z">
<meta property="article:modified_time" content="2024-05-06T03:27:32.492Z">
<meta property="article:author" content="Yifan Chen">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="Leetcode">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="回溯算法">
<meta property="article:tag" content="组合问题">
<meta property="article:tag" content="剪枝操作">
<meta property="article:tag" content="分割问题">
<meta property="article:tag" content="去重">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-03_08-36-04.png?raw=true">

<link rel="canonical" href="http://example.com/2024/05/03/Day-26-Leetcode-39-40-131/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Day 26 Leetcode 39, 40, 131 | YifanChen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YifanChen's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">YifanChen's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个专注技术的新手程序员</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yfchenkeepgoing/yfchenkeepgoing.github.io" class="github-corner" title="YifanChen GitHub" aria-label="YifanChen GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/03/Day-26-Leetcode-39-40-131/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yifan Chen">
      <meta itemprop="description" content="主要记录算法和web开发方面的心得体会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YifanChen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Day 26 Leetcode 39, 40, 131
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-03 05:14:31" itemprop="dateCreated datePublished" datetime="2024-05-03T05:14:31+01:00">2024-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-06 04:27:32" itemprop="dateModified" datetime="2024-05-06T04:27:32+01:00">2024-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">算法（回溯算法）</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">39.组合总和</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><p>创建一个和a数组大小相同的b数组，将其中的元素全部置为0。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a.size(), <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><p><code>substr(i, j)</code> 会从索引 <code>i</code> 开始，取长度为 <code>j</code> 的子字符串。</p>
<p><code>void backtracking(const string&amp; s, int startIndex)</code>中使用<code>const</code>的原因：</p>
<ol>
<li><strong>防止修改</strong>：<code>const</code> 关键字确保 <code>s</code> 字符串在 <code>backtracking</code> 函数中不会被修改。这是一种安全措施，可以防止函数意外地更改输入数据，从而保持数据的完整性。在处理函数参数时，尤其是在不应该或不需要修改输入的情况下，使用 <code>const</code> 可以提供这种保护。</li>
<li><strong>接口设计</strong>：在函数原型中使用 <code>const</code> 声明参数可以<strong>向函数的用户清楚地表明这个参数是用来输入数据的，不应该被函数改变</strong>。这有助于提高代码的可读性和可维护性，使得其他开发者更容易理解每个函数的作用和行为。</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h3><p>本题是集合里元素可以用无数次，那么和组合问题的差别，其实仅在于<code>startIndex</code>上的控制。本题若是想不重不漏，则下一层遍历的起始位置应该与上一层取出的数相同。而对于组合问题，下一层遍历的起始位置应该是上一层取出的数的下一个（因为组合问题中的元素不能重复使用）。据此，我写出了以下的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (s == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            s += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, s, i);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            s -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="40-组合总和II-1"><a href="#40-组合总和II-1" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><p>本题我能顺畅地写出不加去重的版本，如下所示。但对去重没有思路。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == target) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            s += candidates[i];</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, s, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            s -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对以下测试样例会出现报错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">candidates =</span><br><span class="line">[10,1,2,7,6,1,5]</span><br><span class="line">target =</span><br><span class="line">8</span><br><span class="line">Output</span><br><span class="line">[[1,2,5],[1,7],[1,6,1],[2,6],[2,1,5],[7,1]]</span><br><span class="line">Expected</span><br><span class="line">[[1,1,6],[1,2,5],[1,7],[2,6]]</span><br></pre></td></tr></table></figure></p>
<p>很明显，上述代码是需要去重的。</p>
<h3 id="131-分割回文串-1"><a href="#131-分割回文串-1" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><p>拿到本题，我没有思路，因为没有做过分割问题，直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="39-组合总和-1"><a href="#39-组合总和-1" class="headerlink" title="39.组合总和"></a>39.组合总和</h3><p>本题与组合问题的区别：集合中的元素可以重复选取，组合中元素的数量不加限定。集合中都是正整数（若有0，则会进入死循环），且集合中没有重复的元素（这意味着不用做去重的操作）。</p>
<p>本题通过和来限制树的深度，而组合问题通过组合中元素的数量来限制树的深度。本题的树形结构如下所示：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-03_08-36-04.png?raw=true" alt="Snipaste_2024-05-03_08-36-04.png"></p>
<p>由于集合中的元素可以重复使用，因此下一层的集合中应该包括本层选取的元素。现在开始写本题的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用sum表示组合的和，也可以不用sum，让target不断做减法，直到target == 0</span></span><br><span class="line"><span class="comment">// startIndex用于设置下一层递归的起点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidate, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == target)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidate.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(candidate[i]);</span><br><span class="line">        sum += candidate[i];</span><br><span class="line">        <span class="comment">// 递归，注意下一层的startIndex是从i开始，因为集合中的元素可以重复选取</span></span><br><span class="line">        <span class="built_in">backtracking</span>(candidate, target, sum, i);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        sum -= candidate[i];</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码和回溯算法的模板是类似的。本题依然可以做剪枝的操作。具体来说，是对for循环进行剪枝。对<code>candidate</code>数组进行排序后，若某个分支的和大于target，那么就没必要对其后面的分支进行搜索了。加入剪枝操作的完整代码如下所示（注意添加了注释的部分，就是实现剪枝的具体代码）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; s + candidates[i] &lt;= target; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            s += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, s, i);</span><br><span class="line">            s -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>剪枝操作总结：<strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]，相当于把下一层组合可能的sum从小到大扫了过去）已经大于target，就可以结束本轮for循环的遍历</strong>。</p>
<ul>
<li><p>时间复杂度: $O(n \times 2^n)$，注意这只是复杂度的上界，因为剪枝的存在，真实的时间复杂度远小于此。本题的时间复杂度分析同77. 组合。</p>
</li>
<li><p>空间复杂度: $O(target)$</p>
</li>
</ul>
<p><strong>为何是$O(target)$:</strong></p>
<ol>
<li><strong>递归栈深度：</strong> 空间复杂度首先取决于递归调用的最大深度，因为这直接影响了调用栈的大小。在组合总和问题中，你可以多次选择同一个数字，直到其和超过目标值 <code>target</code> 或恰好等于 <code>target</code>。最糟糕的情况发生在选择了最小元素直到达到 <code>target</code> 时，这种情况下，递归的最大深度大约是 <code>target / min(candidates)</code>。如果最小的候选数很小，理论上递归的深度可以接近 <code>target</code>。</li>
<li><strong>路径存储：</strong> 在递归过程中，我们还需要存储当前的组合路径（即当前选取的数字集合）。在最坏的情况下，即当所有选取的数字加起来等于 <code>target</code> 时，路径的长度也可以接近于 <code>target / min(candidates)</code>。尽管路径的具体长度依赖于候选数字的大小，但在分析空间复杂度时，我们考虑最坏情况，即多次选取最小值，使得路径长度和递归深度都接近于 <code>target</code>。</li>
</ol>
<h3 id="40-组合总和II-2"><a href="#40-组合总和II-2" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><p>本题差别：本题的集合中有重复的元素（之前的所有组合问题的集合中都没重复元素），<strong>不能有重复的组合</strong>。这说明我们要去重。另外，集合中的元素在组合中只能使用一次，这需要用一个变量进行控制。</p>
<p>一种朴素的想法：用之前的方法搜索组合，搜索出若干组合，其中肯定有重复的。用map或者set进行去重，输出去重后的所有组合。本方法实现起来较麻烦，且特别容易超时。</p>
<p>接下来介绍在搜索的过程中直接去重的方法：使用过的元素不重复使用。为了讲清楚本题的去重过程，卡尔自创了两个词汇：<strong>树层去重，树枝去重</strong>。去重要考虑到这两个维度。接下来画树形图，从两个维度看如何去重。去重前还需要对集合进行排序。去重需要一个数组<code>used</code>来告诉我们哪些元素使用过，哪些元素没用过。用过的元素的下标在<code>used</code>中对应的值为1，没用过的元素的下标在<code>used</code>中对应的值为0。<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/20230310000918.png?raw=true" alt="20230310000918.png"></p>
<p>上述树除去<code>used</code>数组外的基本部分，还是下一层第一个取的数是上一层取的数往后挪一位（即<code>backtracking(candidates, target, s, i + 1)</code>）。这样的目的是避免重复。对于树枝（树往深度方向走），是可以重复取值的，因为取的是一个集合中不同位置的数值相同的元素。对于树层（同一层树往横向走），不可以重复取值，必然会与之前的某个组合重复。对集合排序的目的就是将值相邻的元素放在一起，若同一层的两个分支的值相同，那么靠左边的分支会包含靠右边的分支的所有情况。<strong>因此去重的关键在于树层去重</strong>。具体的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本代码的重点在于树层去重的过程</span></span><br><span class="line"><span class="comment">// used数组用于标记某个元素是否使用过，用过1，没用过0</span></span><br><span class="line"><span class="comment">// 调用本函数前需要对集合做排序，目的是让值相同的元素在位置上相邻，方便做树层去重</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> targetSum, <span class="type">int</span> sum, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt; used)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (sum &gt; targetSum) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == targetSum) </span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">    <span class="comment">// for循环是在同一层遍历各个节点，因此接下来就要写树层去重的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 树层去重, i &gt; 0的目的是让i - 1 &gt;= 0，也可以写作i &gt; startIndex</span></span><br><span class="line">        <span class="comment">// used[i - 1] == 0对应于上面树的情况，就是第1个1没用，直接用了第2个1，此时重复读取，需要树层去重</span></span><br><span class="line">        <span class="comment">// 若nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 1，则说明是树枝的状态，由于不需要树枝去重，所以此时不需要去重</span></span><br><span class="line">        <span class="comment">// 后续在回溯算法中遇到去重问题并使用used数组时，基本都是这种写法</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 收集元素</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        used[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, targetSum, sum, i + <span class="number">1</span>, used);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        sum -= nums[i];</span><br><span class="line">        used[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以用<code>used</code>数组进行去重，也可以用<code>startIndex</code>进行去重，这里不再深入讲解。用<code>startIndex</code>去重比较抽象，因此理解用<code>used</code>数组去重即可，更易于理解且通用。本题的关键在于理解去重的思路。</p>
<p>本题的完整代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == target) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 树层去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            s += candidates[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, s, i + <span class="number">1</span>, used);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">            s -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// used数组用于标记candidates数组中的元素是否使用过，因此used数组大小应该与candidates数组大小保持相同</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(candidates.size(), <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>()); <span class="comment">// 别忘记排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度: $O(n \times 2^n)$。同77.组合和39.组合总和。<br>空间复杂度：$O(n)$。原因：树的最大深度为n（同<code>candidates</code>数组的长度）。</p>
<h3 id="131-分割回文串-2"><a href="#131-分割回文串-2" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><p>aab。有两种分割方案：aa|b和a|a|b。本题要求我们返回所有的分割方案。如何使用回溯算法解决这个问题？</p>
<p>分割问题和组合问题非常相似。例如abcdef，对组合问题，如果选择了a，则在bcdef中选择下一个字母；如果选择了b，则在cdef中选择下一个字母。同理，对于分割问题，如果分割了a，则接下来分割bcdef。再分割b，则接下来分割cdef。接下来画分割问题的树形结构。</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg?raw=true" alt="131.分割回文串.jpg"></p>
<p>切割线到了字符串的末尾，则切割完毕。结果都在叶子节点。画树形结构较为简单，具体的代码实现中有几个难点，现在开始写具体的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; path;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意传入的变量类型是const string，再加上引用</span></span><br><span class="line"><span class="comment">// startIndex控制下一次切割的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// 切割线到字符串的末尾，则终止</span></span><br><span class="line">    <span class="comment">// 切割线用startIndex表示</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将判断是否是回文的逻辑放入单层搜索的逻辑中</span></span><br><span class="line">        <span class="comment">// 因此终止条件中的path都是符合回文条件的</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如何用代码表示切割出的子串</span></span><br><span class="line">        <span class="comment">// 切割的子串：[startIndex, i]，左闭右闭的区间</span></span><br><span class="line">        <span class="comment">// 用于判断是否回文的函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, startIndex, i)) <span class="comment">// 传入字符串，子串的起始位置，子串的终止位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(子串); <span class="comment">// 是回文，则将子串放入path中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>); <span class="comment">// 下一层切割点从上一层切割点的下个位置开始，否则会重复</span></span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>isPalindrome</code>函数用双指针算法可以轻松实现。注意本题的两个细节：</p>
<ul>
<li><p><code>startIndex</code>是切割线</p>
</li>
<li><p>如何表示子串的范围：<code>[startIndex, i]</code></p>
</li>
</ul>
<p>完整的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断[start, end]是否是回文子串</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt;= j; i ++ , j -- )</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 是回文子串，则将其加入path中</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, startIndex, i))</span><br><span class="line">                path.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>时间复杂度: $O(n \times 2^n)$，时间复杂度同77.组合、39.组合总和、40.组合总和II。</p>
</li>
<li><p>空间复杂度: $O(n^2)$，原因解释如下：</p>
<ol>
<li><strong>递归栈的空间</strong>：最深的递归发生在当字符串每个字符都被分割时，因此递归深度最大为$n$（其中$n$是字符串的长度）。每一层递归需要保存当前索引和路径，这些额外的空间可以认为是常数级别的。</li>
<li><strong>路径存储空间</strong> (<code>path</code> 和 <code>res</code>):<ul>
<li><code>path</code> 变量在最坏情况下（每个字符都独立成一个回文串时）会存储$n$个元素。</li>
<li><code>res</code> 变量存储的是所有可能的分割方案。在极端情况下，如输入字符串完全由相同字符组成（例如 “aaaa”），<strong>分割方案的数量和其中每个方案的长度都可能接近$n$</strong>。但通常来说，我们只计算这个变量直接占用的空间，即指针或引用的空间，这通常也是$O(n^2)$，因为每个回文分割的保存都可能需要一个长度为 的$n$字符串的复制。</li>
</ul>
</li>
<li><strong>辅助空间</strong>：<ul>
<li>检查回文所用的额外空间是常量级的，不随输入大小变化。</li>
</ul>
</li>
</ol>
<p>将以上所有考虑结合，整个算法的空间复杂度主要由存储所有分割方案的数组 <code>res</code> 决定。由于每个分割方案可能包含多个字符串，而每个字符串又可能需要$O(n)$的空间，因此在最坏情况下，这部分的空间复杂度为$O(n⋅k)$，其中 $k$是分割方案的数量，这在极端情况下可以达到$O(n^2)$。</p>
</li>
</ul>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="39-组合总和-2"><a href="#39-组合总和-2" class="headerlink" title="39.组合总和"></a>39.组合总和</h3><ol>
<li>本题通过<code>target</code>来限制树的深度，而77. 组合通过组合中元素的个数来限制树的深度。</li>
<li>本题是集合里元素可以用无数次，那么和组合问题的差别，其实仅在于<code>startIndex</code>上的控制。本题若是想不重不漏，则下一层遍历的起始位置应该与上一层取出的数相同。而对于组合问题，下一层遍历的起始位置应该是上一层取出的数的下一个（因为组合问题中的元素不能重复使用）。</li>
<li>本题的时间复杂度：$O(n \times 2^n)$，空间复杂度：$O(target)$。</li>
<li>本题可以进行剪枝操作。具体来说，是对for循环进行剪枝。对<code>candidate</code>数组进行排序后，若某个分支的和大于target，那么就没必要对其后面的分支进行搜索了。体现在代码上，就是对总集合排序之后，如果下一层的sum（就是本层的sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历。<strong>本题的剪枝不好想，要多加注意</strong>。</li>
</ol>
<h3 id="40-组合总和II-3"><a href="#40-组合总和II-3" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><ol>
<li><p>本题的难点：集合有重复元素，但组合不能重复。</p>
</li>
<li><p>本题需要对组合去重，但不能在搜索完整棵树后用哈希法去重，容易超时。需要在搜索的过程中去重，这需要用到<code>used</code>数组。其中用过的元素标记为1，没用过的元素标记为0。</p>
</li>
<li><p>去重：只需要树层去重（树的同一层若两元素值相同，则右侧的值所在的路径必然被包含在左侧的值所在的路径中），不需要树枝去重（集合中的元素值可以相同，每个元素均可以使用一次，因此不需要对树枝去重）。</p>
</li>
<li><p>本题不可忽视的几个细节：</p>
<ul>
<li><p>集合需要进行排序，这是为了将值相同的元素放在集合中相邻的位置，便于树层去重</p>
</li>
<li><p><code>used</code>数组的大小需要与<code>candidates</code>数组保持相同，因为其是用来标记<code>candidates</code>数组中元素的使用情况的</p>
</li>
<li><p>注意树层去重的代码的写法，建议结合实际例子（实现中的图片）进行理解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树层去重</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == 0</code>说明同一树层上相邻的两个元素相同，此时需要进行树层去重</li>
<li><code>used[i - 1] == 1</code>，说明同一树枝上的<code>candidates[i - 1]</code>被使用过（同一树枝从上往下遍历，未进行回溯，因此<code>candidates[i - 1]</code>始终被标记为被使用过，即<code>used[i - 1] = 1</code>）</li>
<li><code>used[i - 1] == 0</code>，说明同一树层上的<code>candidates[i - 1]</code>被使用过（同一树层从左往右经历过回溯的过程：先对<code>candidates[i - 1]</code>所在的树枝从上往下遍历，然后回溯，再对<code>candidates[i]</code>所在的树枝从上往下遍历。在回溯的过程中，<code>candidates[i - 1]</code>被重新标记为未被使用过，即<code>used[i - 1] = 0</code>）</li>
</ul>
</li>
</ul>
</li>
<li><p>本题的去重代码不好写，同时细节较多需要注意。因此本题容易写错，需要时常复习。</p>
</li>
<li><p>后续在回溯算法中遇到去重问题并使用<code>used</code>数组时，基本都是这种写法：<code>if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == 0) continue;</code>。</p>
</li>
<li><p>本题也可以用<code>startIndex</code>进行去重，但比较难理解，因此不要求掌握。</p>
</li>
<li><p>本题可以像39.组合总和一样进行剪枝操作，只需要在for循环中对i加上限制条件：<code>s + candidates[i] &lt;= target</code>即可。</p>
</li>
</ol>
<h3 id="131-分割回文串-3"><a href="#131-分割回文串-3" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><ol>
<li><p>首先，切割问题其实本质和组合问题是相同的。</p>
<p>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…..。接着选取一个b后，再从cdef中再去选取第二个，以此类推。</p>
<p>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…..。接着从b那里切下去，在cded中再去切割第二段，以此类推。</p>
<p>可以观察本题的树形结构图，能够更加直观地理解切割问题和组合问题的相似。</p>
</li>
<li><p>什么是切割线？</p>
<p>递归参数需要传入<code>startIndex</code>，表示下一轮递归遍历的起始位置，这个<code>startIndex</code>就是切割线。</p>
</li>
<li><p>终止条件：切割线<code>startIndex</code>移动到了字符串的末尾，即<code>startIndex &gt;= s.size()</code></p>
</li>
<li><p>如何截取子串？<code>[startIndex, i]</code>之间的字符串就是子串。用<code>substr</code>函数截取即可。需要判断子串是否是回文串，是则放入<code>path</code>中，不是则<code>continue</code>。</p>
</li>
<li><p>使用最简单的双指针算法即可写出判断字符串是否是回文串的函数。</p>
</li>
<li><p>本题的空间复杂度$O(n^2)$。是极端情况下的空间复杂度，原因参见本题的实现部分。</p>
</li>
<li><p>从主函数传入的参数，在定义其他函数时若需要这个参数，则需要将其设置为<code>const</code>类型。目的是防止其他函数对这个参数的修改，同时向函数的用户清楚地表明这个参数是用来输入数据的。不加<code>const</code>不影响代码的正常运行，但加了<code>const</code>后代码更加规范。</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" rel="tag"># 回溯算法</a>
              <a href="/tags/%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/" rel="tag"># 组合问题</a>
              <a href="/tags/%E5%89%AA%E6%9E%9D%E6%93%8D%E4%BD%9C/" rel="tag"># 剪枝操作</a>
              <a href="/tags/%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98/" rel="tag"># 分割问题</a>
              <a href="/tags/%E5%8E%BB%E9%87%8D/" rel="tag"># 去重</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/02/Day-25-Leetcode-216-17/" rel="prev" title="Day 25 Leetcode 216, 17">
      <i class="fa fa-chevron-left"></i> Day 25 Leetcode 216, 17
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/06/Day-27-Leetcode-93-78-90/" rel="next" title="Day 27 Leetcode 93, 78, 90">
      Day 27 Leetcode 93, 78, 90 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5"><span class="nav-number">1.</span> <span class="nav-text">链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text">知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII"><span class="nav-number">2.1.</span> <span class="nav-text">40.组合总和II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">2.2.</span> <span class="nav-text">131.分割回文串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95"><span class="nav-number">3.</span> <span class="nav-text">初次尝试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">3.1.</span> <span class="nav-text">39.组合总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII-1"><span class="nav-number">3.2.</span> <span class="nav-text">40.组合总和II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-1"><span class="nav-number">3.3.</span> <span class="nav-text">131.分割回文串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="nav-number">4.1.</span> <span class="nav-text">39.组合总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII-2"><span class="nav-number">4.2.</span> <span class="nav-text">40.组合总和II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-2"><span class="nav-number">4.3.</span> <span class="nav-text">131.分割回文串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%83%E5%BE%97%E4%B8%8E%E5%A4%87%E5%BF%98%E5%BD%95"><span class="nav-number">5.</span> <span class="nav-text">心得与备忘录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-2"><span class="nav-number">5.1.</span> <span class="nav-text">39.组合总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII-3"><span class="nav-number">5.2.</span> <span class="nav-text">40.组合总和II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-3"><span class="nav-number">5.3.</span> <span class="nav-text">131.分割回文串</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yifan Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Yifan Chen</p>
  <div class="site-description" itemprop="description">主要记录算法和web开发方面的心得体会</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">89</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yifan Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '1495b8dcfa58a185e440',
      clientSecret: 'f073065ea2e5270367cd8792371419093833c1f3',
      repo        : 'yfchenkeepgoing.github.io',
      owner       : 'yfchenkeepgoing',
      admin       : ['yfchenkeepgoing'],
      id          : 'c0f8b000a4a4a6f914c25837628f764f',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
