<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YifanChen&#39;s Blog</title>
  
  <subtitle>一个专注技术的新手程序员</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-02-04T16:08:12.708Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yifan Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Day 9 | Leetcode 28, 459, summary</title>
    <link href="http://example.com/2024/02/03/Day-9-Leetcode-28-459-summary/"/>
    <id>http://example.com/2024/02/03/Day-9-Leetcode-28-459-summary/</id>
    <published>2024-02-03T07:51:26.000Z</published>
    <updated>2024-02-04T16:08:12.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">28. 实现 strStr()</a><br><a href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html">459.重复的子字符串</a><br><a href="https://programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html">字符串：总结篇</a><br><a href="https://programmercarl.com/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93.html">双指针总结篇</a></p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="KMP算法理论"><a href="#KMP算法理论" class="headerlink" title="KMP算法理论"></a>KMP算法理论</h3><h4 id="KMP与解决的问题"><a href="#KMP与解决的问题" class="headerlink" title="KMP与解决的问题"></a>KMP与解决的问题</h4><p>KMP：发明本算法的三位学者的英文名首字母</p><p>应用：字符串匹配问题</p><p>经典例子：</p><ul><li><p>给出文本串: aabaabaaf</p></li><li><p>给出模式串: aabaaf<br>求在文本串中是否出现过模式串</p></li></ul><h4 id="暴力方法与KMP"><a href="#暴力方法与KMP" class="headerlink" title="暴力方法与KMP"></a>暴力方法与KMP</h4><p>暴力解法：两重for循环，先遍历文本串，再遍历模式串，挨个匹配。从文本串的首位开始，若模式串不匹配文本串，则将模式串后移一位，直到匹配上。时间复杂度O(m * n)，m和n分别是文本串和模式串的长度。</p><p>KMP算法：跳到之前已匹配的地方，继续匹配。</p><h4 id="前缀表的由来"><a href="#前缀表的由来" class="headerlink" title="前缀表的由来"></a>前缀表的由来</h4><p>KMP算法如何知道我们之前已匹配过哪些，且跳到已匹配的内容后面继续匹配？</p><p>前缀表有什么特性，可以让我们找到之前已匹配过的内容？</p><p>在f处不匹配，找到f前面子串的后缀是aa，找到与该后缀相等的前缀的后面开始匹配。故我们要求一个字符串中的最长相等前后缀，重新匹配时跳到最长前缀之后开始匹配。</p><h4 id="前缀与后缀"><a href="#前缀与后缀" class="headerlink" title="前缀与后缀"></a>前缀与后缀</h4><p>前缀：包含首字母，不包含尾字母的所有子串。</p><p>后缀：包含尾字母，不包含首字母的所有子串。</p><h4 id="最长相等前后缀"><a href="#最长相等前后缀" class="headerlink" title="最长相等前后缀"></a>最长相等前后缀</h4><p>最长相等的前缀和后缀的长度。以模式串aabaaf为例。</p><div class="table-container"><table><thead><tr><th>子串</th><th>前缀</th><th>后缀</th><th>最长相等的前缀和后缀的长度</th></tr></thead><tbody><tr><td>a</td><td>无</td><td>无</td><td>0</td></tr><tr><td>aa</td><td>a</td><td>a</td><td>1</td></tr><tr><td>aab</td><td>a, aa</td><td>b, ab</td><td>0</td></tr><tr><td>aaba</td><td>a, aa, aab</td><td>a, ba, aba</td><td>1</td></tr><tr><td>aabaa</td><td>a, aa, aab, aaba</td><td>a, aa, baa, abaa</td><td>2</td></tr><tr><td>aabaaf</td><td>a, aa, aab, aaba, aabaa</td><td>f, af, aaf, baaf, abaaf</td><td>0</td></tr></tbody></table></div><p>得到模式串的前缀表：010120。</p><h4 id="使用前缀表的匹配过程"><a href="#使用前缀表的匹配过程" class="headerlink" title="使用前缀表的匹配过程"></a>使用前缀表的匹配过程</h4><p>模式串 aabaaf<br>前缀表 010120<br>发现f不匹配，要找f前的最长相等前后缀，由前缀表得到最长相等前后缀为2。2意味着有一个后缀aa，前面也有一个与之相等的前缀aa。在后缀aa的后面不匹配了，就要从与后缀相等的前缀的后面继续开始匹配。最长相等前后缀为2，故从<code>s[2] = &#39;b&#39;</code>处开始重新匹配。</p><h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><p>next/prefix都可以用来表示前缀表。在遇到不匹配的地方，next数组告诉我们要回退到哪里。前缀表为010120，对其的处理包括：右移/统一减一。不处理前缀表，就将其作为next数组，依然可以完成KMP算法。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>KMP算法-&gt;能解决哪些问题-&gt;为什么KMP算法匹配失败后可以跳到某个位置-&gt;前缀表-&gt;前缀表的特性及如何求取前缀表-&gt;用前缀表完成一次匹配的操作-&gt;实现KMP算法时，有时对前缀表统一减一，有时右移，这不设计KMP算法原理性的东西，只是实现上方法不同而已。</p><h3 id="KMP算法的代码实现"><a href="#KMP算法的代码实现" class="headerlink" title="KMP算法的代码实现"></a>KMP算法的代码实现</h3><h4 id="next数组不同的实现方式"><a href="#next数组不同的实现方式" class="headerlink" title="next数组不同的实现方式"></a>next数组不同的实现方式</h4><p>模式串：aabaaf</p><p>文本串：aabaabaaf</p><p>前缀表：010120，用next数组表示。</p><p>如何求next数组？</p><ul><li>有人会把前缀表右移，第一位放上-1，得到-101012，作为next数组。</li><li>有人会把前缀表整体-1，得到-10-101-1，作为next数组。</li><li>有人会直接拿前缀表做Next数组。<br>上述实现方式都可以，但具体处理逻辑会略有差别。</li></ul><p>模式串与文本串在模式串的最后一位f处发生了冲突，<strong>看f的前一位的前缀表的值是多少</strong>，发现是2，于是跳转到下标为2的位置，即b。如果next数组是前缀表右移得到，<strong>就直接比较f对应的next数组的值</strong>，发现是2，于是也跳转到b的位置。若next数组是前缀表-1得到，那么就把f的前一位的next数组的值+1，依然跳转到b的位置。</p><p>next数组的核心：遇到冲突向前回退。<strong>本节我们就拿前缀表作为next数组</strong>。</p><h4 id="求Next数组的具体代码"><a href="#求Next数组的具体代码" class="headerlink" title="求Next数组的具体代码"></a>求Next数组的具体代码</h4><p>共4步：</p><ol><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况</li><li>更新next数组的值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的参数：next数组，我们需要对其进行赋值，模式串s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(vector&lt;<span class="type">int</span>&gt; next, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 指针i：指向后缀末尾位置</span></span><br><span class="line">    <span class="comment">// 指针j：指向前缀末尾位置，还代表着i之前（包括i）的子串的最长相等前后缀的长度</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 前缀从0开始</span></span><br><span class="line">    <span class="type">int</span> next[N]; </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// next数组初始位置为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较前后缀所对应的字符是否相等，故i从1开始，这样i和j才能进行比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理前后缀末尾不相同的情况</span></span><br><span class="line">        <span class="comment">// 因为在一次循环中，i相当于是固定不动的，所以此时j回退</span></span><br><span class="line">        <span class="comment">// j回退到next[j - 1]指向的位置，即遇见冲突，就看next数组（即前缀表）的前一位</span></span><br><span class="line">        <span class="comment">// 不止回退一步，而要连续回退，不能写if，而要写while</span></span><br><span class="line">        <span class="keyword">while</span> ( j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = next[j - <span class="number">1</span>]; <span class="comment">// 因为要求j - 1 &gt;= 0，因此要求j &gt; 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理前后缀相同的情况</span></span><br><span class="line">        <span class="comment">// j代表着i之前（包括i）的子串的最长相等前后缀的长度</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) j ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新next数组，在其中存储i之前（包括i）的子串的最长相等前后缀的长度</span></span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟运行过程"><a href="#模拟运行过程" class="headerlink" title="模拟运行过程"></a>模拟运行过程</h4><p>当j指向s[1]，i指向s[2]时，前后缀不匹配，此时next[j - 1] = next[0] = 0，j回退到s[0]，再次比较前后缀是否匹配，发现仍不相同，此时j无法继续回退，我们就更新next数组的值，next[2] = 0，这就代表i = 2之前包括i的子串的最长相等前后缀为0，这与表格中的结果相同。此时i后移一位，指向s[3]，有s[3] == s[0]，j ++，j = 1，next[3] = 1，说明aaba的最长相等前后缀长度是1，这与表格中的结果相同。进入下一轮循环，i = 4，同理。最终用getNext函数完成了对next数组的求值。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>用上述函数，求得了next数组，即前缀表。</p><h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p>求next数组的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的参数：next数组，我们需要对其进行赋值，模式串s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(vector&lt;<span class="type">int</span>&gt; next, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 前缀从0开始</span></span><br><span class="line">    <span class="type">int</span> next[N]; </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// next数组初始位置为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较前后缀所对应的字符是否相等，故i从1开始，这样i和j才能进行比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = next[j - <span class="number">1</span>]; <span class="comment">// 因为要求j - 1 &gt;= 0，因此要求j &gt; 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) j ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新next数组，在其中存储i之前（包括i）的子串的最长相等前后缀的长度</span></span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用next数组做匹配的代码（文本串s，模式串t）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 因为next数组里记录的起始位置为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// i从0开始，遍历文本串</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != t[j]) &#123; <span class="comment">// 不匹配, j - 1 &gt;= 0 =&gt; j &gt; 0</span></span><br><span class="line">        j = next[j - <span class="number">1</span>]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == t[j]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">        j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了</span></span><br><span class="line">    <span class="keyword">if</span> (j == t.<span class="built_in">size</span>()) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">        <span class="comment">// 返回当前在文本串匹配模式串的位置i-模式串的长度 + 1，就是文本串字符串中出现模式串的第一个位置（位置从0开始）</span></span><br><span class="line">        <span class="keyword">return</span> (i - t.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况，模式串长度为0，则返回0，本处是一个易错点</span></span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义next数组</span></span><br><span class="line">        <span class="type">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="comment">// 填充next数组</span></span><br><span class="line">        <span class="built_in">getNext</span>(next, needle);</span><br><span class="line">        <span class="comment">// 用next数组做匹配</span></span><br><span class="line">        <span class="comment">// j指向模式串，i指向文本串</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 模式串匹配不上文本串，则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>n为文本串长度，m为模式串长度</p><ul><li>时间复杂度: 生成next数组，时间复杂度是O(m)；根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)。所以总共的时间复杂度为O(n + m)</li><li>空间复杂度: 开辟空间用于存储next数组，即模式串的前缀表，因此是O(m)</li></ul><h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>枚举所有的子串，看能否构成字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 子串结束位置</span><br><span class="line"><span class="keyword">for</span> 子串与主串比较</span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)。目标子串的开始位置必然是主串最前面的元素，因此只需要枚举子串的结束位置即可。</p><h4 id="移动匹配"><a href="#移动匹配" class="headerlink" title="移动匹配"></a>移动匹配</h4><p>设一个可由重复的子串构成的字符串为s，那么两个s拼接起来，前一个s的后半部分和后一个s的前半部分又可以构成一个新的字符串s。s由重复子串构成的判据：两个s相加起来，若其中出现了s，那么s就是由重复子串构成的。</p><p>注意：在(s + s)中去搜索s时，一定要把(s + s)的首元素和尾元素删去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ss = s + s;</span><br><span class="line">        ss.<span class="built_in">erase</span>(ss.<span class="built_in">begin</span>());</span><br><span class="line">        ss.<span class="built_in">erase</span>(ss.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// string::npos 是 std::string 类型的一个静态成员常量，表示字符串中不存在匹配的位置。在 find() 函数中，如果没有找到匹配的子串，则返回 string::npos。这个值通常是一个很大的无符号整数，表示找不到匹配的位置。</span></span><br><span class="line">        <span class="keyword">if</span> (ss.<span class="built_in">find</span>(s) != string::npos)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>find函数的实现其实就是28. 实现strStr()。若用KMP实现find函数，那么时间复杂度是O(m + n)，find函数的其他实现方法时间复杂度大抵也是O(m + n)。</p><h4 id="KMP解法"><a href="#KMP解法" class="headerlink" title="KMP解法"></a>KMP解法</h4><p>KMP算法的应用场景：模式串是否在文本串中出现过，即上面的find函数的一种实现方式。</p><p>前缀：不包含尾字母，一定包含首字母的所有子串。<br>后缀：包含尾字母，不包含首字母的所有子串。</p><p>结论：若s由重复子串组成，那么它的最小重复单位就是它的最长相等前后缀不包含的那个子串。后缀不包含和前缀不包含的部分是相同的，都是最小重复子串。</p><p>举例：abababab，最长相等前缀是ababab，最长相等后缀是ababab，剩余的部分ab即为最小重复子串。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728205249.png" alt="图三"></p><p>推导：设原字符串是s，标出其下标；设最长相等前缀是t，最长相等后缀是f，也分别标出下标。利用最长相等前缀和最长相等后缀的下标之间的对应关系和最长相等前后缀和原字符串下标之间的对应关系推导即可。</p><p>实现：设s存在最小重复单位，len为s的长度，则<code>next[len - 1]</code>为s的最长相等前后缀的长度，最小重复单位的长度为：<code>len - next[len - 1]</code>，若该长度能被原字符串的长度整除：<code>len % (len - next[len - 1]) == 0</code>，那么return true。有如下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求next数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span> <span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 处理前后缀不相同的情况</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理前后缀相同的情况</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新next数组</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span> <span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next, s);</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 核心代码</span></span><br><span class="line">        <span class="keyword">if</span> (next[len - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; len % (len - (next[len - <span class="number">1</span>] )) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="28-实现-strStr-1"><a href="#28-实现-strStr-1" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p>直接听卡尔讲，尝试去理解，不要求独立写出代码。</p><h3 id="459-重复的子字符串-1"><a href="#459-重复的子字符串-1" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><p>直接听卡尔讲，尝试去理解，不要求独立写出代码。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="28-实现-strStr-2"><a href="#28-实现-strStr-2" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p>因为KMP算法很难，大家别奢求一次就把kmp全理解了，大家刚学KMP一定会有各种各样的疑问，先留着，别期望立刻啃明白，第一遍了解大概思路，二刷的时候，再看KMP会懂很多。或者说大家可以放弃一刷可以不看KMP，今天来回顾一下之前的算法题目就可以。</p><p>因为大家算法能力还没到，细扣很难的算法，会把自己绕进去，就算别人给解释，只会激发出更多的问题和疑惑。所以大家先了解大体过程，知道这么回事， 等自己有算法基础和思维了，在看多看几遍视频，慢慢就理解了。</p><h3 id="459-重复的子字符串-2"><a href="#459-重复的子字符串-2" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><p>本题算是KMP算法的一个应用，不过对KMP了解不够熟练的话，理解本题就难很多。 </p><p>建议是 <strong>KMP和本题，一刷的时候 ，可以适当放过，了解怎么回事就行，二刷的时候再来硬啃</strong></p><h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="28-实现-strStr-3"><a href="#28-实现-strStr-3" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><ol><li>我觉得KMP算法很想一种特殊的双指针算法。一个指针i用于遍历文本串，另一个指针j用于根据next数组的指引在模式串中移动。这种双指针算法可以把时间复杂度从暴力算法的O(n * m)优化为O(n + m)。</li><li>代码分为独立的两部分，第一部分是求next数组（即前缀表），第二部分是同时在两个字符串中移动指针并使用next数组。</li><li>当模式串为空时，应当返回0。因为空字符串被认为是任何字符串的子串，所以文本串中最开始与模式串匹配的字符的索引就是0。如果文本串中不存在与之匹配的模式串，则返回 -1。</li></ol><h3 id="459-重复的子字符串-3"><a href="#459-重复的子字符串-3" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><ol><li>本题有两种解法：移动匹配和KMP解法。如果忘记了KMP算法的next数组怎么写，可以使用移动匹配方法（最难写的KMP部分可以用find函数来代劳）。</li><li>注意string中find函数的用法：在 find() 函数中，如果没有找到匹配的子串，则返回 string::npos。</li><li>本题的KMP解法的关键在于结论：若s由重复子串组成，那么它的最小重复单位就是它的最长相等前后缀不包含的那个子串。</li></ol><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><h3 id="字符串总结"><a href="#字符串总结" class="headerlink" title="字符串总结"></a>字符串总结</h3><p>常见题型和常用方法：</p><ol><li>花式反转字符串（整体&amp;局部反转，有时还要搭配双指针算法删除空格）</li><li>后续处理字符串</li><li>KMP算法（匹配模式串和文本串）</li><li>移动匹配（核心也是KMP算法，只不过核心由库函数find实现）</li></ol><p>小知识：</p><ol><li>substr，split，reverse, erase这四个库函数的时间复杂度都是O(n)，在循环中使用会使得程序的时间复杂度达到O(n^2)。此时需要双指针算法等进行优化。</li><li>字符串本质为字符数组，数据结构基本等用于普通数组，因此普通数组中常用的双指针算法也常用于字符串中。</li></ol><h3 id="双指针总结"><a href="#双指针总结" class="headerlink" title="双指针总结"></a>双指针总结</h3><p>双指针应用于：</p><ol><li>数组：移除元素</li><li>字符串：反转字符串、替换数字、翻转字符串里的单词</li><li>链表：反转链表、环形链表II</li><li><p>哈希表章节：三数之和、四数之和，两数之和若要求返回两数的值而非索引，也可以用双指针做，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 存储结果</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 先排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] + nums[right] &gt; target) right -- ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) left ++ ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;nums[left], nums[right]&#125;); <span class="comment">// 收获答案</span></span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left ++ ;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right -- ;</span><br><span class="line">            <span class="comment">// 寻找新的答案</span></span><br><span class="line">            left ++ ;</span><br><span class="line">            right -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码本质上就是三数之和、四数之和的一部分（for循环中的while循环）。相比于两数之和的哈希写法，新增了值去重的功能。</p><p>双指针的题目中，以三数、四数之和以及反转链表最容易写错，一定要多复习。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html</summary>
      
    
    
    
    <category term="算法（字符串）" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="总结" scheme="http://example.com/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="KMP算法" scheme="http://example.com/tags/KMP%E7%AE%97%E6%B3%95/"/>
    
    <category term="find函数" scheme="http://example.com/tags/find%E5%87%BD%E6%95%B0/"/>
    
    <category term="移动匹配" scheme="http://example.com/tags/%E7%A7%BB%E5%8A%A8%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Day 8 | Leetcode 344, 541, k54, 151, k55</title>
    <link href="http://example.com/2024/02/01/Day-8-Leetcode-344-541-k54-151-k55/"/>
    <id>http://example.com/2024/02/01/Day-8-Leetcode-344-541-k54-151-k55/</id>
    <published>2024-02-01T07:17:56.000Z</published>
    <updated>2024-02-03T07:49:42.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">344.反转字符串</a><br><a href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">541. 反转字符串II</a><br><a href="https://programmercarl.com/kama54.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html">卡码网：54.替换数字</a><br><a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">151.翻转字符串里的单词</a><br><a href="https://programmercarl.com/kama55.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html">卡码网：55.右旋转字符串</a></p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p>一般来说，编程语言自己实现的库函数都是左闭右开的，因此<code>reverse(s, i, i + k)</code>表示的是反转字符串s的第i位到第i + k位，不包含第i + k位。</p><h3 id="卡码网：54-替换数字"><a href="#卡码网：54-替换数字" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><ol><li>注意，cpp中比较大小不能写作<code>48 &lt;= s[i] &lt;= 57</code>，而是要写作<code>s[i] &gt;= 48 &amp;&amp; s[i] &lt;= 57</code>。表达式<code>48 &lt;= s[i] &lt;= 57</code>实际上会先计算<code>48 &lt;= s[i]</code>，这个表达式的结果是一个布尔值<code>true</code>或<code>false</code>，在C++中，这个布尔值会被隐式转换为整数，<code>true</code>转换为<code>1</code>，<code>false</code>转换为<code>0</code>。然后，该整数（<code>0</code>或<code>1</code>）会与<code>57</code>进行比较，所以条件几乎总是为真（除非<code>s[i]</code>是字符<code>&#39;0&#39;</code>）。</li><li>扩容字符串的函数为<code>resize</code>函数。</li><li>cpp中是可以不遍历字符串中的每个字符，就直接cout输出整个字符串的。</li><li>字符串和数组的区别（摘自代码随想录）：<br>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，接下来我来说一说C/C++中的字符串。<br>在C语言中，把一个字符串存入一个数组时，也把结束符 ‘\0’存入数组，并以此作为该字符串是否结束的标志。<br>在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，<strong>就不用’\0’来判断是否结束</strong>。<br>那么vector&lt; char &gt; 和 string 又有什么区别呢？<br>其实在基本操作上没有区别，但是<strong>string提供更多的字符串处理的相关接口</strong>，例如string 重载了+，而vector却没有。所以想处理字符串，我们还是会定义一个string类型。</li><li>若要求某个字符在0-9之间，既可以写<code>s[i] &gt;= 48 &amp;&amp; s[i] &lt;= 57</code>（’0’的ascii码是48，’1’的ascii码是57），也可以写<code>s[i] &gt;= &#39;0&#39; &amp;&amp; s[i] &lt;= &#39;9&#39;</code>。</li></ol><h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><ol><li>erase函数的时间复杂度是O(n)</li><li>本题可以用split函数来从字符串中分割出单词，但那样就失去了意义</li><li>若给一个函数传入的参数加上引用<code>&amp;</code>，那么在函数中对这个参数进行了修改，调用该函数后该参数也会被修改。</li></ol><h3 id="卡码网：55-右旋转字符串"><a href="#卡码网：55-右旋转字符串" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h3><ol><li>注意：若在ACM模式中调用<code>reverse</code>函数，必须<code>#include &lt;algorithm&gt;</code>，否则会报错。但若调用<code>swap</code>函数，不需要引用任何头文件，直接使用即可。</li></ol><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>先尝试用reverse函数秒杀，顺便复习reverse函数的用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>reverse函数相当于把字符串反转以后，将新的字符串存入了旧的字符串中。</p><p>我曾经做过反转链表的题，猜测用双指针可以解决这道题。写下了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = s.<span class="built_in">size</span>() - <span class="number">1</span>; l &lt; r; l ++ , r -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// swap(s[l], s[r]);</span></span><br><span class="line">            <span class="type">int</span> tmp = s[l];</span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>直接用swap函数或者手写swap函数都是可以的。<code>l &lt; r</code>或者<code>l &lt;= r</code>都可以。因为字符串中字符的个数为奇数时，中间那个字符交换不交换都一样；字符个数为偶数时，交换最后两个成对的字符即可。</p><h3 id="541-反转字符串II-1"><a href="#541-反转字符串II-1" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p>拿到这道题，我的第一想法是分类讨论。设字符串的长度是<code>len</code>。若<code>len &lt; k</code>，则全部反转；若<code>k &lt;= len &lt; 2k</code>，则反转前k个字母；若<code>len &gt;= 2k</code>，则按照题意反转。本题在反转的逻辑上没有困难，但问题在于如何分割出需要反转的子字符串。我没想出来什么好办法，写的逻辑太复杂又容易出错。</p><h3 id="卡码网：54-替换数字-1"><a href="#卡码网：54-替换数字-1" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><p>我先输入字符串s，然后定义每个元素由char类型变量组成的vector。遍历字符串s，若其中的某个字符的ascii码在48-57之间，说明该字符是数字0-9，那么向vector中依次插入number这6个字符。其他情况下，向vector中插入原始字符即可。据此思路写下以下的代码，可以通过评测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="number">48</span> &amp;&amp; s[i] &lt;= <span class="number">57</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            out.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; out.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        cout &lt;&lt; out[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="151-翻转字符串里的单词-1"><a href="#151-翻转字符串里的单词-1" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p>这道题yxc应该讲过,要么通过流的方式读入为一个个单词，样例代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span> <span class="comment">// 引入 stringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line); <span class="comment">// 使用 getline 读取一整行</span></span><br><span class="line"></span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(line)</span></span>; <span class="comment">// 使用 stringstream 来分割字符串</span></span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; word) &#123; <span class="comment">// 从 stringstream 中读取单词，直到结束</span></span><br><span class="line">        cout &lt;&lt; word &lt;&lt; endl; <span class="comment">// 输出单个单词</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>要么通过双指针算法找出一个个单词并存储之。然后再将一个个单词逆序拼接为字符串并输出。我先尝试后一种方法。但没有做出来。</p><h3 id="卡码网：55-右旋转字符串-1"><a href="#卡码网：55-右旋转字符串-1" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h3><p>本题我下意识地使用substr来写，得到如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    string s1 = s.<span class="built_in">substr</span>(s.<span class="built_in">size</span>() - k, s.<span class="built_in">size</span>()); <span class="comment">// 后面k个字符</span></span><br><span class="line">    string s2 = s.<span class="built_in">substr</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - k); <span class="comment">// 字符串在后面k个字符前的字符</span></span><br><span class="line">    cout &lt;&lt; s1 + s2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>向substr中传入的区间是左闭右开的。</p><p>若不借助库函数，我还有一个想法。先拿一个字符串保存输入字符串的后面k个字符。然后在输入字符串的基础上，从尾部倒着插入前面的那些字符，最后再将另一个字符串保存的原字符串的后面k个字符插到新字符串的前面去。其实倒着插入和顺着插入也没什么区别。</p><p>我还想到一种做法。受到151. 翻转字符串里的单词启发，首先反转整个字符串，然后反转字符串的前k位，最后反转字符串的后(n - k)位。由此写出了两个版本的代码，第一版是直接调用reverse函数，第二版是手动实现reverse函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + k);</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + k, s.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动实现reverse函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(string &amp;s, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = i, b = j; a &lt; b; a ++ , b -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = s[a];</span><br><span class="line">        s[a] = s[b];</span><br><span class="line">        s[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverseString</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverseString</span>(s, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverseString</span>(s, k, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="344-反转字符串-1"><a href="#344-反转字符串-1" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>在算法的思路上，字符串和数组非常类似。本题应用双指针法即可：首尾交换，再次一级交换，以此类推。因此首尾各有一个指针，两指针交换，然后两指针同时向中间移动。若库函数直接把题目解决了，就不要用库函数。若库函数是题目的一部分，且我们知道库函数的大体实现逻辑和时间复杂度，那就可以用。代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>() / <span class="number">2</span>; i ++ , j -- )</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>swap函数有两种方法，一种是常见的交换数值，另一种是位运算，可参见代码随想录。</p><h3 id="541-反转字符串II-2"><a href="#541-反转字符串II-2" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p>模拟题，模拟复杂的规则下，如何反转字符串。题意：每2k段的前k个字符进行反转，尾部如果剩下的字符超过长度超过k，则反转k个字符，剩下的不动。尾部如果剩下的字符长度小于k，则全部反转。本题的代码可以很简洁。</p><p>本题每次取2k段，因此按照2k来遍历：<code>for (int i = 0; i &lt; s.size(); i += 2k)</code>。然后在for循环中操作前k个字符即可。边界条件想不明白可以带一个具体的例子来试。代码和注释如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每隔2k个字符跳转一次，即每次取出2k个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += <span class="number">2</span> * k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对2k个字符的前k个字符进行反转</span></span><br><span class="line">            <span class="comment">// 由于每次取2k，取若干次后。字符串的尾部剩下的字符长度l可能l &lt; k 或 k &lt;= l &lt; 2k</span></span><br><span class="line">            <span class="comment">// 对前一种情况，需要将尾部全部反转，对后一种情况，需要反转尾部剩下字符的前k个字符</span></span><br><span class="line">            <span class="comment">// 先处理后一种情况，注意加上条件i + k &lt;= s.size()，这可以避免对索引超出范围的元素进行反转</span></span><br><span class="line">            <span class="comment">// 至于i + k是否能取到s.size()，可以举例子：k = 3, s = &#123;a, b, c&#125;，由此可见可以取等于</span></span><br><span class="line">            <span class="comment">// 也可以从理论上分析，由于reverse的区间是左闭右开的，因此s.begin() + i + k实际上取不到，因此可以让i + k = s.size() </span></span><br><span class="line">            <span class="comment">// 处理完后continue即可，除去反转2k个字符中的前k个字符的一般情况，尾部剩下的字符的长度的第一种情况和第二种情况只可能有一种发生</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k); <span class="comment">// 左闭右开</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再处理前一种情况，当剩余的字符长度l &lt; k时，反转剩余的全部字符</span></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>也可以不用continue，直接采用if-else写法，参见代码随想录的写法（代码随线录的注释也更加简洁明了）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="卡码网：54-替换数字-2"><a href="#卡码网：54-替换数字-2" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><p>本题的最佳解法不需要额外的辅助空间。首先扩充原字符串到每个数字字符替换成 “number” 之后的大小。然后用<strong>双指针算法</strong>，指针i指向旧字符串的末尾，指针j指向新字符串的末尾。用指针i遍历旧字符串，若遇到字母，则原样填入指针j指向的位置；若遇到数字，则从后往前将number填入到指针j指向的位置。直到i和j都指向新旧字符串的开头为止。这里的新旧字符串其实是扩容之后和扩容之前的同一字符串，只是为了方便区分称它们为新旧字符串。根据这个思路，我写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// count为字符串中数字的数量</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="number">48</span> &amp;&amp; s[i] &lt;= <span class="number">57</span>)</span><br><span class="line">            count ++ ;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> oldSize = s.<span class="built_in">size</span>();</span><br><span class="line">    s.<span class="built_in">resize</span>(oldSize + count * <span class="number">5</span>); <span class="comment">// 字符串扩容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双指针算法，i指向旧字符串，j指向新字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = oldSize - <span class="number">1</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &lt; <span class="number">48</span> || s[i] &gt; <span class="number">57</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            s[j] = s[i];</span><br><span class="line">            i -- ;</span><br><span class="line">            j -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[j] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">3</span>] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">4</span>] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">5</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">            i -- ;</span><br><span class="line">            j -= <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以直接写作cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        cout &lt;&lt; s[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码随想录的代码本质上和我写的是一样的，但他写的更见简洁一些，我写的更易于理解一些。</p><p>我的写法中，必须让<code>i &gt;= 0</code>，不能写成<code>i &gt; 0</code>，否则答案错误。例子，输入1，输出本来应该为number，若for循环的条件为<code>i &gt; 0</code>，则不会进入for循环，直接输出1，这显然是不对的。但对于代码随想录的写法：<code>for (int i = sNewSize - 1, j = sOldSize - 1; j &lt; i; i--, j--)</code>，则<code>j &lt; i</code>是正确的，若首字符为字母，则j = i时两指针均以指向首字符，首字符保留即可，不需要处理；若首字符为数字，则逻辑也可以正确执行。若<code>j &lt;= i</code>，则反而会出现越界的问题，因为当j和i都指向首字符后，for循环的条件依然满足，此时完成当前循环后，i和j继续-1，再次判断时，i依然等于j，再次进入循环，此时s[i]和s[j]就不存在了（s[-1]不存在）。</p><h3 id="151-翻转字符串里的单词-2"><a href="#151-翻转字符串里的单词-2" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p>是字符串中操作比较复杂的题目，给的字符串中在开头、中间、结尾都可能有空格。反转字符串里的单词后，要将多余的空格都删掉。</p><p>整体思路：先让单词的顺序和目标相同，即将整个字符串都反转。再对每个单词做反转，就得到了目标字符串。<strong>将原字符串整体反转，再将每一个单词反转</strong>。</p><p>难点：如何删去多余的空格。要求空间复杂度O(1)，即不能申请新的字符串来放置删去多余空格后的字符串。且不能使用库函数。使用快慢双指针算法，删除多余空格的时间复杂度为O(n)。<strong>快指针用于遍历旧字符串，慢指针用于依次指向新字符串中的各个元素</strong>。（新字符串在旧字符串的基础上修改，并不需要另外创建字符串来存储新字符串）。双指针的用法同数组章节的移除元素。</p><p>根据上述思路，我写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpace</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; s.<span class="built_in">size</span>(); fast ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[fast] != <span class="string">&#x27; &#x27;</span>) <span class="comment">// 去除字符串开头的空格</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每复制完一个单词后，加一个空格</span></span><br><span class="line">                <span class="comment">// 这句话不可以放在while循环后，否则会在最后一个单词后面增加一个多余的空格</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow ++ ] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将旧字符串的非空部分复制到新字符串中</span></span><br><span class="line">                <span class="keyword">while</span> (fast &lt; s.<span class="built_in">size</span>() &amp;&amp; s[fast] != <span class="string">&#x27; &#x27;</span>) s[slow ++ ] = s[fast ++ ];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpace</span>(s); <span class="comment">// 删去所有多余的空格</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); <span class="comment">// 反转整个字符串，注意reverse函数是左开右闭的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转每个单词</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) i ++ ; <span class="comment">// 找到空格</span></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + start, s.<span class="built_in">begin</span>() + i); <span class="comment">// 反转start到空格之间的单词</span></span><br><span class="line">            start = i + <span class="number">1</span>; <span class="comment">// 更新start</span></span><br><span class="line">            i = start; <span class="comment">// 更新i</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>代码随想录中的反转每个单词的写法和我的略有不同，他用的是for循环，但本质是一样的。</p><h3 id="卡码网：55-右旋转字符串-2"><a href="#卡码网：55-右旋转字符串-2" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h3><p>我在初次尝试中已经给出了空间复杂度为O(1)的最优解法，下面两幅图（对应两种等效的方法）可以帮助理解：</p><ol><li><p>先反转整个字符串，再反转两个子串</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20231106172058.png" alt="img"></p></li><li><p>先反转子串，再反转整个字符串</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20231106172534.png" alt="img"></p></li></ol><h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="344-反转字符串-2"><a href="#344-反转字符串-2" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>两种for循环的写法：<code>for (int i = 0, j = s.size() - 1; i &lt; s.size() / 2; i ++ , j -- )</code>和<code>for (int l = 0, r = s.size() - 1; l &lt; r; l ++ , r -- )</code>都可以。</p><h3 id="541-反转字符串II-3"><a href="#541-反转字符串II-3" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><ol><li>for循环每次以2k为长度去跳转</li><li><p>本题反转字符的<strong>三种情况</strong>：</p><ul><li>每隔 2k 个字符的前 k 个字符进行反转</li><li>剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</li><li>剩余字符少于 k 个，则将剩余字符全部反转</li></ul><p>三种情况每次只可能出现一种，即出现了一种情况，另外两种情况就不会出现了。据此，我写出了<strong>结构分明的三段式代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += <span class="number">2</span> * k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 情况1</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">2</span> * k &lt;= s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 可以省略</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 可以省略</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况3</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>情况1和情况2可以合并（即剩余字符的长度l满足l &gt;= k时，都是反转剩下字符的前k个；只有当l满足l &lt; k时，才要反转剩下的所有字符），因此产生了实现部分中的第二版代码。每次思考时应该先想到三种情况，再写出结构分明的三段式代码，然后对其进行简化。<strong>能够写出三段式代码即可，虽然不简洁但思路清晰简单、不容易出错</strong>。</p></li><li>如果要求一段段地操作字符串或数组，那么for循环中的i变量是可以一段段增加的，而没必要每次+1</li></ol><h3 id="卡码网：54-替换数字-3"><a href="#卡码网：54-替换数字-3" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><ol><li>本题注意使用<strong>双指针做法</strong>。代码推荐参考我在实现中的写法，虽然和代码随想录的代码略有差别，但本质是完全一样的。</li><li>本题注意考虑边界条件，在我的写法中，是<code>i &gt;= 0</code>而非<code>i &gt; 0</code>；在代码随想录的写法中，是<code>j &lt; i</code>而非<code>j &lt;= i</code>。如果边界条件写得不对会导致发生指针异常或者部分样例无法通过。考虑边界条件时，可以举特例，也可以让代码先运行，若发生错误则修改相应的边界条件。</li><li><p><strong>很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong>对于线性数据结构，填充或者删除，后序处理会高效的多。</p><p>这么做有两个好处：</p><ol><li>不用申请新数组。算法的空间复杂度从O(N)降到了O(1)。</li><li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。算法的时间复杂度从O(n^2)降到了O(n)。</li></ol></li></ol><h3 id="151-翻转字符串里的单词-3"><a href="#151-翻转字符串里的单词-3" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><ol><li>本题的总体思路：移除多余的空格-&gt;反转整个字符串-&gt;反转字符串中的每个单词</li><li>利用快慢双指针移除多余的空格有两种写法，一种较为复杂，需要分别移除字符串前面的空格和字符串中间和最后的连续的不止一个的空格，最后再移除字符串最后可能存在的一个空格。<strong>另一种较为简单，思路和<a href="https://programmercarl.com/0027.移除元素.html">27.移除元素</a>是相同的</strong>。<strong>快指针用于遍历旧字符串，慢指针用于依次指向新字符串中的各个元素</strong>。时间复杂度O(n)</li><li><strong>推荐使用较为简单的双指针写法</strong>。除去从旧字符串中复制每个单词到新字符串中的代码，还需要加上用于在新字符串中添加每个单词尾部的空格的代码。<strong>注意这两行代码的顺序不能写反，必须是先有添加空格的代码，再有复制单词的代码，否则会导致在新字符串的末尾多添加一个空格</strong>。</li><li>上面提到的新旧字符串只是有时间上的先后，没有空间上的拷贝。新字符串就是在旧字符串的基础上利用双指针算法通过删除和改动部分元素得到的。因此空间复杂度为O(1)。</li></ol><h3 id="卡码网：55-右旋转字符串-3"><a href="#卡码网：55-右旋转字符串-3" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h3><ol><li>本题加上限制条件：不能申请额外空间，只能在本串上操作（对cpp）。</li><li>可以先反转总串，再反转子串；也可以先反转子串，再反转总串。</li><li>右旋转字符串和左旋转字符串方法完全相同，就是反转的区间不同。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E</summary>
      
    
    
    
    <category term="算法（字符串）" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="双指针算法" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    
    <category term="花式反转字符串" scheme="http://example.com/tags/%E8%8A%B1%E5%BC%8F%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Day 7 | Leetcode 454, 383, 15, 18</title>
    <link href="http://example.com/2024/01/31/Day-7-Leetcode-454-383-15-18/"/>
    <id>http://example.com/2024/01/31/Day-7-Leetcode-454-383-15-18/</id>
    <published>2024-01-31T02:07:29.000Z</published>
    <updated>2024-02-04T16:25:39.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">454.四数相加II</a><br><a href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">383. 赎金信</a><br><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15. 三数之和</a><br><a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">18. 四数之和</a><br><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%BB%E7%BB%93.html">哈希表总结篇</a></p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><p>cpp中的map中的value是支持++操作的，且value可以通过key直接索引到，就像普通的数组那样。</p><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><ol><li><p>不仅对vector可以用范围遍历，对string类型的变量和普通的数组也可以用范围遍历的写法来简化代码。似乎范围遍历的速度要稍快于普通的for循环遍历。</p></li><li><p>cpp中，可以用erase函数来删除string类型变量的第j个字符，有两种写法：<br><code>string.erase(j, 1);</code><br><code>string.erase(s.begin() + j);</code></p></li><li><p>cpp中，如果想使用变量类型来给变量命名，需要使用std，有如下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set; <span class="comment">// 使用 &quot;set&quot; 作为变量名</span></span><br><span class="line">    set.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    set.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>set</code>是作为<code>std::set&lt;int&gt;</code>类型的变量名使用的。由于<code>std::set</code>是在<code>std</code>命名空间中定义的，而变量<code>set</code>是在局部作用域中定义的，所以编译器能够区分这两者。</p></li></ol><h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><ol><li>将四数之和由int类型转换为long类型：<code>(long) nums[i] + nums[j] + nums[l] + nums[r] &gt; target</code></li></ol><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="454-四数相加II-1"><a href="#454-四数相加II-1" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><p>这道题肯定是要用map做哈希的，且map的key用来存储元素的值，map的value用来存储元素的索引。此题和两数之和为target有较多的相同点，但也有些不同。若四个数相加为0，则其中的数两两互为相反数。但这种想法是不对的，可以存在2, 4, -3, -3的情况。对这题的算法我暂时想不出来什么好主意。</p><h3 id="383-赎金信-1"><a href="#383-赎金信-1" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p>看着就是242.有效的字母异位词的变式，若前面那个字符串可以由后面那个字符串中的字母构成，则返回true，否则返回false。本质就是看后面的字符串是否包含前面的字符串。因为两个字符串都只是由小写字母构成，因此用数组做哈希足矣。根据这个思路，我写出了如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本题的本质是判断后面的字符串是否包含前面的字符串，即后面的字符串中出现的所有字符是否在前面的字符串中出现过</span></span><br><span class="line">        <span class="type">int</span> N[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ransomNote.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            N[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            N[magazine[i] - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 数组N中有元素大于0，说明ransomNote中出现了magazine中未出现的字母</span></span><br><span class="line">        <span class="comment">// 说明前者不能完全由后者组成，返回false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (N[i] &gt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>采用范围遍历的方法，可以把上述代码写得更简洁：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ransomNote &lt; magazine return true</span></span><br><span class="line">        <span class="comment">// else return false</span></span><br><span class="line">        <span class="type">int</span> N[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> r: ransomNote)</span><br><span class="line">            N[r - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> m: magazine)</span><br><span class="line">            N[m - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: N)</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><p>这道题的题目我都不太理解，什么叫答案中不可以包含重复的三元组。直到我看到了示例1，明白了这个意思是可能存在情况：两个三元组，它们的索引组成的三元组可能不同，但这两个三元组本身的数值是完全相同的（忽略顺序），此时这两个三元组只能算作一个。这道题应该可以用哈希法，但需要去重。本题我认为有三个难点：</p><ul><li>枚举完一个数，怎么去寻找另外两个数</li><li>用什么数据结构维护另外两个数</li><li>如何去重</li></ul><h3 id="18-四数之和-1"><a href="#18-四数之和-1" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><p>本题应该依然是双指针算法。但需要注意去重的操作。我的思路是先对数组进行排序，然后让<code>a = i, b = i + 1, c = i + 2, d = nums.size() - 1</code>。然后一边向后移动a, b和c，一边对a,b和c去重，一边向前移动d，一边对d去重。根据以上思路，我写下了以下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="comment">// 对i去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 对j去重</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left = j + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[left] + nums[right] &gt; target) right -- ;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[left] + nums[right] &lt; target) left ++ ;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对left和right进行去重</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left ++ ;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right -- ;</span><br><span class="line">                        left ++ ;</span><br><span class="line">                        right -- ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上代码测试样例通过了229 / 294，可见思路是对的，但细节仍不完美。我将在实现部分进一步优化细节。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="454-四数相加II-2"><a href="#454-四数相加II-2" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><p>四数相加和四数之和题目看起来相似，但前者是哈希表中的经典题目，后者用哈希表的方法不太合适。其实只需要知道有多少对四数之和为0，不需要知道每一对的具体数值。</p><p><strong>本题不需要去重</strong>，因此相对简单，四数之和则需要考虑去重。举例：四个数组，每个数组中都有n个0，则返回的结果是n。</p><p><strong>思路</strong>：遍历数组A和B，将从这两个数组取出的元素a + b放入map中；再遍历数组C和D，求得c + d，再判断map中有无我们想要的元素-(c + d)，有则count += -(c+d)出现过的次数（即map中key为-(c+d)的元素的value）。</p><p>本题的数据范围很大，因此用数组来做哈希不可取，只能考虑set/map。<strong>因为不仅需要将a + b放入哈希结构中，还需要统计a + b出现过多少次，因此用map</strong>。用map的key存a + b的值，用map的value存a + b出现的次数。</p><p>时间复杂度：<code>O(n^2) + O(n^2)</code>，还是<code>O(n^2)</code>。如果先遍历一个数组，再遍历三个数组，则时间复杂度是O(n^3)。</p><p>我知道上述思路后，尝试写代码，出现一个问题：不知道如何统计数组A和数组B中各取一个元素求和后的值出现的次数。我把简单的问题想复杂了，map中的value是支持++操作的，且value可以通过key索引到，因此直接：<code>map[num1 + num2] ++ ;</code>即可，这个代码的意思是：若<code>num1 + num2</code>的值出现过，则其<code>value += 1</code>；若没出现过，则相当于：<code>map.insert(&#123;num1 + num2, 1&#125;)</code>。写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历nums1和nums2数组，将两个数组各取一个值的和作为key，和出现的次数作为value存入map中</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num1: nums1)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num2: nums2)</span><br><span class="line">                sum[num1 + num2] ++ ; <span class="comment">// 和为num1 + num2的值的出现次数 + 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历nums3和nums4数组，设两个数组各取一个值的和是c + d</span></span><br><span class="line">        <span class="comment">// 若map中出现了-(c + d)，则count += value</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num3: nums3)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num4: nums4)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> s = num3 + num4;</span><br><span class="line">                <span class="keyword">auto</span> it = sum.<span class="built_in">find</span>(-s);</span><br><span class="line">                <span class="keyword">if</span> (it != sum.<span class="built_in">end</span>())</span><br><span class="line">                    count += it-&gt;second; <span class="comment">// it-&gt;second也可以写作sum[-s]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>更简洁的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num1: nums1)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num2: nums2)</span><br><span class="line">                map[num1 + num2] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num3: nums3)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num4: nums4)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> target = -(num3 + num4);</span><br><span class="line">                <span class="keyword">if</span> (map.<span class="built_in">find</span>(target) != map.<span class="built_in">end</span>())</span><br><span class="line">                    count += map[target];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="383-赎金信-2"><a href="#383-赎金信-2" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p>注意，本题的题干中虽然强调了<code>Each letter in magazine can only be used once in ransomNote</code>，但这个条件在写代码时实际上并不需要考虑。这应该只是生成测试样例时需要遵守的规则。</p><p>本题用暴力做法也可以过，但暴力做法的代码写起来似乎还更麻烦一点。暴力做法就是两重for循环，若ransomNote中出现了magazine中出现过的字符，则从ransomNote中移除该字符，最后判断ransomNote的长度是否为0即可。暴力做法的代码可以参见代码随想录。</p><p>至于时间复杂度为O(n)的哈希解法，我在初次尝试中写的就已经很完美了。若想进一步优化，可以加上判断：若ransomNote的长度大于magazine的长度，则可以直接return false。若在遍历字符串时就对数组中元素的正负进行判断，那需要注意：只能在ransomNote中对数组中元素的正负进行判断，为负则说明赎金信中有magazine中没有的字符。若在magazine中对数组中元素的正负进行判断，可能存在问题：数组中的元素为正不一定代表赎金信中有magazine中没有的字符，可能仅仅是因为尚未遍历完成，数组中的元素还没被减到负数。因此，下面的代码是错误的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> r: ransomNote)</span><br><span class="line">            N[r - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> m: magazine)</span><br><span class="line">        &#123;</span><br><span class="line">            N[m - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">            <span class="keyword">if</span> (N[m - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以通过测试样例轻而易举地看出上述解法的漏洞，比如<br>ransomNote =”aa”<br>magazine =”aab”<br>Output false<br>Expected true<br>而代码随想录上的哈希解法的代码是正确的。</p><p>若想避免上述问题，最直接的办法就是等到N数组中的元素全部计算完成后，另开一个循环来判断其中是否有为正的元素。</p><h3 id="15-三数之和-1"><a href="#15-三数之和-1" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><p>本题可以用哈希法做，但比较复杂。本题需要返回的三元组，其中的元素是数组中元素的值，而非下标。<strong>注意：三元组是去重的。本题相较于两数之和的难点就在于去重</strong>。</p><p>哈希法的大致思路：用两重for循环，第一重确定a，第二重确定b，然后看-(a + b)是否在map中出现过。但这里的难点在于：需要同时对a, b和c（-a - b）去重。去重的细节太多了，基本上都会遇到小问题，难以一次想周全。<strong>因此推荐使用更易于理解的双指针法</strong>。</p><p>双指针法的思路：<strong>使用双指针法之前需要对数组进行排序</strong>。for循环遍历数组，得到a；left指针从数组的第2个位置开始向后移动，得到b；right指针从数组的最后一个位置开始向前移动，得到c。若<code>num[i] + num[left] + num[right] &gt; 0</code>，说明三数之和大了，i是固定的（for循环从头开始遍历），因此应当让<code>right --</code>。若<code>num[i] + num[left] + num[right] &lt; 0</code>，说明三数之和小了，应该让其变大，则应当让<code>left ++</code>。若三数之和为0，则将三者放入二维数组res中。注意细节：去重。num[i], num[left], num[right]三个数都需要去重，因为res中不能有重复的三元组。</p><p>伪代码：（注：<code>a = num[i], b = num[left], c = num[right]</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 存储结果</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 排序后，若最小值仍大于0，说明不存在三数之和等于0的情况，返回现有的res即可</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// nums[i]即a，需要对a去重</span></span><br><span class="line">    <span class="comment">// 三元组之间不可重复，但三元组内部可以有重复的数字，比如000</span></span><br><span class="line">    <span class="comment">// 去重是nums[i] == nums[i + 1] continue还是nums[i] == nums[i - 1] continue</span></span><br><span class="line">    <span class="comment">// 应该是后者。若是前者，由于left指针指向nums[i + 1]，因此若b和a相同，则会跳过这个结果集，这显然是错误的</span></span><br><span class="line">    <span class="comment">// 因为三元组内部是可以有重复的数字的</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 当前三元组的a和上一个三元组的a重复，则进入下一个循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 求三个数，因此是left &gt; right。若left = right，则三个数变为了两个数</span></span><br><span class="line">    <span class="keyword">while</span> (right &gt; left)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right -- ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left ++ ;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;); <span class="comment">// 三者之和等于0.则放入结果数组中，收获结果</span></span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">while</span> (right &gt; left &amp;&amp; right[i] == right[i - <span class="number">1</span>]) right -- ; <span class="comment">// 对c去重</span></span><br><span class="line">        <span class="keyword">while</span> (right &gt; left &amp;&amp; left[i] == left[i + <span class="number">1</span>]) left ++  ; <span class="comment">// 对b去重</span></span><br><span class="line">            <span class="comment">// 收获一个结果后，left和right都向着数组的中间位置移动</span></span><br><span class="line">            left ++ ;</span><br><span class="line">            right -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>细节：</p><ul><li><p>如何对a去重：<code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</code></p></li><li><p>如何对b和c去重：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (right &gt; left &amp;&amp; right[i] == right[i - <span class="number">1</span>]) right -- ; <span class="comment">// 对c去重</span></span><br><span class="line"><span class="keyword">while</span> (right &gt; left &amp;&amp; left[i] == left[i + <span class="number">1</span>]) left ++  ; <span class="comment">// 对b去重</span></span><br></pre></td></tr></table></figure></li><li><p>对b和c去重的代码放在哪里<br> 必须先收获结果，再去重。否则若出现数组中全是0的情况，就会一直运行去重的逻辑，而不收获结果。</p></li></ul><p>根据上述伪代码，我独立写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 用双指针算法前需要先排序</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 二维数组，存放结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三元组&#123;a, b, c&#125;，i指向a, left指向b, right指向c</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若最小的a都大于0，则三数之和不可能等于0，不需要继续循环，返回现有的res即可</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对a去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right -- ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left ++ ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;); <span class="comment">// 收获结果</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 对b和c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left ++ ;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right -- ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 移动left和right指针</span></span><br><span class="line">                    left ++ ;</span><br><span class="line">                    right -- ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="18-四数之和-2"><a href="#18-四数之和-2" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><p>和三数之和思路相同，但多一重for循环。共有i, j, left, right四个指针，前三者初始时分别指向数组的前三个元素，right指向数组最后一个元素。left和right向中心靠拢，使得<code>nums[i] + nums[j] + nums[left] + nums[right] = target</code>。</p><p>细节：剪枝和去重。</p><ul><li>一级剪枝：不能延续三数之和的剪枝操作：<code>if(nums[i] &gt; target) return res;</code>。这没有考虑到数组中可能有负数的情况，若数组中有负数，几个元素相加是越加越小的，因此即使最小的数大于target，通过加上一些负数，四数之和依然可能为target。正确的剪枝操作应该为：<code>if (nums[i] &gt; target &amp;&amp; nums[i] &gt; 0 &amp;&amp; target &gt; 0) break;</code>。其实这里写break（即最后返回）和写return res都是可以的，并不会影响运行结果。</li><li>二级剪枝：<code>if (nums[i] + nums[j] &gt; target &amp;&amp; nums[i] + nums[j] &gt; 0 &amp;&amp; target &gt; 0) break;</code><strong>二级剪枝完成后只能写break，写return res会有几个测试样例无法通过</strong>。原因：一级剪枝条件时直接return res，相当于结束所有循环，返回结果，不会漏掉部分四元组；二级剪枝时直接return res，同样相当于结束所有循环，返回结果，此时就会漏掉部分四元组。<strong>正确的做法应该是结束第二重循环，继续进行第一重循环</strong>。</li></ul><p>其实还有一个细节需要注意，在求四数之和<code>nums[i] + nums[j] + nums[left] + nums[right]</code>时，若四个数都是10亿，加起来就会超过int的限制（大约21亿），因此需要把四数之和转化为<code>long</code>类型：<code>(long) nums[i] + nums[j] + nums[l] + nums[r] &gt; target</code>。如果不将int转换为long，会报错：整数溢出，同时有几个测试样例无法通过。代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a = i, b = j(i + 1), c = l(i + 2), d = r(nums.size() - 1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target &amp;&amp; target &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; <span class="comment">// 一级剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 一级去重</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] &gt; target &amp;&amp; target &gt; <span class="number">0</span> &amp;&amp; nums[i] + nums[j] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; <span class="comment">// 二级剪枝</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 二级去重</span></span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> l = j + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[j] + nums[l] + nums[r] &gt; target) r -- ;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[j] + nums[l] + nums[r] &lt; target) l ++ ;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[l], nums[r]&#125;);</span><br><span class="line">                        <span class="comment">// 对l和r去重</span></span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) l ++ ;</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) r -- ;</span><br><span class="line">                        l ++ ;</span><br><span class="line">                        r -- ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="454-四数相加II-3"><a href="#454-四数相加II-3" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><ol><li><p>本题的大体思路？<br>遍历前两个数组A和B，将a + b的值存入map<br>再遍历后两个数组C和D，在map中查找-(c + d)的值</p></li><li><p>为什么选择map做哈希？<br>因为不仅需要存储a + b的值，还需要存储这个值出现的次数(<code>map[a + b] ++</code>)，用于在4中统计元组的个数</p></li><li><p>map中的key放什么？value放什么？<br>map中的key放a + b的值，map中的value放这个值出现的次数</p></li><li><p>如何统计元组的个数？<br><code>count += map[-(c + d)]</code></p></li><li><p>如何统计a和b的和出现的次数？<br><code>map[a + b] ++</code></p></li></ol><h3 id="383-赎金信-3"><a href="#383-赎金信-3" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p>代码随想录上的哈希解法不如我在初次尝试部分写的哈希解法简洁，而且代码随想录的哈希解法在颠倒遍历两个字符串的顺序时容易出错。<strong>本题的最佳解法是我在初次尝试部分写的第二个版本的代码</strong>。</p><h3 id="15-三数之和-2"><a href="#15-三数之和-2" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><ol><li>采用双指针法，不要用哈希法，哈希法写起来复杂，去重麻烦、难以做剪枝操作，故效率显著低于双指针法</li><li>双指针法思路简单，但要注意去重的细节</li><li>排序的目的是方便剪枝，且一个三元组只会有唯一的顺序</li><li><strong>双指针法只适用于返回的结果是数而不是索引的题目</strong>，因为双指针法使用前必须对数组进行排序，排序后索引会被打乱，因此返回的结果不能是索引。若两数之和要求返回的结果是数，那么也可以用双指针算法。这不禁让我思考，若本题要求返回的结果是索引，那么也只能用哈希法。但如果要求返回的结果是索引，那么就不需要有复杂的去重操作，因此实际上是简化了本题。</li><li>对于<code>nums[i]</code>（即a）去重的代码，可以用if判断写：<code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</code>，也可以用while循环写：<code>while (i &lt; nums.size() &amp;&amp; i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) i ++ ;</code>。一般在写while循环时，都需要加上<strong>对数组索引不可越界的限制</strong>：<code>i &lt; nums.size()</code>。如果出现报错：<code>Runtime Error: AddressSanitizer</code>，大概率是因为数组索引越界了，此时需要检查是否加上了限制条件<code>i &lt; nums.size()</code>和<code>i &gt; 0</code>。</li></ol><h3 id="18-四数之和-3"><a href="#18-四数之和-3" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><ol><li>本题思路和三数之和相同，但需要注意剪枝的细节</li><li>还需要注意在求四数之和时将int类型转换为long类型，避免整数溢出。</li><li>若采用双指针算法，三数之和的时间复杂度是<code>O(n^2)</code>，四数之和的时间复杂度是<code>O(n^3)</code>。用暴力做法的时间复杂度则分别为<code>O(n^3)</code>和<code>O(n^4)</code>。</li><li>本题相比于四数相加，由于要考虑去重问题，所以更加复杂，因此无法（不推荐）使用哈希法，推荐使用双指针算法。</li><li>剪枝方面可以做进一步的优化，但属实没有必要。</li><li>本题写剪枝统一用break，不要用return res，以免方式意外的错误</li><li>本题如果有几个测试样例总是过不了，可以直接删去剪枝的代码，一般就可以通过了。剪枝是优化，即使不加，依然可以轻松通过。剪枝部分是易错点。</li></ol><h2 id="哈希表总结"><a href="#哈希表总结" class="headerlink" title="哈希表总结"></a>哈希表总结</h2><ol><li>哈希表的使用场景：快速判断一个元素是否在集合中出现过。</li><li>哈希的三重境界：普通数组-&gt;set-&gt;map。</li><li>目前哈希中用到的set和map实际上是unordered_set和unordered_map，相对于set和map中的另外两种数据结构（set, multiset, map, multimap），unordered_set和unordered_map的查询效率和增删效率都是最高的。选择set类型的三种数据结构时，若我们不需要数据有序，且需要去重，且希望效率高，则用unordered_set。选择map类型的三种数据结构时，若我们不需要key有序，且希望效率高，则用unordered_map。</li><li>遇到哈希问题时，首先想想能不能用数组做哈希（比如题目中提到字符串中全是小写英文字母，就果断用数组做哈希）。用数组做哈希最直接，运行速度也最快，用set做哈希速度更慢，但遇到大规模的索引，数组放不下时，只能用set。</li><li>什么时候用map做哈希？当对一个元素需要同时存储两个值时，就必须用map做哈希。这两个值一个作为key，一个作为value存入map中。key中一般存储的是元素的值（便于查询），value中可以存放元素的索引（如1. 两数之和），也可以存放元素出现的次数（如454.四数相加II）。</li><li>map可以当作普通数组一样使用，忘了STL的用法可以复习知识部分。</li><li>哈希表部分的八道算法题，前六道都使用的是正统的哈希法，最后两道（三树之和&amp;四数之和）并非不可以使用哈希法，但使用哈希法需要进行复杂的去重操作，代码容易写错，且运行效率低下，因此推荐使用双指针算法。</li><li>三数之和&amp;四数之和的易错点在于剪枝和去重。每重for循环都需要剪枝和去重，while循环进行去重即可，但其实剪枝是一种优化，并不是必须的。但去重是必须的！</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E</summary>
      
    
    
    
    <category term="算法（哈希表）" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="双指针算法" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    
    <category term="总结" scheme="http://example.com/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="数组哈希" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C/"/>
    
    <category term="map哈希" scheme="http://example.com/tags/map%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>How to Understand an Open Source Project</title>
    <link href="http://example.com/2024/01/30/How-to-Understand-an-Open-Source-Project/"/>
    <id>http://example.com/2024/01/30/How-to-Understand-an-Open-Source-Project/</id>
    <published>2024-01-30T11:16:31.000Z</published>
    <updated>2024-01-30T12:08:37.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速了解项目"><a href="#快速了解项目" class="headerlink" title="快速了解项目"></a>快速了解项目</h2><p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-01-30_11-45-52.png?raw=true" alt="Snipaste_2024-01-30_11-45-52.png"></p><p>从0带读Java小说项目。项目：<a href="https://novel.xxyopen.com/">小说精品屋</a></p><p>首先看代码的简介（README），然后看代码的更新频率（几年没更新的就不用看了）。</p><p>接着看项目的介绍，看项目的技术栈和我们自己的技术栈是否匹配。</p><p>接着看包结构（项目结构）。</p><p>看技术选型。高级的技术：ShardingSphere-JDBC（数据库分库分表支持）、分布式缓存支持、搜索引擎服务、开源消息中间件、文件存储、对象存储。</p><p>接着看<strong>核心：项目如何安装，如何启动</strong>。</p><h2 id="了解项目依赖"><a href="#了解项目依赖" class="headerlink" title="了解项目依赖"></a>了解项目依赖</h2><p>通过github1s（在线查看项目的工具）看项目。</p><p>==看项目从整体到局部，先看项目的架构及关键配置文件==</p><p>比如assets放静态文件，sql放SQL语句。根目录下的pom.xml定义了父工程的配置。在父工程的配置中又定义了子模块，可以达到多包同时编译的效果。</p><p>dockerfile：可以用其来生成一个docker镜像</p><p>Java的项目主要分为两部分：resources放一些资源文件和配置，另一部分是java的核心代码。</p><p>看resources/application.yml：跑起这个项目需要启动哪些服务。</p><p>resources/mybatis：放一些SQL语句</p><p>resources/static：放前端的文件，比如javascript, css等等。</p><p>resources/templates：用的是thymeleaf，拓展标签可以动态地把一些后台数据渲染到页面。</p><p>resources/application-dev.yml：是项目的开发环境的配置。</p><p>resources/application-prod.yml：是项目生成环境的配置。</p><p>resources/logback.yml：日志</p><h2 id="了解项目结构"><a href="#了解项目结构" class="headerlink" title="了解项目结构"></a>了解项目结构</h2><p>现在java项目的目录结构比较清晰和规范。都是mvc结构：model view controller。</p><p>controller：控制层，接收用户的请求，给予一些响应，业务逻辑一般不写在其中</p><p>core：项目核心的类</p><p>mapper：mybatis的映射文件，在这个文件中定义操作数据库的方法</p><p>page：控制页面的返回。用户请求一个地址，请求发送到controller，会响应并返回某个页面给用户，和前端的模板有关联。</p><p>service：编写业务的逻辑</p><p>vo：返回给页面的数据</p><p>springboot的启动类，会自动帮助我启动一个tomcat服务器</p><h2 id="追踪请求（了解分层）"><a href="#追踪请求（了解分层）" class="headerlink" title="追踪请求（了解分层）"></a>追踪请求（了解分层）</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV13q4y1U7JU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bf2f8cedefdf16acd0e7a14d8e4669fd">带你读懂一个开源项目，学习通用套路！程序员阅读项目源码技巧、Java 编程项目分享</a></p><p><a href="https://www.code-nav.cn/">编程导航</a></p><p><a href="https://novel.xxyopen.com/">小说精品屋</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快速了解项目&quot;&gt;&lt;a href=&quot;#快速了解项目&quot; class=&quot;headerlink&quot; title=&quot;快速了解项目&quot;&gt;&lt;/a&gt;快速了解项目&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/yfchenkeepgoing/image/blo</summary>
      
    
    
    
    <category term="web开发" scheme="http://example.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java编程项目" scheme="http://example.com/tags/Java%E7%BC%96%E7%A8%8B%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="开源项目" scheme="http://example.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="阅读项目源码技巧" scheme="http://example.com/tags/%E9%98%85%E8%AF%BB%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Day 6 | Leetcode 242, 349, 202, 1</title>
    <link href="http://example.com/2024/01/29/Day-6-Leetcode-242-349-202-1/"/>
    <id>http://example.com/2024/01/29/Day-6-Leetcode-242-349-202-1/</id>
    <published>2024-01-29T07:48:25.000Z</published>
    <updated>2024-01-30T11:13:39.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">哈希表理论基础</a><br><a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词</a><br><a href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集</a><br><a href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">202. 快乐数</a><br><a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1. 两数之和</a></p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h3><p>哈希表-&gt;哈希函数-&gt;哈希碰撞-&gt;拉链法/线性探测法-&gt;常见的三种哈希结构-&gt;set &amp; map及如何选取-&gt;总结</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表是根据关键码的值而直接进行访问的数据结构。举例：其实数组就是一张哈希表。哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。</p><p>哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。</p><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数：哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。如果hashCode得到的数值大于哈希表的大小了，也就是大于tableSize了，此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。</p><p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。接下来<strong>哈希碰撞</strong>登场。</p><h4 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h4><p>小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p><h4 id="拉链法-线性探测法"><a href="#拉链法-线性探测法" class="headerlink" title="拉链法/线性探测法"></a>拉链法/线性探测法</h4><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放冲突的数据了。</p><h4 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h4><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map(映射)</li></ul><h4 id="set-amp-map及如何选取"><a href="#set-amp-map及如何选取" class="headerlink" title="set &amp; map及如何选取"></a>set &amp; map及如何选取</h4><p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-01-29_09-29-58.png?raw=true" alt="Snipaste_2024-01-29_09-29-58.png"></p><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><p><img src="https://raw.githubusercontent.com/yfchenkeepgoing/image/main/image.png" alt="img"></p><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><p>两个unordered都是哈希表实现的,其他四个都是红黑树实现的。三类set和三类map性质上是类似的。</p><p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p><p>那么再来看一下map ，在map 是一个key-value 的数据结构，map中，对key是有限制，因为key的存储方式使用红黑树实现的，对value没有限制。</p><p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下，==当我们遇到了<strong>要快速判断一个元素是否出现集合里</strong>的时候，就要考虑哈希法==。哈希法的查询速度很快：O(1)。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h4><ol><li>将一个数组中的元素全部置为0：<code>int hash[26] = &#123;0&#125;;</code>。实际上，直接写<code>int hash[26]</code>也可以，不给数组中的值赋值，数组中的值默认为0。</li><li>求字符串<code>string s</code>的长度，可以用<code>s.size()</code>，也可以用<code>s.length()</code>。</li><li><code>s[i] - &#39;a&#39;</code>：编译器会自动用ascii码进行计算，不需要手动将变量类型转换为整数。</li><li>一个有返回值的函数，如果执行了return语句，函数直接结束，不需要再break。</li><li>定义一个常量大小的数组，空间复杂度是O(1)。</li></ol><h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h4><ol><li>set, multiset, unordered_set。前两者底层实现是红黑树，最后一个的底层实现是哈希值直接映射。unordered_set就是一个可以无限存装的数组。本题用unordered_set，因为其做映射和取值时效率最高，前两者的底层实现是树，因此取值是还要有查找的过程。unordered_set中的元素不可重复，相当于自动帮我们做去重；而multiset中的元素可以重复。</li><li>可以直接将set类型的数据转换为vector类型：<code>return vector&lt;int&gt;(set.begin(), set.end())</code>。</li><li>cpp中的vector中既有insert方法，又有push_back方法，前者需要指定插入元素的具体位置，后者直接将元素插入到vector的末尾。cpp的set（包括set, multiset, unordered_set）中只有insert方法，传入的参数为要插入的值，不需要指定插入元素的具体位置。</li><li>将vector转换为unordered_set: <code>unordered_set&lt;int&gt; nums1_set(nums1.begin(), nums1.end())</code>。</li><li>在unordered_set中查找元素：<code>nums1_set.find(nums2[i])</code>，返回的结果是一个迭代器（指针）。如果找到该值，<code>find</code>返回一个指向该元素的迭代器；如果未找到，则返回一个指向<code>unordered_set</code>末尾的迭代器，即<code>end()</code>迭代器。</li></ol><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h4><ol><li>返回一个vector可以直接将vector的内容写入大括号中，然后返回，比如<code>return &#123;a[i], b[i]&#125;</code>，返回一个空数组可以直接写成<code>return &#123;&#125;</code>，而不用定义一个vector再利用push_back方法向其中插入数，然后再返回这个vector。</li><li>定义的<code>vector&lt;int&gt; a</code>，若不给其赋值，则该vector长度为0。可见vector是动态地被分配内存，如果不给其赋值，则其长度为0，不占用内存，这与普通数组需要在定义时声明长度有所不同。</li><li>定义unordered_map的方式：<code>unordered_map&lt;int, int&gt; map</code>；unordered_map中有insert函数和find函数，用法同unordered_set；遍历这些STL容器都要用迭代器，相当于是一种加强版的指针；访问unordered_map的key和value：<code>map-&gt;first</code>和<code>map-&gt;second</code>。</li></ol><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="242-有效的字母异位词-1"><a href="#242-有效的字母异位词-1" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p>想到一个办法，用两个数组分别统计两个字符串中出现的字母和字母出现的频次，然后判断两个数组是否完全相同。代码如下所示，可以成功运行：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash1[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> hash2[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash1[s[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash2[t[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (hash1[i] != hash2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>稍微麻烦了点，实际上用一个数组就够了。</p><h3 id="349-两个数组的交集-1"><a href="#349-两个数组的交集-1" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p>暂时还不会用set做哈希，因此先尝试用数组做哈希。我写下了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash1[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> hash2[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计两个数组nums1和nums2中每个数值出现的频次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash1[nums1[i]] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash2[nums2[i]] ++ ;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若一个数同时在nums1和nums2数组中出现的频次&gt;=1，则该数是两数组的重叠，放入结果数组res中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash1[i] &amp;&amp; hash2[i])</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>本题其实是使用set的好题，但是后来力扣改了题目描述和测试用例，添加了 0 &lt;= nums1[i], nums2[i] &lt;= 1000 条件，所以使用数组也可以了，不过建议大家忽略这个条件。 尝试去使用set。</p><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p>尽管说这道题和上一道题原理上差不多，只是套了快乐数的壳子，但我看不出这题怎么用set来进行哈希。直接看讲解吧。</p><h3 id="1-两数之和-1"><a href="#1-两数之和-1" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>看到的第一想法是类似滑动窗口，但滑动窗口（209.长度最小的子数组）返回的是长度最小的子数组的长度，这道题却要返回两个整数的下标，因此还是有很大不同的。如果要快速在集合中查找一个元素是否出现过，那么应该采用哈希表的方法。我产生了一个想法，将nums数组中的所有数一对一对不重不漏地取出，将每一对数的和作为索引（key），将它们的下标作为（value）存入map中，然后通过查询map的索引来找到目标对，进而返回目标对的下标。实现起来有两个难点：</p><ul><li>如何不重不漏地枚举所有的数对？</li><li>如何将两个下标存入一个value里？</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="242-有效的字母异位词-2"><a href="#242-有效的字母异位词-2" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p><strong>判断两个字符串是否由相同的字母组成</strong>，但字母的位置可以不同。两个完全一样的字符串也是有效异位词。由于字符串中都是小写字母，因此a可以对应数组中索引为0的位置，z可以对应数组中索引为25的位置。用数组hash[26]统计第一个数组中每个字母出现的频率，然后第二个字符串中每个字母出现的频率再在hash数组中做对应的减法，若最后数组中所有元素均为0，则说明两个字符串互为有效的字母异位词。</p><p><strong>什么时候用数组/set/map：当哈希值较小，且范围也较小且可控；若哈希值很大，则用set；若是key-value对，则用map</strong>。</p><p>根据上述思路，我独立写出了代码，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 数组中的元素全部初始化为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash[s[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            hash[t[j] - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (hash[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="349-两个数组的交集-2"><a href="#349-两个数组的交集-2" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p>返回两个数组的交集。注意要去重。虽然可以用数组哈希，但还是建议用set。若保持之前的题目描述，让两个数组中的数值可能非常大，比如上亿，此时就必须要用set了，因为数组下标放不下那么大的数，同时会浪费很多存储空间。</p><p>哈希表善于解决判断一个元素是否在一个集合中出现过的题目。<strong>集合中的数值很大时，或者集合中的元素数量很少但数值很分散时，用数组不合适，要用set</strong>。先将数组nums1中的所有数值放到哈希表中，再遍历num2，查看其中的元素的数值是否在哈希表中出现过，出现过则放入res集合中。</p><p>因为要<strong>去重</strong>，所以定义unordered_set来存储result。哈希表也用unordered_set。直接将nums1转化为unordered_set的存储结构。接着遍历nums2，看哈希表中是否出现了nums2中的元素，出现了则将其放入result中。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220707173513.png" alt="set哈希法"></p><p>代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储答案的unordered_set，因为是unordered_set所以自动去重</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将nums1从vector转换为unordered_set</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums1_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在nums1_set中查找nums2中的数据，如果出现过，则将其插入res中</span></span><br><span class="line">        <span class="comment">// 也可以用范围遍历for (int num: nums2)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1_set.<span class="built_in">find</span>(nums2[i]) != nums1_set.<span class="built_in">end</span>())</span><br><span class="line">                res.<span class="built_in">insert</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将res从unordered_set类型转换回vector类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<br>构建<code>nums_set</code>：O(n)<br>遍历<code>nums2</code>并检查元素是否在<code>nums_set</code>中：O(m)<br>构建结果向量：O(k)，其中k是结果集中元素的数量<br>综上所述，总的时间复杂度是O(n + m + k)。但是由于k（结果集的大小）是由n和m决定的，并且在大多数情况下k会小于n和m，所以可以近似地认为时间复杂度主要由n和m决定，即O(n + m)。</p><p>如果用数组做哈希的话，除了我在初次尝试中写的那种方式，其实还有另一种方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res; <span class="comment">// 存储结果，去重</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nums1中出现过的数，则将其在哈希数组中的值标记为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums1)</span><br><span class="line">            hash[num] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若nums2中的数在nums1中出现过，则将其插入res中  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums2)</span><br><span class="line">            <span class="keyword">if</span> (hash[num] == <span class="number">1</span>)</span><br><span class="line">                res.<span class="built_in">insert</span>(num);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// unordered_set-&gt;vector</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="202-快乐数-1"><a href="#202-快乐数-1" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p>题目中说：Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.本题本来是一个数学问题，可以得到严格的数学证明，但我们不需要懂数学，可以用编程的思维去解决它。</p><p>因此，一个数进行如题的操作后，要么会陷入死循环，要么会在某个时刻等于1并保持。因此，可以写一个循环来持续对输入的数进行如题的操作，如果某次操作的结果在之前出现过，那么该数就不是快乐数；如果操作的结果为1，那么该数就是快乐数。要快速判断一个元素是否在集合中出现过，就应该用一个set将集合中的所有元素维护起来。代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 用于求一个数每一位的平方之和的函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSumofDigits</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            s += (n % <span class="number">10</span>) * (n % <span class="number">10</span>); <span class="comment">// 求每一位的平方</span></span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; loop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 持续循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">getSumofDigits</span>(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 结束循环，是快乐数</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 若发现出现死循环，则立即返回不是快乐数</span></span><br><span class="line">                <span class="keyword">if</span> (loop.<span class="built_in">find</span>(s) != loop.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 尚未出现死循环，则继续</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    loop.<span class="built_in">insert</span>(s);</span><br><span class="line">                    n = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以将上述代码写得更见简练，更好理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            s += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">getSum</span>(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 退出条件1，是快乐数</span></span><br><span class="line">            <span class="keyword">if</span> (set.<span class="built_in">find</span>(s) != set.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 退出条件2，不是快乐数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不满足两个退出条件，则继续循环</span></span><br><span class="line">            n = s;</span><br><span class="line">            set.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里主要处理的是数字 n 的每一位，一个数字n它的位数可以认为是logn（一个d位的数大约是10的d次方，n = 10^d =&gt; d = logn）。每次进行快乐数的判断会执行一次该计算操作，但是因为快乐数的范围有限，总体来看不会超过 logn 的常数倍，因此时间复杂度是O(log n)。</p><p>所以随着<code>n</code>的增加，存储在<code>unordered_set</code>中的不同可能结果的数量实际上是有限的。事实上，随着<code>n</code>的增长，这个数量的增长速度接近于对数增长。换句话说，即使<code>n</code>非常大，经过<code>getSum</code>处理后的结果仍然是一个相对较小的数字集合。因此空间复杂度为<code>O(logn)</code>。至于为什么是<code>logn</code>，我认为原因是其增长速度最慢，这比<code>sqrt(n)</code>等其他形式更符合n较大时set中存储的元素的数量接近一个常数的事实。</p><h3 id="1-两数之和-2"><a href="#1-两数之和-2" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>本题需要用map解决。判断一个元素是否在一个集合中出现过：用哈希法。假设target = 9，当遍历到元素3时，我们需要去寻找元素6是否被遍历过。把遍历过的元素加到一个集合（哈希表结构）中，每次遍历新元素a时，判断(target - a)是否在集合中出现过。若出现过，我们需要知道其下标，因此集合中既要存储元素的值，又要存储元素的下标。此时想到用map，存储元素的值用map的key，存储元素的下标用map的value（因为要查找元素是否出现过，因此以元素的值作为key，map能以最快的速度找到这个key是否在这个map中出现过）。</p><p>看完上述思路后，我独立写出了以下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; store;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有元素的值作为key，索引作为value存入map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            store.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每遍历到一个元素nums[i]，查找target - nums[i]是否在map中</span></span><br><span class="line">        <span class="comment">// 是则返回结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = store.<span class="built_in">find</span>(t);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意除去第一个条件外，还需要保证查找到的元素并非当前元素本身</span></span><br><span class="line">            <span class="comment">// 否则会出现target = 两倍当前元素而导致的误判</span></span><br><span class="line">            <span class="keyword">if</span> (it != store.<span class="built_in">end</span>() &amp;&amp; it-&gt;second != i)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继续听讲解，<strong>map用于存放遍历过的元素的值和索引</strong>。本题使用unordered_map，其存和读的效率是最高的。因此写出了以下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; store;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每遍历到一个元素nums[i]，查找target - nums[i]是否在map中</span></span><br><span class="line">        <span class="comment">// 是则返回结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = store.<span class="built_in">find</span>(t);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若找到了target - nums[i]，则将其索引和当前遍历的元素的索引返回</span></span><br><span class="line">            <span class="keyword">if</span> (it != store.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将已经遍历过的元素的值作为key，索引作为value存入map中</span></span><br><span class="line">            store.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我的第一版代码在store中存储了数组中所有元素的值和索引，因此需要保证查找到的元素并非当前元素本身。第二版代码在store中存储的是已经遍历过的元素，故天然满足查找到的元素并非当前元素本身的条件。两版代码都是对的，但后者更为简洁。最简洁版本的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// 用于存储已遍历过的元素的值和索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 用于查找map中是否有目标元素</span></span><br><span class="line">            <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="comment">// 有，则返回两个索引构成的vector</span></span><br><span class="line">            <span class="keyword">if</span> (it != map.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123;i, it-&gt;second&#125;;</span><br><span class="line">            <span class="comment">// 无，则将当前元素的值和索引插入map中，然后开始循环的下一轮</span></span><br><span class="line">            map.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成循环后还没找到两个索引，则返回空vector</span></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="242-有效的字母异位词-3"><a href="#242-有效的字母异位词-3" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><ol><li>本题的本质是判断两个字符串是否由相同的字母组成。</li><li>本题用数组实现哈希。</li><li>遇到哈希问题时，首先想想能不能用数组做哈希。用数组做哈希最直接，运行速度也最快，用set做哈希速度更慢，但遇到大规模的索引，数组放不下时，只能用set。</li></ol><h3 id="349-两个数组的交集-3"><a href="#349-两个数组的交集-3" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><ol><li>本题本来不改测试数据，数组中的数值可能很大时，只能用set做哈希。现在对数组中的数值做了限制，最大不超过1000，则可以用数组做哈希。</li><li>用数组做哈希比用set做哈希效率更高，因为用set的话每次往里Insert一个值，都需要对这个值做一次哈希运算，同时还要开辟一个新的空间。用数组的下标做哈希映射永远是最快的。</li><li>本题适合用来衔接用数组做哈希和用set做哈希。</li><li>本题用set做哈希时，要记住set的各种用法：vector和unordered_set互相转化，在unordered_set中查找元素。这些用法归纳在知识中。</li><li>本题有三种解法：一种是用set哈希，另外两种是用数组做哈希。用数组做哈希建议采用我在初次尝试中的做法，只需要用到数组，不需要用到unordered_set去重。</li><li>采用范围遍历的写法可以简化代码。</li></ol><h3 id="202-快乐数-2"><a href="#202-快乐数-2" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p>这道题的逻辑其实非常简单。若各个位上的平方和为1，则退出循环，返回是快乐数；若平方和之前出现过，则说明进入了死循环，也退出循环，返回不是快乐数；其他情况下，继续循环。由于本题的<code>1 &lt;= n &lt;= 2^31 - 1</code>，各个位的平方和的数据范围非常大，因此必须用set做哈希，不能再用数组做哈希。注意本题时间复杂度和空间复杂度的分析。时间复杂度和空间复杂度不存在<code>sqrt(n)</code>等表达式，要么是1, 要么是logn，要么是n，要么nlogn或者更大。</p><h3 id="1-两数之和-3"><a href="#1-两数之和-3" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>四个重要问题：</p><ol><li>为什么用哈希法：快速查找一个元素（目标元素）是否在集合（unordered_map存放已遍历过的元素）中出现过。</li><li>为什么要用map（unordered_map）：因为既需要存储元素的值，也需要存储元素的索引。这道题目中并不需要key有序，选择unordered_map 效率更高。</li><li>map的作用：存储<strong>已遍历过</strong>的元素的值和索引。</li><li>map中的key存了元素的值（便于查询），value存了元素的索引（作为结果返回）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%</summary>
      
    
    
    
    <category term="算法（哈希表）" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="数组哈希" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C/"/>
    
    <category term="set哈希" scheme="http://example.com/tags/set%E5%93%88%E5%B8%8C/"/>
    
    <category term="map哈希" scheme="http://example.com/tags/map%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Day 4 | Leetcode 24, 19, 160, 142</title>
    <link href="http://example.com/2024/01/27/Day-4-Leetcode-24-19-160-142/"/>
    <id>http://example.com/2024/01/27/Day-4-Leetcode-24-19-160-142/</id>
    <published>2024-01-27T07:55:54.000Z</published>
    <updated>2024-02-01T07:14:41.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">24. 两两交换链表中的节点</a><br><a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">19.删除链表的倒数第N个节点</a><br><a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">面试题 02.07. 链表相交</a><br><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">142.环形链表II</a><br><a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87.html">链表总结篇</a></p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><ol><li>两个链表的交点不是数值相等，而是指针相等。</li><li>本题在构造测试样例时，会输入两个单链表和两个单链表的交叉点，以及交叉点到两个链表头节点的距离。因此，只有指定的交叉点才是真正的交叉点，仅仅是值相等的节点并不一定是真正的交叉点。指定的交叉点被构造出来时在内存中的地址相同，而仅仅是值相等的两个节点在内存中的地址不一定相同。</li></ol><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>应该和交换数组中的两个元素相同。需要创建一个额外的节点tmp，然后若要交换a节点和b节点，则进行：<code>tmp = b, a = b, b = tmp</code>即可。</p><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p>我能想到的办法：先遍历一遍列表，返回列表有几个节点。然后再遍历一遍列表，当cur指向倒数第N个节点的前一个节点时，停止遍历链表，删除cur-&gt;next，然后返回链表的头节点即可。应该也要用到虚拟头节点，避免删除链表的第一个节点时需要特判。我按照上述思路写了代码，可以成功通过测评！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建虚拟头节点</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 统计链表中的节点数量</span></span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            size ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 将cur指向倒数第n个节点的前一个节点</span></span><br><span class="line">        ListNode* cur1 = dummyHead;</span><br><span class="line">        <span class="type">int</span> size1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (size1 &lt; size - n)</span><br><span class="line">        &#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            size1 ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 删除倒数第n个节点，并释放其占用的内存</span></span><br><span class="line">        ListNode* tmp = cur1-&gt;next;</span><br><span class="line">        cur1-&gt;next= cur1-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更好的办法是采用双指针算法，见实现部分。</p><h3 id="面试题-02-07-链表相交-1"><a href="#面试题-02-07-链表相交-1" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p>我的第一想法是采用暴力解法。一个指针指向链表A的头节点，一个指针指向链表B的头节点，移动两个指针，当两个指针指向同一个节点时，说明该节点是两个链表相交的节点。据此，我写出了暴力解法的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* dummyHead2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead1-&gt;next = headA;</span><br><span class="line">        dummyHead2-&gt;next = headB;</span><br><span class="line"></span><br><span class="line">        ListNode* cur1 = dummyHead1;</span><br><span class="line">        ListNode* cur2 = dummyHead2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (cur1 = dummyHead1; cur1 != <span class="literal">NULL</span>; cur1 = cur1-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (cur2 = dummyHead2; cur2 != <span class="literal">NULL</span>; cur2 = cur2-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur1 == cur2)</span><br><span class="line">                    <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>暴力解法的时间复杂度是O(n^2)，应该有时间复杂度为O(n)的解法。时间复杂度更低的代码参见代码随想录。</p><h3 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><p>从没有见过这类题目，拿到题目毫无思路，直接看视频讲解和文字题解。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="24-两两交换链表中的节点-1"><a href="#24-两两交换链表中的节点-1" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>注意：是交换链表中的节点，而不仅仅交换节点的数值。偶数个节点则正好两两交换，奇数个节点则最后一个点不参与交换。一定需要dummyHead，因为要交换节点1、2，就一定要用到它们之前的那个节点，即dummyHead（dummyHead-&gt;2-&gt;1-&gt;3-&gt;…）。同理，要交换节点3、4，就一定要用到它们之前的那个节点，即节点2。<strong>因此当前指针一定要指向要反转的两个节点中的前一个节点，且当前指针每次移动两位</strong>。</p><p>若链表中的节点个数为奇数，则cur-&gt;next-&gt;next == NULL时循环结束，若链表中的节点个数为偶数，则cur -&gt; next == NULL时循环结束。如下图所示。故遍历结束的条件为 <code>while (cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL)</code>。两个条件不可以反过来写，否则当出现空链表时，cur-&gt;next-&gt;next没有被定义，会出现空指针异常。<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/%E7%BB%98%E5%9B%BE1.png?raw=true" alt="绘图1.png"></p><p>接下来是两两交换节点的逻辑。改变后的链表为dummyHead-&gt;2-&gt;1-&gt;3，由于dummyHead-&gt;1改变为dummyHead-&gt;2后，原本的节点1已经不能被访问到了，因此需要先用tmp存下节点1。同理，由于要将2-&gt;3改为2-&gt;1，因此需要先用tmp1存下节点3。交换完节点的链表为：dummyHead-&gt;2-&gt;1-&gt;4-&gt;3…..。对于两两交换节点的逻辑，可以参考代码随想录教程中的三幅图片。</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png" alt="24.两两交换链表中的节点3"></p><p>交换3和4节点的步骤时：cur目前为1，我们让1指向4，4再指向3，3再指向5（如果有5的话）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 交换两个节点需要用到这两个节点前的那个节点</span></span><br><span class="line">        <span class="comment">// 因此定义虚拟头节点，用于交换节点1和节点2</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="comment">// 搞清楚遍历的终止条件，参见笔记的图示</span></span><br><span class="line">        <span class="comment">// 以下两个终止条件分别针对节点数目为偶数和奇数的情况</span></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// dummyHead-&gt;2时，dummyHead-&gt;1不再存在，无法访问到1，因此需要事先存储节点1</span></span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 同理，2-&gt;1时，2-&gt;3不再存在，无法访问到3，因此需要事先存储节点3</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// dummyHead-&gt;2-&gt;1-&gt;3</span></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">// dummyHead-&gt;1变为dummyHead-&gt;2</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp; <span class="comment">// dummyHead-&gt;2-&gt;3变成dummyHead-&gt;2-&gt;1</span></span><br><span class="line">            tmp-&gt;next = tmp1; <span class="comment">//dummyHead-&gt;2-&gt;1再在末尾接上3</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">// cur指针后移两位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第N个节点-1"><a href="#19-删除链表的倒数第N个节点-1" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p>看了代码随想录的思路之后，我独立写出了快慢指针解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast先向后移动n位</span></span><br><span class="line">        <span class="keyword">while</span> (n -- ) fast = fast-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast移动到链表的最后一个节点（非空节点），此时slow移动到链表的倒数第n个节点前面的那个节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除倒数第n个节点</span></span><br><span class="line">        ListNode* tmp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以让fast先向后移动(n + 1)位，然后让fast和slow同时移动，直到fast移动到NULL为止，此时slow指向的也是倒数第n个节点的前一个节点。对这种办法，可以在移动fast指针前先让n ++ , 也可以在第一个while循环后让fast指针多向后移动一位。<strong>最稳妥的写法</strong>如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先将快指针移动n + 1步</span></span><br><span class="line">        n ++ ;</span><br><span class="line">        <span class="keyword">while</span> (n -- &amp;&amp; fast != <span class="literal">NULL</span>) fast = fast-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针同时移动，直到快指针指向NULL。此时慢指针指向要删除的节点前面那个节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存并删除倒数第n个节点</span></span><br><span class="line">        ListNode* tmp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于题目有如下限制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The number of nodes in the list is sz.</span><br><span class="line">1 &lt;= sz &lt;= 30</span><br><span class="line">0 &lt;= Node.val &lt;= 100</span><br><span class="line">1 &lt;= n &lt;= sz</span><br></pre></td></tr></table></figure><p>因此即使不加上fast != NULL，也可以通过，但如果题目没有n &lt;= sz的限制，那么必须加上fast != NULL，且不能使用以下写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n -- &amp;&amp; fast != <span class="literal">NULL</span>) fast = fast-&gt;next;</span><br><span class="line">fast = fast-&gt;next;</span><br></pre></td></tr></table></figure><p>因为若采用以上写法，当n &gt; sz时，当while循环结束后，fast已经指向了NULL，此时再做fast = fast-&gt;next操作，会导致空指针异常。</p><h3 id="面试题-02-07-链表相交-2"><a href="#面试题-02-07-链表相交-2" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p>代码随想录的思路：求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB末尾对齐的位置。此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。否则循环退出返回空指针。</p><p>看了代码随想录的思路后，我独立写出了代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sizea = <span class="number">0</span>, sizeb = <span class="number">0</span>;</span><br><span class="line">        ListNode* cura = headA;</span><br><span class="line">        ListNode* curb = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算a链表的长度</span></span><br><span class="line">        <span class="keyword">while</span> (cura != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cura = cura-&gt;next;</span><br><span class="line">            sizea ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算b链表的长度</span></span><br><span class="line">        <span class="keyword">while</span> (curb != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curb = curb-&gt;next;</span><br><span class="line">            sizeb ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cura = headA, curb = headB;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> delta = <span class="built_in">abs</span>(sizea - sizeb); <span class="comment">// 两链表长度的差值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sizea &gt;= sizeb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (delta -- ) cura = cura-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sizeb -- )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cura == curb) <span class="keyword">return</span> cura;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cura = cura-&gt;next;</span><br><span class="line">                    curb = curb-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (delta -- ) curb = curb-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sizea -- )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cura == curb) <span class="keyword">return</span> cura;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cura = cura-&gt;next;</span><br><span class="line">                    curb = curb-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里特别需要注意的是，在计算完a链表和b链表的长度后，需要让 <code>cura = headA, curb = headB</code>。</p><p>代码随想录的写法更见简洁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* cura = headA, * curb = headB;</span><br><span class="line">        <span class="type">int</span> sizea = <span class="number">0</span>, sizeb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算a链表和b链表的长度</span></span><br><span class="line">        <span class="keyword">while</span> (cura != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cura = cura-&gt;next;</span><br><span class="line">            sizea ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curb != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curb = curb-&gt;next;</span><br><span class="line">            sizeb ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 始终保证链表a的长度大于等于链表b的长度</span></span><br><span class="line">        <span class="keyword">if</span> (sizea &lt; sizeb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(sizea, sizeb);</span><br><span class="line">            <span class="built_in">swap</span>(headA, headB);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 交换cura和curb后，再恢复cura和curb的指向</span></span><br><span class="line">        <span class="comment">// 也可以在上面直接swap(cura, curb)，那这句话就可以写到if判断的前面去</span></span><br><span class="line">        cura = headA, curb = headB;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 计算两链表的长度之差</span></span><br><span class="line">        <span class="type">int</span> delta = sizea - sizeb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指向链表a的指针，让链表a和b的尾部对齐</span></span><br><span class="line">        <span class="keyword">while</span> (delta -- ) cura = cura-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cura != <span class="literal">NULL</span>) <span class="comment">// 写作while (sizeb -- )也可</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cura == curb) <span class="keyword">return</span> cura;</span><br><span class="line">            cura = cura-&gt;next;</span><br><span class="line">            curb = curb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="142-环形链表II-1"><a href="#142-环形链表II-1" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><p>有两问：</p><ol><li><p>判断链表中是否有环</p><p>用快慢指针来判断是否有环。若链表是一条直线，则快慢指针永远不会相遇。只有当链表中有环存在时，快指针先进入了环且在环中浪费了时间，快慢指针才会相遇。快指针从头节点开始，每次移动两位，慢指针也从头节点开始，每次移动一位，二者若相遇则一定在环里相遇，相遇则说明有环。快指针是一个节点一个节点的靠近慢指针，因此二者一定会在环中相遇。</p></li><li><p>找到环的入口</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></p><p>列方程即可解出x：<code>x = n (y + z) - y, (n &gt;= 1)</code>，由于看不出x和负数-y之间的关系，我们让出一圈，看x和z的关系：<code>x = (n - 1) (y + z) + z, (n &gt;= 1)</code>。这就意味着：<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是环形入口的节点</strong>。</p><p>为什么第一次在环中相遇，slow的步数是x+y而不是 x + 若干环的长度 + y 呢？”这个问题，可以这样解释，设快指针每秒移动2格，慢指针每秒移动1格，圆的周长是k。则慢指针走一圈需要的时间是k，设两指针之间的距离为m(m &lt; k)，则快指针追上慢指针的时间是m（快指针相对于满指针每秒移动1格），此时慢指针走过的距离是m，由于m &lt; k，因此慢指针在遇到快指针之前走过的距离小于圆的周长。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head, * slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面两个循环条件保证了fast指针可以指向NULL，但不能指向NULL的next，这样就不会导致空指针异常</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next; <span class="comment">// 快指针每次移动两位</span></span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 慢指针每次移动一位</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 快慢指针相遇，说明链表中有环</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 一指针从相遇处开始移动，一指针从head处开始移动，二者相遇的位置就是环的入口，数学推导见笔记</span></span><br><span class="line">                ListNode* index1 = fast, * index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2)</span><br><span class="line">                &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 若没有返回环的入口节点，则说明没有环，返回空指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我自研的另一种写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head, * slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 判断链表中是否有环</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 有环，则返回环的起点，无环，则返回空指针</span></span><br><span class="line">        <span class="keyword">if</span> (flag &amp;&amp; fast == slow)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* index1 = head, * index2 = slow;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(index1 != index2)</span><br><span class="line">            &#123;</span><br><span class="line">                index1 = index1-&gt;next;</span><br><span class="line">                index2 = index2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，一定要通过flag判断，只有当fast和slow相等且二者都在第一个while循环中转过时，才能确保链表中有环，若fast和slow相等，则可能是链表中只有一个节点的情况，此时fast和slow都没有在第一个循环中转过，因此二者相等且都等于head。</p><h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="24-两两交换链表中的节点-2"><a href="#24-两两交换链表中的节点-2" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><ol><li>注意cur应该指向哪里。</li><li>注意遍历的终止条件（奇数/偶数个节点）</li><li>若原先的两节点之间的连接被断开，则需要在断开前保存两节点中后面那个节点，否则后面的那个节点无法被访问到</li></ol><h3 id="面试题-02-07-链表相交-3"><a href="#面试题-02-07-链表相交-3" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><ol><li>本题的关键思路在于：<strong>对齐两个链表的尾部</strong>。本题的算法实际上也是（快慢）双指针算法。</li><li>比较链表中的两个节点是否相同，直接用 <code>cura == curb</code>即可，不能用 <code>cura-&gt;val == curb-&gt;val &amp;&amp; cura-&gt;next == curb-&gt;next</code>，因为比较两个节点除去比较val和next这两个参数外，还需要比较其本身的内存地址。</li><li>本题的时间复杂度分析：<br>计算两个链表的长度：O(n) + O(m)<br>调整指针以对齐两个链表：O(n - m)或O(m - n)<br>同时遍历两个链表寻找交点：O(min(n, m))<br>第一步和第三步的时间复杂度加在一起是 <code>O(n) + O(m) + O(min(n, m))</code>。但是，因为 <code>O(min(n, m))</code>在 <code>O(n) + O(m)</code>中已经被包含（总是小于或等于 <code>n</code>和 <code>m</code>），所以总的时间复杂度简化为 <code>O(n) + O(m)</code>。第二步（调整指针以对齐两个链表）的时间复杂度实际上也包含在 <code>O(n) + O(m)</code>中，因为无论是 <code>n - m</code>还是 <code>m - n</code>，它的值总是小于或等于 <code>n</code>和 <code>m</code>。因此，整个函数的总时间复杂度为 <code>O(n + m)</code>，这里 <code>n</code>和 <code>m</code>分别是两个链表的长度。这个时间复杂度已经涵盖了所有的主要操作，包括计算长度、对齐链表和寻找交点。<strong>时间复杂度的计算应当关注主要操作，省略次要操作</strong>。</li><li>在leetcode中调用swap，abs等函数时，不需要自行引用头文件，基本的函数和数据结构（STL）已经默认被引用了，因此直接写出来即可。</li></ol><h3 id="142-环形链表II-2"><a href="#142-环形链表II-2" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><ol><li>记住使用快慢双指针算法，有环的情况下快慢指针必然会相遇。</li><li>画图理解如何求环的起点的index。</li><li><strong>记得复习时着重看这道题</strong></li></ol><h2 id="总结：链表"><a href="#总结：链表" class="headerlink" title="总结：链表"></a>总结：链表</h2><ol><li>插入虚拟头节点dummyHead，可以避免空链表并避免对头节点操作的特判</li><li>创建一个当前节点cur，对整个链表进行遍历（<code>cur = cur-&gt;next</code>），而不用链表中原本存在的节点对链表进行遍历</li><li>NULL节点表示不存在的节点；虚拟节点实际上是存在的，其值为0，是人为创建的节点</li><li>递归时，需要先检查递归的终止条件，然后执行递归步骤</li><li>想要删除哪个节点，就用cur指针指向其前面的那个节点</li><li><strong>链表中最常用的算法是双指针算法</strong>，在206.反转链表，19.删除链表的倒数第N个节点，面试题 02.07. 链表相交，142.环形链表II中都用到了，其他题目基本不需要算法，利用链表的一些基本性质进行增删改查即可。</li><li><strong>记得复习142.环形链表II和24.两两交换链表中的节点</strong>，前者是链表中最独特也最难的一道题，难在数学推导和想清楚细节；后者在退出循环的条件和用tmp保存节点方面需要特别注意。</li></ol><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E</summary>
      
    
    
    
    <category term="算法（链表）" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="双指针算法" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    
    <category term="总结" scheme="http://example.com/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="环形链表" scheme="http://example.com/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Day 3 | Leetcode 203, 707, 206</title>
    <link href="http://example.com/2024/01/26/Day-3-Leetcode-203-707-206/"/>
    <id>http://example.com/2024/01/26/Day-3-Leetcode-203-707-206/</id>
    <published>2024-01-26T06:46:36.000Z</published>
    <updated>2024-01-29T07:54:28.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">链表理论基础</a><br><a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">203.移除链表元素</a><br><a href="https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html">707.设计链表</a><br><a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">206.反转链表</a></p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>链表是一种通过指针串联在一起的线性结构。每个节点等于数据域+指针域（存放指向下一个节点的指针）。最后一个节点的指针域指向null。头节点head。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png" alt="img"></p><p>单链表、双链表：既可以向前查询也可以向后查询。<br>循环链表：链表首尾相连（解决约瑟夫环问题）</p><p>链表在内存中不是连续分布的。其通过指针域的指针链接在内存中的各个节点。</p><p>链表的定义：<br>手写链表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上述构造函数初始化节点：<code>ListNode* head = new ListNode(5);</code><br>使用默认构造函数初始化节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p><p>添加节点：见图</p><p>数组和链表有不同的适用场景。数组适合数据量固定，频繁查找，较少增删的场景；链表适合数据量不固定，频繁增删，较少查询的场景。</p><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体中定义了两个变量和三个构造函数。class Solution中的removeElements函数返回的变量类型是ListNode*，即这个函数返回一个指向ListNode对象的指针。</p><p>如果使用C，C++编程语言的话，不要忘了还要从内存中删除这两个移除的节点。如果移除一个节点之后，没有手动在内存中删除这个节点，leetcode依然也是可以通过的，只不过，内存使用的空间大一些而已，但建议依然要养成手动清理内存的习惯。</p><p>删除头节点：</p><ul><li>直接使用原来的链表来进行删除操作：头节点后移一位</li><li>设置一个虚拟头结点在进行删除操作：原链表的所有节点就都可以按照统一的方式进行移除了，最后<code>return dummyNode-&gt;next;</code></li></ul><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><ul><li>void函数可以直接return，表示退出</li><li>统一使用虚拟头节点的方式，便于进行增删改的操作</li><li>变量名前加_表示是这个类的变量，而非局部变量，这是cpp中的一种约定俗成</li></ul><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="203-移除链表元素-1"><a href="#203-移除链表元素-1" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p>对链表题我一直有点懵，不太熟悉链表题的格式，但是对用数组模拟链表倒是挺熟悉的。我知道算法的思路大致是：先定义一个虚的头节点，然后遍历链表，删去值等于val的节点，然后返回头节点指针指向的节点，就是新的头节点，但我不知道这种代码怎么写。</p><h3 id="707-设计链表-1"><a href="#707-设计链表-1" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p>这题yxc也教过，但是在他那里似乎是用数组模拟链表，实现链表的各种功能，而这里是调用链表完成函数中的功能，我认为这题不难，只是多个功能需要分别实现，单个功能的代码较为简单。这道题我基本会做，但<strong>处理边界条件时要倍加注意</strong>！！</p><h3 id="206-反转链表-1"><a href="#206-反转链表-1" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p>yxc也讲过这个题，但我也给完全忘了</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="203-移除链表元素-2"><a href="#203-移除链表元素-2" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><h4 id="方法1-特判头节点"><a href="#方法1-特判头节点" class="headerlink" title="方法1: 特判头节点"></a>方法1: 特判头节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head -&gt; val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            head = head -&gt; next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除非头节点</span></span><br><span class="line">        ListNode* cur = head; <span class="comment">// cur存储要删去的节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 要删的节点cur-&gt;next不可为空, cur != NULL是考虑空链表的情况</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; cur -&gt; next != <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; next -&gt; val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* tmp = cur -&gt; next;</span><br><span class="line">                cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cur = cur -&gt; next; <span class="comment">// 后移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法2-加入虚拟头节点"><a href="#方法2-加入虚拟头节点" class="headerlink" title="方法2: 加入虚拟头节点"></a>方法2: 加入虚拟头节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建虚拟头节点</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead -&gt; next = head;</span><br><span class="line">        <span class="comment">// 上面的两行代码：创建虚拟头节点可以简写为：</span></span><br><span class="line">        <span class="comment">// ListNode* dummyHead = new ListNode(0, head);</span></span><br><span class="line">        <span class="comment">// 或者ListNode* dummyHead = new ListNode();</span></span><br><span class="line">        <span class="comment">// dummyHead -&gt; next = head;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统一方法删去值为val的节点</span></span><br><span class="line">        <span class="comment">// 从虚拟头节点开始遍历, cur为目标节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 此时因为加入了虚拟头节点，因此链表不可能为空，因此不再需要考虑链表为空的判断条件：cur != NULL</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur -&gt; next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; next -&gt; val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* tmp = cur -&gt; next;</span><br><span class="line">                cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head = dummyHead -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以方法2为主。</p><h3 id="707-设计链表-2"><a href="#707-设计链表-2" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 记住struct的写法</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedList* next;</span><br><span class="line">        <span class="built_in">LinkedList</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化, 带下划线的变量表示类中的变量，而非局部变量</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(<span class="number">0</span>); <span class="comment">// 虚拟头节点</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; ( _size - <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        LinkedList* cur = _dummyHead -&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index -- ) cur = cur -&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedList* head = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line">        head -&gt; next = _dummyHead -&gt; next;</span><br><span class="line">        _dummyHead -&gt; next = head;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedList* tail = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line"></span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        <span class="comment">// while循环中的条件不能是_size -- ，不然会破坏链表长度的准确性</span></span><br><span class="line">        <span class="keyword">while</span>(cur -&gt; next != <span class="literal">NULL</span>) cur = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = tail;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size || index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        LinkedList* node = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(index -- ) cur = cur -&gt; next;</span><br><span class="line"></span><br><span class="line">        node -&gt; next = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = node;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= _size) <span class="keyword">return</span>;</span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index -- ) cur = cur -&gt; next;</span><br><span class="line">        LinkedList* tmp = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        _size -- ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LinkedList* _dummyHead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="206-反转链表（常考）"><a href="#206-反转链表（常考）" class="headerlink" title="206.反转链表（常考）"></a>206.反转链表（常考）</h3><p>是考察对基础数据结构操作非常好的一道题目。先掌握双指针解法，再掌握递归的解法。根据双指针代码写出递归代码。</p><h4 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h4><p><img src="https://github.com/yfchenkeepgoing/image/blob/main/%E7%BB%98%E5%9B%BE%20(1" alt="绘图 (1).png">.png?raw=true)</p><p>具体解法：由于不需要让翻转以后的链表的头节点为空，因此当cur指向NULL时，遍历结束。因此循环为：<code>while(cur)</code>，cur == NULL为遍历的终止条件。</p><p>更新cur和pre的方式：用临时节点将cur的下一个节点保存下来。否则一旦反转后cur的写一个节点就会丢失（反转后的链表的下一个节点是pre）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = cur -&gt; next;</span><br><span class="line">            cur -&gt; next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="递归解法1"><a href="#递归解法1" class="headerlink" title="递归解法1"></a>递归解法1</h4><p>按照双指针的思路写递归的代码。递归的代码更简短但更难懂。</p><p>具体解法：定义一个reverse函数，其中有两个参数，即<code>reverse(cur, pre)</code>。</p><p>在主函数中调用reverse函数，需要传入两个参数cur和pre，前者对应于双指针解法中的head，后者对应于双指针解法中的null。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 仿照双指针解法，递归函数中需要传入两个参数：cur和pre</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* cur, ListNode* pre)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 先检查递归的终止条件，同双指针解法</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再执行递归的步骤</span></span><br><span class="line">        <span class="comment">// 同双指针解法中tmp = cur -&gt; next, cur -&gt; next = pre, pre = cur, cur = tmp</span></span><br><span class="line">        ListNode* tmp = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(tmp, cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 双指针解法中初始时cur = head, pre = NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(head, <span class="literal">NULL</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="递归解法2"><a href="#递归解法2" class="headerlink" title="递归解法2"></a>递归解法2</h4><p>另一种递归解法，思路和递归解法1完全不同，我认为相比于递归解法1更好理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断终止条件是否成立</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 空链表，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head; <span class="comment">// 递归结束，返回反转后链表的head</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行递归流程</span></span><br><span class="line">        ListNode* last = <span class="built_in">reverseList</span>(head-&gt;next); <span class="comment">// 从第二个节点开始反转链表</span></span><br><span class="line">        <span class="comment">// 将原来的头节点接到反转后链表的尾节点之后，反转后链表的尾节点是head-&gt;next</span></span><br><span class="line">        head-&gt;next-&gt;next = head; </span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 尾节点指向空</span></span><br><span class="line">        <span class="keyword">return</span> last; <span class="comment">// 返回反转后链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h3><ol><li>插入虚拟头节点dummyHead，可以避免空链表并避免对头节点操作的特判</li><li>创建一个当前节点cur，对整个链表进行遍历（<code>cur = cur-&gt;next</code>），而不用链表中原本存在的节点对链表进行遍历</li><li>NULL节点表示不存在的节点；虚拟节点实际上是存在的，其值为0，是人为创建的节点</li><li>递归时，需要先检查递归的终止条件，然后执行递归步骤</li></ol><h3 id="203-移除链表元素-3"><a href="#203-移除链表元素-3" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><ol><li>想要删除一个节点，需要先用tmp存下它，然后再delete删去之。</li><li>以后写，尽量采用方法2，即加入虚拟头节点。</li><li>cur -&gt; next表示的是cur节点的next变量（即指针域），而cur -&gt; val表示的是cur节点的val变量（即节点的值）。通过构造函数也可以给这两个变量直接赋值。</li><li>在方法1中，一定要加上判断条件<code>cur != NULL</code>，因为当链表为空时，<code>while (cur -&gt; next != NULL)</code> 这个条件将尝试访问 <code>NULL</code> 指针的 <code>next</code> 成员，这将触发未定义行为，从而导致程序报错。在方法2中，则不需要加上判断条件<code>cur != NULL</code>，因为有虚拟头节点的存在，链表不可能为空，至少有一个节点（即虚拟头节点）。当然，在方法2中加上这个判断条件也不会影响程序的正常运行。</li></ol><h3 id="707-设计链表-3"><a href="#707-设计链表-3" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><ol><li>想清楚一个极端情况：返回第0个节点的值，是否会出现空指针异常等错误。</li><li>cur节点都赋值为_dummyHead</li><li>注意删除第n个节点时的内存释放问题</li><li>在第n个节点前增加或者删除一个节点，应该让cur指向第n-1个节点，cur-&gt;next指向第n个节点。</li><li>注意插入节点时先更新后面的边，再更新前面的边</li><li>只要传入参数index，就要记得对index进行判断，排除掉不需处理的情况。对get函数和deleteAtIndex函数，判断条件都是<code>index &lt; 0 || index &gt; _size - 1</code>，但对addAtIndex函数，判断条件是<code>index &lt; 0 || index &gt; _size</code>，因为<code>index = _size</code>表示将节点插入到链表的末尾。</li><li>别忘记_size ++ / _size — </li></ol><h3 id="206-反转链表-2"><a href="#206-反转链表-2" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><h4 id="双指针解法-1"><a href="#双指针解法-1" class="headerlink" title="双指针解法"></a>双指针解法</h4><p>代码量少，思维量大！需要明确：cur和pre初始的取值；循环终止的条件；如何更新pre和cur。画图理解即可。</p><h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><p>递归解法1参照双指针解法写。<strong>这题推荐就用双指针解法，比较清楚明白</strong>，且空间复杂度为O(1)，优于递归解法的空间复杂度O(n)。递归解法2相比于递归解法1更好理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%</summary>
      
    
    
    
    <category term="算法（链表）" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="双指针算法" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="递归" scheme="http://example.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>Day 2 | Leetcode 977, 209, 59</title>
    <link href="http://example.com/2024/01/25/Day-2-Leetcode-977-209-59/"/>
    <id>http://example.com/2024/01/25/Day-2-Leetcode-977-209-59/</id>
    <published>2024-01-25T04:41:58.000Z</published>
    <updated>2024-02-01T07:14:20.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p><a href="https://www.bilibili.com/video/BV1QB4y1D7ep">https://www.bilibili.com/video/BV1QB4y1D7ep</a></p><p><a href="https://www.bilibili.com/video/BV1tZ4y1q7XE">https://www.bilibili.com/video/BV1tZ4y1q7XE</a></p><p><a href="https://www.bilibili.com/video/BV1SL4y1N7mV/">https://www.bilibili.com/video/BV1SL4y1N7mV/</a></p><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p><a href="https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html">https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html</a></p><p><a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html</a></p><p><a href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html</a></p><p><a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.com/problems/squares-of-a-sorted-array/">https://leetcode.com/problems/squares-of-a-sorted-array/</a></p><p><a href="https://leetcode.com/problems/minimum-size-subarray-sum/">https://leetcode.com/problems/minimum-size-subarray-sum/</a></p><p><a href="https://leetcode.com/problems/spiral-matrix-ii/">https://leetcode.com/problems/spiral-matrix-ii/</a></p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>cpp中sort函数的用法：sort(a.begin(), a.end())，排序后的结果就存储在a中。</li><li><code>vector&lt;int&gt; result(A.size(), 0);</code>的意思是创建一个长度为A.size()，数值全部为0的vector。</li><li><p>cpp中的问号表达式——条件运算符</p><p>len = sub &lt; len ? sub: len;表示若sub &lt; len，则len = sub；否则len等于len，保持不变。</p><p>len == INT32_MAX ? 0: len;表示若len等于INT32_MAX，则l表达式值为0，否则表达式值为len。</p></li><li><code>INT32_MAX</code>：这是一个在 C++ 中定义的常量，代表 32 位整数类型（即 <code>int</code> 类型）可以表示的最大值。</li><li>初始化一个二维vector，让其中的元素全部为0：<code>vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0));</code>，即初始化一个全部元素为0的一维数组，然后将其复制n遍。</li></ol><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p>暴力做法，先平方，再排序。双指针做法有点思路，但由于不知道如何创建一个值为0且长度与nums相同的vector，因此不能完全正确地写出代码。</p><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h3><p>滑动窗口我听yxc讲过，但是已经完全忘了，直接看视频讲解，然后看文字版讲解。</p><p>暴力解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> sub = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                s += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (s &gt;= target)</span><br><span class="line">                &#123;</span><br><span class="line">                    sub = j - i + <span class="number">1</span>;</span><br><span class="line">                    len = len &lt; sub ? len: sub;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len == INT32_MAX ? <span class="number">0</span>: len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>暴力做法超时了。还是需要滑动窗口。</p><h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h3><p>yxc讲过这题，我印象中涉及到一个向量，撞墙了就拐弯，遇到自己之前走过的地方也拐弯，挺生动形象的，但我已经忘记怎么写了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="977-有序数组的平方-1"><a href="#977-有序数组的平方-1" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p>取平方后，最大的元素一定在原数组的两边。故用左右指针，从数组的两边向中间推进。需要一个新的数组来存储结果，新的数组的下标由大到小来更新。</p><h4 id="for-if写法"><a href="#for-if写法" class="headerlink" title="for+if写法"></a>for+if写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ans数组来存储答案</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于每次循环都要比较两个数的平方的大小关系，因此将最后一个数放入ans时</span></span><br><span class="line">        <span class="comment">// i和j都会等于该数的索引，因此要求i可以等于j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt;= j; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &lt;= nums[j] * nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[n -- ] = nums[j] * nums[j];</span><br><span class="line">                j -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans[n -- ] = nums[i] * nums[i];</span><br><span class="line">                i ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="for-while写法"><a href="#for-while写法" class="headerlink" title="for + while写法"></a>for + while写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>; l &lt;= r; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 一定要记得加上l &lt;= r的条件</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] * nums[l] &gt;= nums[r] * nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                res[k -- ] = nums[l] * nums[l];</span><br><span class="line">                l ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] * nums[l] &lt; nums[r] * nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                res[k -- ] = nums[r] * nums[r];</span><br><span class="line">                r -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="while-while写法"><a href="#while-while写法" class="headerlink" title="while+while写法"></a>while+while写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[i] * nums[i] &lt;= nums[j] * nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[k -- ] = nums[j] * nums[j];</span><br><span class="line">                j -- ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[i] * nums[i] &gt; nums[j] * nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[k -- ] = nums[i] * nums[i];</span><br><span class="line">                i ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="while-if写法"><a href="#while-if写法" class="headerlink" title="while + if写法"></a>while + if写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] * nums[l] &lt;= nums[r] * nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                res[k -- ] = nums[r] * nums[r];</span><br><span class="line">                r -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[k -- ] = nums[l] * nums[l];</span><br><span class="line">                l ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="209-长度最小的子数组-1"><a href="#209-长度最小的子数组-1" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h3><p>其实核心思想也是双指针，只不过取两指针中间的集合像是一个正在滑动的窗口，因此也叫滑动窗口。用一个for循环替代暴力做法里的两个for循环。一个for循环中的循环变量j若表示滑动窗口的起始位置，则j在遍历的过程中，终止位置也需要去遍历，这与暴力做法无异。<strong>因此for循环中的循环变量j表示滑动窗口的终止位置，起始位置需要动态移动地去获得</strong>。<strong>滑动窗口的精髓在于如何移动起始位置</strong>。</p><p>若滑动窗口的起始位置和终止位置间的数的和&gt;=target，那么起止位置可以向后移动，即窗口可以缩小，看缩小后的窗口是否还可以符合条件。若满足条件，则可更新滑动窗口。更新滑动窗口时，需要同时更新滑动窗口的起始位置和滑动窗口中元素和的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = INT32_MAX; <span class="comment">// result</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// i是滑动窗口的起始位置</span></span><br><span class="line">        <span class="type">int</span> sub = <span class="number">0</span>; <span class="comment">// 窗口长度</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 窗口之和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// j是滑动窗口的终止位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[j]; <span class="comment">// 将新的终止位置放到窗口的和中去</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新滑动窗口</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                sub = j - i + <span class="number">1</span>; </span><br><span class="line">                len = len &lt; sub ? len: sub;</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == INT32_MAX ? <span class="number">0</span>: len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="59-螺旋矩阵II-1"><a href="#59-螺旋矩阵II-1" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h3><p>不涉及算法，是道模拟题。不易写对的原因是转圈的过程中需要处理的边界条件很多。</p><p>边界条件：正方形的4个边界点</p><p>循环不变量：<br>循环——不断转圈<br>不变量——对每条边的处理规则<br>对每条边的处理规则应该不变。<strong>按照左闭右开的规则处理正方形的每一条边，每条边只处理头节点，不处理尾节点</strong>。</p><p>n * n的矩阵，需要转n / 2圈，若n为奇数，则中心那个值最后单独赋即可。每一圈的终止位置在上一圈的基础上-1。</p><p>示意图如下所示：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-01-26_06-26-17.png?raw=true" alt="Snipaste_2024-01-26_06-26-17.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">      </span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>, count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j ++ )</span><br><span class="line">                ans[startx][j] = count ++ ;</span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i ++ )</span><br><span class="line">                ans[i][j] = count ++ ;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j -- )</span><br><span class="line">                ans[i][j] = count ++ ;</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i -- )</span><br><span class="line">                ans[i][j] = count ++ ;</span><br><span class="line">          </span><br><span class="line">            startx ++ ;</span><br><span class="line">            starty ++ ;</span><br><span class="line">            offset ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) ans[n / <span class="number">2</span>][n / <span class="number">2</span>] = count;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="977易错点"><a href="#977易错点" class="headerlink" title="977易错点"></a>977易错点</h3><ol><li>一定要新建一个数组ans，不能在原数组的基础上修改，否则会混乱。</li><li>一定要注意左指针和右指针可以相等，因为最后总要处理两个元素，两个指针最终总会移到一起去。否则当两个指针指向同一个数时，该数会被落下，不会被添加到答案数组中。</li><li>这道题在for/while循环内用if或者while都可以，但用while的时候需要记得加上判断条件：<code>while(l &lt;= r &amp;&amp; ....)</code>，不加l &lt;= r的条件会报错：run time error。</li></ol><h3 id="209心得"><a href="#209心得" class="headerlink" title="209心得"></a>209心得</h3><p>滑动窗口方法其实脱胎于暴力做法。要特别注意遍历的是窗口的终止位置。</p><p>更新窗口的起始位置时，同时需要更新窗口中元素之和。</p><p>不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度至多是 2 × n 也就是O(n)。</p><h3 id="209易错点"><a href="#209易错点" class="headerlink" title="209易错点"></a>209易错点</h3><p>一定要记得把滑动窗口的初始位置定义在循环之外。</p><p>一定要记得在移动窗口初始位置的同时改变窗口中元素的sum。</p><h3 id="59易错点"><a href="#59易错点" class="headerlink" title="59易错点"></a>59易错点</h3><ol><li>注意每一条边都是左开右闭</li><li>注意画图理解</li><li>注意为n为奇数时单独给中心点赋值</li><li>注意如何定义一个二维所有元素为0的矩阵</li><li>offsetx/y和startx/y不会出现在同一个式子中</li></ol><h3 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h3><p>看代码随想录的数组总结</p><h2 id="数组总结"><a href="#数组总结" class="headerlink" title="数组总结"></a>数组总结</h2><p>数组题目中：整数二分一道（704）。双指针三道（27, 977, 包括滑动窗口209），双指针题目的难度是递增的，27最简单，977稍难，209最难。模拟题一道：59。</p><p>从方法上来说，704和59都应该采用循环不变量的原则，27、977、209则都是双指针算法的应用。</p><p>引用总结文章：<a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80</a><br>中的一幅图片：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;h3 id=&quot;视频&quot;&gt;&lt;a href=&quot;#视频&quot; class=&quot;headerlink&quot; title=&quot;视频&quot;&gt;&lt;/a&gt;视频&lt;/h3&gt;&lt;p&gt;&lt;a </summary>
      
    
    
    
    <category term="算法（数组）" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="双指针算法" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="螺旋矩阵" scheme="http://example.com/tags/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    
    <category term="总结" scheme="http://example.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Day 1 | Leetcode 704, 27</title>
    <link href="http://example.com/2024/01/24/Day-1-Leetcode-704-27/"/>
    <id>http://example.com/2024/01/24/Day-1-Leetcode-704-27/</id>
    <published>2024-01-24T10:47:40.000Z</published>
    <updated>2024-01-29T07:55:12.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p><a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><p><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE</a></p><p><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6</a></p><p><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%9C%89%E5%87%A0%E4%B8%AA%E7%96%91%E9%97%AE%EF%BC%9F.html">https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%9C%89%E5%87%A0%E4%B8%AA%E7%96%91%E9%97%AE%EF%BC%9F.html</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.com/problems/binary-search/">https://leetcode.com/problems/binary-search/</a></p><p><a href="https://leetcode.com/problems/remove-element/">https://leetcode.com/problems/remove-element/</a></p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><p>数组是存放在<strong>连续内存空间</strong>上的<strong>相同类型数据</strong>的集合。</p><p>注意：</p><ul><li><p>数组下标都是从0开始的</p></li><li><p>数组内存空间的地址是连续的</p></li><li><p>正是因为数组的在内存空间的地址是连续的，所以我们在<strong>删除或者增添元素的时候，就难免要移动其他元素的地址</strong></p></li><li><p>C++中，要注意vector和array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组</p></li><li><p>数组的元素是不能删的，只能覆盖</p></li><li><p>C++中二维数组在地址空间上是连续的（在现代系统上，二维数组中的每个int占用4个字节）</p></li><li><p>Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。输出的值不是真正的地址，而是经过处理的数值</p></li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度是一个函数，它定性描述该算法的运行时间。</p><p>大O用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。有时业界也默认O代表的就是一般情况，而不是严格的上界。面试中说道算法的时间复杂度是多少指的都是一般情况。</p><p>数据用例的不一样，时间复杂度也是不同的。</p><p>我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大。</p><p>我们统一说 logn，也就是忽略底数的描述。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>是对一个算法在运行过程中占用内存空间大小的量度。</p><p>来看一下例子，什么时候的空间复杂度是$O(1)$呢，C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大O(1)。</p><p>当消耗空间和输入参数n保持线性增长，这样的空间复杂度为O(n)，来看一下这段C++代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>随着n的增大，开辟的内存大小呈线性增长，即 O(n)。</p><p>递归的时候，会出现空间复杂度为logn的情况。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h3><h4 id="Leetcode-704-二分查找"><a href="#Leetcode-704-二分查找" class="headerlink" title="Leetcode 704 二分查找"></a>Leetcode 704 二分查找</h4><p>这题应该是整数二分，虽然我在yxc的算法基础课里学过这题，但时隔几个月我已经彻底忘了（不管是原理还是实现），从头开始吧。</p><h4 id="Leetcode-27-移除元素"><a href="#Leetcode-27-移除元素" class="headerlink" title="Leetcode 27 移除元素"></a>Leetcode 27 移除元素</h4><p>试试暴力做法吧，双指针做法想不出来。根据yxc的经验，暴力做法成功后再想办法去优化。</p><h3 id="看完代码随想录后的想法"><a href="#看完代码随想录后的想法" class="headerlink" title="看完代码随想录后的想法"></a>看完代码随想录后的想法</h3><h4 id="Leetcode-704-二分查找-1"><a href="#Leetcode-704-二分查找-1" class="headerlink" title="Leetcode 704 二分查找"></a>Leetcode 704 二分查找</h4><p>二分法的使用前提：数组为有序数组，且数组中无重复元素。满足这两个性质的题目可尝试二分法。</p><p>二分法中区间的定义有两种：左闭右闭和左闭右开。<strong>每一次边界的处理都要坚持根据区间的定义来操作</strong>。</p><h4 id="Leetcode-27-移除元素-1"><a href="#Leetcode-27-移除元素-1" class="headerlink" title="Leetcode 27 移除元素"></a>Leetcode 27 移除元素</h4><p>暴力做法：遍历数组-&gt;找到需要移除的元素-&gt;将该元素后面的所有元素都前移一位-&gt;索引前移一位，数组长度减1</p><p>双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Leetcode-704-二分查找-2"><a href="#Leetcode-704-二分查找-2" class="headerlink" title="Leetcode 704 二分查找"></a>Leetcode 704 二分查找</h3><p>cpp中的vector中求数组的长度没有len函数，应该用size函数。</p><p>cpp中两个整数的做除法如果得到的结果变量类型为整数，则是向下取整的。</p><p>cpp中的vector是动态数组，要先向用push_back向其中添加元素，然后才能通过索引来访问元素。</p><p>左闭右闭和左闭右开的写法中，需要注意right初始值的选取的不同（由于一种写法的右边界可以取到，另一种写法的右边界取不到）。还需要注意分成三类讨论，即target &gt; nums[mid], target &lt; nums[mid]和target == nums[mid]。这样就可以避免处理大于等于和小于等于的情况。</p><p>返回总是返回mid，不要尝试返回l或者r，可能会遇到边界问题。</p><p>用(l + r) &gt;&gt; 1比(l + r) / 2要更快一点。</p><p>建议采用l + (r - l) / 2代替(r + l) / 2，前者可以防止(r + l)溢出整数的范围。</p><p>时间复杂度：O(log n)<br>空间复杂度：O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左闭右闭，因此要求左右边界均可取到，因此r的值要与右边界的索引相同</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">// (l + r) &gt;&gt; 1速度更快</span></span><br><span class="line">            <span class="comment">// 分三类情况讨论</span></span><br><span class="line">            <span class="comment">// 因为区间是右闭的，所以r不可能取为mid，最大为mid - 1</span></span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[mid]) r = mid - <span class="number">1</span>; </span><br><span class="line">            <span class="comment">// 因为区间是左闭的，所以l不可能取为mid，最小为mid + 1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// return l/r都是错误的，可以通过模拟一个输入知道错误原因</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右开写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左闭右开，因此target不能取为右边界的值，要保证区间完全覆盖住target，因此r的值要比右边界的索引大1</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右边界取不到，因此是l &lt; r</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 因为区间是左闭的，所以l不可能取为mid，最小为mid + 1</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 因为区间是右开的，所以r可以取为mid</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) r = mid;</span><br><span class="line">            <span class="comment">// return l是错误的，可以通过模拟一个输入知道错误原因</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Leetcode-27-移除元素-2"><a href="#Leetcode-27-移除元素-2" class="headerlink" title="Leetcode 27 移除元素"></a>Leetcode 27 移除元素</h3><h4 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h4><p>若不前移i，则若数组中出现连续的两个val时，结果会发生错误，不能完全移除数组中所有的val。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历数组，找到需要移除的元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将该元素后面的所有元素都前移一位，覆盖掉需要移除的元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j ++ )</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                <span class="comment">// 索引前移一位，数组长度减1</span></span><br><span class="line">                i -- ;</span><br><span class="line">                size -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h4 id="快慢双指针做法"><a href="#快慢双指针做法" class="headerlink" title="快慢双指针做法"></a>快慢双指针做法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快指针用于遍历所有元素、慢指针用于记录更新后数组的下标</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); fast ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val)</span><br><span class="line">                nums[slow ++ ] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h4 id="相向双指针做法"><a href="#相向双指针做法" class="headerlink" title="相向双指针做法"></a>相向双指针做法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相向双指针方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 跳过所有不需要移除的元素，剩下需要移除的元素</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] != val) l ++ ;</span><br><span class="line">            <span class="comment">// 跳过所有需要移除的元素，剩下不需要移除的元素</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[r] == val) r -- ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将右边不需要移除的元素覆盖掉左边需要移除的元素(交换左右两边的元素)</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) nums[l ++ ] = nums[r -- ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回左边的最后一个值的索引</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><p>注意：while (l &lt;= r &amp;&amp; nums[l] != val)和while (l &lt;= r &amp;&amp; nums[r] == val)中的两个判断条件不可以写反，否则会出现Runtime Error。这是因为短路原则，最好先进行边界检查，再访问数组。</p><p>逻辑：数组的左边放等于val的元素，因此需要跳过所有不等于val的元素；数组的右边放不等于val的元素，因此需要跳过所有等于val的元素。交换数组的左右两边，让数组的左边放不等于val的元素，数组的右边放等于val的元素，然后输出数组左边的最后一个值的索引。</p><p>相向双指针方法的基本过程我大致理解了，但还不理解其的细节和应用。</p><h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="Leetcode-704-二分查找-3"><a href="#Leetcode-704-二分查找-3" class="headerlink" title="Leetcode 704 二分查找"></a>Leetcode 704 二分查找</h3><p>我认为代码随想录的做法比yxc的讲解更加清晰。清楚地归纳总结出了左闭右闭和左闭右开的写法，并根据选择区间的开闭性质清晰地写出了代码。同时，分成三类讨论，避免了处理大于等于和小于等于的情况。</p><p>还没有做35和34，等到二刷来做。</p><h3 id="Leetcode-27-移除元素-3"><a href="#Leetcode-27-移除元素-3" class="headerlink" title="Leetcode 27 移除元素"></a>Leetcode 27 移除元素</h3><p>相向双指针方法的理解有待加深。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;h3 id=&quot;文章&quot;&gt;&lt;a href=&quot;#文章&quot; class=&quot;headerlink&quot; title=&quot;文章&quot;&gt;&lt;/a&gt;文章&lt;/h3&gt;&lt;p&gt;&lt;a </summary>
      
    
    
    
    <category term="算法（数组）" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="整数二分" scheme="http://example.com/tags/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"/>
    
    <category term="双指针算法" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Django Project Summary</title>
    <link href="http://example.com/2024/01/21/Django-Project-Summary/"/>
    <id>http://example.com/2024/01/21/Django-Project-Summary/</id>
    <published>2024-01-21T21:23:39.000Z</published>
    <updated>2024-01-22T03:39:00.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django项目总结"><a href="#Django项目总结" class="headerlink" title="Django项目总结"></a>Django项目总结</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>Game based on Django framework, developed by yifanChen</p><h3 id="Website"><a href="#Website" class="headerlink" title="Website"></a>Website</h3><p><a href="https://app5894.acapp.acwing.com.cn/">https://app5894.acapp.acwing.com.cn/</a></p><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p><a href="https://github.com/yfchenkeepgoing/Django_app">https://github.com/yfchenkeepgoing/Django_app</a></p><h3 id="Gameplay"><a href="#Gameplay" class="headerlink" title="Gameplay"></a>Gameplay</h3><ol><li>Right-click to move</li><li>Left-click plus ‘Q’ for the skill: Fireball, with a cooldown of 3 seconds</li><li>Left-click plus ‘F’ for the skill: Flash, with a cooldown of 5 seconds</li><li>In multiplayer mode, the winning player gains 10 points, and the losing player loses 5 points</li></ol><h3 id="Technology-Stack"><a href="#Technology-Stack" class="headerlink" title="Technology Stack"></a>Technology Stack</h3><ol><li>Frontend: JQuery</li><li>Backend: Django</li><li>Database: SQLite, Redis</li><li>Network Protocols: HTTPS, WSS</li><li>RPC: Thrift</li><li>Authorization Protocol: OAuth</li><li>Authentication: JWT</li></ol><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ol><li>Complete menu interface and game interface</li><li>Frontend and backend separation, with AcApp and Web versions on the frontend</li><li>Deployed with Nginx to interface with the AcApp</li><li>Comprehensive account system, username and password login, and one-click login with AcWing &amp; GitHub OAuth</li><li>Online multiplayer and chat system implemented via WSS protocol</li><li>Matchmaking system implemented through Thrift service</li><li>Cross-origin issues resolved through Rest Framework and JWT authentication, achieving complete frontend-backend separation</li><li>The ranking board displays the top ten players ranked by score</li></ol><h2 id="Django项目的框架"><a href="#Django项目的框架" class="headerlink" title="Django项目的框架"></a>Django项目的框架</h2><p>一个Django项目，大致由以下六部分组成：</p><ol><li>templates目录：管理html文件</li><li>urls目录：管理路由，即链接与函数的对应关系，即每个链接交给哪个函数处理的信息，存储在urls文件夹中。</li><li>views目录：视图，管理http函数（函数实现在views目录中）</li><li>models目录：管理数据库数据。</li><li>consumers目录：管理websocket函数（views管理http函数，即负责单向连接的函数；consumers管理双向连接的函数，比如联机对战和聊天的逻辑）</li><li>static目录：管理静态文件，比如：</li></ol><ul><li>css文件：对象的格式（网页每部分的格式），比如位置、长宽、颜色、背景、字体大小等</li><li>js：对象的逻辑（项目的核心），比如对象的创建与销毁、事件函数、移动、变色等，渲染html也会在js部分（前端）</li><li>image：图片</li><li>audio：声音</li></ul><p>urls文件夹、views文件夹、models文件夹和consumers文件夹都由python文件组成，如果想通过import将文件导入，则需要在文件夹下创建 <code>__init__.py</code>文件（即索引文件，内容为空即可）。在所有python文件夹中都需要创建这样的函数，否则在import时就无法进去，会报错。</p><h2 id="项目核心逻辑"><a href="#项目核心逻辑" class="headerlink" title="项目核心逻辑"></a>项目核心逻辑</h2><p>本项目由于是一个小游戏，因此前端的js代码占比较大。游戏单人模式的实现纯粹由前端完成，我用js代码实现了一个简易的游戏引擎。游戏的单人模式不需要前后端交互。</p><p>需要前后端交互的部分有：</p><ol><li>注册与登录：涉及到写入、读取、查询数据库</li><li>acwing和GitHub一键登录：即OAuth授权登录</li><li>实现联机对战和聊天系统：涉及到在多名玩家之间同步五个事件（函数）：create_player, move_to, shoot_fireball, attack, message。前四个用于实现联机对战，最后一个用于实现聊天系统。</li><li>Rest Framework与JWT身份验证：是对第一点和第二点的补充。</li></ol><ul><li>JWT（json web token）相比于django自带的登录验证方式（通过session_id）安全性更高。</li><li>方便实现真正意义上的前后端分离，即后端只需要提供实现好的api给前端调用，而Rest Framework为这些api的调试提供了可视化界面。</li><li>JWT可以解决跨域产生的问题。</li><li>可以使用http的四大类请求方法：get, post, delete, put，而不像之前仅仅使用get方法，这又提高了令牌的安全性。</li></ul><p>纯后端的部分只有匹配系统的实现。匹配系统的实现涉及到两个后端（即django web server和match system）之间的通信，匹配系统本身涉及到多线程和锁等方面的知识。</p><p>我认为本项目的重点主要在于前后端交互的部分，前后端交互其实有一套统一的范式：先在views中实现后端的函数；然后在urls中为后端的函数定义url链接；再在前端代码中利用ajax技术通过url获得后端传来的数据（前后端一般以json的格式传递数据）；最后通过前端使用或展示数据。如果给用户设计了一套通过点击鼠标或者使用键盘向后端请求数据的模式，那么还需要在前端进行按键索引和绑定监听函数等操作。</p><h2 id="改进项目"><a href="#改进项目" class="headerlink" title="改进项目"></a>改进项目</h2><ol><li>使用功能更强大的前端框架，比如Vue或者React，取代简单的JQuey。</li><li>使用更多种类型的数据库，比如关系型数据库MySQL，文档数据库MongoDB，对象存储服务等等。</li><li>使用另外几种实现前后端通信的技术取代ajax，比如Fetch API，Server-Sent Events (SSE)，GraphQL和WebRTC，以提高系统的性能。</li><li>学习并尝试使用Springboot框架和Go语言的后端框架。</li><li>使用k8s来自动化部署、扩展和管理容器化应用程序。</li></ol><h2 id="漫谈"><a href="#漫谈" class="headerlink" title="漫谈"></a>漫谈</h2><h3 id="后端的主要分类"><a href="#后端的主要分类" class="headerlink" title="后端的主要分类"></a>后端的主要分类</h3><p>算法与推荐系统、开发各种服务、数据库</p><h3 id="对于实现客户端与服务器之间的通信功能的技术的选择"><a href="#对于实现客户端与服务器之间的通信功能的技术的选择" class="headerlink" title="对于实现客户端与服务器之间的通信功能的技术的选择"></a>对于实现客户端与服务器之间的通信功能的技术的选择</h3><p>除了AJAX，现代Web开发中还有几种其他技术可以实现类似的客户端与服务器之间的通信功能。一些技术在特定场景下比AJAX更高效。以下是一些常用的技术：</p><ol><li><strong>Fetch API</strong>： Fetch API提供了一种更简洁和强大的方式来发起网络请求。它基于Promise，使得写异步代码更加简洁和直观。Fetch API是AJAX的现代替代方案，被广泛支持和使用。</li><li><strong>WebSocket</strong>： WebSocket提供了全双工通信渠道，使得客户端和服务器可以实时、双向地通信。它非常适用于需要频繁和即时数据更新的应用，如在线游戏、聊天应用和实时数据流。</li><li><strong>Server-Sent Events (SSE)</strong>： SSE允许服务器主动向客户端发送新数据。它是单向的，只有服务器可以发送消息给客户端。SSE适合实现如股票行情、新闻订阅等场景，其中服务器定期推送更新。</li><li><strong>GraphQL</strong>： GraphQL是一种数据查询和操作语言，它允许客户端以更灵活的方式请求数据。与REST相比，GraphQL可以减少数据传输量，因为它允许客户端精确指定所需的数据。</li><li><strong>WebRTC</strong>： WebRTC（Web Real-Time Communication）允许在不需要安装插件的情况下在Web应用中实现实时通信功能，常用于视频聊天和点对点数据共享。</li></ol><p>每种技术都有其特定的应用场景和优势。选择哪一种技术取决于应用的具体需求：</p><ul><li>对于简单的异步数据请求，AJAX和Fetch API都是不错的选择。</li><li>对于需要高实时性的应用，WebSocket或WebRTC可能更合适。</li><li>对于服务器主动推送数据的场景，SSE是一个好的选择。</li><li>对于需要更灵活数据交互的场景，GraphQL提供了更好的解决方案。</li></ul><p>在性能方面，WebSocket和WebRTC通常在需要频繁和快速通信的场景下比AJAX更高效，因为它们建立了持久的连接，而不是像AJAX那样为每个请求创建新的连接。</p><h3 id="如何使用MySQL，MongoDB，对象存储服务等外置的数据库（它们不像sqlite，不集成于后端框架内）"><a href="#如何使用MySQL，MongoDB，对象存储服务等外置的数据库（它们不像sqlite，不集成于后端框架内）" class="headerlink" title="如何使用MySQL，MongoDB，对象存储服务等外置的数据库（它们不像sqlite，不集成于后端框架内）"></a>如何使用MySQL，MongoDB，对象存储服务等外置的数据库（它们不像sqlite，不集成于后端框架内）</h3><ul><li>租一台数据库服务器</li><li>在框架中负责数据库的部分配置数据库服务器的连接/登录</li><li>下载该框架下使用该种数据库的包</li><li>在框架中负责数据库的部分调用包中的api完成对数据库的各种操作，比如读、写、删除等。</li></ul><p>在 Django 中，通常不需要直接使用 SQL 语句来操作 MySQL 数据库，因为 Django 提供了一个强大的 ORM（对象关系映射）系统，允许你通过 Python 代码来操作数据库。这意味着你可以使用 Django 的模型和查询 API 来查询和操作数据，而无需直接编写 SQL 语句。</p><p>Django 本身不直接支持 MongoDB，因为它是一个 NoSQL 数据库，与 Django 的 ORM 系统设计理念不同。如果你想在 Django 项目中使用 MongoDB，可以采取以下方法：</p><ul><li>使用 Djongo： Djongo 是一个将 Django ORM 映射到 MongoDB 的工具。通过 Djongo，你可以在一定程度上使用 Django ORM 的风格来操作 MongoDB。</li><li>使用 PyMongo： PyMongo 是 MongoDB 的官方 Python 驱动程序。使用 PyMongo，你可以直接以 Python 代码与 MongoDB 交互，但这意味着你需要手动编写数据库操作逻辑，而不是使用 Django ORM。</li></ul><p>对于对象存储服务（如 Amazon S3），通常使用的是 RESTful API 而非传统的数据库查询语言。在 Django 项目中使用对象存储通常涉及以下步骤：</p><ul><li>选择合适的库： 例如，对于 Amazon S3，你可以使用 boto3，这是 AWS 的官方 Python SDK。</li><li>进行配置和认证： 通常需要设置认证凭据和相关配置。</li><li>使用 SDK 提供的 API： 使用 SDK 提供的方法来上传、下载、列出文件等。</li></ul><h3 id="JWT可以存放在内存、local-storage和cookie中，这三个存放地各自有优缺点"><a href="#JWT可以存放在内存、local-storage和cookie中，这三个存放地各自有优缺点" class="headerlink" title="JWT可以存放在内存、local storage和cookie中，这三个存放地各自有优缺点"></a>JWT可以存放在内存、local storage和cookie中，这三个存放地各自有优缺点</h3><p>Cookie：<br>优点：自动由浏览器管理，并且可以设置为HttpOnly（无法通过JavaScript访问，增加安全性），支持跨域访问控制（SameSite属性）。<br>缺点：容易受到CSRF（跨站请求伪造）攻击，尽管可以通过适当的防范措施（如使用CSRF Token）来缓解。</p><p>LocalStorage：<br>优点：易于使用，可以在浏览器会话间持久存储。<br>缺点：容易受到XSS（跨站脚本攻击）攻击，因为恶意脚本可以访问LocalStorage并窃取令牌。</p><p>内存（JavaScript变量）：<br>优点：在浏览器关闭时自动清除，不容易受到XSS攻击（只要不将令牌暴露给恶意脚本）。<br>缺点：不持久，用户刷新页面或关闭浏览器时会丢失，可能需要重新认证。</p><p>最佳实践：<br>安全性考虑：通常推荐将JWT存储在HttpOnly的Cookie中，因为这样可以防止JavaScript访问令牌，从而减少XSS攻击的风险。</p><p>CSRF防范：如果使用Cookie，应结合CSRF保护机制。</p><p>易用性：如果需要在会话间持久保存用户的登录状态，LocalStorage可能更为方便。但是，务必注意XSS攻击的风险，并采取适当的安全措施。</p><p>短期使用：对于需要高安全性且可接受在会话结束后用户需要重新登录的场景，可以考虑仅将JWT存储在内存中。</p><p>在实践中，选择哪种方式取决于应用的安全需求、用户体验需求以及开发者对相关安全风险的管理能力。在处理任何形式的认证信息时，安全总是首要考虑的因素。<strong>在本项目中，出于安全性和短期使用的考量，我将JWT存储在了内存，即js变量中</strong>。如果没有明确地将JWT存储在Local Storage或Cookie中，那么它们就是存储在内存中。这意味着令牌只在当前页面会话中有效，一旦页面被关闭或刷新，令牌就会丢失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Django项目总结&quot;&gt;&lt;a href=&quot;#Django项目总结&quot; class=&quot;headerlink&quot; title=&quot;Django项目总结&quot;&gt;&lt;/a&gt;Django项目总结&lt;/h1&gt;&lt;h2 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;head</summary>
      
    
    
    
    <category term="web开发" scheme="http://example.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Backend" scheme="http://example.com/tags/Backend/"/>
    
    <category term="Django" scheme="http://example.com/tags/Django/"/>
    
    <category term="Frontend" scheme="http://example.com/tags/Frontend/"/>
    
    <category term="JQuery" scheme="http://example.com/tags/JQuery/"/>
    
    <category term="Ajax" scheme="http://example.com/tags/Ajax/"/>
    
    <category term="Database" scheme="http://example.com/tags/Database/"/>
    
    <category term="SQLite" scheme="http://example.com/tags/SQLite/"/>
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>How to Migrate and Restart a Cloud Server</title>
    <link href="http://example.com/2024/01/21/How-to-Migrate-and-Restart-a-Cloud-Server/"/>
    <id>http://example.com/2024/01/21/How-to-Migrate-and-Restart-a-Cloud-Server/</id>
    <published>2024-01-21T19:31:01.000Z</published>
    <updated>2024-01-21T19:35:51.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迁移云服务器"><a href="#迁移云服务器" class="headerlink" title="迁移云服务器"></a>迁移云服务器</h1><h2 id="1、租云服务器，配置其免密登录"><a href="#1、租云服务器，配置其免密登录" class="headerlink" title="1、租云服务器，配置其免密登录"></a>1、租云服务器，配置其免密登录</h2><p>将本地的公钥复制到云服务器的~/.ssh/authorized_keys中，或者使用云服务器平台提供的密钥，在本地的.ssh文件夹中添加密钥在本地的位置<br>第一次登录云服务器（未配置免密登录）的具体流程可以参照以下步骤：</p><p>IR_Group_7_project Demo Instruction</p><ol><li>Login our VM instance<br>Move key to secure location (eg. ~/.ssh in linux), then</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 path/to/shaoxi_key.pem</span><br><span class="line">ssh -i path/to/shaoxi_key.pem shaoxi@52.174.147.101</span><br></pre></td></tr></table></figure><h2 id="2、在云服务器中安装docker"><a href="#2、在云服务器中安装docker" class="headerlink" title="2、在云服务器中安装docker"></a>2、在云服务器中安装docker</h2><p>安装步骤参见官网：<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a><br>一般安装的版本为20.10.9，使用命令：<code>VERSION_STRING=5:20.10.9~3-0~ubuntu-focal</code><br>查看docker是否安装成功：<code>docker --version</code></p><h2 id="3、在云服务器平台开放以下端口"><a href="#3、在云服务器平台开放以下端口" class="headerlink" title="3、在云服务器平台开放以下端口"></a>3、在云服务器平台开放以下端口</h2><p>22， 8000， 443， 80， 20000，协议均为TCP，源和目的地都为任何（0.0.0.0）</p><h2 id="4、将本地的C-Users-chen-yi-fan-django-lesson-1-tar上传到云服务器里"><a href="#4、将本地的C-Users-chen-yi-fan-django-lesson-1-tar上传到云服务器里" class="headerlink" title="4、将本地的C:\Users\chen yi fan\django_lesson_1.tar上传到云服务器里"></a>4、将本地的C:\Users\chen yi fan\django_lesson_1.tar上传到云服务器里</h2><p>在powershell中执行的具体的命令为：<br><code>scp .\django_lesson_1.tar azureuser@20.123.135.13:~/</code></p><h2 id="5、将镜像xxxx从本地文件xxxx-tar中加载出来"><a href="#5、将镜像xxxx从本地文件xxxx-tar中加载出来" class="headerlink" title="5、将镜像xxxx从本地文件xxxx.tar中加载出来"></a>5、将镜像xxxx从本地文件xxxx.tar中加载出来</h2><p><code>sudo docker load -i xxxx.tar</code></p><h2 id="6、查看镜像是否成功加载出来"><a href="#6、查看镜像是否成功加载出来" class="headerlink" title="6、查看镜像是否成功加载出来"></a>6、查看镜像是否成功加载出来</h2><p>查看所有镜像的命令: <code>sudo docker images</code></p><h2 id="7、使用镜像重新创建并运行容器"><a href="#7、使用镜像重新创建并运行容器" class="headerlink" title="7、使用镜像重新创建并运行容器"></a>7、使用镜像重新创建并运行容器</h2><p><code>docker run -p 20000:22 -p 8000:8000 -p 80:80 -p 443:443 --name django_server -itd django_lesson:1.1</code></p><h2 id="8、登录到容器中"><a href="#8、登录到容器中" class="headerlink" title="8、登录到容器中"></a>8、登录到容器中</h2><p><code>sudo docker attach django_server</code><br>登录为root用户</p><h2 id="9、创建非root用户"><a href="#9、创建非root用户" class="headerlink" title="9、创建非root用户"></a>9、创建非root用户</h2><p><code>adduser acs</code><br>赋予其sudo权限：<code>usermod -aG sudo acs</code><br>设置密码</p><h2 id="10、配置容器的免密登录"><a href="#10、配置容器的免密登录" class="headerlink" title="10、配置容器的免密登录"></a>10、配置容器的免密登录</h2><p>配置免密登录的过程是：在容器的.ssh/authorized_keys中写入本地的.ssh文件夹（C:\Users\chen yi fan.ssh）中的公钥的内容<br>然后修改本地的.ssh/config文件，添加容器的信息，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host django_azure</span><br><span class="line">    HostName 20.123.135.13</span><br><span class="line">    User acs</span><br><span class="line">    Port 20000</span><br></pre></td></tr></table></figure><h2 id="11、从本地-其他云服务器上登录到容器的命令"><a href="#11、从本地-其他云服务器上登录到容器的命令" class="headerlink" title="11、从本地/其他云服务器上登录到容器的命令"></a>11、从本地/其他云服务器上登录到容器的命令</h2><p><code>ssh acs@ip -p 20000</code><br>退出容器时注意不要关闭容器，而是挂起容器：ctrl+p ctrl+q</p><h2 id="12、完成容器的一些配置："><a href="#12、完成容器的一些配置：" class="headerlink" title="12、完成容器的一些配置："></a>12、完成容器的一些配置：</h2><p>nginx配置：<br>（1）修改yxc的acapp中的服务器IP<br>（2）将服务器的IP添加到项目的settings.py的ALLOWED_HOSTS中<br>（3）将yxc提供的nginx.conf写入容器的/etc/nginx/nginx.conf文件中<br>（4）将yxc提供的acapp.key写入容器的/etc/nginx/cert/acapp.key文件中<br>（5）将yxc提供的acapp.pem写入容器的/etc/nginx/cert/acapp.pem文件中<br>（6）启动nginx服务：<code>sudo /etc/init.d/nginx start</code><br>（7）启动uwsgi服务：<code>uwsgi --ini scripts/uwsgi.ini</code></p><p>redis配置：<br>（1）安装redis：<code>pip install django_redis</code><br>（2）启动redis-server：<code>sudo redis-server /etc/redis/redis.conf</code><br>（3）用<code>top</code>命令看有没有进程叫redis-server</p><p>django channels配置：<br>（1）安装channels_redis：<code>pip install channels_redis</code><br>（2）启动django_channels：<br>  在~/acapp目录下执行：<code>daphne -b 0.0.0.0 -p 5015 acapp.asgi:application</code></p><p>同时启动https（uwsgi）和wss（daphne）协议的服务后，项目就应该可以正常运行</p><h2 id="13、启动https和wss服务"><a href="#13、启动https和wss服务" class="headerlink" title="13、启动https和wss服务"></a>13、启动https和wss服务</h2><p>启动https服务：<code>uwsgi --ini scripts/uwsgi.ini</code></p><p>启动wss服务：<code>daphne -b 0.0.0.0 -p 5015 acapp.asgi:application</code></p><hr><h1 id="重启云服务器"><a href="#重启云服务器" class="headerlink" title="重启云服务器"></a>重启云服务器</h1><p>在云平台暂停云服务器后重新启动服务器并进入容器</p><h2 id="1-在云平台启动云服务器"><a href="#1-在云平台启动云服务器" class="headerlink" title="1. 在云平台启动云服务器"></a>1. 在云平台启动云服务器</h2><p>需要等待5-10分钟才能完成重启的过程</p><h2 id="2-查看云服务器中已有的容器"><a href="#2-查看云服务器中已有的容器" class="headerlink" title="2. 查看云服务器中已有的容器"></a>2. 查看云服务器中已有的容器</h2><p>运行命令：<code>sudo docker ps -a</code></p><h2 id="3-启动被暂停-退出的容器"><a href="#3-启动被暂停-退出的容器" class="headerlink" title="3. 启动被暂停/退出的容器"></a>3. 启动被暂停/退出的容器</h2><p>运行命令：<code>sudo docker start django_server</code></p><h2 id="4-进入容器"><a href="#4-进入容器" class="headerlink" title="4. 进入容器"></a>4. 进入容器</h2><p>在vscode上选择django_azure，点击进入即可</p><h2 id="5-启动容器中的服务"><a href="#5-启动容器中的服务" class="headerlink" title="5. 启动容器中的服务"></a>5. 启动容器中的服务</h2><p>主要需要启动以下五个服务：</p><p>启动nginx服务：<code>sudo /etc/init.d/nginx start</code></p><p>启动redis-server：<code>sudo redis-server /etc/redis/redis.conf</code></p><p>启动uwsgi（https）服务：<code>uwsgi --ini scripts/uwsgi.ini</code></p><p>启动wss服务：<code>daphne -b 0.0.0.0 -p 5015 acapp.asgi:application</code></p><p>启动match system服务：<code>./main.py</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;迁移云服务器&quot;&gt;&lt;a href=&quot;#迁移云服务器&quot; class=&quot;headerlink&quot; title=&quot;迁移云服务器&quot;&gt;&lt;/a&gt;迁移云服务器&lt;/h1&gt;&lt;h2 id=&quot;1、租云服务器，配置其免密登录&quot;&gt;&lt;a href=&quot;#1、租云服务器，配置其免密登录&quot; class</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="Cloud Server" scheme="http://example.com/tags/Cloud-Server/"/>
    
  </entry>
  
  <entry>
    <title>How to Build and Maintain a Personal Blog</title>
    <link href="http://example.com/2024/01/20/Blog/"/>
    <id>http://example.com/2024/01/20/Blog/</id>
    <published>2024-01-20T05:57:24.000Z</published>
    <updated>2024-01-20T09:58:31.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何搭建和维护个人博客"><a href="#如何搭建和维护个人博客" class="headerlink" title="如何搭建和维护个人博客"></a>如何搭建和维护个人博客</h1><h2 id="个人博客的实现方式"><a href="#个人博客的实现方式" class="headerlink" title="个人博客的实现方式"></a>个人博客的实现方式</h2><p>使用GitHub Pages和Hexo框架搭建和维护个人博客</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="注意1"><a href="#注意1" class="headerlink" title="注意1"></a>注意1</h3><p>尽量避免在一点不止一行的情况下使用：</p><p>的结构，因为这会导致网页上的博客渲染异常。在这种情况下，建议每一点使用一个小标题</p><h3 id="注意2"><a href="#注意2" class="headerlink" title="注意2"></a>注意2</h3><p>在线博客的刷新需要几分钟时间，请在更新博客后稍安勿躁。在线博客各部分的更新速度不同，比如博客内容先更新了，但日志还没有更新，这是正常现象，稍稍等待即可</p><h3 id="注意3"><a href="#注意3" class="headerlink" title="注意3"></a>注意3</h3><p>由于托管博客的仓库有两个分支，其中的master分支总会在我部署博客时实时更新，因此source分支在发布新博客时更新即可，不需要实时更新</p><h3 id="注意4"><a href="#注意4" class="headerlink" title="注意4"></a>注意4</h3><p>使用VSCode在本地编辑博客即可，博客的内容可以复制自Typora，在VSCode中点击md文件左上角的铅笔符号（Edit in VSCode）即可在VSCode中编辑博客内容，每次编辑完后记得运行部署脚本将博客更新部署到网站上</p><h2 id="博客结构"><a href="#博客结构" class="headerlink" title="博客结构"></a>博客结构</h2><p>本博客计划同时按照标签页（tags）和分类页（categories）进行分类。分类是更大的范畴，主要分为算法、web开发、工具使用、个人随笔和找工记录五大类。标签页是更小的范畴，有Python, C++, Java, Django, Springboot, Typora, GitHub Pages, Hexo, VsCode, 简历等等。一般一篇文章只隶属于一个category，但可以同时拥有多个标签。</p><p>本博客可以通过网址：<br><a href="https://yfchenkeepgoing.github.io/">https://yfchenkeepgoing.github.io/</a><br>访问，注意由于GitHub Pages是静态网页，因此出现延迟请稍安勿躁。另外，本博客所在的仓库地址为：<a href="https://github.com/yfchenkeepgoing/yfchenkeepgoing.github.io">https://github.com/yfchenkeepgoing/yfchenkeepgoing.github.io</a><br>其中有两个分支，分别为master和source。master托管了正在运行的博客，其中的内容在每次运行部署脚本后就会被更新。source托管了博客文件夹的所有源文件，需要通过git命令进行更新。博客网页与master分支中的内容进行了绑定。</p><h2 id="个人博客的特点和功能"><a href="#个人博客的特点和功能" class="headerlink" title="个人博客的特点和功能"></a>个人博客的特点和功能</h2><ol><li>配置站点信息</li><li>修改为next主题</li><li>进行了next主题的配置，包括样式、favicon、avatar、rss、code、top、reading_process、bookmark、github_banner、pangu、math、pjax</li><li>采用gitalk存储并显示评论，需要评论者使用GitHub登录</li><li>使用了标签页和分类页</li><li>拥有搜索页</li></ol><h2 id="如何搭建个人博客"><a href="#如何搭建个人博客" class="headerlink" title="如何搭建个人博客"></a>如何搭建个人博客</h2><p>参见知乎链接：<br><a href="https://zhuanlan.zhihu.com/p/371995929">https://zhuanlan.zhihu.com/p/371995929</a></p><p>其中指导非常详细，但过程较为繁琐，本文不再赘述。本文的重点在于如何维护搭建好的个人博客。</p><h2 id="如何维护个人博客"><a href="#如何维护个人博客" class="headerlink" title="如何维护个人博客"></a>如何维护个人博客</h2><h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><p>进入博客的根目录下，然后调用 Hexo 的 generate 命令，将 Hexo 编译生成 HTML 代码，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>然后我们利用 Hexo 提供的 serve 命令把博客在本地运行起来，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo serve</span><br></pre></td></tr></table></figure><p>然后通过链接：<a href="http://localhost:4000/即可访问到渲染出的博客页面。注意：在这种情况下，博客页面只对自己可见，因此上述命令只能用于调试。">http://localhost:4000/即可访问到渲染出的博客页面。注意：在这种情况下，博客页面只对自己可见，因此上述命令只能用于调试。</a></p><h3 id="维护在线博客"><a href="#维护在线博客" class="headerlink" title="维护在线博客"></a>维护在线博客</h3><h4 id="增加新的文章并将其分类到特定的tags和categories中"><a href="#增加新的文章并将其分类到特定的tags和categories中" class="headerlink" title="增加新的文章并将其分类到特定的tags和categories中"></a>增加新的文章并将其分类到特定的tags和categories中</h4><p>新建一篇名为HelloWorld的文章，在本地博客的根目录下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new hello-world</span><br></pre></td></tr></table></figure><p>创建的文章会出现在 source/_posts 文件夹下，是 MarkDown 格式。<br>在文章开头通过如下格式添加必要信息：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hello-world # 自动创建，如hello<span class="emphasis">_world</span></span><br><span class="line"><span class="emphasis">date: 日期 # 自动创建，如2024-01-20 02:07:51</span></span><br><span class="line"><span class="emphasis">tags: </span></span><br><span class="line"><span class="emphasis">- 标签1</span></span><br><span class="line"><span class="emphasis">- 标签2</span></span><br><span class="line"><span class="emphasis">- 标签3</span></span><br><span class="line"><span class="emphasis">categories:</span></span><br><span class="line"><span class="emphasis">- 分类1</span></span><br><span class="line"><span class="emphasis">- 分类2</span></span><br><span class="line"><span class="emphasis">- 分类3</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure><p>开头下方撰写正文，MarkDown 格式书写即可。这样在下次编译的时候就会自动识别标题、时间、类别等等，另外还有其他的一些参数设置，可以参考文档：<a href="https://hexo.io/zh-cn/docs/writing.html">https://hexo.io/zh-cn/docs/writing.html</a></p><h4 id="标签和分类的区别"><a href="#标签和分类的区别" class="headerlink" title="标签和分类的区别"></a>标签和分类的区别</h4><p><strong>Tags（标签）</strong>：<br>标签是用来描述博客文章中的具体细节的关键词。<br>它们是扁平的，不形成层次结构。<br>标签可以非常具体，也可以非常多，用于描述文章的具体内容，如“Python”、“Web开发”、“机器学习”等。<br><strong>一个文章可以有多个标签，标签的数量通常比分类多</strong>。</p><p><strong>Categories（分类）</strong>：<br>分类通常用来表示博客文章的主要主题或大的分组。<br>它们是层次性的，可以有子分类，形成一个结构化的树状层次，例如：“技术”可以有子分类如“编程”、“网页设计”等。<br>分类通常较少，更宽泛，用于将文章分配到几个广泛的、互相排斥的主题中。<br><strong>一个博客文章通常只属于一个或少数几个分类</strong>。</p><p>使用示例：<br>假设您写了一篇关于Python网络编程的博客文章。您可以将这篇文章归类到“编程”分类下，并给它加上“Python”、“网络编程”、“套接字编程”等标签。</p><p><strong>总结：<br>分类用于表示文章的主要主题，是更广泛的分组工具。<br>标签用于详细描述文章的内容和细节，是更具体的关键词。</strong></p><h4 id="通过部署脚本部署在线博客"><a href="#通过部署脚本部署在线博客" class="headerlink" title="通过部署脚本部署在线博客"></a>通过部署脚本部署在线博客</h4><p>在根目录下新建一个 deploy.sh 的脚本文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>在部署发布的时候只需要执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh deploy.sh</span><br></pre></td></tr></table></figure><p>就可以完成博客的更新了，非常方便。</p><p>注意，在发布博客时只能执行上述命令，不能执行 <code>./deploy.sh</code>，否则博客无法正常发布。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何搭建和维护个人博客&quot;&gt;&lt;a href=&quot;#如何搭建和维护个人博客&quot; class=&quot;headerlink&quot; title=&quot;如何搭建和维护个人博客&quot;&gt;&lt;/a&gt;如何搭建和维护个人博客&lt;/h1&gt;&lt;h2 id=&quot;个人博客的实现方式&quot;&gt;&lt;a href=&quot;#个人博客的实现方</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="GitHub Pages" scheme="http://example.com/tags/GitHub-Pages/"/>
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
    <category term="next主题" scheme="http://example.com/tags/next%E4%B8%BB%E9%A2%98/"/>
    
    <category term="gitalk" scheme="http://example.com/tags/gitalk/"/>
    
  </entry>
  
  <entry>
    <title>How to use Typora</title>
    <link href="http://example.com/2024/01/20/Typora/"/>
    <id>http://example.com/2024/01/20/Typora/</id>
    <published>2024-01-20T02:07:51.000Z</published>
    <updated>2024-01-21T17:07:23.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="（1）标题"><a href="#（1）标题" class="headerlink" title="（1）标题"></a>（1）标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="（2）快捷键"><a href="#（2）快捷键" class="headerlink" title="（2）快捷键"></a>（2）快捷键</h2><p>普通模式和源代码模式：ctrl+/<br>md语法正确显示需要在有文字的一行后面再空一行，把鼠标放在有文字的最后一行的后两行的位置</p><p>标题：按下ctrl和+，则当前行变成第六级的标题，每按一次ctrl和+则当前标题的等级提升一级。按下ctrl和-则是按下ctrl和+的逆向操作。</p><h2 id="（3）字体"><a href="#（3）字体" class="headerlink" title="（3）字体"></a>（3）字体</h2><p><strong>加粗</strong><br><em>倾斜</em><br><strong><em>斜体加粗</em></strong><br><del>删除线</del> （~<em>2删除线~</em>2）<br>==高亮==<br>我是^上标^<br>我是~下标~       （注意用英文的~）</p><h2 id="（4）列表"><a href="#（4）列表" class="headerlink" title="（4）列表"></a>（4）列表</h2><p>无序列表：<br>下一级是加号前面空两格<br>第一级是实心的圆，第二级是空心的圆，第三级开始都是实心的小方框</p><ul><li>一二三四五<ul><li>上山打老虎<ul><li>老虎没打到<ul><li>打到小松鼠</li></ul></li></ul></li></ul></li></ul><p>有序列表：</p><ol><li>一二三四五</li><li>上山打老虎</li><li>老虎没达到</li><li>打到小松鼠</li></ol><h2 id="（5）表格"><a href="#（5）表格" class="headerlink" title="（5）表格"></a>（5）表格</h2><div class="table-container"><table><thead><tr><th>MON</th><th>TUE</th><th>WED</th><th>THU</th><th>FRI</th></tr></thead><tbody><tr><td>上山</td><td>上山</td><td>上山</td><td>上山</td><td>上山</td></tr><tr><td>打老虎</td><td>打老虎</td><td>打老虎</td><td>打老虎</td><td>打老虎</td></tr></tbody></table></div><p>在普通模式下，输入：|MON|TUE|WED|THU|FRI|，再输入回车，即可出现表格，可以增加表格的行和列，以及左右居中等等</p><h2 id="（6）引用"><a href="#（6）引用" class="headerlink" title="（6）引用"></a>（6）引用</h2><p>下一级别：加一个&gt;</p><blockquote><p>一二三四五</p><blockquote><p>上山打老虎</p><blockquote><p>老虎没达到</p><blockquote><p>打到小松鼠</p></blockquote></blockquote></blockquote></blockquote><h2 id="（7）分割线"><a href="#（7）分割线" class="headerlink" title="（7）分割线"></a>（7）分割线</h2><p>疯狂打——-即可</p><hr><h2 id="（7）代码"><a href="#（7）代码" class="headerlink" title="==（7）代码=="></a>==（7）代码==</h2><p><code>我是代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（8）字数和侧边栏"><a href="#（8）字数和侧边栏" class="headerlink" title="（8）字数和侧边栏"></a>（8）字数和侧边栏</h2><p>字数在右下角<br>侧边栏在左侧，可以通过在普通模式中点击左下角的小圆圈呼出<br>大纲也在侧边栏中</p><h2 id="（9）插入图片"><a href="#（9）插入图片" class="headerlink" title="（9）插入图片"></a>（9）插入图片</h2><p>将图片放入到图片文件夹中，然后复制图片将其直接粘贴进来即可</p><p><img src="D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/Snipaste_2023-12-27_04-15-35.png" alt="Snipaste_2023-12-27_04-15-35"></p><p><img src="D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/Snipaste_2023-12-27_04-12-14.png" alt="Snipaste_2023-12-27_04-12-14"></p><h2 id="（10）改变字体颜色"><a href="#（10）改变字体颜色" class="headerlink" title="（10）改变字体颜色"></a>（10）改变字体颜色</h2><p>将字体改变为红色：<code>&lt;font color=red&gt;</code>文字 <code>&lt;/font&gt;</code></p><p>==平常用高亮即可，不要用红色==</p><h2 id="11-diff代码块"><a href="#11-diff代码块" class="headerlink" title="(11) diff代码块"></a>(11) diff代码块</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- 这行被删除了</span></span><br><span class="line"><span class="addition">+ 这行被添加了</span></span><br><span class="line">  这行没有改变</span><br></pre></td></tr></table></figure><h2 id="12-enter和shift-enter的区别"><a href="#12-enter和shift-enter的区别" class="headerlink" title="(12) enter和shift enter的区别"></a>(12) enter和shift enter的区别</h2><p>enter: 新起一段（空一行）<br>shift enter: 新起一行</p><h2 id="13-markdown-source-code"><a href="#13-markdown-source-code" class="headerlink" title="(13) markdown source code"></a>(13) markdown source code</h2><pre><code>## （1）标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题## （2）快捷键普通模式和源代码模式：ctrl+/md语法正确显示需要在有文字的一行后面再空一行，把鼠标放在有文字的最后一行的后两行的位置标题：按下ctrl和+，则当前行变成第六级的标题，每按一次ctrl和+则当前标题的等级提升一级。按下ctrl和-则是按下ctrl和+的逆向操作。## （3）字体**加粗***倾斜****斜体加粗***~~删除线~~ （~*2删除线~*2）==高亮==我是^上标^我是~下标~       （注意用英文的~）## （4）列表无序列表：下一级是加号前面空两格第一级是实心的圆，第二级是空心的圆，第三级开始都是实心的小方框+ 一二三四五  + 上山打老虎    + 老虎没打到      + 打到小松鼠有序列表：1. 一二三四五2. 上山打老虎3. 老虎没达到4. 打到小松鼠## （5）表格| MON    | TUE    | WED    | THU    | FRI    || ------ | ------ | ------ | ------ | ------ || 上山   | 上山   | 上山   | 上山   | 上山   || 打老虎 | 打老虎 | 打老虎 | 打老虎 | 打老虎 |在普通模式下，输入：|MON|TUE|WED|THU|FRI|，再输入回车，即可出现表格，可以增加表格的行和列，以及左右居中等等## （6）引用下一级别：加一个>> 一二三四五>>> 上山打老虎>>>>> 老虎没达到>>>>>>> 打到小松鼠>>>>>>>>>## （7）分割线疯狂打-----即可---##==（7）代码==`我是代码`<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>## （8）字数和侧边栏字数在右下角侧边栏在左侧，可以通过在普通模式中点击左下角的小圆圈呼出大纲也在侧边栏中## （9）插入图片将图片放入到图片文件夹中，然后复制图片将其直接粘贴进来即可![Snipaste_2023-12-27_04-15-35](D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/Snipaste_2023-12-27_04-15-35.png)![Snipaste_2023-12-27_04-12-14](D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/Snipaste_2023-12-27_04-12-14.png)## （10）改变字体颜色将字体改变为红色：`<font color=red>`文字 `</font>`==平常用高亮即可，不要用红色==## (11) diff代码块<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- 这行被删除了</span></span><br><span class="line"><span class="addition">+ 这行被添加了</span></span><br><span class="line">  这行没有改变</span><br></pre></td></tr></table></figure>## (12) enter和shift enter的区别enter: 新起一段（空一行）shift enter: 新起一行</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;（1）标题&quot;&gt;&lt;a href=&quot;#（1）标题&quot; class=&quot;headerlink&quot; title=&quot;（1）标题&quot;&gt;&lt;/a&gt;（1）标题&lt;/h2&gt;&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="Typora" scheme="http://example.com/tags/Typora/"/>
    
    <category term="Mardown" scheme="http://example.com/tags/Mardown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/01/20/hello-world/"/>
    <id>http://example.com/2024/01/20/hello-world/</id>
    <published>2024-01-20T00:56:39.893Z</published>
    <updated>2024-01-20T00:56:39.893Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
