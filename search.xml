<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>How to Build and Maintain a Personal Blog</title>
    <url>/2024/01/20/Blog/</url>
    <content><![CDATA[<h1 id="如何搭建和维护个人博客"><a href="#如何搭建和维护个人博客" class="headerlink" title="如何搭建和维护个人博客"></a>如何搭建和维护个人博客</h1><h2 id="个人博客的实现方式"><a href="#个人博客的实现方式" class="headerlink" title="个人博客的实现方式"></a>个人博客的实现方式</h2><p>使用GitHub Pages和Hexo框架搭建和维护个人博客</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="注意1"><a href="#注意1" class="headerlink" title="注意1"></a>注意1</h3><p>尽量避免在一点不止一行的情况下使用：</p>
<p>的结构，因为这会导致网页上的博客渲染异常。在这种情况下，建议每一点使用一个小标题</p>
<h3 id="注意2"><a href="#注意2" class="headerlink" title="注意2"></a>注意2</h3><p>在线博客的刷新需要几分钟时间，请在更新博客后稍安勿躁。在线博客各部分的更新速度不同，比如博客内容先更新了，但日志还没有更新，这是正常现象，稍稍等待即可</p>
<h3 id="注意3"><a href="#注意3" class="headerlink" title="注意3"></a>注意3</h3><p>由于托管博客的仓库有两个分支，其中的master分支总会在我部署博客时实时更新，因此source分支在发布新博客时更新即可，不需要实时更新</p>
<h3 id="注意4"><a href="#注意4" class="headerlink" title="注意4"></a>注意4</h3><p>使用VSCode在本地编辑博客即可，博客的内容可以复制自Typora，在VSCode中点击md文件左上角的铅笔符号（Edit in VSCode）即可在VSCode中编辑博客内容，每次编辑完后记得运行部署脚本将博客更新部署到网站上</p>
<h2 id="博客结构"><a href="#博客结构" class="headerlink" title="博客结构"></a>博客结构</h2><p>本博客计划同时按照标签页（tags）和分类页（categories）进行分类。分类是更大的范畴，主要分为算法、web开发、工具使用、个人随笔和找工记录五大类。标签页是更小的范畴，有Python, C++, Java, Django, Springboot, Typora, GitHub Pages, Hexo, VsCode, 简历等等。一般一篇文章只隶属于一个category，但可以同时拥有多个标签。</p>
<p>本博客可以通过网址：<br><a href="https://yfchenkeepgoing.github.io/">https://yfchenkeepgoing.github.io/</a><br>访问，注意由于GitHub Pages是静态网页，因此出现延迟请稍安勿躁。另外，本博客所在的仓库地址为：<a href="https://github.com/yfchenkeepgoing/yfchenkeepgoing.github.io">https://github.com/yfchenkeepgoing/yfchenkeepgoing.github.io</a><br>其中有两个分支，分别为master和source。master托管了正在运行的博客，其中的内容在每次运行部署脚本后就会被更新。source托管了博客文件夹的所有源文件，需要通过git命令进行更新。博客网页与master分支中的内容进行了绑定。</p>
<h2 id="个人博客的特点和功能"><a href="#个人博客的特点和功能" class="headerlink" title="个人博客的特点和功能"></a>个人博客的特点和功能</h2><ol>
<li>配置站点信息</li>
<li>修改为next主题</li>
<li>进行了next主题的配置，包括样式、favicon、avatar、rss、code、top、reading_process、bookmark、github_banner、pangu、math、pjax</li>
<li>采用gitalk存储并显示评论，需要评论者使用GitHub登录</li>
<li>使用了标签页和分类页</li>
<li>拥有搜索页</li>
</ol>
<h2 id="如何搭建个人博客"><a href="#如何搭建个人博客" class="headerlink" title="如何搭建个人博客"></a>如何搭建个人博客</h2><p>参见知乎链接：<br><a href="https://zhuanlan.zhihu.com/p/371995929">https://zhuanlan.zhihu.com/p/371995929</a></p>
<p>其中指导非常详细，但过程较为繁琐，本文不再赘述。本文的重点在于如何维护搭建好的个人博客。</p>
<h2 id="如何维护个人博客"><a href="#如何维护个人博客" class="headerlink" title="如何维护个人博客"></a>如何维护个人博客</h2><h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><p>进入博客的根目录下，然后调用 Hexo 的 generate 命令，将 Hexo 编译生成 HTML 代码，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>然后我们利用 Hexo 提供的 serve 命令把博客在本地运行起来，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo serve</span><br><span class="line">hexo new <span class="string">&quot;Day 30 Leetcode 332, 51, 37&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后通过链接：<a href="http://localhost:4000/即可访问到渲染出的博客页面。注意：在这种情况下，博客页面只对自己可见，因此上述命令只能用于调试。">http://localhost:4000/即可访问到渲染出的博客页面。注意：在这种情况下，博客页面只对自己可见，因此上述命令只能用于调试。</a></p>
<h3 id="维护在线博客"><a href="#维护在线博客" class="headerlink" title="维护在线博客"></a>维护在线博客</h3><h4 id="增加新的文章并将其分类到特定的tags和categories中"><a href="#增加新的文章并将其分类到特定的tags和categories中" class="headerlink" title="增加新的文章并将其分类到特定的tags和categories中"></a>增加新的文章并将其分类到特定的tags和categories中</h4><p>新建一篇名为HelloWorld的文章，在本地博客的根目录下执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new hello-world</span><br></pre></td></tr></table></figure>
<p>创建的文章会出现在 source/_posts 文件夹下，是 MarkDown 格式。<br>在文章开头通过如下格式添加必要信息：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hello-world # 自动创建，如hello<span class="emphasis">_world</span></span><br><span class="line"><span class="emphasis">date: 日期 # 自动创建，如2024-01-20 02:07:51</span></span><br><span class="line"><span class="emphasis">tags: </span></span><br><span class="line"><span class="emphasis">- 标签1</span></span><br><span class="line"><span class="emphasis">- 标签2</span></span><br><span class="line"><span class="emphasis">- 标签3</span></span><br><span class="line"><span class="emphasis">categories:</span></span><br><span class="line"><span class="emphasis">- 分类1</span></span><br><span class="line"><span class="emphasis">- 分类2</span></span><br><span class="line"><span class="emphasis">- 分类3</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure>
<p>开头下方撰写正文，MarkDown 格式书写即可。这样在下次编译的时候就会自动识别标题、时间、类别等等，另外还有其他的一些参数设置，可以参考文档：<a href="https://hexo.io/zh-cn/docs/writing.html">https://hexo.io/zh-cn/docs/writing.html</a></p>
<h4 id="标签和分类的区别"><a href="#标签和分类的区别" class="headerlink" title="标签和分类的区别"></a>标签和分类的区别</h4><p><strong>Tags（标签）</strong>：<br>标签是用来描述博客文章中的具体细节的关键词。<br>它们是扁平的，不形成层次结构。<br>标签可以非常具体，也可以非常多，用于描述文章的具体内容，如“Python”、“Web开发”、“机器学习”等。<br><strong>一个文章可以有多个标签，标签的数量通常比分类多</strong>。</p>
<p><strong>Categories（分类）</strong>：<br>分类通常用来表示博客文章的主要主题或大的分组。<br>它们是层次性的，可以有子分类，形成一个结构化的树状层次，例如：“技术”可以有子分类如“编程”、“网页设计”等。<br>分类通常较少，更宽泛，用于将文章分配到几个广泛的、互相排斥的主题中。<br><strong>一个博客文章通常只属于一个或少数几个分类</strong>。</p>
<p>使用示例：<br>假设您写了一篇关于Python网络编程的博客文章。您可以将这篇文章归类到“编程”分类下，并给它加上“Python”、“网络编程”、“套接字编程”等标签。</p>
<p><strong>总结：<br>分类用于表示文章的主要主题，是更广泛的分组工具。<br>标签用于详细描述文章的内容和细节，是更具体的关键词。</strong></p>
<h4 id="通过部署脚本部署在线博客"><a href="#通过部署脚本部署在线博客" class="headerlink" title="通过部署脚本部署在线博客"></a>通过部署脚本部署在线博客</h4><p>在根目录下新建一个 deploy.sh 的脚本文件，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>在部署发布的时候只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh deploy.sh</span><br></pre></td></tr></table></figure>
<p>就可以完成博客的更新了，非常方便。</p>
<p>注意，在发布博客时只能执行上述命令，不能执行 <code>./deploy.sh</code>，否则博客无法正常发布。</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>Hexo</tag>
        <tag>next主题</tag>
        <tag>gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 10 | Leetcode 232, 225</title>
    <url>/2024/02/04/Day-10-Leetcode-232-225/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">栈与队列理论基础</a><br><a href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html">232.用栈实现队列</a><br><a href="https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html">225. 用队列实现栈</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="栈与队列理论基础"><a href="#栈与队列理论基础" class="headerlink" title="栈与队列理论基础"></a>栈与队列理论基础</h3><p>顾名思义，<strong>队列是先进先出，栈是先进后出</strong>（可以从顶部添加元素，也可以从顶部移除元素，但是不能从中间或底部添加或移除元素）。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235346563.png" alt="栈与队列理论1"></p>
<p>栈和队列是STL（C++标准库）里面的两个数据结构。STL有多个版本，其中有三个版本最为普遍。我们介绍的栈和队列是三个版本中的SGI STL里面的数据结构。知道版本才确定其底层实现。</p>
<p>栈：先进后出<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235434905.png" alt="栈与队列理论2"></p>
<p>栈提供push和pop等等接口，时间复杂度都是O(1)，所有元素必须符合先进后出规则（只能在顶部添加和移除元素），所以<strong>栈不提供走访功能，也不提供迭代器(iterator)</strong>。 不像是set 或者map提供迭代器iterator来遍历所有元素。</p>
<p><strong>我们可以用多种容器来实现栈的功能</strong>，栈的底层实现可以是vector，deque（双端队列），list（双向链表）都是可以的， 主要就是数组和链表的底层实现。</p>
<p>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构（deque是容器）。deque是一个双向队列，<strong>只要封住一段，只开通另一端就可以实现栈的逻辑了</strong>。<strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的</strong>。也可以指定vector为栈的底层实现，初始化语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数int：指定了栈中元素的类型</span></span><br><span class="line"><span class="comment">// 第二个参数std::vector&lt;int&gt;：指定了底层容器的类型及其元素类型。即使用一个整型向量来存储栈中的元素。</span></span><br><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure>
<p>通过允许指定底层容器，<code>std::stack</code>提供了灵活性，可以根据不同的性能需求或使用场景来选择最合适的容器类型。例如，<code>std::vector</code>提供了随机访问的能力，但是在容器前端添加或删除元素可能较慢，而<code>std::deque</code>在容器的前端和后端添加或删除元素都较快，但不支持快速随机访问。选择哪种底层容器取决于你的具体需求。</p>
<p>队列是先进先出的数据结构，<strong>同样不允许有遍历行为，不提供迭代器,  SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p>
<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>
<p>STL队列和栈都不被归类为容器，而被归类为container adapter（容器适配器）。<strong>因为可以用不同的容器来实现栈和队列的功能，因此栈和队列不对应于某个特定的容器</strong>。</p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p>yxc讲过的应该是用数组来实现栈和队列，并没有见过怎么用栈来实现队列。直接看卡尔的讲解。</p>
<h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h3><p>我想了想，没想出什么好办法，听卡尔讲吧。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="232-用栈实现队列-1"><a href="#232-用栈实现队列-1" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p>不涉及具体的算法，考察对栈和队列的基本操作。向队列中插入元素123，则队列吐出元素的顺序是123。向栈中插入元素123，则栈吐出元素的顺序是321。若想用栈实现队列，就需要两个栈，一个栈用于存储元素，<strong>另一个栈用于改变第一个栈中元素出栈的顺序</strong>。第一个栈吐出元素的顺序是321，将它们依次插入第二个栈中，则第二个栈吐出元素的顺序是123。第一个栈被称为入栈，第二个栈被称为出栈。</p>
<p><img src="D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/tstmp_20240205061240.gif" alt="tstmp_20240205061240"></p>
<p>入栈中不要有滞留元素的行为，<strong>一旦需要弹出元素，就把入栈中的所有元素全部放入出栈中</strong>，让出栈实现元素的弹出。如果没有把入栈中的所有元素全部放入出栈，则出栈中弹出元素的顺序会与队列弹出元素的顺序不同。</p>
<p>本题pop函数的实现需要特别注意。若出栈为空，则将入栈中的所有元素加入到出栈中。peek和pop方法大部分代码都是重复的，可以在peek中直接调用pop方法：<code>result = this-&gt;pop();</code>。此时第一个元素被获取的同时也被弹出了，因此需要将其插入回去：<code>stackOut.push(result)</code>（peek方法只需要查询元素的数值，不需要像pop函数那样弹出元素）。参考视频讲解中的伪代码，我写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; inStack; <span class="comment">// 入栈</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; outStack; <span class="comment">// 出栈</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向入栈中插入元素即可</span></span><br><span class="line">        inStack.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若出栈为空，则将入栈中的所有元素全部加入到出栈中</span></span><br><span class="line">        <span class="comment">// 如果没有把入栈中的所有元素加入到出栈中，则弹出元素的顺序会发生错误</span></span><br><span class="line">        <span class="comment">// 若出栈不为空，则跳过if判断部分，直接执行本函数最后三行代码</span></span><br><span class="line">        <span class="keyword">if</span> (outStack.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (inStack.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp = inStack.<span class="built_in">top</span>();</span><br><span class="line">                inStack.<span class="built_in">pop</span>();</span><br><span class="line">                outStack.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回出栈顶部的元素并将该元素弹出</span></span><br><span class="line">        <span class="type">int</span> res = outStack.<span class="built_in">top</span>();</span><br><span class="line">        outStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 复用上面实现的pop函数</span></span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 由于pop函数弹出了出栈顶部的元素，peek函数只需要查询出栈顶部的元素，不需要弹出</span></span><br><span class="line">        <span class="comment">// 因此将该元素插入回出栈中</span></span><br><span class="line">        outStack.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 入栈和出栈同时为空时，队列才为空</span></span><br><span class="line">        <span class="comment">// 若只有入栈为空，则出栈中依然有元素没有弹出，说明队列还可以弹出元素，不为空</span></span><br><span class="line">        <span class="comment">// 若只有出栈为空，则入栈中依然有元素可以加入出栈中，之后出栈还可以继续弹出元素，故队列也不为空</span></span><br><span class="line">        <span class="keyword">if</span> (inStack.<span class="built_in">empty</span>() &amp;&amp; outStack.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="225-用队列实现栈-1"><a href="#225-用队列实现栈-1" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h3><p>两个栈才能实现一个队列。<strong>虽然两个队列可以模拟栈，但重点讲一个队列模拟栈的进元素和出元素</strong>。</p>
<p>用两个队列模拟栈：假设栈中先后插入元素123，则栈弹出元素的顺序为321。那么我们可以在队列1中先插入123，然后将1和2放入队列2中，然后从队列1中弹出元素3。接着若想让队列1弹出元素2，则将队列2中的元素2放入队列1中即可。详细讲解见代码随想录网站。</p>
<p>用一个队列模拟栈：在队列中先加入123，然后取出元素1，加入队列中；再取出元素2，加入队列中，此时队列弹出的元素就是3。<strong>推广：队列中有size个元素，先弹出(size - 1)个元素，再将它们加入队列中，再弹出队列中剩余的最后一个元素即可</strong>。</p>
<p>根据上述原理，我独立写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">       q.<span class="built_in">push</span>(x); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = q.<span class="built_in">size</span>(); <span class="comment">// 队列中有size个元素</span></span><br><span class="line">        <span class="comment">// 循环(size - 1)次</span></span><br><span class="line">        <span class="comment">// 先弹出队首的元素，再将其加入到队尾中</span></span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(tmp); </span><br><span class="line">            count -- ;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 弹出队首的元素，即为最后插入的元素</span></span><br><span class="line">        <span class="type">int</span> res = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复用pop函数，但是由于本函数只需要实现查询元素的功能，要记得将弹出的元素插入回去</span></span><br><span class="line">    <span class="comment">// 也可直接return q.back()。因为栈顶的元素就是队列尾部的元素（队列中，从front弹出元素，从back插入元素）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 队列为空，则栈也为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>更简洁的写法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        size -- ;</span><br><span class="line">        <span class="keyword">while</span> (size -- )</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用</strong>，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。据此原理，我写下了如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将除去队尾的元素的其他元素全部加入到q2中</span></span><br><span class="line">        <span class="type">int</span> size = q1.<span class="built_in">size</span>();</span><br><span class="line">        size -- ;</span><br><span class="line">        <span class="keyword">while</span> (size -- )</span><br><span class="line">        &#123;</span><br><span class="line">            q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 收获答案</span></span><br><span class="line">        <span class="type">int</span> res = q1.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// 将q2赋给q1</span></span><br><span class="line">        q1 = q2;</span><br><span class="line">        <span class="comment">// 清空q2</span></span><br><span class="line">        <span class="keyword">while</span> (q2.<span class="built_in">size</span>()) q2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>() &amp;&amp; q2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="232-用栈实现队列-2"><a href="#232-用栈实现队列-2" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><ol>
<li>注意stack内置的pop函数不会返回被移除的元素的值。</li>
<li>实现pop函数时：出栈为空，则插入入栈中的所有元素；出栈不为空，则直接弹出出栈中的首元素。</li>
<li>一旦需要弹出元素，就把入栈中的所有元素全部放入出栈中，否则出栈中弹出元素的顺序会与队列弹出元素的顺序不同。</li>
<li>入栈和出栈都为空时，模拟的队列才为空。</li>
<li>取出栈顶元素再弹出栈顶元素的实现，都是先<code>int tmp = stack.top()</code>，再<code>stack.pop()</code>。</li>
</ol>
<h3 id="225-用队列实现栈-2"><a href="#225-用队列实现栈-2" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h3><ol>
<li>本题的关键在于如何弹出元素。</li>
<li>队列中，从front弹出元素，从back插入元素。取出队列尾部的元素：<code>queue.back()</code>，取出队列头部的元素：<code>queue.front()</code>。</li>
<li>掌握一个队列实现栈的方法即可，两个队列实现栈更加复杂。</li>
</ol>
]]></content>
      <categories>
        <category>算法（栈与队列）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 11 | Leetcode 20, 1047, 150</title>
    <url>/2024/02/05/Day-11-Leetcode-20-1047-150/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html">20. 有效的括号</a><br><a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">1047. 删除字符串中的所有相邻重复项</a><br><a href="https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html">150. 逆波兰表达式求值</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><ol>
<li>cpp中，将一个个字母存储在stack中，用<code>stack&lt;int&gt;</code>或者<code>stack&lt;char&gt;</code>都是一样的。若是<code>stack&lt;int&gt;</code>，则字符以ascii码的形式存储。</li>
<li><p>在Linux系统中，cd（change directory）命令用于更改当前工作目录。它确实可以借助栈的概念来理解路径的导航，尤其是处理相对路径时。</p>
<p>考虑命令<code>cd a/b/c/../../</code>，这里我们可以将目录路径视作一个栈的操作序列：</p>
<p><code>cd a</code>：进入目录a，相当于将a压入栈。<br><code>cd b</code>：进入子目录b，相当于将b压入栈中a的上面。<br><code>cd c</code>：进入子目录c，相当于将c压入栈中b的上面。<br>此时栈的状态为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>然后遇到<code>..</code>，这代表上一级目录，相当于从栈中弹出最上面的元素。第一个<code>..</code>将c弹出。<br>栈的状态更新为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>第二个<code>..</code>将b弹出。<br>最终栈的状态为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<p>所以，最后当前工作目录是a。<strong>在这个过程中，我们可以将每个目录视为栈中的一个元素，每进入一个新的子目录就相当于压入一个元素，而每次使用<code>..</code>就相当于弹出一个元素，回到上一级目录</strong>。这就是栈数据结构在文件系统路径解析中的一个应用。</p>
</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="20-有效的括号-1"><a href="#20-有效的括号-1" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p>不知道怎么做，直接看卡尔的讲解视频。</p>
<h3 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><p>本题应该是一道用栈解决的经典问题。以输入s = “abbaca”为例，定义一个栈，遍历字符串，遍历到第一个字符时，判断栈顶元素是否与之相同，是，则弹出栈顶元素，否，则插入该字符。对后面的字符也是这样处理的。根据这个思路，我独立写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == st.<span class="built_in">top</span>()) st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        string out;</span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            out += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(out.<span class="built_in">begin</span>(), out.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要特别注意：</p>
<ul>
<li>对栈做top操作时需要保证其非空，否则会报访问未知地址，导致程序非法访问内存的错误</li>
<li>将栈中的一个个元素弹出并插入到一个字符串中后，需要将字符串颠倒顺序，输出才是正确的顺序</li>
</ul>
<h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p>我看题后，暂时还没有解题思路。先看视频，了解本题的解题思路。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="20-有效的括号-2"><a href="#20-有效的括号-2" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p>本题是用栈来解决的经典题目。栈的应用：编译器做词法分析、linux系统的命令。</p>
<p>不匹配的场景共有三个：</p>
<ol>
<li>多出左括号</li>
<li>括号的类型不匹配</li>
<li>多出右括号</li>
</ol>
<p>各种不匹配的场景都可被归为以上三类。</p>
<p>如何用栈结构解决三类不匹配的情形？</p>
<p>对1，从字符串的左边向右边遍历，遇到左括号，就将一个对应的右括号加入到栈中。当遍历到字符串的右括号时，若栈顶元素和右括号相同，则弹出栈顶元素。如果字符串遍历完了，但栈不为空，栈中还剩余右括号，就说明字符串中的左括号多了，不匹配。</p>
<p>对2，从左往右遍历字符串，遇到左括号，就在栈中加入一个对应的右括号。遇到右括号，将其与栈顶的元素比较，若不相同，则说明不匹配。</p>
<p>对3，从左往右遍历字符串，遇到左括号，就在栈中加入一个对应的右括号。遇到右括号，将其与栈顶的元素比较，相同则弹出栈顶的元素。若字符串还没遍历完，栈就空了，说明字符串的前面没有左括号与后面的右括号对应，说明多出了右括号，也不匹配。</p>
<p>字符串遍历完之后，栈是空的，就说明全都匹配了。</p>
<p>剪枝：字符串长度为奇数，一定会有不匹配的括号，直接return false即可。</p>
<p>看了卡尔的视频后，我写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// stack&lt;int&gt;和stack&lt;char&gt;都可以</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝：字符串长度为奇数，一定不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="comment">// 不匹配的两种情况：多出右括号和括号类型不匹配</span></span><br><span class="line">            <span class="comment">// 两个判据不可颠倒，否则可能会出现栈为空但依然试图取栈顶元素的情况，编译器会报错</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || s[i] != st.<span class="built_in">top</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 栈不为空且栈的顶元素和s[i]相同，则弹出st的顶元素，两两抵消</span></span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不匹配的情况：多出左括号</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="1047-删除字符串中的所有相邻重复项-1"><a href="#1047-删除字符串中的所有相邻重复项-1" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><p>本题用栈解决非常简单，用其他数据结构比较复杂。本题和20. 有效的括号是同一类问题。本题的主要思路：相邻的字母相同，就做消除的动作。</p>
<p>栈用来存遍历过的元素，同时帮助我们完成消除的动作。<strong>本题可以用一个字符串来模拟栈的行为</strong>，这样在输出时就不需要再把栈转换为字符串了。<strong>用字符串模拟栈时，可以让字符串的尾部作为栈顶，字符串的头部作为栈底</strong>，这样字符串中字符的顺序就是正确的。</p>
<p>根据以上原理，我写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (out.<span class="built_in">empty</span>()) out.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == out.<span class="built_in">back</span>()) out.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">else</span> out.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以将上述代码写的更为精简（将两种需要push_back()的情况合并为一种）：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 字符串为空或者字符串尾部的元素与s[i]不同时，直接在字符串的尾部插入s[i]</span></span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">empty</span>() || res.<span class="built_in">back</span>() != s[i]) res.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            <span class="comment">// 否则，意味着字符串尾部的元素和s[i]相同，则两两抵消，弹出字符串尾部的元素</span></span><br><span class="line">            <span class="keyword">else</span> res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>相比于我在初次尝试中空间复杂度为O(n)的做法，上面的做法空间复杂度是O(1)，因为返回值不计空间复杂度。</p>
<h3 id="150-逆波兰表达式求值-1"><a href="#150-逆波兰表达式求值-1" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p>什么是逆波兰表达式：是后缀表达式。后缀表达式是方便计算机来做运算的一种表达式。我们正常易于阅读的表达式是中缀表达式。例如(1+2)x(3+4)。画成二叉树的形式：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[x] --&gt; B[+];</span><br><span class="line">    A --&gt; C[+];</span><br><span class="line">    B --&gt; D[1];</span><br><span class="line">    B --&gt; E[2];</span><br><span class="line">    C --&gt; F[3];</span><br><span class="line">    C --&gt; G[4];</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>后缀表达式就是上述二叉树的后序遍历</strong>。<strong>后续遍历的顺序是左右中</strong>。因此后缀表达式是：12+34+x。二叉树的中序表达式是1+2x3+4。中序表达式若要得到正确的结果，需要加上括号。但后缀表达式我们不需要加任何括号，从头到尾遍历我们就可以计算出正确的结果。<strong>计算机只需顺序处理后缀表达式，即可得到计算结果，而不必担心括号优先级，这就是为什么说后缀表达式是方便计算机来做运算的一种表达式</strong>。</p>
<p>计算机如何顺序处理后缀表达式？用栈。遍历后缀表达式时，遇到数字就将数字加入栈中，遇到运算符就从栈中取出元素来做运算，再把运算结果加入栈中。以上面的后缀表达式为例，先将1和2加入栈中，遇到+，则弹出2和1，算2+1=3，将3加入栈中。再将3和4加入栈中，遇到+，则弹出4和3，算4+3=7，将7加入栈中。遇到x，栈中弹出7和3，算7x3=21。最后将21加入栈中。后缀表达式的结果就是栈中最后的元素。</p>
<p>总结：两个数字遇到一个操作符时，也做消除操作，将合成的数字加入到栈中。栈适合做相邻字符的消除操作。</p>
<p>根据以上原理，我参照代码随想录的代码写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&quot;+&quot;</span> || s[i] == <span class="string">&quot;-&quot;</span> || s[i] == <span class="string">&quot;*&quot;</span> || s[i] == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 注意采用long long类型</span></span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 注意是先num2再num1</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(num2 + num1);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">                <span class="keyword">else</span> st.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoll</span>(s[i])); <span class="comment">// stoi可以将字符串转换为int, stoll可以将字符串转换为long long</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>(); <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题关于数字的变量类型全部用int而不用long long，也可以通过评测。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="20-有效的括号-3"><a href="#20-有效的括号-3" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><ol>
<li>本题的思路：在字符串中遇到左括号就在栈中插入右括号，在字符串中遇到右括号则判断其能否与栈顶元素相消。</li>
<li>不匹配的三种情况：多出右括号、多出左括号、括号类型不匹配。</li>
<li>本题利用了栈的性质：后插入的元素先弹出，这与本题字符串中后出现的左括号必然有先出现的右括号与之匹配的题意相符。</li>
<li><code>st.empty()</code>和<code>s[i] != st.top()</code>这两个判据顺序不可颠倒，否则会出现栈为空但依然试图取栈顶元素的情况，编译器会报错。</li>
<li>本题可以做剪枝优化：字符串长度为奇数，则必然不匹配。</li>
<li>栈用<code>stack&lt;int&gt;</code>或者<code>stack&lt;char&gt;</code>都可以。前者就是将字符存储为ascii码。</li>
</ol>
<h3 id="1047-删除字符串中的所有相邻重复项-2"><a href="#1047-删除字符串中的所有相邻重复项-2" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><ol>
<li>栈特别适合处理对相邻字符需要做特殊判断的一些问题。比如相邻的括号匹配和消除。</li>
<li>字符串类型的变量也有empty, back, pop_back, push_back等函数。</li>
<li>本题可以用字符串来模拟栈，这样返回时不需要将栈转换回字符串，且可以通过让字符串头部对应栈底，字符串尾部对应栈顶的方式，来让输出的字符串不需要调整顺序（即不需要reverse）</li>
<li>本题需要考虑三种情况：栈为空/栈顶元素和字符串中元素相同/不相同</li>
<li>函数的递归调用需要用到栈</li>
<li>一个函数的返回值不会被计入这个函数的空间复杂度，额外的空间占用才会被计入空间复杂度</li>
</ol>
<h3 id="150-逆波兰表达式求值-2"><a href="#150-逆波兰表达式求值-2" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><ol>
<li>栈适合用于做相邻两个字符的消除操作。</li>
<li>逆波兰表达式即为二叉树的后缀表达式。</li>
<li>后缀表达式由二叉树的后序遍历（按左右中的顺序）得到。</li>
<li>本题思路：遇到数字则将其插入栈中，遇到运算符就弹出栈中的两个数字，计算并将计算结果插入栈中。</li>
<li>注意：运算时先num2（后弹出的数字，二叉树的左子节点）后num1（先弹出的数字，二叉树的右子节点）。</li>
<li>stoi可以将字符串转换为int，stoll可以将字符串转换为long long。</li>
<li>本题无需采用long long类型变量，用int类型变量就可以通过测评。</li>
</ol>
]]></content>
      <categories>
        <category>算法（栈与队列）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>栈</tag>
        <tag>栈的经典应用</tag>
        <tag>相邻元素两两抵消</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 13 | Leetcode 239, 347, summary</title>
    <url>/2024/02/06/Day-13-Leetcode-239-347-summary/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">239. 滑动窗口最大值</a><br><a href="https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html">347.前 K 个高频元素</a><br><a href="https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93.html">栈与队列总结</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><h3 id="栈与队列总结"><a href="#栈与队列总结" class="headerlink" title="栈与队列总结"></a>栈与队列总结</h3><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="239-滑动窗口最大值-1"><a href="#239-滑动窗口最大值-1" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p>本题应该有些类似于滑动窗口的经典题目：209.长度最小的子数组。本题的思路：用一个长度始终为3的队列，滑过数组。每次算出队列中的最大值，然后存入数组中。我打算另写一个函数来返回三个值中的最大值。但是应该是有办法在队列进出元素的时候顺便维护其中的最大值。</p>
<p>我根据暴力做法的思路，写下了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 得出队列中的最大值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">queuemax</span><span class="params">(queue&lt;<span class="type">int</span>&gt; q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> max = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> tmp = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (max &lt; tmp) max = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &lt; k) q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q.<span class="built_in">size</span>() == k)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">queuemax</span>(q));</span><br><span class="line">                q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">queuemax</span>(q));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述代码在输入数组不大时可以正常运行，但输入数组太大时会超时，测试样例通过了37 / 51。上述暴力做法的时间复杂度是O(n * k)。看代码随想录的视频讲解吧。</p>
<h3 id="347-前-K-个高频元素-1"><a href="#347-前-K-个高频元素-1" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><p>拿到这道题，我的第一想法是拿哈希去做。但发现哈希不能解决本题，因为对统计频率的数组排序后，数组的下标（即输入数组的元素）被打乱了。直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="239-滑动窗口最大值-2"><a href="#239-滑动窗口最大值-2" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p>本题是第一道hard。难点：如何求窗口中的最大值？暴力做法时间复杂度O(n <em> k)。需要一个特殊的队列，实现pop, push和getMaxValue（返回当前队列中的最大值）这三个操作。还可以用一个优先级队列。<strong>cpp中的优先级队列就是大顶堆（单调递减）或者小顶堆（单调递增）</strong>。大顶堆本质就是一个排序后的二叉树，最大的元素在上面。始终维护大顶堆，让大顶堆不断插入元素和弹出元素，大顶堆最前面的元素就是滑动窗口的最大值。<em>*但是用大顶堆是不行的</em></em>，因为无法正确地弹出元素（大顶堆内部自动做了排序，打乱了原来元素的顺序）。</p>
<p>因此用优先队列是不行的，需要我们自行实现一个<strong>单调队列</strong>来解决问题。需要维持队列中的元素是单调递增或单调递减的，同时需要保证pop操作的正确。<strong>单调队列中只需要维护有可能成为最大值的元素，而不需要维护k个元素</strong>。</p>
<p>模拟单调队列：<br>假设输入数组为13-1-35321。首先在队列中加入元素1，再加入3，若队列的前面有小于3的元素，则将这些元素全部弹出。这样做可以让队列的出口处就是最大值。<strong>由于随着滑动窗口的移动，本身就会舍弃第1个1，因此没必要维护3之前比3小的元素</strong>。接着在队列中加入-1。此时队列的前面没有小于-1的元素，故-1可以保留在队列中。此时取队首元素3，就是最大值。接着加入-3，队列前面的元素都大于-3，故保留-3，此时队列的最大值还是3。接着加入5，由于5比队列前面的元素都大，因此需要pop掉除5以外的全部元素，此时取队列的最大值，即队首元素，是5。接着放入3，3&lt;5，放入3，此时队列的最大值还是5。接着加入2，2&lt;5&amp;&amp;2&lt;3，因此放入2，此时队列的最大值还是5。再向后移动，需要把最大值5pop掉，加入1，1&lt;2 &amp;&amp; 1&lt;3，因此队列中加入1，此时队列的最大值是队首元素3。</p>
<p>单调队列在数组中移动的规则：除去常规的移动窗口的pop和push操作外，若push进来的元素比队列前面的元素都大，那前面的元素都要pop出去，直到队列前面的元素都大于push进来的元素为止。本方法的好处在于<code>getMaxValue</code>时取队首元素即可。</p>
<p>根据原理，我画出了如下的示意图，可以帮助理解（下图中打x的元素是因为单调队列的特殊规则：<code>若push进来的元素比队列前面的元素都大，那前面的元素都要pop出去</code>而被提前被删去的元素）。<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-02-07_13-50-29.png?raw=true" alt="Snipaste_2024-02-07_13-50-29.png"></p>
<p>根据上述原理，我尝试写出相应的代码，但是有一个问题我始终无法解决：根据规则：<code>若push进来的元素比队列前面的元素都大，那前面的元素都要pop出去</code>，有时原本的队首元素已经被更新为最大的元素了，意味着滑动窗口本身最前面的元素已经被弹出了，但有时，滑动窗口本身最前面的元素还没有被弹出，它仍作为队首元素，需要手动弹出。如何判断是否需要手动弹出队首元素。我来看看卡尔的代码实现，看他是如何解决这个问题的。</p>
<p>卡尔写了单调队列的三个关键函数。单调队列是在双向队列的基础上实现的，双向队列的首尾都可以出入元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// cpp中队列默认用deque双向队列来实现，双向队列的首尾都可以出元素和入元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 只有当需要pop的元素和队首元素（单调队列中目前的最大值）相同时，才弹出队首元素</span></span><br><span class="line">    <span class="comment">// 例如上图的倒数第二行到最后一行的操作（532-&gt;321）</span></span><br><span class="line">    <span class="comment">// 若需要pop的元素小于队首元素，那么在push时该元素已经被删除了</span></span><br><span class="line">    <span class="comment">// 例如上图中的-1-35-&gt;-353，本来需要手动删除-1，但由于-1&lt;5，因此在push(5)时-1已经被删除了</span></span><br><span class="line">    <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val == que.<span class="built_in">front</span>())</span><br><span class="line">        que.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当队列不为空且要插入的值val &gt; 队列中的最后一个元素时，持续从队尾弹出元素</span></span><br><span class="line">    <span class="comment">// 例如上图中的3-1-3-&gt;-1-35，要插入5，持续从队尾弹出比5小的元素，然后再插入5</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val &gt; que.<span class="built_in">back</span>()) que.<span class="built_in">pop_back</span>();</span><br><span class="line">    que.<span class="built_in">push_back</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">(deque&lt;<span class="type">int</span>&gt; que)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述关键代码的基础上，我写下了解决本题的完整代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">            <span class="comment">// 单调队列中只维护当前队列中的最大值，作为队首元素</span></span><br><span class="line">            <span class="comment">// 故窗口滑动时只需要在滑出最大值时手动删除最大值即可</span></span><br><span class="line">            <span class="comment">// 其他值都会在push时被删除</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val == que.<span class="built_in">front</span>()) que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保证单调队列从队首到队尾是单调递减的</span></span><br><span class="line">            <span class="comment">// 新插入的元素若大于当前队列中的最大值，则删除当前队列，将插入的元素放在队列的首部</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val &gt; que.<span class="built_in">back</span>()) que.<span class="built_in">pop_back</span>();</span><br><span class="line">            que.<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前队列中的最大值为队首元素，故返回队首元素即可</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]);</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="347-前-K-个高频元素-2"><a href="#347-前-K-个高频元素-2" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><p>两个难点：</p>
<ul>
<li><p>如何求数组中每个元素的频率</p>
</li>
<li><p>如何对这个频率进行排序，并求前k个高频的元素</p>
</li>
</ul>
<p>用map来进行排序，key用来存放元素，value用来存放元素出现的次数。接着以value为基准做从大到小的排序（不好做，因为map默认是按照key的顺序来进行排序的），最后输出value对应的key即可。时间复杂度<code>O(nlogn)</code>。</p>
<p>求前k个高频的元素，只需维护k个有序的集合，没必要对所有元素都进行排序。经典的数据结构：大顶堆、小顶堆。堆擅长在很大的数据集中求前k个高/低频的元素。大顶堆的根节点是最大的元素，小顶堆的根节点是最小的元素。</p>
<p>如何用堆解决这个问题？用堆去遍历map中的所有元素（以value为基准进行统计），堆中维持k个元素，遍历完map中的所有元素后，堆中的k个元素就是前k个高频元素。<strong>大/小顶堆？</strong>用大顶堆遍历map中的所有元素时，遇到新元素时，将其插入到大顶堆中，会弹出堆顶的元素（最大的元素），<strong>用大顶堆遍历完map后，堆中剩下的元素是前k个低频的元素</strong>。<strong>因此要用小顶堆</strong>。小顶堆每次在push进来元素时，弹出堆顶元素（最小的元素），堆中剩下的就是最大的元素。最后输出前k个最大的value对应的key。时间复杂度：遍历数组O(n)，每次堆中元素调整O(logk)（堆中有k个元素，堆是树状结构），总时间复杂度为O(nlogk)。在数组很大，k较小的情况下，本做法的性能明显优于对整个map进行排序的性能。优先级队列的底层实现是堆，<strong>因此用优先级队列即可</strong>。可自行实现大顶堆和小顶堆。</p>
<p>参考代码随想录的代码，我写下了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">compare</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="comment">// 为定义小顶堆重载运算符，这里的函数名为operator()，而非operator</span></span><br><span class="line">        <span class="comment">// 对大顶堆，本来应该是右边的元素&gt;左边的元素，对小顶堆，则与此相反</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; lhs, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rhs)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second; <span class="comment">// 比较的是元素出现的次数，而非元素的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nums[i]作为key, 出现此处作为value存入map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            map[nums[i]] ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义小顶堆，其中的元素类型是pair&lt;int, int&gt;，底层实现是vector&lt;pair&lt;int, int&gt;&gt;</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, compare&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map，不断将map中的元素插入小顶堆中，小顶堆不断弹出根节点处最小的元素</span></span><br><span class="line">        <span class="comment">// 最后剩下的k个元素是出现频次最高的k个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; k) q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点处是最小的元素，越往下元素越大，因此将小顶堆中的k个元素倒着插入res中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = q.<span class="built_in">top</span>().first; <span class="comment">// 插入res的是key, 即nums[i]</span></span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="239-滑动窗口最大值-3"><a href="#239-滑动窗口最大值-3" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><ol>
<li>单调队列需要手动实现，cpp标准库中没有现成可用的单调队列。</li>
<li>单调队列的好处在于能够将当前队列中的最大值放在队首，且不改变其他值的排列顺序（即其他值在单调队列中的排列顺序和它们在输入数组中的排列顺序相同）。</li>
<li>单调队列的特殊规则：若push进来的元素比队列前面的元素都大，那前面的元素都要pop出去。</li>
<li>定义一个类，在双向队列的基础上实现单调队列，而不要试图在主函数中对<code>queue&lt;int&gt;</code>做加工。</li>
<li>本题的详细模拟流程见实现中的图片。</li>
<li><p>单调队列中定义了三个函数：pop, push和getMaxValue。<br>对pop函数（负责模拟窗口的滑动，删除队首的最大值），需要注意：</p>
<ul>
<li>单调队列中只维护当前队列中的最大值，作为队首元素</li>
<li>故窗口滑动时只需要在滑出最大值时手动删除最大值即可</li>
<li>其他值都会在push时被删除</li>
</ul>
<p>对push函数（负责向单调队列中插入元素，同时调整队列中元素的顺序，将最大值置于队首），需要注意：</p>
<ul>
<li>保证单调队列从队首到队尾是单调递减的</li>
<li>新插入的元素若大于当前队列中的最大值，则删除当前队列，将插入的元素放在队列的首部</li>
<li>当前队列中的非最大值会在不断调用push函数的过程中被删除，最大值则需要pop函数来删除</li>
</ul>
</li>
<li>时间复杂度: O(n) 空间复杂度: O(k)<br>输入数组中的每个元素在单调队列中最多也就被插入和弹出各一次，没有任何多余操作，所以整体的时间复杂度还是O(n)。空间复杂度因为我们定义一个辅助队列，所以是O(k)。</li>
<li>本题之所以选择在双向队列的基础上加工出单调队列,是因为双向队列可以方便地在队首和队尾插入和删除元素。</li>
<li><p>注意类的写法、双向队列的<code>push_back</code>, <code>push_front</code>, <code>pop_back</code>, <code>pop_front</code>以及单调队列的<code>push</code>, <code>pop</code>等方法，不要写错或者混淆。</p>
<h3 id="347-前-K-个高频元素-3"><a href="#347-前-K-个高频元素-3" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3></li>
<li><p>本题的大致思路：用map来存储元素的值和出现次数，用一个小顶堆遍历map，最终获取出现次数最高的k个元素。<br><strong>map-&gt;priority_queue-&gt;vector</strong></p>
</li>
<li>本题的思路：用map的key存储元素的值，value存储元素出现的次数。定义一个小顶堆。遍历map，不断将map中的元素插入到小顶堆中，不断弹出小顶堆根节点处的元素，最后小顶堆中剩下的k个元素就是出现次数最高的k个元素。将这k个元素倒着插入结果数组中即可。</li>
<li>为什么使用小根堆：小跟堆根节点处的元素最小，每次弹出元素也是从根节点处弹出，因此用大小为k的小根堆遍历完map后，小根堆中的k个元素是出现次数最高的k个元素，较小的元素在遍历的过程中就已经被弹出了。</li>
<li>注意小顶堆的定义方式：在优先级队列的基础上，传入的参数分别为小顶堆中存储的元素类型，小顶堆的底层实现，自定义的compare类（用于实现小顶堆根节点是最小元素的特性）。</li>
<li>注意如何写compare类，关键在于重载运算符。</li>
<li>注意vector数组是可以定义大小的，定义方式为<code>vector&lt;int&gt; res(k)</code>，vector元素定义了大小之后，就能像普通数组那样用索引给元素赋值：<code>res[i]</code>，插入元素的push_back函数并不是必须的。</li>
<li>根据小根堆的特点，res数组需要倒着插入，即从下标<code>k - 1</code>处开始插入。</li>
<li>定义类是，要记得在类中的函数前加上public，否则无法正常调用类中的函数。</li>
<li>本算法的时间复杂度是O(nlogk)，好于对map全部排序的O(nlogn)，在n较大，k较小时性能提升尤为明显。</li>
</ol>
<h3 id="栈与队列总结-1"><a href="#栈与队列总结-1" class="headerlink" title="栈与队列总结"></a>栈与队列总结</h3><ol>
<li>栈和队列的理论基础：栈先入后出，队列先入先出</li>
<li>用两个栈实现队列，用一个队列实现栈</li>
<li>栈的应用：栈的应用相对较为简单且单一。栈特别适合处理对相邻字符需要做特殊判断的一些问题。比如相邻的括号匹配（20. 有效的括号）、相邻字符的消除（删除字符串中的所有相邻重复项）和后缀表达式中相邻数字的计算（逆波兰表达式求值）。</li>
<li>队列的应用：队列的应用更为复杂且多样，包括手动实现单调队列（239. 滑动窗口最大值）和手动实现大/小顶堆（优先级队列）347. 前k个高频元素）。对于队列的应用要多复习，这两题写起来都较为复杂。</li>
<li>单调队列不是一成不变的，而是不同场景不同写法。不要以为239. 滑动窗口最大值中的单调队列实现就是固定的写法。</li>
<li><p>栈里面的元素在内存中是连续分布的么？</p>
<p>这个问题有两个陷阱：</p>
<ul>
<li>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。</li>
<li>陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。</li>
</ul>
</li>
<li>拓展题：71. 简化路径</li>
<li>优先级队列就是大/小顶堆，名字虽为队列（因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列），但本质是完全二叉树。大顶堆（堆头是最大元素），小顶堆（堆头是最小元素）。从小到大排就是小顶堆，从大到小排就是大顶堆。大小顶堆和大小根堆是相同的。</li>
</ol>
]]></content>
      <categories>
        <category>算法（栈与队列）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>队列</tag>
        <tag>队列的经典应用</tag>
        <tag>单调队列</tag>
        <tag>优先级队列（大/小顶堆）</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>DJI Osmo Pocket3 User Guide</title>
    <url>/2025/03/22/DJI-Osmo-Pocket3-User-Guide/</url>
    <content><![CDATA[<h2 id="首次使用"><a href="#首次使用" class="headerlink" title="首次使用"></a>首次使用</h2><ol>
<li>修改pocket3的语言：将屏幕从上往下滑，点击“设置”（齿轮图标），往左滑到最后点“更多”，里面有个“语言”设置按钮进行语言设置。</li>
<li>资源：<ul>
<li><a href="https://www.bilibili.com/video/BV1Fj411v7yW?vd_source=649ef3a5183a7826e9a118e84c31f544">Osmo Pocket 3 - 使用指南 MAX版</a></li>
<li>DJI Mimo中的课程，和第一个资源有部分重合但内容更多，包括新手课程-初级课程-中级课程-高级课程</li>
</ul>
</li>
<li>修改两个app的语言为中文：<ul>
<li>DJI Mimo：设置中无法调节语言，只会跟随我的系统语言设置，暂时将我的系统语言换回中文</li>
<li>大疆商城：设置-国家/地区-中国大陆</li>
</ul>
</li>
<li>将pocket3放回保护盖中时，注意屏幕朝里面放回去，否则关不上保护壳</li>
<li>1/4螺纹手柄：<ul>
<li>提升机身握持手感</li>
<li>上面有type c接口，可以用来充电</li>
<li>安装时，直接插入pocket3底部（无需按住解锁按键）。取下时，请按住解锁按键同时向下拔出。</li>
</ul>
</li>
<li>旋转屏幕至水平方向可以开启pocket3，恢复屏幕到竖直方向可以关闭pocket3。关机状态下云台将进入轴锁锁定状态，防止云台晃动受到损坏。</li>
<li>橘色的是拍摄按键：<ul>
<li>短按：开机、拍照、录像</li>
<li>长按：关机</li>
</ul>
</li>
<li>黑色的是五维摇杆</li>
<li>pocket3开机默认为视频录像模式，插入SD卡（需要用力用指甲将SD卡给顶进去，插入成功后SD卡会完全没入机身，不会弹出来），点击拍摄按键即可开始录像。再次点击结束录制</li>
<li>在屏幕上朝右滑动进入回放界面，将自动开始播放最近一次拍摄的视频。点击暂停并再次向右滑动，可以选择收藏或删除该视频。屏幕朝左滑动或者按一次摇杆，回到拍摄界面。</li>
</ol>
<h2 id="相机功能"><a href="#相机功能" class="headerlink" title="相机功能"></a>相机功能</h2><ol>
<li>点击屏幕左下角的拍摄图标，多种拍摄模式供选择。包括：全景、拍照、视频、低光视频、慢动作和静止延时。</li>
<li>选择录像模式后，屏幕向上滑动进入参数设置界面，可以设置录像分辨率，帧率和画幅比例（16：9/1：1），最高支持4K 60HZ 16：9。</li>
<li>屏幕往左滑动可以开启和关闭PRO模式。在PRO模式下可以做更多参数的调节，包括曝光、白平衡、色彩模式、对焦方式、图像调解等（学妹说的参数预设，大疆pocket3直出参数大合集小红书中的参数就是在这里调节）。<ul>
<li>色彩模式：可选择普通色彩、HLG-10bit、D-logM 10bit。</li>
<li>图像调节：可调解锐度、去噪等级。</li>
<li>对焦模式（默认为连续）：<ul>
<li>单次：执行一次对焦后不再自动对焦，适用于不改变对焦位置的场景拍摄</li>
<li>连续：持续对焦主体，适用于拍摄动态目标</li>
<li>展示模式：优先对焦前景物体，适用于近距离物体展示。展示模式适合如化妆展示、开箱展示等，此时相机快速对焦镜头前方的被展示物品。</li>
</ul>
</li>
<li>麦克风图标：对收音效果进行设置，包括：<ul>
<li>声道：单声道/立体声</li>
<li>降风噪：开/关</li>
<li>指向收音：全向、向前、前后双向</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="美颜功能"><a href="#美颜功能" class="headerlink" title="美颜功能"></a>美颜功能</h2><ol>
<li>屏幕左滑可以看到美颜，点击可开启/关闭</li>
<li>开启美颜后，可以看到屏幕右上角有美颜图标（笑脸）</li>
<li>美颜效果不会实时在屏幕内显示，连接Mimo后，可以在Mimo内实时观看美颜后的效果，SD卡内会保留原始素材效果</li>
<li>进入Mimo的美颜调节界面后，可以选择使用默认参数，一键自动美颜，也可以自由调整磨皮、美白、瘦脸等参数</li>
<li>带有美颜效果的素材需要通过收集DJI Mimo App导出。在Mimo进入美颜设置前，需要稍等片刻完成渲染</li>
<li>在拍摄时没有开美颜的视频，可以在DJI Mimo App中开启一键美颜，自由调整磨皮、美白、瘦脸等参数，然后一键导出。在拍摄时开启了美颜的视频，也可以在DJI Mimo App中关闭美颜或者重新调整磨皮、美白、瘦脸等参数。</li>
</ol>
<h2 id="系统功能介绍"><a href="#系统功能介绍" class="headerlink" title="系统功能介绍"></a>系统功能介绍</h2><ol>
<li><p>自定义模式：可保存用户自定义拍摄模式，可保存的参数有：</p>
<ul>
<li>拍摄模式（视频/照片等）</li>
<li>拍摄的基础参数（比如4K/16: 9/60HZ）</li>
<li>图像设置参数（即白平衡的参数，比如AWB）</li>
</ul>
<p>保存好后，可以点击屏幕左下角的拍摄图标在多种拍摄模式中进行选择（自定义的拍摄模式被命名为C1/C2等等）</p>
</li>
<li><p>转屏开录：开启转屏开录开关后，关机状态下顺时针旋转屏幕，即可快速开启录制</p>
</li>
<li><p>屏幕亮度调节：可以调节屏幕显示亮度，范围0-100%</p>
</li>
<li><p>自拍跟随：开启后，当相机方向转向屏幕侧时，自动开启智能跟随人脸，摄像头会跟随人脸的移动而移动，确保人脸始终在屏幕的中央</p>
</li>
<li><p>系统设置，可设置：无线麦克风、云台开机方向、旋转屏幕关机（秒数）、自拍镜像 等系统设置选项</p>
</li>
<li><p>横竖拍模式切换，默认为自适应横竖拍，也可以根据需要设置为锁定横拍或锁定竖拍</p>
</li>
<li><p>云台转向速度：</p>
<ul>
<li>慢：云台转向柔和，具有超强的增稳效果</li>
<li>默认：默认模式下，适合大多数拍摄场景，获得稳定的运镜画面</li>
<li>快：适合拍摄机动性强的目标，增稳效果有所减弱，还原手持临场感</li>
</ul>
</li>
<li><p>云台模式：不同云台模式将影响增稳控制的风格</p>
<ul>
<li>默认增强：默认模式，适合vlog、自拍等大多数拍摄场景</li>
<li>俯仰锁定：镜头保持绝对水平，适合推拉横移的创作拍摄，如舞蹈，运动跟拍等</li>
<li>FPV：画面不保持水平，跟随握持方向，适合创意拍摄</li>
<li>FPV-I：回中方向垂直于机身的FPV模式，适合沿屏幕取景正对方向快启快拍</li>
</ul>
</li>
</ol>
<h2 id="云台模式"><a href="#云台模式" class="headerlink" title="云台模式"></a>云台模式</h2><p>共有三种云台模式：</p>
<ul>
<li>默认增稳：适合vlog，自拍等大多数拍摄场景</li>
<li>俯仰锁定：适合推拉横移的创作拍摄，如舞蹈、运动跟拍等。在该模式下，镜头保持绝对水平</li>
<li>FPV模式：适合街舞或创意运镜的拍摄。在该模式下，画面不保持水平，跟随握持方向</li>
<li>还新增了一个FPV-I模式，视频里没有介绍，但是我在系统功能介绍的云台模式部分记录了该模式的特点</li>
</ul>
<p>云台转向速度有三档可以选择，不同转向速度将影响云台跟随手转动的幅度和速度：</p>
<ul>
<li>“慢”档：获得稳定的运镜画面，跟手速度最慢</li>
<li>“默认”速度：云台转向柔和，具有超强的增稳效果，跟手速度中等</li>
<li>“快”挡：适合拍摄机动性强的目标，增稳效果有所减弱，还原手持拍摄场景快速跟随手转动</li>
</ul>
<h2 id="智能辅助功能"><a href="#智能辅助功能" class="headerlink" title="智能辅助功能"></a>智能辅助功能</h2><ol>
<li>智能跟随：双击pocket3拍摄界面，双击跟随主体，可实现跟随拍摄，将被摄物体牢牢锁定在画面中心。智能跟随6.0跟随效果大幅提升，在人物短暂被遮挡后，可以找回目标并重新开始跟随。解除跟随只需要将被跟随物体移出pocket3拍摄范围内，此时pocket3首先会显示黄色的云台到达限位，或者会显示白色的目标丢失。中焦模式不支持智能跟随。开关中焦模式就是点击 分辨率参数（比如4K60）旁边的方框形状即可。中焦模式我目前觉得就是一个放大的功能。</li>
<li>除手动选择目标外，还提供了三种触发跟随的方式（后两种跟随方式都是通过点击屏幕左侧中间处的图标，分别选择前两项开启）：<ul>
<li>自拍跟随：下滑页面开启自拍跟随模式，在拍摄方向转至自拍时，自动对最近的人脸开启智能跟随，并在转回前方视角时取消跟随。</li>
<li>主角跟随：当需要将pocket3放置在远处单人拍摄跟随视角时，可以使用主角跟随模式。此模式下，开始录制后进入镜头的第一个目标将被锁定为画面的主角。镜头将实时跟随主角进行拍摄。</li>
<li>预构图跟随：需要锁定人物在画面中的位置，可使用预构图跟随功能。进入预构图跟随功能后，会在屏幕中显示九个构图点，可以通过上下左右推动摇杆将构图点对准需拍摄的人物脸部后，单击摇杆开启跟随。开启录制后，人物目标将被锁定在选定的构图位置，大大减少运镜难度。</li>
</ul>
</li>
<li>旋转运镜：通过点击屏幕左侧中间处的图标，选择最后一项开启。画面旋转90°/180°，拍摄独特运镜。<ul>
<li>云台新的结构设计可以实现手电筒模式（pocket3向前指）下的90°或180°旋转。点击屏幕上方旋转图标或单击摇杆，云台镜头将自动旋转90°或180°进行拍摄，呈现独特的运镜效果。</li>
<li>非手电筒模式下的常规模式，云台也可以点击屏幕上方旋转图标或单击摇杆进行90°或180°旋转</li>
<li>第一次点击屏幕上方的旋转图标或单击摇杆，会旋转。第二次点击屏幕上方的旋转图标或单击摇杆，会复位</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>大疆</tag>
        <tag>Pocket3</tag>
        <tag>指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Comprehensive Introduction to C#</title>
    <url>/2024/11/18/Comprehensive-Introduction-to-C/</url>
    <content><![CDATA[<h1 id="Comprehensive-Introduction-to-C"><a href="#Comprehensive-Introduction-to-C" class="headerlink" title="Comprehensive Introduction to C"></a>Comprehensive Introduction to C</h1><p>参考笔记：<a href="https://blog.csdn.net/weixin_52421373/article/details/127972228">https://blog.csdn.net/weixin_52421373/article/details/127972228</a></p>
<p>vs 2013 ultimate的密钥：</p>
<p>VS_2013英文版下载：<a href="https://www.123pan.com/s/mWzgjv-es653.html">https://www.123pan.com/s/mWzgjv-es653.html</a></p>
<p>中文语言包下载：<a href="https://www.123pan.com/s/mWzgjv-ts653.html">https://www.123pan.com/s/mWzgjv-ts653.html</a> </p>
<p>KEY:BWG7X-J98B3-W34RT-33B3R-JVYW9</p>
<h2 id="1-课程简介，C-语言简介，开发环境准备"><a href="#1-课程简介，C-语言简介，开发环境准备" class="headerlink" title="1. 课程简介，C#语言简介，开发环境准备"></a>1. 课程简介，C#语言简介，开发环境准备</h2><h3 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h3><p>C#面向对象</p>
<p>采用知识点和示例程序相结合的方式</p>
<p>认真做课后作业，独自写一遍视频中的程序</p>
<h3 id="C-语言简介"><a href="#C-语言简介" class="headerlink" title="C#语言简介"></a>C#语言简介</h3><ul>
<li><p>程序（Program），即软件。机器码（计算机指令）-&gt;汇编语言-&gt;高级语言。高级语言翻译为计算机指令的过程被称为编译，编译用编译器。</p>
</li>
<li><p>为什么需要程序：随着硬件功能的增强，需要更强大的软件（程序）来统一管理硬件，让硬件之间能够协调和网络通信。这些软件组合在一起形成了操作系统。在操作系统上编写具备特定功能的程序。为什么需要程序可以总结为两点：</p>
<ul>
<li>管理硬件资源</li>
<li>实现用户的特定需求</li>
</ul>
</li>
<li><p>C#是一门通用的语言，可以编写多种类型的程序。不是特别追求性能时，可以用C#开发各种应用程序。</p>
<ul>
<li><p>纵向：语言-&gt;类库-&gt;框架（由浅入深）</p>
<p>框架是有一定逻辑组织的类库。框架是类库的最佳组合（best practice），避免自行组合时出错。</p>
</li>
<li><p>横向：命令行程序，桌面程序，设备（平板/手机）程序，Web（网站/服务）程序，游戏…</p>
</li>
</ul>
<p>C++偏底层，学习曲线陡峭。</p>
<p>C语言不面向对象，主要目标是编写高性能的操作系统，不适合用来写应用程序。</p>
<p>Java适合写设备程序和Web程序，但是不适合用来写桌面程序。</p>
</li>
<li><p>怎样编写程序</p>
<p>编辑-&gt;编译（高级语言经过编译变为机器语言）-&gt;调试（编译器看不出来的错误，通过调试被发现）-&gt;发布</p>
</li>
</ul>
<h3 id="开发环境和学习资料的准备"><a href="#开发环境和学习资料的准备" class="headerlink" title="开发环境和学习资料的准备"></a>开发环境和学习资料的准备</h3><ul>
<li><p>集成开发环境：集成了编辑、编译、调试和发布四个步骤。</p>
</li>
<li><p>下载Visual Studio：可视化工作室，应用了所见即所得的理念。</p>
<p>有两种桌面程序，后者是新一代的桌面开发技术：</p>
<ul>
<li>Windows Forms Application</li>
<li>WPF Application (windows presentation foundation)</li>
</ul>
</li>
<li><p>安装Visual Studio(2013)，安装免费版即可</p>
</li>
<li><p>打开Visual Studio，进入start page。选择tools-options-start up-show empty environment，点击OK。下次再打开visual studio，就会显示一个空的开发环境，让我们创建新项目。</p>
</li>
<li><p>学习资料</p>
<ul>
<li>下载离线MSDN文档（特点：全面，文章数量多，在Visual Studio的help-add and remove help content-manage content中下载，点击update，文档很大，速度较慢）</li>
<li>C#语言定义文档（Language Specification）（特点：精确，难读懂，会出现很大的跳跃性，看不懂的去看MSDN文档，谷歌下载即可）</li>
<li>推荐数据：C# 5.0 In A Nutshell（特点：读MSDN文档的指南针，其中列出了重点）</li>
</ul>
</li>
<li><p>MSDN文档中最重要的部分：</p>
<ul>
<li>Visual Basic and Visual C#-Visual C#-C# Programming Guide</li>
<li>Visual Basic and Visual C#-Visual C#-C# Reference：横向领略C#语言的特性</li>
<li>Visual Basic and Visual C#-Visual C#-C# Reference-C# Sample Application：源码</li>
<li>Visual Basic and Visual C#-Visual C#-C# Reference-C# Walkthroughs：功能浏览</li>
</ul>
</li>
</ul>
<h3 id="本节课作业"><a href="#本节课作业" class="headerlink" title="本节课作业"></a>本节课作业</h3><ul>
<li>下载并安装Visual Studio Express 2013 for Windows Desktop（建议学生下载professional版本，其对学生免费）</li>
<li>下载离线MSDN文档并尝试阅读</li>
<li>编写视频中的小程序（所见即所得的wpf程序）</li>
</ul>
<h3 id="作业完成情况"><a href="#作业完成情况" class="headerlink" title="作业完成情况"></a>作业完成情况</h3><ul>
<li><code>HelloWorld</code>项目的地址：D:\OneDrive - stu.xjtu.edu.cn\文档\Visual Studio 2013\Projects</li>
<li>MSDN文档成功下载了下面四个（最重要的文档已经下载下来了，其他文档要么是没有要么是下载失败）：<ul>
<li>.NET Framework 4</li>
<li>Get started with Blend for Visual Studio 2013</li>
<li>Welcome to Visual Studio 2013</li>
<li>Visual Basic and Visual C#</li>
</ul>
</li>
</ul>
<h2 id="2-初识各类应用程序"><a href="#2-初识各类应用程序" class="headerlink" title="2. 初识各类应用程序"></a>2. 初识各类应用程序</h2><p>带领大家认识各种可以用C#编写的应用程序</p>
<h3 id="编程学习的捷径"><a href="#编程学习的捷径" class="headerlink" title="编程学习的捷径"></a>编程学习的捷径</h3><ul>
<li>编程不是“学”出来的，而是“练”出来的</li>
<li>在反复应用中积累，忽然有一天就会“顿悟”。在实践中理解书本上知识的精髓。</li>
<li>学习原则<ul>
<li>从感观到原理</li>
<li>从使用别人的到创建自己的</li>
<li>必须亲自动手</li>
<li>必须学以致用、紧跟实际工作</li>
<li>追求实用，不搞“学院派”</li>
</ul>
</li>
</ul>
<h3 id="编写我们的第一个程序——Hello-World"><a href="#编写我们的第一个程序——Hello-World" class="headerlink" title="编写我们的第一个程序——Hello, World!"></a>编写我们的第一个程序——Hello, World!</h3><ul>
<li><p>Solution与Project</p>
<ul>
<li>Solution是针对客户需求的总的解决方案。举例：汽车经销商需要一套销售软件</li>
<li>Project利用具体的技术解决具体的某个问题</li>
<li>Visual Studio针对不同技术有不同的Project模板</li>
<li>Visual Studio在管理代码时，解决方案（Solution）在最高的级别。一个Solution中可以包含一到多个Project。</li>
</ul>
<p>如下图所示（各个组件是Project，所有Project在一起构成一个Solution）：</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/solution%20and%20project.png?raw=true" alt="solution and project.png"></p>
</li>
<li><p>Project模板（对比不同VS版本）</p>
<p>VS有各种版本（express, professional, ultimate），版本越高级，其中包含的Project的模板越多，所支持的开发技术越多。一般来说，professional版本足够用了。</p>
</li>
<li><p>分别编写Console, WPF, Windows Forms的Hello World程序</p>
</li>
<li><p>初学编程时很重要的两点</p>
<ul>
<li>不要怕见到自己看不懂的东西</li>
<li>要跟着操作，一遍一遍地练习，为的是熟悉手里的工具，培养感觉</li>
</ul>
</li>
</ul>
<h3 id="见识C-编写的各类应用程序"><a href="#见识C-编写的各类应用程序" class="headerlink" title="见识C#编写的各类应用程序"></a>见识C#编写的各类应用程序</h3><ul>
<li>目的1：让大家拥有辨识各类程序的“火眼金睛”</li>
<li>目的2：让大家了解一下完成C#语言学习后的职业发展方向（你最喜欢哪种？）</li>
</ul>
<p>十种技术编写Hello World程序，打星号的是当下流行的技术。</p>
<h4 id="Console（控制台）"><a href="#Console（控制台）" class="headerlink" title="Console（控制台）"></a>Console（控制台）</h4><ul>
<li><p>File-New Project-Visual C#-Windows-Console Application，可以分别设置solution和project的name。</p>
</li>
<li><p>C#的源码文件用<code>.cs</code>作为扩展名</p>
</li>
<li><p>写入以下的代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleHelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行时，直接点击Start会一闪而过，选择Debug-Start Without Debugging，就可以持续看到结果。</p>
</li>
</ul>
<h4 id="WPF-Windows-Presentation-Foundation"><a href="#WPF-Windows-Presentation-Foundation" class="headerlink" title="WPF(Windows Presentation Foundation)*"></a>WPF(Windows Presentation Foundation)*</h4><p>注意对比其与WPF。新建项目，选择WPF Application。现在页面下方出现了一些类似html的代码（<code>xaml</code>代码），设计师可以直接通过修改这些代码来设计界面。我理解类似前后端分离，同时前端不需要写代码，有可视化界面。后端的代码类似Windows Forms。</p>
<ul>
<li><p>点击Toolbox，搜索TextBox，将其拖入窗口中并调整大小。改Name，去掉其中的Text。</p>
</li>
<li><p>再搜索Button，将其拖入窗口中并调整大小。改Name，改其中的Text。</p>
</li>
<li><p>既可以改代码来改属性，也可以改可视化界面来改属性。</p>
</li>
<li><p>选中Button，点击Events。目前Click的值为空，点击Button不会有响应。双击Button，同样生成代码模板，在其中写入以下的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Data;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Documents;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Input;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Media;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Media.Imaging;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Navigation;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Shapes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WpfHelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Interaction logic for MainWindow.xaml</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buttonSayHello_Click</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            textBoxShowHello.Text = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行项目，点击Click Me按钮，TextBox中出现Hello, World!</p>
</li>
</ul>
<h4 id="Windows-Forms-Old"><a href="#Windows-Forms-Old" class="headerlink" title="Windows Forms(Old)"></a>Windows Forms(Old)</h4><p>新建项目，选择windows forms application。</p>
<ul>
<li><p>点击Toolbox，搜索TextBox，将其拖入窗口中并调整大小。</p>
</li>
<li><p>再搜索Button，将其拖入窗口中并调整大小。</p>
</li>
<li><p>修改Button的属性：修改其上的文字，给其起一个带有独特含义的名字</p>
</li>
<li><p>修改TextBox的属性：修改其名字为<code>textBoxShowHello</code></p>
</li>
<li><p>选中Button，在属性面板有闪电符号，就是Events（事件）。当前Click对应的值为空，表示点击Click没有任何的反应。双击事件中的Click，自动生成了代码模板。写入以下的代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WinFormHelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buttonSayHello_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            textBoxShowHello.Text = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在点击click me时，文本框就显示了Hello, World!现在让程序响应了button click事件，程序的相应为在<code>TextBox</code>中显示出<code>Hello, World</code>。</p>
</li>
</ul>
<h4 id="ASP-NET-Web-Forms-Old"><a href="#ASP-NET-Web-Forms-Old" class="headerlink" title="ASP.NET Web Forms(Old)"></a>ASP.NET Web Forms(Old)</h4><p>选择visual c#-web-asp.net web application，再选择empty，勾选web forms。此时就获得了一个空的网站。右击右侧菜单的WebFormHelloWorld，选择add-web form，输入其名称为default，这样就生成了一个模板代码<code>Default.aspx</code>。在其中加入<code>Hello, World</code>:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ Page Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; CodeBehind=&quot;Default.aspx.cs&quot; Inherits=&quot;WebFormHelloWorld.Default&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head runat=&quot;server&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>点击运行（点击浏览器的名称即可），网页就显示出了<code>Hello, World!</code>。右键<code>WebFormHelloWorld</code>，点击publish，即可将其部署，供外人访问。</p>
<h4 id="ASP-NET-MVC-Model-View-Controller"><a href="#ASP-NET-MVC-Model-View-Controller" class="headerlink" title="ASP.NET MVC(Model-View-Controller)*"></a>ASP.NET MVC(Model-View-Controller)*</h4><p>是ASP.NET Web Forms技术的升级版。其特点是代码解耦合，易于维护。创建项目同ASP.NET Web Forms，但是要点击empty，勾选MVC。选择controllers-add-controller，选择MVC 5 Controller - Empty，点击add，然后输入其名称为<code>HomeController</code>，然后add。此时生成了<code>HomeController.cs</code>的样板代码：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Web;</span><br><span class="line"><span class="keyword">using</span> System.Web.Mvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MvcHelloWorld.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HomeController</span> : <span class="title">Controller</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// GET: /Home/</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ActionResult <span class="title">Index</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> View();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时views文件夹中的home文件夹中还没有任何view。在函数：<code>public ActionResult Index()</code>中右击，选择add view，点击add，此时在home文件夹中生成了<code>Index.cshtml</code>。在其中写入代码：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">@&#123;</span><br><span class="line">    ViewBag.Title = &quot;Index&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello, Wolld!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>点击运行，网页上出现了Hello, World!同样也可以将这个项目publish到自己的网站上去。</p>
<h4 id="WCF-Windows-Communication-Foundation"><a href="#WCF-Windows-Communication-Foundation" class="headerlink" title="WCF(Windows Communication Foundation)*"></a>WCF(Windows Communication Foundation)*</h4><p>wcf是纯粹的网络服务。创建项目时选择visual c#-wcf-wcf service application，命名为WcfHello。</p>
<p>打开模板代码<code>IService1.cs</code>，在其中写入代码：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IService1</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">OperationContract</span>]</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetData</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">OperationContract</span>]</span><br><span class="line">    <span class="function">CompositeType <span class="title">GetDataUsingDataContract</span>(<span class="params">CompositeType composite</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">OperationContract</span>]</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">SayHello</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Add your service operations here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到<code>Service1.svc.cs</code>中，点击<code>IService1</code>下面的蓝色小标记，选择Implement interface IService1。此时就会生成模板代码：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">SayHello</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将其改为：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">SayHello</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>点击运行，会启动wcf test client的工具。wcf是最特殊的服务，只有纯粹的数据交互，没有前端，因此需要用到这个测试工具。双击其中的SayHello()，点击Invoke，就会调用SayHello函数，该函数会返回一个hello world给客户端。我尝试调用，果然在测试界面打印出了hello world。</p>
<p>现在尝试写一个加法器，在<code>IService1.cs</code>中写：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">OperationContract</span>]</span><br><span class="line"><span class="function"><span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Service1.svc.cs</code>中写：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次运行，双击Add方法，设置a和b的值为10和20，点击Invoke，计算结果为30。</p>
<h4 id="Windows-Store-Application"><a href="#Windows-Store-Application" class="headerlink" title="Windows Store Application*"></a>Windows Store Application*</h4><p>给平板电脑app写的程序。选择visual c#-windows store-blank app(xaml)。其和WPF很像。打开<code>MainPage.xaml</code>，将ToolBox中的TextBox拖进去，然后再拖入button。将TextBox重命名为<code>textBoxShowHello</code>，再将其中的Text清空。将buttom重命名为<code>buttonSayHello</code>，将其content改为Click Me。选择simulator，运行之，此时点击button没有任何反应。</p>
<p>选择button-click，然后双击，生成模板代码，在其中写入代码：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">textBoxShowHello.Text = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>再次在simulator中运行，此时点击click me，hello world就出现了。</p>
<h4 id="Windows-Phone-Application"><a href="#Windows-Phone-Application" class="headerlink" title="Windows Phone Application*"></a>Windows Phone Application*</h4><p>创建项目，选择visual c#-windows phone-windows phone app，取名为PhoneHelloWorld。生成的代码同样和wpf非常类似。</p>
<p>同样的，在ToolBox中搜索TextBox，拖入界面中，取名为textBoxShowHello，清空text；再搜索Button，同样拖入界面中，取名为buttonSayHello，将content改为click me；再切换到Button的事件中去，双击click，生成模板代码，写入以下内容：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">textBoxShowHello.Text = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>选择一款较好的模拟器（内存和屏幕分辨率可选），然后执行。点击click me，hello world就出现了。</p>
<p>如何部署到手机上？<br>选择build-deploy solution，如果windows phone连接到了电脑上，就会直接找到该设备然后部署上去。</p>
<h4 id="Cloud-Windows-Azure"><a href="#Cloud-Windows-Azure" class="headerlink" title="Cloud(Windows Azure)*"></a>Cloud(Windows Azure)*</h4><p>微软云计算平台上的hello world。创建项目，选择visual c#-cloud-windows azure cloud service，项目取名为CloudHelloWorld，要架网站，就选择asp.net web role，点击右箭头将其加到云平台上，改名为SayHello，点击OK。选择empty，勾选MVC。此时看上去和ASP.NET MVC完全相同。</p>
<p>右键controllers-add-controller，选择MVC 5 Controller - Empty，取名为HomeController。在生成的主函数中右键，add view，点击add。在index.cshtml中，写上hello world。点击运行即可，此时要启动云平台的模拟器才能运行程序。</p>
<p>查找最近的项目：file-recent projects and solutions</p>
<p>云平台模拟器会加载刚刚写的网站。</p>
<p>部署时，右键CloudHelloWorld，选择publish，选择云平台的订阅，就可以直接发布。发布网站需要买域名，买空间，但微软的云平台替你完成了这些步骤。</p>
<h4 id="WF-Workflow-Foundation"><a href="#WF-Workflow-Foundation" class="headerlink" title="WF(Workflow Foundation)"></a>WF(Workflow Foundation)</h4><p>workflow：工作流。选择visual c#-workflow-workflow console application，这个工作流执行起来是在console中执行，命名为WfHelloWorld。</p>
<p>在ToolBox中搜索WriteLine，拖入界面中，在其中写入<code>&quot;Hello, World!&quot;</code>，点击debug-start with debugging。</p>
<h2 id="3-初识类与名称空间"><a href="#3-初识类与名称空间" class="headerlink" title="3. 初识类与名称空间"></a>3. 初识类与名称空间</h2><h3 id="剖析Hello-World程序"><a href="#剖析Hello-World程序" class="headerlink" title="剖析Hello, World程序"></a>剖析Hello, World程序</h3><p>剖析的对象：最简单的console application。</p>
<ul>
<li>初识类（class）与名称空间（namespace）<ul>
<li>初学者：类（class）构成程序的主体。高级版本：类是最基础的C#类型。类是一个数据结构，将状态（字段）和操作（方法和其他函数成员）组合在一个单元中。类为动态创建的类实例（instance）提供了定义，实例也称为对象（object）。类支持继承和多态性，这是派生类可用来扩展和专用化基类的机制。</li>
<li>名称空间（namespace）以树型结构组织类（和其他类型），也可以有效地避免同名类的冲突。<ul>
<li>例如Button和Path类</li>
</ul>
</li>
</ul>
</li>
<li><p>下面以<code>HelloWorld</code>程序来展示类和名称空间。有以下代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using是将名称空间引用到程序中来</span></span><br><span class="line"><span class="comment">// 名称空间的标记是&#123;&#125;</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写的Program类放在了ConsoleHelloWorld这个名称空间中，该名称空间的名字默认和project的名字一样</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleHelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类在visual studio中高亮的颜色是水蓝色</span></span><br><span class="line">    <span class="comment">// c#是完全面向对象的</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Console类是内置的，我们利用其中的WriteLine方法</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以简写为（权限命名写法）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleHelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>); <span class="comment">// 权限命名写法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印两行：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleHelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">            System.Console.WriteLine(<span class="string">&quot;Good morning!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更方便的写法是引入名称空间：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleHelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Good morning!&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Good evening!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何知道某个函数属于哪个名称空间？</p>
<ul>
<li>方法1：help-view help，在index中搜索console class，可以看到相应的文档。其中有信息：<code>Assembly: mscorlib (in mscorlib.dll)</code>，<code>mscorlib(microsoft core library)</code>是类库。与操作系统有关的重要的类都在System这个名称空间中。</li>
<li>点击报红的单词的任意位置，单词的首字母处会出现蓝色的小方块，为智能标记。点开智能标记，可选择<code>Using System</code>或者<code>System.Console</code>。弹出智能标记的快捷键：<code>ctrl + .</code>或者<code>Shift+Alt+F10</code>。</li>
</ul>
<p>不同命名空间中相同的类名产生冲突的例子：</p>
<p>新建一个wpf程序。在<code>MainWindow.xaml.cs</code>中，可以存在两个path类，分别是：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">System.Windows.Shapes.Path</span><br><span class="line">System.IO.Path</span><br></pre></td></tr></table></figure>
<p>前者是windows中用于画多边形的path，后者是文件路径的path。如果需要同时用到两者，就只能用权限命名。</p>
<p>另一个例子：button class有更多种，用来写web/.NET/windows等等。使用名称空间就可以解决类名冲突的问题。</p>
</li>
</ul>
<h3 id="类库-assembly-的应用"><a href="#类库-assembly-的应用" class="headerlink" title="类库(assembly)的应用"></a>类库(assembly)的应用</h3><p>dll: dynamic link library（动态链接库），以ddl结尾的文件是类库。</p>
<p>类和名称空间是放在类库中的。类库是类的仓库。</p>
<ul>
<li>类库引用是使用名称空间和类的物理基础</li>
</ul>
<p>以一个wpf程序为例，其中的<code>Button</code></p>
<ul>
<li>名称空间为System.Windows.Controls</li>
<li>类库为 (in PresentationFramework.dll) </li>
<li>如何查看类库引用在项目的哪里？在项目的References中就可以看到PresentationFramework。双击PresentationFramework，打开的窗口为对象浏览器（ObjectBrowser）。展开其中的PresentationFramework，即可看到有哪些名称空间，展开名称空间又可以看到其中有哪些类。</li>
</ul>
<p>Console application由于不需要显示窗口，因此需要引用的类库要少于wpf application。</p>
<p>不同技术类型的项目会默认引用不同的类库。</p>
<p>如何为自己的项目添加对其他类库的引用？</p>
<ul>
<li><p>DLL引用（黑盒引用，无ddl的源代码，直接用编译好的dll文件）</p>
<ul>
<li><p>以输出hello world的console application为例。如果有一个外部的dll，必须配有文档。例如一个文件夹中存放了<code>MyLibrary.dll</code>和<code>MyLibrary Document</code>。右键项目的references-add reference-browse，即可把dll文件给加载进来，此时<code>MyLibrary</code>就会出现在References中。然后可以对照文档来使用类库中的名称空间、类和方法。也可以双击References中的<code>MyLibrary</code>，打开对象浏览器，来查看其中的名称空间、类和方法。</p>
</li>
<li><p>黑盒引用的问题：类库一旦出错，本人无法修改，只能让类库的编写者去修改，然后编写者再次将类库编译为ddl并将该文件发送给本人，才能解决这个错误。此时我的项目会对类库产生依赖，我的<code>Program</code>类也会对类库中的类和方法产生依赖。这就是依赖关系。尽量使用弱的依赖关系，避免牵一发而动全身的问题。有一些办法可以减轻依赖关系。</p>
</li>
<li><p>做实验：引用微软提供的类库，让console application显示窗口。在references中添加类库：<code>System.Windows.Forms</code>。help viewer中的msdn文档搜索功能非常难用，不如用微软提供的在线文档。让console application显示窗口的代码为：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleHelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Form form = <span class="keyword">new</span> Form();</span><br><span class="line">            form.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NuGet简介</p>
<p>使用NuGet添加对dll的引用。NuGet技术被用来解决比较复杂的依赖关系（复杂的依赖关系：底层的类库未被引用，则上层的类库也无法被引用）。</p>
<ul>
<li><p>做实验，在console application中引入一个wpf的窗口。在References中添加依赖：PresentationFramework。然后写入以下代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleHelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.Windows.Window window = <span class="keyword">new</span> System.Windows.Window();</span><br><span class="line">            window.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时会产生报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error	1	The type &#x27;System.Windows.Markup.IAddChild&#x27; is defined in an assembly that is not referenced. You must add a reference to assembly &#x27;PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35&#x27;.	d:\OneDrive - stu.xjtu.edu.cn\文档\Visual Studio 2013\Projects\ConsoleHelloWorld\ConsoleHelloWorld\Program.cs	10	13	ConsoleHelloWorld</span><br><span class="line"></span><br><span class="line">Error	2	The type &#x27;System.Windows.Markup.IQueryAmbient&#x27; is defined in an assembly that is not referenced. You must add a reference to assembly &#x27;System.Xaml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&#x27;.	d:\OneDrive - stu.xjtu.edu.cn\文档\Visual Studio 2013\Projects\ConsoleHelloWorld\ConsoleHelloWorld\Program.cs	10	13	ConsoleHelloWorld</span><br></pre></td></tr></table></figure>
<p>报错说明更底层的类库：<code>PresentationCore</code>和<code>System.Xaml</code>还没有被引用，需要将这两者加入到References中。再运行时，还会出现报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error	2	The type &#x27;System.Windows.DependencyObject&#x27; is defined in an assembly that is not referenced. You must add a reference to assembly &#x27;WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35&#x27;.	d:\OneDrive - stu.xjtu.edu.cn\文档\Visual Studio 2013\Projects\ConsoleHelloWorld\ConsoleHelloWorld\Program.cs	10	13	ConsoleHelloWorld</span><br></pre></td></tr></table></figure>
<p>还需要添加更底层的<code>WindowsBase</code>，这很麻烦。因为这时候你只有DLL，没有源代码，几乎可以说是“蒙着眼睛引用类库”。这是很危险的！特别是对于大型的项目。</p>
<p>后来有人用包的形式发布一组类库，用户输入命令，一组类库就都被引用了，不需要手动引用，这样很安全且高效，这就是NuGet技术。</p>
<p>例如需要写一个用于连接数据库的程序，需要用到技术<code>Entity Framework</code>（实体框架），该类库可以将代码中的类和数据库中的表映射起来。可以采用NuGet技术来对上述类库进行引用。右击References-点击add nuget packages-选择online-输入Entity Framework，点击Install即可，此时就会看到两个自动安装的类库：<code>EntityFramework</code>和<code>EntityFramework.SqlServer</code>，这两个类库由NuGet自动管理。但是我这样操作搜索不到结果，于是我采用了另一种方式。点击Tools-Library Package Manager-Package Manager Console，在其中输入命令：<code>Install-Package EntityFramework</code>，也可以起到相同的效果。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>项目引用（白盒引用，有源代码，源代码放在项目中，故称项目引用）</p>
<p>直接获得类库项目的源代码，比如类库项目的名字是<code>MyLibrary</code>，其中的代码名为<code>Calculator.cs</code>，代码为：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何引用<code>MyLibrary</code>这个类库，点击References-add references-solution-projects，当前的projects页面为空，因此需要将<code>MyLibrary</code>这个project添加到当前的solution中去。一个项目可以被多个solution包含（这被称为project的重用），因此将类库项目也包含到当前的solution中。将类库的project包含到当前solution中的操作：solution-add-existing project，选中MyLibrary-MyLibrary.csproj，将其添加进来。现在solution中有两个项目，一个是HelloWorld，一个是MyLibrary。再次右击References-add references-solution-projects，勾选<code>MyLibrary</code>，点击OK，此时<code>MyLibrary</code>就作为类库被成功引用了。此时就可以愉快地在console application中引用<code>MyLibrary</code>中的类和方法了：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleHelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> result = Tools.Calculator.Sub(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时由于已经有了类库的源代码，就可以对类库中的错误进行排除。接下来的内容跳转到排除错误部分。</p>
</li>
</ul>
<h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>类与类之间，类库与类库之间一旦互相引用，就产生了依赖关系。依赖关系在软件质量中起了关键作用。</p>
<p>质量好的软件，其依赖关系清晰且好维护；质量差的软件，依赖关系不清楚。</p>
<ul>
<li><p>依赖关系，就是类（或对象）之间的耦合关系</p>
</li>
<li><p>优秀的程序追求“高内聚，低耦合”</p>
<ul>
<li>高内聚指的是一些数据和功能，该属于哪个类，就精确地放入哪个类。</li>
<li>低耦合指的是类和类之间的依赖关系尽可能低</li>
<li>“高内聚，低耦合”对类和类库都是如此</li>
<li>程序只有这样做才会结构清晰</li>
<li>教学程序往往会违反这个原则</li>
</ul>
</li>
<li><p>UML（通用建模语言）类图：以图的形式表达程序中的关系，UML除了可以画类图，还可以画流程图、序列图等。类图用来展现类和类之间的关系。以<code>HelloWrold</code>程序为例：</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/uml.png?raw=true" alt="uml.png"></p>
<p>这是一种非常紧密的耦合关系。</p>
</li>
</ul>
<h3 id="排除错误"><a href="#排除错误" class="headerlink" title="排除错误"></a>排除错误</h3><p>如何排除程序中的错误？</p>
<p>在项目引用时，由于有类库的源代码，可以直接debug。点击出错的行（<code>double result = Tools.Calculator.Sub(1, 1);</code>），设置断点。然后debug-start debugging，此时程序会执行到断点前，result值为0.0（还未进行出错行的运算）。接下来点击step into(F11)，此时执行指针就自动跳转到了类库的此处：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b - <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就可以发现错误的出处。debug时需要找到root cause。</p>
<p>中文标点符号：全角<br>英文标点符号：半角</p>
<ul>
<li>仔细阅读编译器的报错</li>
<li>MSDN文档与搜索引擎结合</li>
</ul>
<h3 id="如何建立一个类库项目"><a href="#如何建立一个类库项目" class="headerlink" title="如何建立一个类库项目"></a>如何建立一个类库项目</h3><p>solution-add-new project-class library（非可执行程序，编译出来的结果就是dll文件，即类库），项目起名为<code>SuperCalculator</code>，模板代码重命名为<code>Calculator.cs</code>，在其中写入代码：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Mul</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Div</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">double</span>.PositiveInfinity;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> a / b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着右击references-add reference-project-SuperCalculator，将这个自定义的类库引入主程序，就可以在主程序中使用它：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleHelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> result1 = Calculator.Mul(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">            Console.WriteLine(result1);</span><br><span class="line">            <span class="built_in">double</span> result2 = Calculator.Div(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">            Console.WriteLine(result2);</span><br><span class="line">            <span class="built_in">double</span> result3 = Calculator.Div(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">            Console.WriteLine(result3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="本节作业"><a href="#本节作业" class="headerlink" title="本节作业"></a>本节作业</h3><ul>
<li>练习创建类库项目进行项目引用</li>
<li>练习DLL引用</li>
<li>练习阅读编译器报错并排除错误</li>
</ul>
<h2 id="4-类、对象、类成员简介"><a href="#4-类、对象、类成员简介" class="headerlink" title="4. 类、对象、类成员简介"></a>4. 类、对象、类成员简介</h2><h3 id="类（class）是显示世界事物的模型"><a href="#类（class）是显示世界事物的模型" class="headerlink" title="类（class）是显示世界事物的模型"></a>类（class）是显示世界事物的模型</h3><ul>
<li>类是现实世界事物进行抽象所得到的结果<ul>
<li>事物包括“物质”（实体）与“运动”（逻辑）</li>
<li>抽象也被称为建模。建模是一个去伪存真（留下需要的，去掉不要的）、由表及里（暴露的接口是表，封装的内容是里）的过程</li>
</ul>
</li>
</ul>
<h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><ul>
<li><p>什么时候叫“对象”，什么时候叫“实例”</p>
<ul>
<li><p>对象也叫实例，是类经过“实例化”后得到的内存中的实体</p>
<ul>
<li>Formally “instance” is synonymous with “object”——对象和实例是一回事</li>
<li>“飞机”与“一架飞机”有何区别？天上有（一架）飞机——必须是实例飞，概念是不能飞的</li>
<li>有些类是不能实例化的，比如“数学”（Math class），我们不能说“一个数学”</li>
</ul>
</li>
<li><p>依照类，我们可以创建对象，这就是“实例化”</p>
<ul>
<li>现实世界中常称“对象”，程序世界中（特别是内存关系）常称“实例”</li>
<li>二者并无太大区别，常常混用，初学者不必迷惑</li>
</ul>
</li>
<li><p>使用new操作符创建类的实例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ClassAndInstance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 实例化</span></span><br><span class="line">            (<span class="keyword">new</span> Form()).ShowDialog(); <span class="comment">// ()表示实例在内存中诞生后的初始化方式，被称为构造器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序运行的结果就是表单已窗口的形式呈现，即表单已被实例化。</p>
</li>
</ul>
</li>
<li><p>引用变量</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ClassAndInstance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Form myForm; <span class="comment">// 声明引用变量</span></span><br><span class="line">            myForm = <span class="keyword">new</span> Form(); <span class="comment">// 用引用变量引用一个实例</span></span><br><span class="line">            myForm.Text = <span class="string">&quot;My Form!&quot;</span>; <span class="comment">// 设置标题的文字</span></span><br><span class="line">            myForm.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用引用变量引用了一个实例后，我们就可以多次访问这个实例。</p>
</li>
<li><p>引用变量与实例的关系</p>
<ul>
<li><p>孩子与气球。孩子相当于引用变量，气球相当于实例。绳子相当于赋值符号</p>
</li>
<li><p>气球不一定有孩子牵着。此时气球就飞掉了，内存垃圾收集器很快就回收了该变量，内存就被释放掉了</p>
</li>
<li><p>多个孩子可以使用各自的绳子牵着同一个气球。如以下代码所示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Form myForm1;</span><br><span class="line">Form myForm2;</span><br><span class="line">myForm1 = <span class="keyword">new</span> Form();</span><br><span class="line">myForm2 = myForm1;</span><br></pre></td></tr></table></figure>
<p>上面两个引用变量引用的是同一个实例/对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ClassAndInstance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Form myForm1;</span><br><span class="line">            Form myForm2;</span><br><span class="line">            myForm1 = <span class="keyword">new</span> Form();</span><br><span class="line">            myForm2 = myForm1;</span><br><span class="line">            myForm1.Text = <span class="string">&quot;My Form&quot;</span>;</span><br><span class="line">            myForm2.Text = <span class="string">&quot;I changed it!&quot;</span>;</span><br><span class="line">            myForm1.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时显示的是<code>I changed it!</code>。用任何一个引用变量访问到的都是同一个实例。</p>
<p>多个孩子也可以都通过同一根绳子牵着气球，目前暂且不讲。</p>
</li>
</ul>
</li>
</ul>
<h3 id="类的三大成员"><a href="#类的三大成员" class="headerlink" title="类的三大成员"></a>类的三大成员</h3><p>类的成员有十多种，但这三种非常重要，也是初学者最先接触到的。</p>
<ul>
<li><p>属性（Property）</p>
<ul>
<li>用于存储数据</li>
<li>这些数据组合起来表示类或对象当前的状态</li>
</ul>
</li>
<li><p>方法（Method）</p>
<ul>
<li>由C语言中的函数（function）进化而来，表示类或对象“能做什么”</li>
<li>工作中90%的时间是在与方法打交道，因为它是“真正做事”、“构成逻辑”的成员</li>
</ul>
</li>
<li><p>事件（Event）</p>
<ul>
<li>类或对象通知其他类或对象的机制，<strong>为C#所特有</strong>（Java通过其他方法实现这个机制）。例如当点击按钮时，发生click这个事件，响应该事件的方法中可以让界面上的文本框显示出<code>Hello World</code>的字符串。</li>
<li>事件是非必须的，但有它在编程会变得方便且灵活，但这也意味着它可能会被滥用。因此，善用事件机制非常重要。</li>
</ul>
</li>
<li><p>使用MSDN文档。将鼠标移到一个类上，按下快捷键ctrl+shift+F1，就可以跳转到相应的MSDN文档。如果想看该类在哪个分支上，点击左上角的show topic in contents按钮。以Form class为例，其下面的第一句话：<code>Represents a window or dialog box that makes up an application&#39;s user  interface.</code>，是以一句话概括本类的作用。接着是：</p>
<ul>
<li>继承关系列表：Inheritance Hierarchy</li>
<li>名称空间：namespace</li>
<li>类库: Assembly</li>
<li>声明的格式：Syntax</li>
<li>构造函数: Constructors</li>
<li>属性：要么用来记忆值，要么表示Form的状态</li>
<li>方法：Form这个类/对象可以做什么</li>
<li>事件：表示Form能以怎样的形式在发生什么事情时通知别的类或对象</li>
<li>类的详细解释，包含了类最常用的功能（即最常用的属性、方法和事件）：Remarks</li>
<li>例子：Examples。MSDN的例子质量良莠不齐</li>
<li>版本信息</li>
<li>平台</li>
<li>多线程安全性：Thread Safety</li>
</ul>
</li>
<li><p>某些特殊类或对象在成员方面侧重点不同</p>
<ul>
<li><p>模型类或对象重在属性，如Entity Framework。模型类的功能主要是从数据库中读取数据，然后把数据写回数据库。其侧重于数据，因此属性特别发达。例子：用<code>Entity Framework</code>生成的作为数据模型的类。首先需要安装Entity Framework及其相关的包，可以使用Nuget/命令行，我的Nuget不管用，因此使用命令行。</p>
<p>打开sql server 2012 developer version，创建一个样例数据库：AdventureWorksLT2012，打开Tables，再打开<code>SalesLT.Product</code>，打开其前1000行，主要包含ProductID, Name, ProductNumber, Color等数据。</p>
<p>在项目中，右击solution-add-new item-data-ado.net entity data model，将其名字改为<code>AdventureWorksModel.edmx</code>。选择generate from database，然后新建一个和本地数据库<code>AdventureWorksLT2012</code>的连接。然后选择Product表和Address表。此时visual studio就和entity framework一起生成了一些专门用于数据传输的数据模型类。会显示两个数据模型类，分别是<code>Product</code>和<code>Address</code>类。这两个类中，只有属性，没有方法和事件。使用这些类的代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印产品的Name属性</span></span><br><span class="line">AdventureWorksLT2012Entities proxy = <span class="keyword">new</span> AdventureWorksLT2012Entities();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速插入foreach代码的方法是：输入foreach时，当VS2013有所提示时，连续按两下Tab键</span></span><br><span class="line"><span class="keyword">foreach</span>(Product p <span class="keyword">in</span> proxy.Products)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 输入cw，然后按两下tab键，就会补全为Console.WriteLine</span></span><br><span class="line">    Console.WriteLine(p.Name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印产品的数目</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;===========================&quot;</span>); <span class="comment">// 分割线</span></span><br><span class="line">Console.WriteLine(proxy.Products.Count());</span><br></pre></td></tr></table></figure>
</li>
<li><p>工具类或对象重在方法，如Math, Console。工具类主要用于计算和其他具体功能。以<code>Math</code>为示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MethodSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> x = Math.Sqrt(<span class="number">4</span>);</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">double</span> y = Math.Pow(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            Console.WriteLine(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通知类或对象重在事件，如各种Timer（时钟每隔一段时间触发某个事件，这个事件会执行某些功能）。</p>
<p>新建WPF Application，先创建一个合适大小的textBox，然后去后台，写入以下代码，即可生成一个简易的时钟：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Data;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Documents;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Input;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Media;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Media.Imaging;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Navigation;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Shapes;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EventSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Interaction logic for MainWindow.xaml</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Window的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            DispatcherTimer timer = <span class="keyword">new</span> DispatcherTimer();</span><br><span class="line">            timer.Interval = TimeSpan.FromSeconds(<span class="number">1</span>); <span class="comment">// 时间间隔1秒钟</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写完+=后，连续按两次tab键</span></span><br><span class="line">            <span class="comment">// 将timer_Tick函数挂接到事件上</span></span><br><span class="line">            <span class="comment">// 当事件Tick被触发时，timer_Tick函数就会被执行</span></span><br><span class="line">            <span class="comment">// timer_Tick方法用于响应事件，因此该方法也被称为事件处理器</span></span><br><span class="line">            timer.Tick += timer_Tick;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让时钟开始</span></span><br><span class="line">            timer.Start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">timer_Tick</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.timeTextBox.Text = DateTime.Now.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="类的静态成员与实例成员"><a href="#类的静态成员与实例成员" class="headerlink" title="类的静态成员与实例成员"></a>类的静态成员与实例成员</h3><ul>
<li><p>静态（Static）成员在语义上表示它是“类的成员”</p>
</li>
<li><p>实例（非静态）成员在语义上表示它是“对象的成员”，而非“类的成员”</p>
</li>
<li><p>例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StaticSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// WriteLine方法是隶属于Console类的，因此该方法是静态方法</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Form form = <span class="keyword">new</span> Form();</span><br><span class="line">            form.Text = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// Text是实例属性</span></span><br><span class="line">            form.ShowDialog(); <span class="comment">// ShowDialog是实例方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在MSDN文档中，若某个属性上面加了红色的大写的S，那么其是静态属性。同理，同样的标记也被用于静态方法。静态事件非常少见。</p>
</li>
<li><p>“绑定”（Binding）指的是编译器如何把一个成员 与 类或对象关联起来</p>
<ul>
<li>早绑定。编译器就决定将成员与哪个类/对象关联。</li>
<li><p>晚绑定。程序运行起来后，再决定将成员与哪个类/对象关联，编译器不知道此事。有晚绑定功能的语言是动态语言，比如javascript。</p>
</li>
<li><p>不可小觑的“.”操作符——成员访问</p>
</li>
</ul>
</li>
</ul>
<h3 id="本节作业-1"><a href="#本节作业-1" class="headerlink" title="本节作业"></a>本节作业</h3><ul>
<li>跟着视频进行操作，直到能够自己动手编写这些程序</li>
</ul>
<h2 id="5-语言基本元素概览、初始类型、变量与方法，算法简介"><a href="#5-语言基本元素概览、初始类型、变量与方法，算法简介" class="headerlink" title="5. 语言基本元素概览、初始类型、变量与方法，算法简介"></a>5. 语言基本元素概览、初始类型、变量与方法，算法简介</h2><h3 id="构成C-语言的基本元素"><a href="#构成C-语言的基本元素" class="headerlink" title="构成C#语言的基本元素"></a>构成C#语言的基本元素</h3><p>前五种被统称为标记（Token）。标记是对编译器有意义的记号。</p>
<ul>
<li><p>关键字（Keyword）：构成一门编程语言的基本词汇。</p>
<p>具体参照这个文档：<a href="https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/x53a06bb(v=vs.120)?redirectedfrom=MSDN">https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/x53a06bb(v=vs.120)?redirectedfrom=MSDN</a></p>
<p>其中包含两个表格，第一个表格中的关键字一直都是关键字（70多个），第二个表格中的关键字是上下文关键字（20多个）。一共100多个关键字。</p>
<p>注意：</p>
<ul>
<li>某些关键字有多个用途</li>
<li>关键字按照逻辑分组，可以分为Types, Modifiers, Statement, Namespace, Operator等</li>
</ul>
</li>
<li><p>操作符（Operator）</p>
<p>查看文档：<a href="https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/6a71f45d(v=vs.120)?redirectedfrom=MSDN">https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/6a71f45d(v=vs.120)?redirectedfrom=MSDN</a></p>
<p>操作符大概30-40个。有些操作符是关键字，因此这类关键字被称为操作符关键字。</p>
</li>
<li><p>标识符（Identifier），即名字</p>
<ul>
<li><p>什么是合法的标识符</p>
<ul>
<li>首先不能与关键字冲突。关键字又名保留字，不能被用来作为标识符。</li>
<li><p>可以用字母、数字和下划线来组成标识符，但是不能拿数字开头，可以拿字母和下划线开头。</p>
</li>
<li><p>怎样阅读语言定义文档</p>
<p>以Identifier为例：</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/identifier1.png?raw=true" alt="identifier1.png"></p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/identifier2.png?raw=true" alt="identifier2.png"></p>
<ul>
<li>斜体字意味着还未完全解释清楚，后面还有它的解释</li>
<li>标识符=非关键字的标识符&amp;关键字+<code>@ 标识符&amp;关键字</code></li>
<li>下标opt表示可选的</li>
<li>汉语也可以用作标识符</li>
</ul>
</li>
</ul>
</li>
<li><p>大小写规范：驼峰命名法（myVariable），pascal命名法（MyVariable）</p>
<p>C#中，变量名都用驼峰法，方法名、类名、名称空间等用pascal法</p>
</li>
<li><p>命名规范：要求变量名、类名、类的成员都有意义</p>
<ul>
<li>类名是一个名词</li>
<li>类的成员名的属性是名字，方法是动词/动词短语</li>
</ul>
</li>
</ul>
</li>
<li><p>标点符号：比如<code>&#123;&#125;</code>, <code>;</code>。是符号，但是不参与运算。</p>
</li>
<li><p>文本（字面值）</p>
<ul>
<li><p>整数</p>
<ul>
<li><p>多种后缀</p>
</li>
<li><p>例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">2</span>; <span class="comment">// 32 bit表示一个数字</span></span><br><span class="line"><span class="built_in">long</span> y = <span class="number">3L</span>; <span class="comment">// 大小写L均可，64 bit表示一个数字，long能表示的数字范围广于int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>实数</p>
<ul>
<li><p>多种后缀</p>
</li>
<li><p>例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> x = <span class="number">3.0F</span>; <span class="comment">// 32 bit表示一个浮点数，F是必须的后缀，否则3.0默认为双精度浮点数</span></span><br><span class="line"><span class="built_in">double</span> y = <span class="number">4.0</span>D; <span class="comment">// D表示双精度浮点数, 64 bit表示一个浮点数</span></span><br><span class="line"><span class="built_in">double</span> z = <span class="number">4.0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>字符</p>
</li>
<li><p>字符串</p>
<ul>
<li>例子：<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> c = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 单引号中只能有一个字符，字符类型的变量必须用单引号</span></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str3 = <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>布尔</p>
</li>
<li><p>空（null）</p>
<ul>
<li>例子：<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">bool</span> b2 = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注释与空白</p>
<ul>
<li>单行：<code>//</code></li>
<li>多行（块注释）：<code>/* */</code>。块注释不能嵌套</li>
<li>空白：一个空白和多个空白/tab键生成的空白没有区别</li>
<li>格式化代码：edit-advanced-format document，快捷键为ctrl + k, ctrl + d</li>
</ul>
</li>
</ul>
<h3 id="简要介绍类型、变量与方法"><a href="#简要介绍类型、变量与方法" class="headerlink" title="简要介绍类型、变量与方法"></a>简要介绍类型、变量与方法</h3><ul>
<li><p>初识类型（Type）</p>
<ul>
<li><p>亦称数据类型（Data Type）：明确的数据类型/推断的数据类型（<code>var</code>）</p>
</li>
<li><p>例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>; <span class="comment">// 编译器会根据赋的值自动推断var变量的类型</span></span><br><span class="line">Console.WriteLine(x.GetType().Name); <span class="comment">// 输出为Int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">3L</span>;</span><br><span class="line">Console.WriteLine(y.GetType().Name); <span class="comment">// 输出为Int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> z = <span class="number">3.0</span>;</span><br><span class="line">Console.WriteLine(z.GetType().Name); <span class="comment">// 输出为Double</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w = <span class="number">3.0F</span>;</span><br><span class="line">Console.WriteLine(w.GetType().Name); <span class="comment">// 输出为Single</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>变量是存放数据的地方，简称“数据”</p>
<ul>
<li>变量的声明</li>
<li>变量的使用</li>
</ul>
</li>
<li><p>方法（旧称函数）是处理数据的逻辑，又称“算法”</p>
<ul>
<li><p>方法即成员函数</p>
</li>
<li><p>方法的声明</p>
</li>
<li><p>方法的调用</p>
</li>
<li><p>例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Identifier</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">            <span class="built_in">int</span> x = c.Add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> str = c.GetToday();</span><br><span class="line">            Console.WriteLine(str);</span><br><span class="line"></span><br><span class="line">            c.PrintSum(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> result = a + b;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetToday</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> day = DateTime.Now.Day;</span><br><span class="line">            <span class="keyword">return</span> day.ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintSum</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> result = a + b;</span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>程序=数据+算法</p>
<ul>
<li>有了变量和方法就可以写有意义的程序了</li>
</ul>
</li>
</ul>
<h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><ul>
<li><p>循环初体验</p>
<p>循环又称迭代。例子：打印x到1</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Identifier</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">            c.PrintXTo1(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintXTo1</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = x; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归初体验</p>
<p>例子：打印x到1</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Identifier</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">            c.PrintXTo1(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归写法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintXTo1</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(x);</span><br><span class="line">                PrintXTo1(x - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算1到100的和</p>
<p>循环写法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Identifier</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">            <span class="built_in">int</span> result = c.SumFrom1ToX(<span class="number">100</span>);</span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环写法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">SumFrom1ToX</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; x + <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归写法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Identifier</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">            <span class="built_in">int</span> result = c.SumFrom1ToX(<span class="number">100</span>);</span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归写法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">SumFrom1ToX</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> result = x + SumFrom1ToX(x - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="本节作业-2"><a href="#本节作业-2" class="headerlink" title="本节作业"></a>本节作业</h3><p>独立完成“汉诺塔问题”</p>
<p>汉诺塔的问题：n个盘子，由A柱子，经过B柱子，最终放到C柱子上。</p>
<p>以递归角度进行分析为：</p>
<ul>
<li>把n-1个盘子由A移动到B；(借助辅助塔C)</li>
<li>把第n个盘子，由A移动到C;</li>
<li>把n-1个盘子由B移动到C; (借助辅助塔A) </li>
</ul>
<p>汉诺塔的代码：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Identifier</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span>(<span class="params"><span class="built_in">int</span> disks, <span class="built_in">char</span> <span class="keyword">from</span>, <span class="built_in">char</span> to</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;移动次数: &#123;0&#125; 把块: &#123;1&#125; 按照如下移动： &#123;2&#125; --&gt; &#123;3&#125;&quot;</span>, ++m, disks, <span class="keyword">from</span>, to);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span>(<span class="params"><span class="built_in">int</span> disks, <span class="built_in">char</span> <span class="keyword">from</span>, <span class="built_in">char</span> to, <span class="built_in">char</span> assist</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disks == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                move(<span class="number">1</span>, <span class="keyword">from</span>, to);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                hanoi(disks - <span class="number">1</span>, <span class="keyword">from</span>, assist, to);</span><br><span class="line">                move(disks, <span class="keyword">from</span>, to);</span><br><span class="line">                hanoi(disks - <span class="number">1</span>, assist, to, <span class="keyword">from</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">char</span> A = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="built_in">char</span> B = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">            <span class="built_in">char</span> C = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">            hanoi(<span class="number">4</span>, A, C, B);</span><br><span class="line">            Console.WriteLine(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化后的程序：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Identifier</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span>(<span class="params"><span class="built_in">char</span> <span class="keyword">from</span>, <span class="built_in">char</span> to</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span>(<span class="params"><span class="built_in">int</span> disks, <span class="built_in">char</span> <span class="keyword">from</span>, <span class="built_in">char</span> to, <span class="built_in">char</span> assist</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disks == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                move(<span class="keyword">from</span>, to);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                hanoi(disks - <span class="number">1</span>, <span class="keyword">from</span>, assist, to);</span><br><span class="line">                move(<span class="keyword">from</span>, to);</span><br><span class="line">                hanoi(disks - <span class="number">1</span>, assist, to, <span class="keyword">from</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">char</span> <span class="keyword">from</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="built_in">char</span> to = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">            <span class="built_in">char</span> assist = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">            hanoi(<span class="number">4</span>, <span class="keyword">from</span>, to, assist);</span><br><span class="line">            Console.WriteLine(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-详解类型、变量与对象（上）"><a href="#6-详解类型、变量与对象（上）" class="headerlink" title="6. 详解类型、变量与对象（上）"></a>6. 详解类型、变量与对象（上）</h2><p>分析编程语言在内存中是如何运作的。</p>
<h3 id="什么是类型（Type）"><a href="#什么是类型（Type）" class="headerlink" title="什么是类型（Type）"></a>什么是类型（Type）</h3><ul>
<li><p>数据结构是类型的延申。</p>
</li>
<li><p>又名数据类型（Data Type）</p>
<ul>
<li>A data type is a homogeneous collection of values, effectively presented, equipped with a set of operations which manipulate these values.</li>
<li>是数据在内存中存储时的“型号”。内存全称是内部存储单元。当今的计算机架构是冯诺依曼系统，其有几大组成部分：运算器和控制器（CPU），存储器（内存），输入输出系统。程序运行时必须从硬盘加载到内存中，内存越大的计算机，内存中可以同时运行的程序越多。总之，内存是计算机程序运行的空间。外存是扩展存储器，是对内存的扩展，如计算机中的硬盘，硬盘是电磁存储，因此关机后数据也不会丢失。</li>
<li>小内存容纳大尺寸数据会轻则丢失精确度，重则发生错误。</li>
<li>大内存容纳小尺寸数据会导致内存的浪费。</li>
<li>编程语言的数据类型与数学中的数据类型不完全相同。例如数学中3/4=0.75，编程中3/4=0。</li>
</ul>
</li>
<li><p>强类型语言与弱类型语言的比较</p>
<ul>
<li><p>编程时，数据受到数据类型的约束，就是强类型编程语言。数据不严格受数据类型的约束，就是弱类型编程语言。强弱类型语言各有优缺点。C#语言是强类型语言。例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x;</span><br><span class="line">x = <span class="number">100</span>; <span class="comment">// 内存中用32 bit/4 Byte来存储100这个整数值</span></span><br><span class="line"><span class="built_in">long</span> y;</span><br><span class="line">y = <span class="number">100L</span>; <span class="comment">// L代表长整型整数，在内存中用64 bit/8 Byte</span></span><br><span class="line"><span class="comment">// x = 100L; 这样写会报错，且会build失败</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> b;</span><br><span class="line">b = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// b = 100; 报错，因为整数100无法转化为bool类型的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (x = <span class="number">200</span>) <span class="comment">// if的括号中明确要求一个bool类型的值。赋值后得到的不是bool值，因此会报错</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;It&#x27;s OK!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C语言实例：if条件</p>
<p>例子：新建一个c++项目，new project-visual c++-win32-Win32 Console Application</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Console.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">// c中没有专门的布尔类型，只要表达式的值不为0，就算作真，此处赋值后，得到的值为200，算作真</span></span><br><span class="line">	<span class="keyword">if</span> (x = <span class="number">200</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s OK!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C中常见的避免错误的写法，将字面值写到前面去，即<code>200 = x</code>，编译器报错后，就立即改为<code>200 == x</code>。</p>
</li>
<li><p>JavaScript示例：动态类型。js中的变量基本不受数据类型的约束。</p>
<p>例子：新建项目，选择visual c#-web-asp.net web application，选择empty，web forms。右击项目-add-html page，命名为<code>index.html</code>，这样其执行后就是首页。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">ButtonClicked</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> myVar = <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript">            myVar = <span class="string">&quot;Chen Yifan&quot;</span>; <span class="comment">// 强类型中不允许，但js中可以</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(myVar); <span class="comment">// 弹出小的警告框，显示100，这里js并没有管100的类型</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, JavaScript!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span><span class="attr">onclick</span>=<span class="string">&quot;ButtonClicked()&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>弱类型，灵活性与危险并存。</p>
</li>
<li><p>C#语言（4.0版本后）对弱类型/动态类型的模仿，例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c#中的dynamic关键字类似于js中的var关键字</span></span><br><span class="line"><span class="built_in">dynamic</span> myVar = <span class="number">100</span>;</span><br><span class="line">Console.WriteLine(myVar);</span><br><span class="line">myVar = <span class="string">&quot;Chen Yifan&quot;</span>;</span><br><span class="line">Console.WriteLine(myVar);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="类型在C-语言中的作用"><a href="#类型在C-语言中的作用" class="headerlink" title="类型在C#语言中的作用"></a>类型在C#语言中的作用</h3><ul>
<li><p>一个C#类型中所包含的信息有：</p>
<ul>
<li><p>存储此类型变量所需的内存空间大小，例如int类型占有4 Byte/32 bit，long类型占有8 Byte/64 bit。</p>
</li>
<li><p>此类型的值可表示的最大、最小值范围（与第一条推算）。可以查看以下的<a href="https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/s1ax56ch(v=vs.120">文档</a>?redirectedfrom=MSDN)，再分为三个文档：<a href="https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/exx3b86w(v=vs.120">Integral Types Table</a>?redirectedfrom=MSDN), <a href="https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/9ahet949(v=vs.120">Floating-Point Types Table</a>?redirectedfrom=MSDN), <a href="https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/364x0z75(v=vs.120">decimal</a>?redirectedfrom=MSDN)。一般用<code>ulong</code>来表示对象的身份id（类似<code>uuid</code>）。</p>
</li>
<li><p>此类型所包含的成员（如方法、属性、事件等）</p>
</li>
<li><p>此类型由何基类（父类）派生而来。程序未执行时，处于静态时期，即编辑期和编译期；程序执行起来后，处于动态/运行时期，即运行期。C#的机制：反射，即程序运行时，拿到对象/类型，可以立即知道其中的成员，然后根据需求来操作这些成员。例子参见<code>TypeSample</code>，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TypeSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Type myType = <span class="keyword">typeof</span>(Form); <span class="comment">// 查看Form类的类型</span></span><br><span class="line"></span><br><span class="line">            PropertyInfo[] pInfos = myType.GetProperties(); <span class="comment">// 一个类型知道其成员, GetProperties能够在程序运行的过程中动态地探知类型的所有属性</span></span><br><span class="line">            MethodInfo[] mInfos = myType.GetMethods(); <span class="comment">// GetMethods是得到该类型方法的函数</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> m <span class="keyword">in</span> mInfos)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(m.Name);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> p <span class="keyword">in</span> pInfos)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(p.Name);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">            Console.WriteLine(myType.Name); <span class="comment">// Form类的类型的名字就是Form</span></span><br><span class="line">            Console.WriteLine(myType.FullName); <span class="comment">// Form类的类型的全名是System.Windows.Forms.Form</span></span><br><span class="line">            Console.WriteLine(myType.BaseType.FullName); <span class="comment">// 一个类型知道其基类/父类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反射的用途：能够拿到某个属性，就能动态地访问到该属性的值；能够拿到某个方法，就能够动态地调用该方法。</p>
</li>
<li><p>程序运行的时候，此类型的变量在分配在内存的什么位置（即变量应该被分配到栈中还是堆中）。静态的程序在硬盘中，动态的程序在内存中。运行程序就是静态到动态的切换，就是从硬盘中装载到内存中。内存中有两个区域，分别是stack栈和heap堆。</p>
<ul>
<li><p>Stack简介：函数调用用到的是栈。栈较小，只有1-2M。</p>
</li>
<li><p>Stack overflow：栈较小且快。栈爆的两种情况：</p>
<ul>
<li>算法没写好，函数调用过多</li>
<li>往栈上分配了太多的内存</li>
</ul>
</li>
<li><p>stack overflow的例子1，对应stack overflow的第一种情况：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StackOverflow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            BadGuy bg = <span class="keyword">new</span> BadGuy();</span><br><span class="line">            bg.BadMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title">BadGuy</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BadMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> x = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归调用BadMethod</span></span><br><span class="line">            <span class="comment">// 很快就会stack overflow，因为每次调用都需要在栈上切出一块内存存储变量x</span></span><br><span class="line">            <span class="keyword">this</span>.BadMethod(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stack overflow的例子2，对应stack overflow的第二种情况：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StackOverflow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// stackalloc是往栈上切内存，切的过多就会stack overflow</span></span><br><span class="line">            <span class="comment">// c#中不推荐使用指针，一定要用需要在函数前加unsafe</span></span><br><span class="line">            <span class="comment">// 记得去project-StackOverflow properties-build中勾选allow unsafe code，并保存</span></span><br><span class="line">            <span class="keyword">unsafe</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span>* p = <span class="keyword">stackalloc</span> <span class="built_in">int</span>[<span class="number">9999999</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Heap简介：堆用来存储对象/实例。堆较大，有几个G。</p>
</li>
<li><p>使用Performance Monitor查看进程的堆内存使用量</p>
</li>
<li><p>使用wpf application介绍堆。compile是编译，build是组装。一个程序从硬盘加载到内存中，开始执行后，就形成了一个进程（process）。在wpf application中，创建一个界面，上面有两个button，一个用于consume heap memory，一个用于release heap memory，对应的点击两个按钮后执行的逻辑为：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Data;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Documents;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Input;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Media;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Media.Imaging;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Navigation;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Shapes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">HeapSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Interaction logic for MainWindow.xaml</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Window&gt; winList; <span class="comment">// 本变量需要被两个函数使用，因此被声明在函数之外</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            winList = <span class="keyword">new</span> List&lt;Window&gt;();</span><br><span class="line">            <span class="comment">// 往list中加入15000个Window，Window的实例占用的内存较多</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Window w = <span class="keyword">new</span> Window();</span><br><span class="line">                winList.Add(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Botton2_Click</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            winList.Clear(); <span class="comment">// 找合适的时机回收垃圾内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>build-build solution后，右击项目，选择open folder in file explorer，进入bin-debug，双击运行<code>HeapSample.exe</code>。win+r，键入perfmon，即performance monitor，打开了性能监视器，可用其监视系统和某个程序的性能。点击添加-process-private bytes，选择实例为HeapSample，即可开始监视HeapSample这个程序使用的堆内存。双击图例，选择图表，最大值从100改为1024，然后的点击两个按钮，即可开始实验。观察到，点击consume heap memory按钮，堆内存的占用拉高；点击release heap memory按钮，堆内存的占用先不变，后拉低（因为不是立即释放内存，而是在合适的时机释放内存，当内存占用不多时，先不会释放内存）。</p>
<p>未来写程序时，观察程序是否占用过多内存，或者某个操作是否占用过多的内存，就可以用performance monitor。</p>
</li>
<li><p>关于内存泄漏：对象被分配，但没有被回收，导致内存被浪费掉了。比较C++和C#</p>
<ul>
<li>C++中，对象被分配但没被回收，会导致内存泄漏</li>
<li>C#中，有垃圾收集器的机制，不需要手动释放内存，会自动回收内存。C#中也不需要手动释放内存，相对安全，不易出现内存泄漏。</li>
</ul>
</li>
</ul>
</li>
<li><p>此类型所允许的操作（运算），例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TypeSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> result1 = <span class="number">3.0</span> / <span class="number">4.0</span>; <span class="comment">// 浮点除法</span></span><br><span class="line">            Console.WriteLine(result1);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">double</span> result2 = <span class="number">3</span> / <span class="number">4</span>; <span class="comment">// 整数除法</span></span><br><span class="line">            Console.WriteLine(result2); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="7-详解类型、变量与对象（下）"><a href="#7-详解类型、变量与对象（下）" class="headerlink" title="7. 详解类型、变量与对象（下）"></a>7. 详解类型、变量与对象（下）</h2><h3 id="C-语言的类型系统"><a href="#C-语言的类型系统" class="headerlink" title="C#语言的类型系统"></a>C#语言的类型系统</h3><ul>
<li><p>C#的五大数据类型</p>
<ul>
<li>类（Classes）：如Windows, Form, Console, String</li>
<li>结构体（Structures）：如Int32, Int64, Single, Double</li>
<li>枚举（Enumerations）：如HorizontalAlignment, Visibility</li>
<li>接口（Interfaces）</li>
<li>委托（Delegates）</li>
</ul>
</li>
<li><p>C#类型的派生谱系</p>
<p>树状的，带有层级结构的类型系统。根部是Object数据类型。C#的类型系统包括引用类型和值类型，引用类型包括类、接口和委托，值类型包括结构体和枚举，所有类型都以Object类型为基类型。三组关键字。第一组对应的是引用类型，蓝色的是数据类型的关键字，黑色的是用于定义引用类型的关键字，<code>class</code>用于定义类，<code>interface</code>用于定义接口，<code>delegate</code>用于定义委托。第二组对应的是值类型，蓝色的是数据类型，黑色的是用于定义值类型的关键字，<code>struct</code>用于定义结构体，<code>enum</code>用于定义枚举。第三组，最上面是bool类型的取值，中间的：<code>void</code>表示函数无返回值，<code>null</code>表示引用变量为空，最下面是用于声明变量的。</p>
<p>蓝色的字表明：</p>
<ul>
<li>是现成的数据类型，非常常用，c#已经将其作为关键字</li>
<li>是基本数据类型（又称内建数据类型），别的类型都是基于这些类型构成的，没有更基本的类型来构成它们</li>
</ul>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/csharpType.png?raw=true" alt="csharpType.png"></p>
</li>
<li><p>实验</p>
<ul>
<li><p>实验1：证明Form是一个类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Type myType = <span class="keyword">typeof</span>(Form); <span class="comment">// 获取Form的类型</span></span><br><span class="line">Console.WriteLine(myType.FullName);</span><br><span class="line">Console.WriteLine(myType.IsClass);</span><br></pre></td></tr></table></figure>
<p>或者在<code>Form</code>上右击，选择go to definition，或者按下快捷键F12，就来到了微软定义<code>Form</code>的地方，可以看到定义<code>Form</code>时，有以下代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Form</span> : <span class="title">ContainerControl</span></span><br></pre></td></tr></table></figure>
<p>因此<code>Form</code>的类型是class，其基类是<code>ContainerControl</code>。</p>
</li>
<li><p>实验2：结构体类型：<code>int</code>, <code>long</code>等，都是结构体类型。在上面右击，选择go to definition，即可验证。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Int32 : IComparable, IFormattable, IConvertible, IComparable&lt;<span class="built_in">int</span>&gt;, IEquatable&lt;<span class="built_in">int</span>&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Int64 : IComparable, IFormattable, IConvertible, IComparable&lt;<span class="built_in">long</span>&gt;, IEquatable&lt;<span class="built_in">long</span>&gt;</span><br></pre></td></tr></table></figure>
<p><code>int</code>即相当于<code>Int32</code>，<code>long</code>即相当于<code>Int64</code>。</p>
</li>
<li><p>实验3：枚举类型，用于限定用户从一个集合中选取有效值。显示窗口时，有三种状态：最大化、标准模式（可调整窗口大小）和最小化。现在来设置窗口的状态，有效值就三个，因此需要枚举类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Form f = <span class="keyword">new</span> Form();</span><br><span class="line">f.WindowState = FormWindowState.Maximized; </span><br><span class="line">f.ShowDialog(); <span class="comment">// 此时显示最大化的窗口</span></span><br></pre></td></tr></table></figure>
<p>查看<code>FormWindowState</code>的源代码，用<code>enum</code>关键字声明的类型就是枚举类型：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> Assembly System.Windows.Forms.dll, v4.0.0.0</span></span><br><span class="line"><span class="comment">// C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5\System.Windows.Forms.dll</span></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">System.Windows.Forms</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Summary:</span></span><br><span class="line">    <span class="comment">//     Specifies how a form window is displayed.</span></span><br><span class="line">    [<span class="meta">ComVisible(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> FormWindowState</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Summary:</span></span><br><span class="line">        <span class="comment">//     A default sized window.</span></span><br><span class="line">        Normal = <span class="number">0</span>,</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Summary:</span></span><br><span class="line">        <span class="comment">//     A minimized window.</span></span><br><span class="line">        Minimized = <span class="number">1</span>,</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Summary:</span></span><br><span class="line">        <span class="comment">//     A maximized window.</span></span><br><span class="line">        Maximized = <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三个关键字：</p>
<ul>
<li><code>class</code>：用来声明类 类型</li>
<li><code>struct</code>：用来声明结构体类型</li>
<li><code>enum</code>：用来声明枚举类型</li>
</ul>
</li>
<li><p>接口和委托类型暂且不讲。</p>
</li>
</ul>
</li>
</ul>
<h3 id="变量、对象与内存（核心内容）"><a href="#变量、对象与内存（核心内容）" class="headerlink" title="变量、对象与内存（核心内容）"></a>变量、对象与内存（核心内容）</h3><ul>
<li><p>什么是变量</p>
<p><strong>变量 = 以变量名所对应的内存地址为起点、以其数据类型所要求的存储空间为长度的一块内存区域</strong></p>
<ul>
<li><p>表面上来看（C#代码的上下文行文上来看），变量的用途是存储数据</p>
</li>
<li><p>实际上，<strong>变量表示了存储位置，并且每个变量都有一个类型，以决定什么样的值能够存入变量</strong></p>
<ul>
<li><p>变量表示了存储位置：变量名表示（对应着）变量的值在内存中的存储位置。例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x; <span class="comment">// x是一个标签，其对应着内存中的地址，100就存在这个地址</span></span><br><span class="line">x = <span class="number">100</span>; </span><br></pre></td></tr></table></figure>
</li>
<li><p>每个变量都有一个类型，以决定什么样的值能够存入变量。同样用上面的例子解释：只有<code>int</code>类型的值可以保存到x指示的地址上去。</p>
</li>
</ul>
</li>
<li><p>变量一共有7种</p>
<ul>
<li>静态变量，实例变量（成员变量，字段），数组元素，值参数，引用参数，输出形参，局部变量</li>
</ul>
</li>
<li><p>狭义的变量指局部变量，因为其它种类的变量都有自己的约定名称</p>
<ul>
<li>简单地讲，局部变量就是方法体（函数体）里声明的变量</li>
</ul>
</li>
<li><p>7种变量的例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TypeInCSharp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">100</span>]; <span class="comment">// 声明了长度为100的整型数组</span></span><br><span class="line">            <span class="comment">// 取出数组中的元素: array[0], array[99]</span></span><br><span class="line">            <span class="comment">// 这100个数组中的元素都是变量</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> x; <span class="comment">// 局部变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Amount; <span class="comment">// 静态成员变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例变量/字段</span></span><br><span class="line">        <span class="comment">// 字段容易被赋为不合法的值，属性自带逻辑，可以保护字段不被赋不合法的值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数</span></span><br><span class="line">        <span class="comment">// double b是值参数变量, ref double a是引用参数变量, out double a是输出参数变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> result = a + b; <span class="comment">// result是Add方法的局部变量</span></span><br><span class="line">            <span class="keyword">return</span> result; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量的声明</p>
<ul>
<li><p>有效的修饰符组合<sub>opt</sub>+类型+变量名+初始化器<sub>opt</sub></p>
</li>
<li><p>opt表示可选的，没有opt下角标则是必需的</p>
</li>
<li><p>例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TypeInCSharp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> a; <span class="comment">// 声明变量</span></span><br><span class="line">            a = <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">int</span> b; <span class="comment">// 声明变量</span></span><br><span class="line">            b = <span class="number">200</span>;</span><br><span class="line">            <span class="built_in">int</span> c = a + b; <span class="comment">// 声明变量</span></span><br><span class="line">            Console.WriteLine(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 有效的修饰符组合: public static</span></span><br><span class="line">        <span class="comment">// 类型: int</span></span><br><span class="line">        <span class="comment">// 变量名: Amount</span></span><br><span class="line">        <span class="comment">// 初始化器: = 0</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Amount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>值类型的变量</p>
<ul>
<li><p>值类型没有实例，所谓的“实例”与变量合二为一。比如<code>int a = 100</code>，<code>a</code>既是变量，也是<code>int</code>类型的实例。</p>
</li>
<li><p>基本知识：计算机内存的最小单位是bit，1个bit存储1个二进制数。8个bit组成一个字节（Byte），计算机内存中以字节为单元进行存取数据和读取数据，计算机为每个字节准备了一个唯一的编号，内存地址就是某个字节在计算机中的编号。寻找某个特定字节的过程：寻址。</p>
<p>操作系统如何使用内存：</p>
<ul>
<li>部分内存保留给计算机操作系统，别的应用程序不能用</li>
<li>其他内存为自由内存</li>
</ul>
</li>
<li><p>以byte/sbyte/short/ushort这四种结构体为例，演示值类型的变量在内存中如何存储。</p>
<ul>
<li><p>byte: vs中输入byte，然后快捷键ctrl+shift+F1查看其文档，获取基本信息</p>
</li>
<li><p>例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TypeInCSharp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span> b;</span><br><span class="line">            b = <span class="number">100</span>; <span class="comment">// 内存中存储为二进制，值为01100100</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">sbyte</span> sb; <span class="comment">// Signed 8-bit integer, range -128 to 127</span></span><br><span class="line">            sb = <span class="number">100</span>; <span class="comment">// 内存中存储为二进制，值为01100100，最高位为符号位</span></span><br><span class="line">            <span class="comment">// 负数 = 正数按位取反加1，故-100 = 10011100（注意进位）</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">ushort</span> us; <span class="comment">// Unsigned 16-bit integer, range 0 to 65,535</span></span><br><span class="line">            us = <span class="number">1000</span>; <span class="comment">// 内存中存储为二进制，值为000000 + 1111101000, 注意高位存储在内存地址（字节编号）较大处</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">short</span> s; <span class="comment">// Signed 16-bit integer, range -32,768 to 32,767</span></span><br><span class="line">            s = <span class="number">1000</span>; <span class="comment">// 值为000000 + 1111101000</span></span><br><span class="line">            s = <span class="number">-1000</span>; <span class="comment">// 按位取反加1, -1000存储为1111110000011000</span></span><br><span class="line">            <span class="built_in">string</span> str = Convert.ToString(s, <span class="number">2</span>); <span class="comment">// s转为二进制，然后打印为字符串</span></span><br><span class="line">            Console.WriteLine(str); <span class="comment">// 验证-1000存储为1111110000011000</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>引用类型的变量与实例</p>
<ul>
<li><p>引用类型变量与实例的关系：引用类型变量里存储的数据是对象/实例的内存地址</p>
</li>
<li><p>以类为例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TypeInCSharp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu; <span class="comment">// 计算机看到引用类型，就分配4 Byte，将其中的所有bit都置为0，说明此时变量stu没有引用任何实例</span></span><br><span class="line">            stu = <span class="keyword">new</span> Student(); <span class="comment">// 在堆内存中创建一个Student实例，实例才是真正包含ID和Score这两个字段的实体</span></span><br><span class="line">            <span class="comment">// 将实例在堆内存中的地址保存到stu变量中，即将内存编号以二进制的形式写入上面的4 Byte中</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 也可解释为什么可以用两个不同的引用变量来引用同一个实例</span></span><br><span class="line">            Student stu2;</span><br><span class="line">            stu2 = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">uint</span> ID; <span class="comment">// 32 bit</span></span><br><span class="line">        <span class="built_in">ushort</span> Score; <span class="comment">// 16 bit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>局部变量是在stack上分配内存</p>
</li>
<li><p>变量的默认值。例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TypeInCSharp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ID和Score的默认值为0</span></span><br><span class="line">            <span class="comment">// 所有类型的变量，其默认值都是分配好的Byte的各个bit全部置为0</span></span><br><span class="line">            <span class="comment">// 但所有本地变量都需要有显示地赋初值</span></span><br><span class="line">            Console.WriteLine(stu.ID); </span><br><span class="line">            Console.WriteLine(stu.Score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">uint</span> ID; </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">ushort</span> Score; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量（值不可改变的变量），例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TypeInCSharp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">int</span> x = <span class="number">100</span>; <span class="comment">// 常量const，常量不可被二次赋值，常量的初始化器不可省略或者换行</span></span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>装箱与拆箱（Boxing &amp; Unboxing）</p>
<p>在实际编程中少用，因为会导致性能的损失。有以下的例子和笔记：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TypeInCSharp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> x = <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">object</span> obj = x; <span class="comment">// 装箱</span></span><br><span class="line">            <span class="comment">// obj是引用类型，在内存中分配4 Byte的存储单元</span></span><br><span class="line">            <span class="comment">// 分开来写: object obj; // 4 Byte全部置零</span></span><br><span class="line">            <span class="comment">// obj = x;</span></span><br><span class="line">            <span class="comment">// 装箱：当obj要引用的值不是堆上的实例，而是栈上的值类型变量</span></span><br><span class="line">            <span class="comment">// 操作就是在堆上找一片空余的区域，将栈上的值拷贝过去</span></span><br><span class="line">            <span class="comment">// 再将堆上的地址存储到obj对应的内存空间中</span></span><br><span class="line">            <span class="comment">// 总之，obj变量对堆上的实例进行引用，实例中封装着x这个整数，这就是装箱</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拆箱: 拿到obj在堆上存储的整数值x</span></span><br><span class="line">            <span class="built_in">int</span> y = (<span class="built_in">int</span>)obj;</span><br><span class="line">            <span class="comment">// 看到obj在堆上存储的值，将其转换为整数类型，然后存储在y对应的内存空间中</span></span><br><span class="line">            Console.WriteLine(y);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 装箱和拆箱会损失性能，因为在栈和堆之间搬运了东西</span></span><br><span class="line">            <span class="comment">// 装箱：将栈上的值类型变量封装为object类型的实例，存储在堆上</span></span><br><span class="line">            <span class="comment">// 拆箱：将堆上object类型的实例里面的值，按照要求拆为目标数据类型，存储在栈上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="本节作业-3"><a href="#本节作业-3" class="headerlink" title="本节作业"></a>本节作业</h3><ul>
<li>理解并熟记所有概念和知识</li>
<li>对照视频编写示例程序，直至能够默写</li>
</ul>
<h2 id="8-方法的定义、调用与调试（上）"><a href="#8-方法的定义、调用与调试（上）" class="headerlink" title="8. 方法的定义、调用与调试（上）"></a>8. 方法的定义、调用与调试（上）</h2><h3 id="方法的由来"><a href="#方法的由来" class="headerlink" title="方法的由来"></a>方法的由来</h3><h3 id="方法的定义与调用（重要）"><a href="#方法的定义与调用（重要）" class="headerlink" title="方法的定义与调用（重要）"></a>方法的定义与调用（重要）</h3><h3 id="构造器（一种特殊的方法）"><a href="#构造器（一种特殊的方法）" class="headerlink" title="构造器（一种特殊的方法）"></a>构造器（一种特殊的方法）</h3><h3 id="方法的重载（Overload）"><a href="#方法的重载（Overload）" class="headerlink" title="方法的重载（Overload）"></a>方法的重载（Overload）</h3><h3 id="如何对方法进行debug"><a href="#如何对方法进行debug" class="headerlink" title="如何对方法进行debug"></a>如何对方法进行debug</h3><h3 id="方法的调用与栈"><a href="#方法的调用与栈" class="headerlink" title="方法的调用与栈*"></a>方法的调用与栈*</h3><h2 id="9-方法的定义、调用与调试（下）"><a href="#9-方法的定义、调用与调试（下）" class="headerlink" title="9. 方法的定义、调用与调试（下）"></a>9. 方法的定义、调用与调试（下）</h2>]]></content>
      <categories>
        <category>Software Development</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 1 | Leetcode 704, 27</title>
    <url>/2024/01/24/Day-1-Leetcode-704-27/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p><a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p>
<p><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE</a></p>
<p><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6</a></p>
<p><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%9C%89%E5%87%A0%E4%B8%AA%E7%96%91%E9%97%AE%EF%BC%9F.html">https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%9C%89%E5%87%A0%E4%B8%AA%E7%96%91%E9%97%AE%EF%BC%9F.html</a></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.com/problems/binary-search/">https://leetcode.com/problems/binary-search/</a></p>
<p><a href="https://leetcode.com/problems/remove-element/">https://leetcode.com/problems/remove-element/</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><p>数组是存放在<strong>连续内存空间</strong>上的<strong>相同类型数据</strong>的集合。</p>
<p>注意：</p>
<ul>
<li><p>数组下标都是从0开始的</p>
</li>
<li><p>数组内存空间的地址是连续的</p>
</li>
<li><p>正是因为数组的在内存空间的地址是连续的，所以我们在<strong>删除或者增添元素的时候，就难免要移动其他元素的地址</strong></p>
</li>
<li><p>C++中，要注意vector和array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组</p>
</li>
<li><p>数组的元素是不能删的，只能覆盖</p>
</li>
<li><p>C++中二维数组在地址空间上是连续的（在现代系统上，二维数组中的每个int占用4个字节）</p>
</li>
<li><p>Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。输出的值不是真正的地址，而是经过处理的数值</p>
</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度是一个函数，它定性描述该算法的运行时间。</p>
<p>大O用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。有时业界也默认O代表的就是一般情况，而不是严格的上界。面试中说道算法的时间复杂度是多少指的都是一般情况。</p>
<p>数据用例的不一样，时间复杂度也是不同的。</p>
<p>我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大。</p>
<p>我们统一说 logn，也就是忽略底数的描述。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>是对一个算法在运行过程中占用内存空间大小的量度。</p>
<p>来看一下例子，什么时候的空间复杂度是$O(1)$呢，C++代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大O(1)。</p>
<p>当消耗空间和输入参数n保持线性增长，这样的空间复杂度为O(n)，来看一下这段C++代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>随着n的增大，开辟的内存大小呈线性增长，即 O(n)。</p>
<p>递归的时候，会出现空间复杂度为logn的情况。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h3><h4 id="Leetcode-704-二分查找"><a href="#Leetcode-704-二分查找" class="headerlink" title="Leetcode 704 二分查找"></a>Leetcode 704 二分查找</h4><p>这题应该是整数二分，虽然我在yxc的算法基础课里学过这题，但时隔几个月我已经彻底忘了（不管是原理还是实现），从头开始吧。</p>
<h4 id="Leetcode-27-移除元素"><a href="#Leetcode-27-移除元素" class="headerlink" title="Leetcode 27 移除元素"></a>Leetcode 27 移除元素</h4><p>试试暴力做法吧，双指针做法想不出来。根据yxc的经验，暴力做法成功后再想办法去优化。</p>
<h3 id="看完代码随想录后的想法"><a href="#看完代码随想录后的想法" class="headerlink" title="看完代码随想录后的想法"></a>看完代码随想录后的想法</h3><h4 id="Leetcode-704-二分查找-1"><a href="#Leetcode-704-二分查找-1" class="headerlink" title="Leetcode 704 二分查找"></a>Leetcode 704 二分查找</h4><p>二分法的使用前提：数组为有序数组，且数组中无重复元素。满足这两个性质的题目可尝试二分法。</p>
<p>二分法中区间的定义有两种：左闭右闭和左闭右开。<strong>每一次边界的处理都要坚持根据区间的定义来操作</strong>。</p>
<h4 id="Leetcode-27-移除元素-1"><a href="#Leetcode-27-移除元素-1" class="headerlink" title="Leetcode 27 移除元素"></a>Leetcode 27 移除元素</h4><p>暴力做法：遍历数组-&gt;找到需要移除的元素-&gt;将该元素后面的所有元素都前移一位-&gt;索引前移一位，数组长度减1</p>
<p>双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Leetcode-704-二分查找-2"><a href="#Leetcode-704-二分查找-2" class="headerlink" title="Leetcode 704 二分查找"></a>Leetcode 704 二分查找</h3><p>cpp中的vector中求数组的长度没有len函数，应该用size函数。</p>
<p>cpp中两个整数的做除法如果得到的结果变量类型为整数，则是向下取整的。</p>
<p>cpp中的vector是动态数组，要先向用push_back向其中添加元素，然后才能通过索引来访问元素。</p>
<p>左闭右闭和左闭右开的写法中，需要注意right初始值的选取的不同（由于一种写法的右边界可以取到，另一种写法的右边界取不到）。还需要注意分成三类讨论，即target &gt; nums[mid], target &lt; nums[mid]和target == nums[mid]。这样就可以避免处理大于等于和小于等于的情况。</p>
<p>返回总是返回mid，不要尝试返回l或者r，可能会遇到边界问题。</p>
<p>用(l + r) &gt;&gt; 1比(l + r) / 2要更快一点。</p>
<p>建议采用l + (r - l) / 2代替(r + l) / 2，前者可以防止(r + l)溢出整数的范围。</p>
<p>时间复杂度：O(log n)<br>空间复杂度：O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左闭右闭，因此要求左右边界均可取到，因此r的值要与右边界的索引相同</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">// (l + r) &gt;&gt; 1速度更快</span></span><br><span class="line">            <span class="comment">// 分三类情况讨论</span></span><br><span class="line">            <span class="comment">// 因为区间是右闭的，所以r不可能取为mid，最大为mid - 1</span></span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[mid]) r = mid - <span class="number">1</span>; </span><br><span class="line">            <span class="comment">// 因为区间是左闭的，所以l不可能取为mid，最小为mid + 1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// return l/r都是错误的，可以通过模拟一个输入知道错误原因</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左闭右开写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左闭右开，因此target不能取为右边界的值，要保证区间完全覆盖住target，因此r的值要比右边界的索引大1</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右边界取不到，因此是l &lt; r</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 因为区间是左闭的，所以l不可能取为mid，最小为mid + 1</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 因为区间是右开的，所以r可以取为mid</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) r = mid;</span><br><span class="line">            <span class="comment">// return l是错误的，可以通过模拟一个输入知道错误原因</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-27-移除元素-2"><a href="#Leetcode-27-移除元素-2" class="headerlink" title="Leetcode 27 移除元素"></a>Leetcode 27 移除元素</h3><h4 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h4><p>若不前移i，则若数组中出现连续的两个val时，结果会发生错误，不能完全移除数组中所有的val。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历数组，找到需要移除的元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将该元素后面的所有元素都前移一位，覆盖掉需要移除的元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j ++ )</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                <span class="comment">// 索引前移一位，数组长度减1</span></span><br><span class="line">                i -- ;</span><br><span class="line">                size -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p>
<h4 id="快慢双指针做法"><a href="#快慢双指针做法" class="headerlink" title="快慢双指针做法"></a>快慢双指针做法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快指针用于遍历所有元素、慢指针用于记录更新后数组的下标</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); fast ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val)</span><br><span class="line">                nums[slow ++ ] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="相向双指针做法"><a href="#相向双指针做法" class="headerlink" title="相向双指针做法"></a>相向双指针做法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相向双指针方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 跳过所有不需要移除的元素，剩下需要移除的元素</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] != val) l ++ ;</span><br><span class="line">            <span class="comment">// 跳过所有需要移除的元素，剩下不需要移除的元素</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[r] == val) r -- ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将右边不需要移除的元素覆盖掉左边需要移除的元素(交换左右两边的元素)</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) nums[l ++ ] = nums[r -- ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回左边的最后一个值的索引</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<p>注意：while (l &lt;= r &amp;&amp; nums[l] != val)和while (l &lt;= r &amp;&amp; nums[r] == val)中的两个判断条件不可以写反，否则会出现Runtime Error。这是因为短路原则，最好先进行边界检查，再访问数组。</p>
<p>逻辑：数组的左边放等于val的元素，因此需要跳过所有不等于val的元素；数组的右边放不等于val的元素，因此需要跳过所有等于val的元素。交换数组的左右两边，让数组的左边放不等于val的元素，数组的右边放等于val的元素，然后输出数组左边的最后一个值的索引。</p>
<p>相向双指针方法的基本过程我大致理解了，但还不理解其的细节和应用。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="Leetcode-704-二分查找-3"><a href="#Leetcode-704-二分查找-3" class="headerlink" title="Leetcode 704 二分查找"></a>Leetcode 704 二分查找</h3><p>我认为代码随想录的做法比yxc的讲解更加清晰。清楚地归纳总结出了左闭右闭和左闭右开的写法，并根据选择区间的开闭性质清晰地写出了代码。同时，分成三类讨论，避免了处理大于等于和小于等于的情况。</p>
<p>还没有做35和34，等到二刷来做。</p>
<h3 id="Leetcode-27-移除元素-3"><a href="#Leetcode-27-移除元素-3" class="headerlink" title="Leetcode 27 移除元素"></a>Leetcode 27 移除元素</h3><p>相向双指针方法的理解有待加深。</p>
]]></content>
      <categories>
        <category>算法（数组）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>整数二分</tag>
        <tag>双指针算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 16 | Leetcode 104, 559, 111, 222</title>
    <url>/2024/02/18/Day-16-Leetcode-104-559-111-222/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html">104.二叉树的最大深度</a><br><a href="https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html">111.二叉树的最小深度</a><br><a href="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html">222.完全二叉树的节点个数</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h3><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="104-二叉树的最大深度-1"><a href="#104-二叉树的最大深度-1" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><p>我看到本题后，发现本题在层序遍历里面做过，就用层序遍历先求解。写出了如下代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题应该可以尝试用别的遍历方法，比如递归去求解。直接看卡尔的视频讲解吧。</p>
<h3 id="559-n叉树的最大深度"><a href="#559-n叉树的最大深度" class="headerlink" title="559. n叉树的最大深度"></a>559. n叉树的最大深度</h3><p>本题我首先尝试用层序遍历的解法求解，写出了如下的可以AC的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                Node* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;children.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[i]) q.<span class="built_in">push</span>(node-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            height ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接着思考如何递归求解。递归知道思路，但写不出取孩子树最大高度的那部分关键代码。</p>
<h3 id="111-二叉树的最小深度-1"><a href="#111-二叉树的最小深度-1" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><p>本题可以用层序遍历来做，属于层序遍历的10道题之一。我写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            depth ++ ;</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我再尝试用递归求解。发现有坑，做不出来，看卡尔的讲解。</p>
<h3 id="222-完全二叉树的节点个数-1"><a href="#222-完全二叉树的节点个数-1" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h3><p>拿到本题，我的第一想法依然是层序遍历。不得不说层序遍历法可以解决很多问题。我写下了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                cnt ++ ;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>感叹下，层序遍历确实能解决很多题，应该还不止卡尔给出的那10道题。我再来尝试递归解法。我觉得应该采用后序遍历，先统计根节点左右子树的节点数量，将二者加起来再加1即可。我写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历：左右中</span></span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">countNodes</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">countNodes</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> cnt = left + right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这道题我能想到的解法就是这两种，接着看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="104-二叉树的最大深度-2"><a href="#104-二叉树的最大深度-2" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><p>什么是深度，什么是高度？</p>
<ul>
<li>深度：二叉树中任意一个节点到根节点的距离。根节点的深度规定为1（0也可以，规则不同）。</li>
<li>高度：二叉树中任意一个节点到叶子节点的距离。叶子节点的高度规定为1。</li>
</ul>
<p><strong>求高度用后序遍历，求深度用前序遍历</strong>。求高度是从下往上计数，因此要求从下往上遍历，而后序遍历顺序为左右中，恰好就是从下往上。求深度是从上往下计数，因此要求从上往下遍历，而前序遍历顺序为中左右。恰好就是从上往下。本题本来应该用前序遍历，但<strong>根节点的高度就是二叉树的最大深度</strong>，<strong>因此本题用后序遍历也可以做</strong>。</p>
<p>递归三部曲：</p>
<ul>
<li><p>传入的参数和返回值</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">(TreeNode* node)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>终止条件</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 叶子节点的高度是1，其下的空节点高度是0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>单层递归（后序遍历：左右中）</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> leftheight = <span class="built_in">getheight</span>(node-&gt;left); <span class="comment">// 左节点高度</span></span><br><span class="line"><span class="type">int</span> rightheight = <span class="built_in">getheight</span>(node-&gt;right); <span class="comment">// 右节点高度</span></span><br><span class="line"><span class="type">int</span> height = <span class="number">1</span> + <span class="built_in">max</span>(leftheight, rightheight); <span class="comment">// 中节点高度，为左右孩子的高度取最大值+1</span></span><br><span class="line"><span class="keyword">return</span> height; <span class="comment">// 根节点的高度就是二叉树的最大深度</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>本题的前序遍历写法相比于后序遍历写法要复杂很多（前序遍历还涉及到回溯的过程）。本题也可以用迭代法实现。</p>
<h3 id="559-n叉树的最大深度-1"><a href="#559-n叉树的最大深度-1" class="headerlink" title="559. n叉树的最大深度"></a>559. n叉树的最大深度</h3><p>受到代码随想录的启发，写出了递归法（类似后序遍历）的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 挑选出最高的孩子节点，将其高度记为height</span></span><br><span class="line">        <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            height = <span class="built_in">max</span>(height, <span class="built_in">maxDepth</span>(root-&gt;children[i]));</span><br><span class="line">        height ++ ; <span class="comment">// 中节点（父节点）的高度在最高的孩子节点的基础上+1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="111-二叉树的最小深度-2"><a href="#111-二叉树的最小深度-2" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><p>本题和二叉树的最大深度有很多细节不同，容易踩坑。最小深度：根节点到叶子节点的最小距离（根节点到最近的叶子节点的距离）。像104题一样，本题求二叉树的最小深度，也可以通过<strong>后序遍历</strong>求高度的方式来求解。<strong>二叉树的最小深度实际上就是根节点的最小高度</strong>。本题求深度，本来应该用前序遍历，但前序遍历的代码不如后序遍历简洁，因此<strong>本题依然推荐使用后序遍历</strong>。</p>
<p>误区，不能写：<code>int height = 1 + min(left, right);</code>，若根节点的左子树为空，右子树不为空，则这样写二叉树的最小深度为1，显然不对。正确的方法是取右子树的最小高度，然后+1。为处理这种情况，需要写如下的单次递归的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="built_in">getheight</span>(node-&gt;left);</span><br><span class="line"><span class="type">int</span> right = <span class="built_in">getheight</span>(node-&gt;right);</span><br><span class="line"><span class="comment">// 若根节点的左子树为空，右子树不为空，二叉树的最小深度为右子树的最小高度+1</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + right;</span><br><span class="line"><span class="comment">// 若根节点的左子树不为空，右子树为空，二叉树的最小深度为左子树的最小高度+1</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + left;</span><br><span class="line"><span class="comment">// 若左右子树都不为空，则取其中最小的最小高度+1返回</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span> + <span class="built_in">min</span>(left, right);</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p>
<p>本题后序遍历的完整写法如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树为空，右子树非空</span></span><br><span class="line">        <span class="comment">// 也可写作if (left == 0 &amp;&amp; right) </span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + right;</span><br><span class="line">        <span class="comment">// 左子树非空，右子树为空</span></span><br><span class="line">        <span class="comment">// 也可写作if (left &amp;&amp; right == 0)</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + left;</span><br><span class="line">        <span class="comment">// 左右子树都不为空</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span> + <span class="built_in">min</span>(left, right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我写出了一个精简后的版本，但并不会影响代码的可读性（依然可以轻松看出后序遍历）：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">minDepth</span>(root-&gt;left); <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">minDepth</span>(root-&gt;right); <span class="comment">// 右</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (!left &amp;&amp; right) <span class="keyword">return</span> <span class="number">1</span> + right; <span class="comment">// 左空右不空</span></span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; !right) <span class="keyword">return</span> <span class="number">1</span> + left; <span class="comment">// 左不空右空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(left, right); <span class="comment">// 左右都不空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="222-完全二叉树的节点个数-2"><a href="#222-完全二叉树的节点个数-2" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h3><p>普通二叉树，递归法（前中后序）和迭代法（层序遍历）都可以求二叉树的节点个数。我在初次尝试中写的两个版本的代码都是把本题中的二叉树当成了普通二叉树，而没有利用完全二叉树的特性。本题强调了完全二叉树，就是暗示我们尽量利用完全二叉树的特性。</p>
<p>在递归法（前中后序）中，后序遍历的代码是最简洁的。每个节点都遍历了一遍，时间复杂度是O(n)。接下来利用完全二叉树的特性来降低时间复杂度。完全二叉树：除了底层节点，上面的节点都是满的。底层节点从左到右依次排开。对于满二叉树，只要知道深度h，节点数目就是2^h - 1。对于完全二叉树，如果其子树是满二叉树，则可以直接用上述公式来计算，计算完左右子树的节点数再+1（根节点）即可。<strong>关键：如何判断子树为满二叉树，并求其深度</strong>。</p>
<p>对于满二叉树，一直向左遍历和一直向右遍历的深度应该是相等的。<strong>一直向左遍历和一直向右遍历的深度相等的完全二叉树的子树一定是满二叉树</strong>。<strong>若遇到子树非满二叉树的情况，则继续向下遍历</strong>（即继续遍历子树的左右子树），直到是满二叉树为止，然后不断返回并+1。这种方式利用了完全二叉树的特性，且避免了遍历没有必要的节点，时间复杂度小于O(n)。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNum</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件1</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 终止条件2：遇到子树为满二叉树的情况，则返回子树中节点的数量</span></span><br><span class="line">    TreeNode* left = node-&gt;left; <span class="comment">// 用于遍历子树的左侧</span></span><br><span class="line">    TreeNode* right = node-&gt;right; <span class="comment">// 用于遍历子树的右侧</span></span><br><span class="line">    <span class="type">int</span> leftdepth = <span class="number">0</span>, rightdepth = <span class="number">0</span>; <span class="comment">// 左侧和右侧的深度</span></span><br><span class="line">    <span class="comment">// 计算左侧的深度</span></span><br><span class="line">    <span class="keyword">while</span> (left)</span><br><span class="line">    &#123;</span><br><span class="line">        left = left-&gt;left;</span><br><span class="line">        leftdepth ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算右侧的深度</span></span><br><span class="line">    <span class="keyword">while</span> (right)</span><br><span class="line">    &#123;</span><br><span class="line">        right = right-&gt;right;</span><br><span class="line">        rightdepth ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右侧深度相等，说明子树是满二叉树，可以利用公式快速计算子树的节点数量</span></span><br><span class="line">    <span class="keyword">if</span> (leftdepth == rightdepth) <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftdepth) - <span class="number">1</span>; <span class="comment">// 2 &lt;&lt; 0 = 2^1, 2 &lt;&lt; 1 = 2^2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归的逻辑，后序遍历</span></span><br><span class="line">    leftnum = <span class="built_in">getNum</span>(node-&gt;left); <span class="comment">// 左子树数量</span></span><br><span class="line">    rightnum = <span class="built_in">getNum</span>(node-&gt;right); <span class="comment">// 右子树数量</span></span><br><span class="line">    <span class="type">int</span> res = leftnum + rightnum + <span class="number">1</span>; <span class="comment">// 中</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述解法不需要去遍历完全二叉树中的所有节点，而是用公式直接计算子树为满二叉树时的节点数量并返回。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="104-二叉树的最大深度-3"><a href="#104-二叉树的最大深度-3" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><ol>
<li>本题可以用层序遍历法求解，属于层序遍历法可以求解的10道题之一。但本题用递归（后序遍历）求解代码最为简洁。</li>
<li>注意二叉树中深度和高度这两个概念。某个节点的深度指其到根节点的距离，某个节点的高度指其到叶子节点的距离。这两个概念可以说是相反的。</li>
<li>求深度用前序遍历，求高度用后序遍历。</li>
<li>二叉树的最大深度就是根节点的高度。因此本题可以用后序遍历求解，实际上后序遍历的代码远比前序遍历的代码简单。因此本题的推荐做法就是后序遍历。</li>
<li>对于559. n叉树的最大深度。同样可以采用类似后序遍历的递归方法和层序遍历的迭代方法。对于递归方法，注意如何挑选出最高的孩子节点。</li>
</ol>
<h3 id="111-二叉树的最小深度-3"><a href="#111-二叉树的最小深度-3" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><ol>
<li>本题可以用迭代法（层序遍历）和递归法（前/后序遍历）求解。最推荐的方法是后序遍历，因为其代码最为简洁。</li>
<li>后序遍历是用来求高度的，但二叉树的最小深度就是根节点的最小高度，因此本题可以用后序遍历。</li>
<li>本题的易错点为：不可以直接将104题的max改成min（因为二叉树的最小深度为根节点到叶子节点的最小距离），而是要针对左右子树是否为空进行分类讨论。</li>
<li>本题的层序遍历写法同样需要注意：只有当左右孩子都为空的时候，才说明遍历到最低点了。</li>
</ol>
<h3 id="222-完全二叉树的节点个数-3"><a href="#222-完全二叉树的节点个数-3" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h3><ol>
<li>本题可以采用递归写法和迭代写法。递归写法建议采用后序遍历，迭代写法建议采用层序遍历。二者的时间复杂度都是O(n)。</li>
<li>上述方法对普通二叉树都适用，但对本题的完全二叉树，充分利用其特性可将时间复杂度进一步减小。</li>
<li>一直向左遍历和一直向右遍历的深度相等的完全二叉树的子树一定是满二叉树<strong>。</strong>若遇到子树非满二叉树的情况，则继续向下遍历，最终必然会遇到满二叉树。对于满二叉树，只要知道深度h，节点数目就是2^h - 1。因此不需要遍历完全二叉树的每一个节点，就可以求得其节点的个数。</li>
<li>上述解法的终止条件有两个，一个是遇到叶子节点，另一个是子树为满二叉树。单层递归逻辑采用后序遍历写法。</li>
<li>时间复杂度分析：递归调用的次数=树的高度=log n，每层递归需要计算子树的高度，故也是log n。因此总的时间复杂度为O(log n * log n)。</li>
<li>空间复杂度分析：递归的深度（即递归调用栈的最大深度）大约是树的高度。对于一棵平衡二叉树来说，其高度大约是log n，其中n是树中节点的数量。故空间复杂度为O(log n)。</li>
</ol>
]]></content>
      <categories>
        <category>算法（二叉树）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>二叉树</tag>
        <tag>层序遍历</tag>
        <tag>递归解法</tag>
        <tag>后序遍历</tag>
        <tag>满二叉树</tag>
        <tag>完全二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 14 | Leetcode Recursive traversal, Iterative traversal, Unified iteration</title>
    <url>/2024/02/11/Day-14-Leetcode-Recursive-traversal-Iterative-traversal-Unified-iteration/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">理论基础</a><br><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">递归遍历</a><br><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">迭代遍历</a><br><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">统一迭代</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h4><p>解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树（完全二叉树包含满二叉树，满二叉树一定是完全二叉树）</p>
<p>“度”是指一个节点拥有的子节点的数量</p>
<h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。也可以说深度为k，有2^k-1个节点的二叉树。</p>
<h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p>完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且<strong>最下面一层的节点都集中在该层最左边的若干位置</strong>。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。</p>
<p>之前我们刚刚讲过优先级队列其实是一个堆，<strong>堆就是一棵完全二叉树</strong>，同时保证父子节点的顺序关系。</p>
<h5 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h5><p>前面介绍的树，都是没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。搜索的时间复杂度是O(logn)。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均<strong>小于</strong>它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均<strong>大于</strong>它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树<h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5>平衡二叉树（Balanced Binary Tree）是一种特殊的二叉树，它满足以下性质：对于树中的每一个节点，其左子树和右子树的高度差的绝对值不超过1。这个条件确保了<strong>树的高度大致保持在log(n)级别</strong>，其中n是树中节点的数量。由于这种高度平衡，平衡二叉树可以在对数据进行插入、删除和查找操作时提供较好的性能，特别是保持操作的时间复杂度接近于<code>O(logn)</code>。<h5 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h5>平衡二叉搜索树：又被称为AVL树。具有以下性质：<strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1</strong>，并且左右两个子树都是一棵平衡二叉树。</li>
</ul>
<p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn。map的key和set中的元素是有序的，因为它们的底层实现是平衡二叉搜索树，而平衡二叉搜索树是有序的。</p>
<h4 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h4><p>二叉树可以链式存储，也可以顺序（线性）存储。那么链式存储方式就用指针， 顺序存储的方式就是用数组。顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p>
<p>用数组来存储二叉树如何遍历的呢？如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。但是用链式表示的二叉树，更有利于我们理解，所以<strong>一般我们都是用链式存储二叉树</strong>。</p>
<p>代码构造二叉树：创造一个头节点，其左指针指向左子节点，右指针指向右子节点，然后向函数中传入头节点即可。</p>
<h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>二叉树主要有两种遍历方式：</p>
<ol>
<li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li>
<li>广度优先遍历：一层一层的去遍历。</li>
</ol>
<p>从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p>
<ol>
<li>深度优先遍历（一般用递归法）</li>
</ol>
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
<ol>
<li>广度优先遍历<br>层次遍历（迭代法）</li>
</ol>
<p>这里前中后，<strong>其实指的就是中间节点的遍历顺序</strong>（但是所有遍历顺序都是先左后右）。<br>左指左子树，右指右子树。在左右子树中继续按照规则搜索。<br>前序遍历：中左右<br>中序遍历：左中右<br>后序遍历：左右中</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806191109896.png" alt="img"></p>
<p>每个子树和整棵树都遵循中左右/左中右/左右中。</p>
<p>最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用<strong>递归</strong>的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。<strong>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助<strong>栈</strong>使用递归的方式来实现的。</p>
<p>而广度优先遍历的实现一般使用<strong>队列</strong>来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p>
<h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>链式存储的二叉树节点的定义方式：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>二叉树的定义和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针，有两个指针，指向左右孩子。</p>
<h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>针对leetcode上的三道题目，分别是前序、中序、后序遍历，题号是144，145和94。按照三步来思考，才能保证写出正确的递归代码。所有二叉树的题目都用递归三部曲进行分析。本章节主要讲如何写出递归的代码，不关注底层实现机制。</p>
<p>三部曲：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
<li>确定终止条件</li>
<li>确定单层递归的逻辑</li>
</ol>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序：中左右</p>
<ol>
<li><p>确定递归函数的参数和返回值</p>
<p>没必要一次性确定，可以在写递归函数时根据需要来填充参数。一般参数为根节点和数组，后者用来存放遍历的结果。返回值一般是void，因为我们把想要的结果放在了参数的数组中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> <span class="comment">// 参数为根节点和结果数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定终止条件（搞不好会出现栈溢出等问题）。深度优先搜索是遇到NULL时返回。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定单层递归的逻辑</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 中</span></span><br><span class="line"><span class="built_in">treversal</span>(cur-&gt;left, vec); <span class="comment">// 左</span></span><br><span class="line"><span class="built_in">treversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br></pre></td></tr></table></figure>
<p>注意在前序遍历中上面三行代码的顺序不可改变。</p>
</li>
</ol>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>左中右。只需要改变第三步：确定单层递归的逻辑的代码。三行代码的顺序不可改变。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">treversal</span>(cur-&gt;left, vec); <span class="comment">// 左</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 中</span></span><br><span class="line"><span class="built_in">treversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br></pre></td></tr></table></figure></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>左右中。同样只需要改变第三步：确定单层递归的逻辑的代码。三行代码的顺序不可改变。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">treversal</span>(cur-&gt;left, vec); <span class="comment">// 左</span></span><br><span class="line"><span class="built_in">treversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 中</span></span><br></pre></td></tr></table></figure></p>
<h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><h4 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>非递归的方式：迭代法，如何实现二叉树的前中后序遍历。通常对简单的递归逻辑，要求写出相应的迭代（非递归）写法。最基础的就是用迭代法实现前中后序遍历。使用迭代法模拟递归，也需要使用到栈这种数据结构。理论上，所有递归都可以用栈模拟出来。</p>
<p>以下面的二叉树为例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[5] --&gt; B[4];</span><br><span class="line">    A --&gt; C[6];</span><br><span class="line">    B --&gt; D[2];</span><br><span class="line">    B --&gt; E[1];</span><br></pre></td></tr></table></figure>
<p>前序遍历上述二叉树，顺序为中左右，输出结果为54216。用栈来辅助遍历上述二叉树。首先将5加入栈中，然后弹出5，将其放入结果数组中。接着处理5的左右孩子，先把6加入栈中，再把4加入栈中（栈是先进后出的），然后弹出4，将其放入结果数组中。接着处理4的左右孩子，依旧是先放右孩子1，再放左孩子2，然后弹出2，加入结果数组中，因为2已经是叶子节点了，接着弹出1，加入结果数组中，最后弹出6，加入结果数组中。结果数组中是54216，符合预期。关键点是先将右孩子放入栈中，再将左孩子放入栈中，这样弹出时就会先弹出左孩子。<strong>弹出时还要关注弹出的节点是否是叶子节点。是，则不需要继续向栈中加入元素；否，则需要向栈中继续加入弹出节点的左右孩子</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">function</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; st; <span class="comment">// 栈</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 结果数组</span></span><br><span class="line">    </span><br><span class="line">    st.<span class="built_in">push</span>(root); <span class="comment">// 中节点入栈</span></span><br><span class="line">    <span class="comment">// 栈不为空，则执行以下逻辑</span></span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将中节点从栈中弹出，加入到结果数组中</span></span><br><span class="line">        TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) <span class="comment">// 特判：中节点是否为空</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>; <span class="comment">// 若中节点为空，进入下一次循环</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将中节点的左右孩子放入栈中，先将右孩子入栈，再将左孩子入栈，这样出栈时才是先左后右的顺序</span></span><br><span class="line">        st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右</span></span><br><span class="line">        st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归模拟前序遍历，本来前序遍历的顺序应该是中左右，但由于栈先进后出的特性，代码中实际的顺序是中右左。</p>
<h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历是左右中。实现后序遍历的原理如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[前序遍历：中左右] --&gt;|颠倒左右| B[中右左]</span><br><span class="line">    B --&gt;|翻转结果数组| C[左右中]</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">function</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    st.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        	res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        st.<span class="built_in">push</span>(root-&gt;left); <span class="comment">// 左</span></span><br><span class="line">        st.<span class="built_in">push</span>(root-&gt;right); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历无法在前序遍历的基础上通过交换某几行代码的顺序来实现。遍历节点和处理节点是两种逻辑。前序和后序遍历中，遍历的节点和要处理的节点是一个顺序，才能写出上述比较简洁的代码。但在中序遍历中，遍历节点的顺序与和处理节点的顺序不同。后面会继续介绍中序遍历的写法，以及如何像递归写法那样更改几行代码的顺序来实现前中后序遍历的迭代写法。</p>
<p>处理二叉树时有两步操作，一步是访问节点，一步是处理节点。访问节点是从根节点开始，一个节点一个节点地去访问。处理节点是把访问到的节点中的元素放入结果数组中。</p>
<p>以下面的二叉树为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[5] --&gt; B[4];</span><br><span class="line">    A --&gt; C[6];</span><br><span class="line">    B --&gt; D[1];</span><br><span class="line">    B --&gt; E[2];</span><br></pre></td></tr></table></figure>
<p>对于中序遍历，先访问的节点是5，但先处理的节点应该是1（先把1放入结果数组中）。我们要处理1节点，需要先访问节点5、4、1。这就造成了访问的顺序和处理的顺序不同。因此中序遍历需要另一套写法。</p>
<p>下面模拟中序遍历迭代法的过程。需要一个指针帮助我们遍历二叉树，同时用栈记录遍历过的顺序，然后逆向输出即可。指针一路向左访问，指针先指向5，5入栈；指针再指向4，4入栈；指针再指向1，1入栈。到叶子节点了（叶子节点的左指针为空），便从栈中取出元素，从栈中弹出1并加入到结果数组中。看1的右孩子，为空，故再从栈中弹出4并加入到结果数组中，看4的右孩子，不为空，4的右孩子2入栈。2的左孩子为空，故将2从栈中弹出，加入到结果数组中。再看2的右孩子，为空，故从栈中弹出5并加入到结果数组中。5的右孩子为6，不为空，6入栈。6的左孩子为空，故6出栈，加入结果数组中。6的右孩子为空，本该从栈中弹出元素，但此时栈为空，故结束。结果数组为14256，符合中序遍历的顺序。</p>
<p><strong>总结</strong>：用指针遍历节点，用栈来记录遍历过的节点，再从栈中弹出元素放入结果数组中。指针一路向左访问，若某个节点的左指针为空，则从栈中取出该节点并放入结果数组中。若某个节点的右指针为空，则从栈中弹出顶部元素并放入结果数组中，若某个节点的右指针不为空，则将右指针指向的节点入栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">traversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode* cur = root; <span class="comment">// 用于遍历二叉树的指针，一开始指向根节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cur为空且栈也为空时，遍历终止</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 栈用于记录指针访问过的元素</span></span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left; <span class="comment">// 指针一路向左访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针一路向左，遇到某个节点的左指针为空</span></span><br><span class="line">        <span class="comment">// 则从栈中取出该节点并放入结果数组中</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cur = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 看当前指针的右孩子是否为空</span></span><br><span class="line">            <span class="comment">// 若为空，则从栈中弹出顶部节点，并将其加入到结果数组中</span></span><br><span class="line">            <span class="comment">// 若不为空，则将右孩子入栈</span></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前迭代法的前中后序遍历没有像递归那样统一起来，其实也是可以统一起来的。统一的写法：用一个栈完成遍历节点和处理节点的过程，但栈中要加入空节点做标记，标记正在遍历的节点和处理的节点。</p>
<h3 id="统一迭代"><a href="#统一迭代" class="headerlink" title="统一迭代"></a>统一迭代</h3><p>对前中后序这三种遍历方式，使用迭代法是可以写出统一风格的代码。以中序遍历为例，我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p>
<h4 id="中序遍历-2"><a href="#中序遍历-2" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点非空才将其放入栈中</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环条件：栈不为空</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// node不为空，则按照右中左的顺序访问节点</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(node); <span class="comment">// 中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只有遇到空节点的时候，才处理节点（将下一个节点放进结果集）</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将空节点弹出，重新取出栈中的元素</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于前序和后序遍历，只需要改变node不为空时访问节点的顺序即可。前序遍历原本的顺序是中左右，考虑到栈先入后出的特性，调整为右左中。后续遍历原本的顺序是左右中，考虑到栈先入后出的特性，调整为中右左。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="递归遍历-1"><a href="#递归遍历-1" class="headerlink" title="递归遍历"></a>递归遍历</h3><h4 id="144-前序遍历二叉树"><a href="#144-前序遍历二叉树" class="headerlink" title="144. 前序遍历二叉树"></a>144. 前序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 前序遍历递归写法的核心函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> <span class="comment">// 递归函数的参数和返回值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 确定终止条件</span></span><br><span class="line">        </span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, vec); <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于主函数，调用核心函数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root, res); <span class="comment">// 调用核心函数</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>完整的，带有测试样例的代码为：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建树的示例代码，需要根据实际情况调整</span></span><br><span class="line">    TreeNode* node3 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    TreeNode* node2 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>, node3, <span class="literal">nullptr</span>);</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>, <span class="literal">nullptr</span>, node2);</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = solution.<span class="built_in">preorderTraversal</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : res) &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放分配的内存（在实际使用中，考虑使用智能指针自动管理内存）</span></span><br><span class="line">    <span class="keyword">delete</span> node3;</span><br><span class="line">    <span class="keyword">delete</span> node2;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="145-后序遍历二叉树"><a href="#145-后序遍历二叉树" class="headerlink" title="145. 后序遍历二叉树"></a>145. 后序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, res); <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, res); <span class="comment">// 右</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="94-中序遍历二叉树"><a href="#94-中序遍历二叉树" class="headerlink" title="94. 中序遍历二叉树"></a>94. 中序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, res); <span class="comment">// 左</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, res); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="迭代遍历-1"><a href="#迭代遍历-1" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><h4 id="144-前序遍历二叉树-1"><a href="#144-前序遍历二叉树-1" class="headerlink" title="144. 前序遍历二叉树"></a>144. 前序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序为中左右，因为栈的先入后出的特性，所以代码顺序调整为中右左</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st; <span class="comment">// 用栈实现迭代，模拟递归</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 结果数组</span></span><br><span class="line"></span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右</span></span><br><span class="line">            st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="145-后序遍历二叉树-1"><a href="#145-后序遍历二叉树-1" class="headerlink" title="145. 后序遍历二叉树"></a>145. 后序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历：左右中。前序遍历：中左右 </span></span><br><span class="line"><span class="comment">// 中左右-&gt;中右左-&gt;左右中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左</span></span><br><span class="line">            st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="94-中序遍历二叉树-1"><a href="#94-中序遍历二叉树-1" class="headerlink" title="94. 中序遍历二叉树"></a>94. 中序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历的迭代写法，参见总结部分的精髓即可写出以下的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件：指针和栈都为空</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 指针不为空，则将指针指向的节点放入栈中，指针向左走</span></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指针为空，则将栈顶元素弹出并放入结果数组中，指针向右走</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="统一迭代-1"><a href="#统一迭代-1" class="headerlink" title="统一迭代"></a>统一迭代</h3><h4 id="94-中序遍历二叉树-2"><a href="#94-中序遍历二叉树-2" class="headerlink" title="94. 中序遍历二叉树"></a>94. 中序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将非空的头节点插入栈中</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环终止条件：栈为空</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若node不为空，则按照右中左的顺序访问节点</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 访问右节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(node); <span class="comment">// 访问中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 只访问没处理，在中结点上面添加NULL来标记</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 访问左节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若node为空，则处理该节点下面的节点，将其加入到res中</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="144-前序遍历二叉树-2"><a href="#144-前序遍历二叉树-2" class="headerlink" title="144. 前序遍历二叉树"></a>144. 前序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// node不为空，访问节点</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左</span></span><br><span class="line">                st.<span class="built_in">push</span>(node); <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点后面插入NULL</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// node为空，处理节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="145-后序遍历二叉树-2"><a href="#145-后序遍历二叉树-2" class="headerlink" title="145. 后序遍历二叉树"></a>145. 后序遍历二叉树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统一迭代写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 节点不为空，则访问节点，顺序为中右左</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(node);</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 节点为空，则处理节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="递归遍历-2"><a href="#递归遍历-2" class="headerlink" title="递归遍历"></a>递归遍历</h3><ol>
<li>记住递归三部曲：<ul>
<li>确定递归函数的参数和返回值</li>
<li>确定终止条件</li>
<li>确定单层递归的逻辑</li>
</ul>
</li>
<li>前序、中序、后序遍历的代码只有单层递归的逻辑部分有所不同。更确切地说，只是三行代码的顺序发生了改变。</li>
<li>递归的核心函数返回值为void，结果数组以引用的方式作为参数传入，经过核心函数的改变后，改变后的数组会被传出，在主函数中调用其即可。</li>
<li>易错点：核心函数中忘记加上引用<code>&amp;</code>，插入数组时没有取root指针的值(<code>root-&gt;val</code>)，而是直接将root指针传入了。</li>
<li>注意如何写出完整的带有测试样例的代码，这涉及到如何写<code>struct TreeNode</code>和<code>main</code>函数。</li>
<li>熟悉几个英文单词：<ul>
<li>遍历：traversal</li>
<li>前序：pre-order、中序：in-order、后序：post-order、层序：level-order</li>
<li>二叉树：binary tree</li>
<li>递归：Recursion  迭代：Iteration</li>
</ul>
</li>
</ol>
<h3 id="迭代遍历-2"><a href="#迭代遍历-2" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><ol>
<li>迭代遍历的本质是用栈来模拟递归，用结果数组来收集结果。由于栈的先入后出的特性，前序遍历的顺序本来应该是中左右，迭代写法的顺序调整为中右左。后序遍历是在前序遍历的基础上颠倒右和左的顺序，再翻转结果数组（前序遍历=中左右-&gt;中右左-&gt;左右中=后序遍历）。</li>
<li>中序遍历的迭代写法不能像后序遍历那样从前序遍历迭代写法的基础上直接进行改造。这是因为在中序遍历中，遍历节点的顺序与和处理节点的顺序不同。</li>
<li>中序遍历的迭代写法需要一个指针来遍历所有节点，一个栈用于记录遍历过的节点，一个数组用于存放结果。</li>
<li><strong>中序遍历迭代写法的精髓</strong>：当指针不为空时，用栈记录指针遍历过的元素，指针持续向左走。当指针为空时，从栈中弹出顶部的节点并将其放入结果数组中，然后指针向右走。当指针为空且栈为空时，终止。</li>
<li>统一迭代的写法可以将前中后序遍历的迭代写法统一起来。</li>
<li>迭代写法确实更复杂些，注意事项也更多，也更容易写错。了解思路即可，可以放过。</li>
</ol>
<h3 id="统一迭代-2"><a href="#统一迭代-2" class="headerlink" title="统一迭代"></a>统一迭代</h3><ol>
<li>统一迭代的思路其实比较清晰：当头节点非空时，头节点入栈。在栈非空时，不断循环。弹出栈顶节点，若该节点不为空，则按照顺序访问节点，并在访问中节点之后插入NULL，作为标记（说明该节点只被访问过，没有被处理过）；若该节点为空，则处理当前的栈顶节点（原本的栈顶节点已被弹出），将其放入结果数组中，并将其弹出。</li>
<li>对于前序、中序和后序遍历，只需要改变node不为空时访问节点的顺序即可。<strong>考虑到栈先入后出的特性</strong>：前序遍历原本的顺序是中左右，调整为右左中。中序遍历原本的顺序是左中右，调整为右中左。后续遍历原本的顺序是左右中，调整为中右左。</li>
<li>统一迭代思路清晰且对于前中后序遍历能够保持一致的写法，建议用迭代法遍历二叉树时，优先采用统一迭代的写法。前面的迭代遍历的一般写法虽然较为简单，但只能在前序和后序遍历时保持统一，在中序遍历时需要重新写。</li>
</ol>
]]></content>
      <categories>
        <category>算法（二叉树）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>二叉树</tag>
        <tag>前中后序遍历</tag>
        <tag>递归遍历</tag>
        <tag>迭代遍历</tag>
        <tag>统一迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 17 | Leetcode 110, 257, 404</title>
    <url>/2024/02/20/Day-17-Leetcode-110-257-404/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html">110.平衡二叉树</a><br><a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">257. 二叉树的所有路径</a><br><a href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html">404.左叶子之和</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h3><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h3><p>先尝试递归解法。我写下了如下的代码，可以运行成功，但时间复杂度较高：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求最大根节点的最大高度，用后序遍历</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">getheight</span>(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">getheight</span>(node-&gt;right);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span> + <span class="built_in">max</span>(left, right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">isBalanced</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">getheight</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> right = <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">getheight</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(leftdepth - rightdepth) &lt;= <span class="number">1</span>) flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点需要同时满足：左子树为平衡二叉树，右子树也为平衡二叉树，且左右子树高度差&lt;=1</span></span><br><span class="line">        <span class="comment">// 整个树才是平衡二叉树</span></span><br><span class="line">        <span class="type">bool</span> res = left &amp;&amp; right &amp;&amp; flag;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接着看卡尔的讲解。</p>
<h3 id="257-二叉树的所有路径-1"><a href="#257-二叉树的所有路径-1" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><p>拿到本题，我毫无办法，直接看卡尔的讲解。</p>
<h3 id="404-左叶子之和-1"><a href="#404-左叶子之和-1" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h3><p>本题我本来想一上来就是层序遍历，但后面发现是左叶子，而非左孩子。叶子节点是没有左右孩子的节点。我产生了一个另外的想法，先前序遍历一遍二叉树，遍历到左节点时判断左节点是否是左叶子节点，是的话则将其加入结果res中，最后返回res即可。我尝试了，但做不出来，看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="110-平衡二叉树-1"><a href="#110-平衡二叉树-1" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h3><p>平衡二叉树：二叉树中任何一个节点左右子树的高度差不超过1。求高度要用后序遍历。本题可以用递归法，也可以用迭代法，但优先掌握递归法。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span> <span class="comment">// 返回一个节点的高度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="comment">// 若某节点的左右子树的高度差超过1，说明该子树不再为平衡二叉树，进而说明整个树并非平衡二叉树</span></span><br><span class="line">    <span class="comment">// 当发现这样的节点时，就不返回节点的高度，直接返回-1</span></span><br><span class="line">    <span class="comment">// 左</span></span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">getHeight</span>(node-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 左子树并非平衡二叉树，则返回-1</span></span><br><span class="line">    <span class="comment">// 右</span></span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 右子树并非平衡二叉树，则返回-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中</span></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) res = <span class="number">-1</span>; <span class="comment">// 左右子树相差大于1，则说明该子树为非平衡二叉树，返回-1</span></span><br><span class="line">    <span class="keyword">else</span> res = <span class="number">1</span> + <span class="built_in">max</span>(left, right); <span class="comment">// 计算左右子树的父节点的高度</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>必须用后序遍历，因为需要先计算左右子树的高度，然后才能进行比较。完整代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// node为根节点的二叉树是平衡二叉树则返回node的高度，是非平衡二叉树则返回-1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">getheight</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">getheight</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> res = <span class="number">1</span> + <span class="built_in">max</span>(left, right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getheight</span>(root) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="257-二叉树的所有路径-2"><a href="#257-二叉树的所有路径-2" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><p>给定二叉树，返回从根节点到叶子节点的所有路径。<strong>求路径需要使用前序遍历</strong>。原因：只有前序遍历可以让父节点指向孩子节点，从而输出路径。虽然也可以用迭代法，但推荐使用递归法。<strong>回溯和递归是相辅相成、相伴而生的</strong>。本题第一次提到回溯。本题的解题过程中有回溯的过程。</p>
<p>为什么会有回溯？假设有以下的二叉树：<br><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img"></p>
<p>假设有容器收集路径，收集到路径125，如何弹出2和5，然后再让容器重新收集路径13？回溯的过程：弹出5和2，加入3。<br>关键代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path数组用来记录单条路径</span></span><br><span class="line"><span class="comment">// res数组用来存放最终的结果（包含多条路径），是一个数组，数组的每个元素都是一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 中：处理过程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// 左右孩子都为空，说明遍历到了叶子节点，收获结果</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path); <span class="comment">// 将单条路径的结果放入最终结果中，省略了vector-&gt;string和加上-&gt;的代码</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层处理逻辑，用前序遍历：中左右</span></span><br><span class="line">    <span class="comment">// 中：处理过程，即添加遍历到的节点，本题的处理过程需要写到终止条件之前</span></span><br><span class="line">    <span class="comment">// 因为本题的终止条件是到叶子节点，若中写在终止条件之后，则叶子节点没有被放入path中</span></span><br><span class="line">    <span class="comment">// 左</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">traversal</span>(node-&gt;left, path, res); </span><br><span class="line">    	  path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，弹出5和2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">traversal</span>(node-&gt;right, path, res);</span><br><span class="line">    	  path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            string s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                s += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                s += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;left, path, res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;right, path, res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="404-左叶子之和-2"><a href="#404-左叶子之和-2" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h3><p>左叶子的定义：首先必须是叶子节点（叶子节点的左右孩子为空）。同时还必须是父节点的左孩子。</p>
<p>本题和之前的二叉树类题目有不同之处。之前的题目遍历到哪个节点就处理哪个节点，但这题遍历到某个节点时，不能直接处理该节点，因为无法判断该节点是否其父节点的左孩子。<strong>这题的思路为遍历到某个节点，若其左孩子不为空，但左孩子的左右孩子为空，那么该节点的左孩子就是左叶子</strong>，处理该节点的左孩子即可。</p>
<p><strong>本题用后序遍历比较容易</strong>，因为后序遍历是左右中，是一层层向上返回。本题也可使用迭代法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">traversal</span><span class="params">(TreeNode* node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件1</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 终止条件2，可不写，不写就会做无用的递归</span></span><br><span class="line">    <span class="comment">// 如果当前遍历的节点是叶子节点，那其左叶子也必定是0</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左</span></span><br><span class="line">    <span class="type">int</span> leftNum = <span class="built_in">traversal</span>(node-&gt;left);</span><br><span class="line">    <span class="comment">// node为左叶子的父节点，左叶子为node-&gt;left</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">        leftNum = node-&gt;left-&gt;val;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右</span></span><br><span class="line">    <span class="type">int</span> rightNum = <span class="built_in">traversal</span>(node-&gt;right);</span><br><span class="line">    <span class="comment">// 中</span></span><br><span class="line">    <span class="type">int</span> sum = leftNum + rightNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码可以精简。但不建议初学者看。</p>
<p>本题其实用层序遍历也可以解决，关键依然在于对于左叶子的父节点的判断，代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) res += node-&gt;left-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>直接把queue改为stack，也可以解决本题。采用queue的写法是层序遍历，而采用stack的写法是普通迭代写法（区别于统一迭代写法）。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="110-平衡二叉树-2"><a href="#110-平衡二叉树-2" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h3><ol>
<li>平衡二叉树：二叉树中任何一个节点左右子树的高度差不超过1。求高度要用后序遍历。</li>
<li>我在初次尝试中的做法较为简单，但没有进行剪枝，意味着即使某些树的子树为非平衡二叉树，依然会继续递归，而不是直接<code>return false</code>。这样导致程序的时间复杂度较高。</li>
<li>卡尔提供的解法的核心思路在于：node为根节点的二叉树是平衡二叉树则返回node的高度，是非平衡二叉树则返回-1。本解法的时间复杂度较低，原因在于当发现某个子树是非平衡二叉树时，就说明整棵二叉树都是非平衡二叉树，则一路返回-1，相当于做了剪枝的操作。</li>
<li>本题优先掌握递归法即可，不要求掌握迭代写法。迭代写法代码很长，且因为迭代法有很多重复的计算，导致效率很低。</li>
</ol>
<h3 id="257-二叉树的所有路径-3"><a href="#257-二叉树的所有路径-3" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><ol>
<li><p>本题第一次让我接触到了回溯。更具体地说，是第一次在代码中显示地写出了回溯。</p>
</li>
<li><p>本题虽然是一个easy，但对我这个初学者来说难度不小，需要记得复习。</p>
</li>
<li><p>本题的核心思路依然是递归三部曲：</p>
<ul>
<li>确定传入的参数：节点、单条路径和最终结果，后两者需要加上引用。</li>
<li>终止条件：到达叶子节点</li>
<li>单层递归逻辑：前序遍历。中节点的处理逻辑需要放在终止条件之前，否则单条路径中不包含叶子节点。左右节点的处理逻辑注意判空和回溯。</li>
</ul>
</li>
<li><p>本题推荐采用我在实现中的写法，虽然代码略显复杂，但清楚地体现了回溯的过程，且不容易出错。不建议写精简的写法，容易出错，且对理解本题的原理并无帮助。</p>
</li>
</ol>
<h3 id="404-左叶子之和-3"><a href="#404-左叶子之和-3" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h3><ol>
<li>注意本题中对于左叶子的定义。</li>
<li>本题不能遍历到哪个节点就处理哪个节点，而是遍历到左叶子的父节点，就处理左叶子。</li>
<li>本题采用后序遍历的写法，代码较为简单，结果从下往上一层层返回。本题也可采用层序遍历的套路写法。</li>
<li>本题有两个终止条件，第二个终止条件可以不写，但会导致多递归一层。</li>
<li><strong>注意如何判断一个节点是否为左叶子的父节点</strong>：<code>if (node-&gt;left != NULL &amp;&amp; node-&gt;left-&gt;left == NULL &amp;&amp; node-&gt;left-&gt;right == NULL)</code>。</li>
<li>本题依然可以方便地套用层序遍历的常规代码。</li>
<li>我非常惊讶地发现，<strong>在本题中，若采用类似层序遍历的写法，用栈或者队列作为存放遍历过的节点的数据结构，都可以得到能够正常运行的代码</strong>。卡尔的讲义上给出的迭代法的写法并非是严格意义上的层序遍历，而仅仅是前序遍历的普通迭代写法（也并非统一迭代）。层序遍历需要用队列作为数据结构，而卡尔给的迭代写法采用了栈作为数据结构，但采用严格的层序遍历的写法依然可以解决这道题。</li>
</ol>
]]></content>
      <categories>
        <category>算法（二叉树）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>层序遍历</tag>
        <tag>递归解法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 15 | Leetcode Breadth-first traversal, 226, 101</title>
    <url>/2024/02/15/Day-15-Leetcode-Breadth-first-traversal-226-101/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">层序遍历</a><br><a href="https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html">226.翻转二叉树</a><br><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html">101. 对称二叉树</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>二叉树的层序遍历相当于图论中的广度优先搜索。leetcode 102：层序输出二叉树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[6] --&gt; B[4];</span><br><span class="line">    A --&gt; C[7];</span><br><span class="line">    B --&gt; D[1];</span><br><span class="line">    B --&gt; E[3];</span><br><span class="line">    C --&gt; F[5]</span><br><span class="line">    C --&gt; G[8]</span><br></pre></td></tr></table></figure>
<p>上述二叉树，一层放在一个数组里，返回的是二维数组。只依赖二叉树本身的结构，无法层序保存二叉树中的节点。需要借助另一种数据结构：队列，用于保存每一层遍历过的元素。图论中的广度优先搜索也是依赖队列实现的。</p>
<p>模拟过程：根节点6加入队列，记录队列大小（size=1）。size表示这层二叉树中有几个元素。接下来弹出当前层的元素6，将6加入到结果数组中，开始处理下一层。再将6的左右孩子4和7加入队列中，此时size=2，第二层的元素个数为2，接下来弹出size（2）个元素，先弹出4，将4的左右孩子1和3加入队列。再弹出7，size归0，第二层遍历结束。弹出7后，再将7的左右孩子5和8加入队列。此时size=4，说明第三层中元素个数为4。接着队列中再弹出size(4)个元素，加入结果数组。上述过程如下图所示。<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-02-16_02-48-16.png?raw=true" alt="Snipaste_2024-02-16_02-48-16.png"></p>
<p>我尝试根据上述模拟过程独立写出代码，但不知道怎么写while循环结束的条件。直接看卡尔的讲解。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">queue&lt;TreeNode*&gt; q;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历的终止条件：队列中无元素</span></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = q.<span class="built_in">size</span>(); <span class="comment">// 记录当前层节点的数量</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">// 存放一层的节点的值</span></span><br><span class="line">    <span class="comment">// 队列中弹出size个节点，加入到vec中</span></span><br><span class="line">    <span class="keyword">while</span> (size -- )</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将弹出节点的左右孩子加入到队列中</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p>
<p>上述代码也是图论中广度优先搜索的模板。leetcode上有10道题都可以用本模板解决，只需要改动不超过三行代码。</p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><p>我能想到的办法是层序遍历二叉树，然后将每一层的输出数组翻转。但这样做需要将数组还原回到二叉树，比较麻烦。随后有产生想法，让一个节点的左指针指向其右节点，右指针指向其左节点即可，可能需要一个中间变量来存放左节点或者右节点。直接看卡尔的视频。</p>
<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><p>看到本题，我的第一想法是，本题是翻转二叉树的变式。若一个二叉树被翻转后，仍和原来保持一致，那么就可以认为它是对称二叉树。现在的问题在于如何比较两棵二叉树是否完全相同，我认为可以采用层序遍历，一层层比较即可。或者直接层序遍历完后将二叉树存入一个二维数组中，然后用两重循环+双指针算法判断二维数组是否对称。这样做实际上有个问题：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img"></p>
<p>上面这棵二叉树，层序遍历得到的二维数组为[1, [2, 2], [3, 3]]。二维数组是对称的，但二叉树却不是对称的。还是看卡尔的讲解吧。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h3><h4 id="107-二叉树的层次遍历II"><a href="#107-二叉树的层次遍历II" class="headerlink" title="107.二叉树的层次遍历II"></a>107.二叉树的层次遍历II</h4><p>只需要在最后翻转res数组即可：<code>reverse(res.begin(), res.end());</code>。翻转一个二维数组，二维数组中所有元素（一维数组）的顺序都会颠倒，但一维数组本身（即一维数组内部的顺序不会改变）。reverse函数可以用双指针算法手动实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> len = res.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>; i &lt; len / <span class="number">2</span>; i ++ , j -- )</span><br><span class="line">    <span class="built_in">swap</span>(res[i], res[j]);</span><br></pre></td></tr></table></figure></p>
<p>似乎手动实现的速度要快于调用现成的reverse函数。</p>
<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i == size - <span class="number">1</span>) res.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 将一层最右边的节点的值加入到结果数组中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum / size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                Node* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;children.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[i]) q.<span class="built_in">push</span>(node-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a>515.在每个树行中找最大值</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> max = <span class="number">-2147483648</span>; <span class="comment">// Node.val的最小值，可简写为int max = INT_MIN;</span></span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                max = node-&gt;val &gt; max ? node-&gt;val: max; <span class="comment">// 注意问号表达式的用法</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            Node* node0, *node; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 取出一层的头结点</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    node0 = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                 <span class="comment">// 本句话的目的：当一层只有头节点时，可以让该头节点在弹出的同时继续在队列中行插入其左右子节点</span></span><br><span class="line">                    node = node0; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 本层前一个节点next指向本节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// node0和node交替前进</span></span><br><span class="line">                    node = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    node0-&gt;next = node;</span><br><span class="line">                    node0 = node;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本层最后一个节点指向NULL</span></span><br><span class="line">            node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="117-填充每个节点的下一个右侧节点指针II"><a href="#117-填充每个节点的下一个右侧节点指针II" class="headerlink" title="117.填充每个节点的下一个右侧节点指针II"></a>117.填充每个节点的下一个右侧节点指针II</h4><p>本题代码和116完全相同。116题目中的条件：完整二叉树实际上是多余的。不管是不是完整二叉树，都可以用同样的代码解题。</p>
<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res ++ ;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：只有当某个节点的左右孩子都为空，这个节点才在二叉树的底部。一旦遇到这样的节点，立即跳出循环，返回res。根据这个思路，我将上述代码做了简化：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> ++ res;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="226-翻转二叉树-1"><a href="#226-翻转二叉树-1" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><p>面试中的常考题。本质是交换每个节点的左右孩子，交换的是指针而非数值。这道题显然用递归解比较简单，但要想清楚用哪种遍历顺序。<strong>本题用前序和后序是最直接的，用中序遍历代码比较难写</strong>。迭代和层序遍历也可以做此题，但不要求掌握。</p>
<p>递归三部曲：</p>
<ul>
<li><p>确定递归函数的返回值和参数: <code>TreeNode* invertTree(root)</code></p>
</li>
<li><p>确定函数的终止条件：<code>if (root == NULL) return root</code></p>
</li>
<li><p>具体的处理逻辑：前序遍历——中左右</p>
<p> 对中节点，需要交换中节点的左右孩子: <code>swap(root-&gt;left, root-&gt;right)</code></p>
<p> 左节点：<code>invertTree(root-&gt;left);</code></p>
<p> 右节点：<code>invertTree(root-&gt;right);</code></p>
<p> 将swap函数放在处理逻辑的最后，就是左右中，就是后续遍历。因此前序和后续遍历皆可解本题。但中序遍历不可以，举个例子：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[4] --&gt; B[2];</span><br><span class="line">    A --&gt; C[7];</span><br><span class="line">    B --&gt; D[1];</span><br><span class="line">    B --&gt; E[3];</span><br><span class="line">    C --&gt; F[6]</span><br><span class="line">    C --&gt; G[9]</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[4] --&gt; B[2];</span><br><span class="line">    A --&gt; C[7];</span><br><span class="line">    B --&gt; D[3];</span><br><span class="line">    B --&gt; E[1];</span><br><span class="line">    C --&gt; F[6]</span><br><span class="line">    C --&gt; G[9]</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[4] --&gt; B[7];</span><br><span class="line">    A --&gt; C[2];</span><br><span class="line">    B --&gt; D[6];</span><br><span class="line">    B --&gt; E[9];</span><br><span class="line">    C --&gt; F[3]</span><br><span class="line">    C --&gt; G[1]</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[4] --&gt; B[7];</span><br><span class="line">    A --&gt; C[2];</span><br><span class="line">    B --&gt; D[6];</span><br><span class="line">    B --&gt; E[9];</span><br><span class="line">    C --&gt; F[1]</span><br><span class="line">    C --&gt; G[3]</span><br></pre></td></tr></table></figure>
<p> 相当于原先根节点的左子树被处理了两次，原先根节点的右子树没被处理。对中序遍历的写法，具体的逻辑应该为：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">invertTree</span>(root-&gt;left); <span class="comment">// 处理左子树</span></span><br><span class="line"><span class="built_in">swap</span>(root-&gt;left, root-&gt;right); <span class="comment">// 交换左右子树，原先的右子树变为了现在的左子树，原先的左子树变为了现在的右子树</span></span><br><span class="line"><span class="built_in">invertTree</span>(root-&gt;left); <span class="comment">// 原先的左子树已经被处理过了，现在需要处理原先的右子树，就是现在的左子树</span></span><br></pre></td></tr></table></figure>
<p> 不建议绕弯子去写中序，很容易出错。</p>
</li>
</ul>
<p>前序遍历：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root; <span class="comment">// 终止条件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中左右</span></span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 每次递归后返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>后序遍历写法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右中</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>中序遍历写法(<strong>绕，理解即可，不要写</strong>)：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左中右</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="101-对称二叉树-1"><a href="#101-对称二叉树-1" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><p>本质上是判断根节点的左子树和右子树是否可以互相翻转。需要比较二叉树同是外侧的节点和同是内侧的节点是否相等。接着考虑用哪种方式遍历二叉树。<strong>二叉树类的题目确定遍历顺序非常重要</strong>。<strong>本题目只能使用后序遍历</strong>（左右中）。因为我们需要先收集完根节点左右孩子的信息再返回给根节点，才能知道根节点的左右孩子是否相同，进而知道二叉树是否是对称的。</p>
<ol>
<li><p>确定函数传入的参数和返回值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断根节点的左右子树是否可以互相翻转</span></span><br><span class="line"><span class="comment">// 本质是判断两个二叉树是否可以相互翻转，因此需要同时处理两棵二叉树</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> <span class="comment">// 传入的参数为左子树的头节点和右子树的头节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>确定终止条件<br>共有以下5种情况<br>|左节点|右节点|返回值|<br>|:—-:|:—-:|:—-:|<br>|空|非空|false|<br>|非空|空|false|<br>|空|空|true|<br>|非空且值不等|非空且值不等|false|<br>|非空且值相等|非空且值相等|继续向下遍历，写单层递归的逻辑|</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单层递归的逻辑（如何像下一层遍历）<br>同是外侧的节点和同是内侧的节点相同，才可以return true。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right); <span class="comment">// 比较一对外侧节点是否相同</span></span><br><span class="line"><span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);  <span class="comment">// 比较一对内侧节点是否相同</span></span><br><span class="line"><span class="type">bool</span> res = outside &amp;&amp; inside; <span class="comment">// 内外侧节点都相同，则才可以左右翻转</span></span><br><span class="line"><span class="keyword">return</span> res; </span><br></pre></td></tr></table></figure>
<p>上面代码框的前三行代码分别对应后序遍历的左右中。中只能放在最后，不能提前，否则会出现还没计算outside和inside就来计算res的情况，因此必须是后序遍历。</p>
</li>
</ol>
<p>后序遍历解决本题的完整代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);</span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">        <span class="type">bool</span> res = outside &amp;&amp; inside;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>本题也可以用迭代法实现。</p>
<h4 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572.另一个树的子树"></a>572.另一个树的子树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;left);</span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;right);</span><br><span class="line">        <span class="type">bool</span> res = outside &amp;&amp; inside;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">compare</span>(root, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 递归比较root树的子树和subRoot是否相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubtree</span>(root-&gt;left, subRoot) || <span class="built_in">isSubtree</span>(root-&gt;right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题注意如何递归地比较root树的子树和subRoot树是否相同：<code>return isSubtree(root-&gt;left, subRoot) || isSubtree(root-&gt;right, subRoot);</code>。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="层序遍历-2"><a href="#层序遍历-2" class="headerlink" title="层序遍历"></a>层序遍历</h3><ol>
<li>本题（leetcode102）的模板需要熟记，可以用来解决10道leetcode。</li>
<li>本题的关键在于用队列来保存每一层遍历过的元素。</li>
<li><strong>本题的思路可以概括为</strong>：将二叉树的一层加入到队列中，记录队列的大小为size。然后弹出size个节点，用数组收集弹出的节点，并在弹出节点的同时插入弹出的节点的左右子节点。弹完size个节点后，数组中就是当前层的所有元素，而队列中则是下一层的所有节点。</li>
<li>本题不需要用指针来遍历整棵树，只需要对维护和操作队列即可。</li>
<li>本题收获最终结果的退出条件为队列为空；二叉树的一层遍历完毕的退出条件为size = 0。</li>
<li><p>二叉树的右视图这题需要特别注意，以下写法是错误的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因是：对于以下的二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[6] --&gt; B[4];</span><br><span class="line">    A --&gt; C[NULL];</span><br></pre></td></tr></table></figure>
<p>尽管6只有左子节点，没有右子节点，但站在二叉树的右边看这颗二叉树，看到的结果是[6, 4]，如果按照上面的写法，则返回的结果是[6]，4作为左子节点不会被加入到队列中，也不会出现在结果数组中。</p>
</li>
<li><p>N叉树的层序遍历需要注意：新定义的N叉树的名字叫Node，不要下意识地写成TreeNode。在队列中更新N叉树下一层的节点时，注意需要用for循环遍历一遍当前node的孩子数组，因为N叉树中的一个节点不仅有左右孩子，而是有一个孩子数组。</p>
</li>
<li><p>二叉树的最大深度的解题关键在于：层序遍历二叉树，每遍历完一层记录层数的变量+1。</p>
</li>
<li><p>二叉树的最大/最小深度这两道题，<code>res ++</code>放在第二重while循环之后和之前都可以。我在实现中的写法都是把<code>res ++</code>放在了第二重while循环之后，但实际上放在第二重while循环之前写出的代码更简洁易懂，可以参考代码随想录上给出的代码。</p>
</li>
<li><p>注意复习填充每个节点的下一个右侧节点指针，这道题第一遍没有写出来。本题的关键在于特判一层的头节点，以及node0和node交替前进。</p>
</li>
<li><p>116和117题的代码完全相同。差别只在于116题题目说是完整二叉树，117题目则没有这个说明。</p>
</li>
</ol>
<h3 id="226-翻转二叉树-2"><a href="#226-翻转二叉树-2" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><ol>
<li><p>注意：本题中的root是指遍历的每个节点，而非特指根节点。</p>
</li>
<li><p>本题的关键思路：交换中节点的左右子树，递归处理左右节点。</p>
</li>
<li><p>记住前序和后续的写法即可，swap要么写在左右的上面，要么写在左右的下面。抛弃中序写法，太绕！</p>
</li>
<li><p>记得最后要<code>return root</code>。因为终止条件：<code>if (root == NULL) return root</code>，只会返回一个为空的节点。大多数情况下不会触发这个终止条件，而是触发最后一个<code>return root</code>。</p>
</li>
<li><p>可以定义一个cur节点遍历二叉树的每个节点，这样就不会与根节点root产生混淆。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中左右</span></span><br><span class="line">        <span class="built_in">swap</span>(cur-&gt;left, cur-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(cur-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(cur-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>本题除递归写法外，用一般迭代、统一迭代、层序遍历的写法都可以，其实在原本的三种迭代方式的代码的基础上稍作修改就可以，但三种迭代方式的代码本身就已经较为复杂，容易写错，因此除非必须建议不要采用迭代写法。</p>
</li>
<li><p>但还是不得不说，<strong>层序遍历解本题也很方便</strong>，本题也可以归类到层序遍历能够解决的10道题中，在层序遍历的基础上，交换每个节点的左右子节点即可，代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="comment">// 交换每个节点的左右子节点</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="101-对称二叉树-2"><a href="#101-对称二叉树-2" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><ol>
<li>本题实际上需要比较根节点的左右子树是否可以相互翻转，因此需要同时遍历两棵树，所以传入的参数为左右子树的头节点。</li>
<li>本题只能采用后序遍历，遍历左子树的顺序是左右中，遍历右子树的顺序是右左中。</li>
<li>终止条件需要分五类讨论。见实现中的表格。</li>
<li>单层递归的核心逻辑为：判断同在外侧的节点是否相同，判断同在内侧的节点是否相同。</li>
<li>本题的迭代写法其实也不难理解，原理是通过一个容器来成对的存放我们要比较的元素。但优先掌握本题的递归写法即可。</li>
<li>100.相同的树和572.另一个树的子树基本和本题是一样的，只要稍加修改就可以。572题稍有特殊，需要注意如何递归地比较root树的子树和subRoot树是否相同。同时在主函数中也需要进行分类讨论（subRoot树为空, root树为空，两树相同，root树的子树和subRoot树相同/相异）。</li>
</ol>
]]></content>
      <categories>
        <category>算法（二叉树）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>二叉树</tag>
        <tag>层序遍历</tag>
        <tag>递归解法</tag>
        <tag>后序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 2 | Leetcode 977, 209, 59</title>
    <url>/2024/01/25/Day-2-Leetcode-977-209-59/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p><a href="https://www.bilibili.com/video/BV1QB4y1D7ep">https://www.bilibili.com/video/BV1QB4y1D7ep</a></p>
<p><a href="https://www.bilibili.com/video/BV1tZ4y1q7XE">https://www.bilibili.com/video/BV1tZ4y1q7XE</a></p>
<p><a href="https://www.bilibili.com/video/BV1SL4y1N7mV/">https://www.bilibili.com/video/BV1SL4y1N7mV/</a></p>
<h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p><a href="https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html">https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html</a></p>
<p><a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html</a></p>
<p><a href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html</a></p>
<p><a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80</a></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.com/problems/squares-of-a-sorted-array/">https://leetcode.com/problems/squares-of-a-sorted-array/</a></p>
<p><a href="https://leetcode.com/problems/minimum-size-subarray-sum/">https://leetcode.com/problems/minimum-size-subarray-sum/</a></p>
<p><a href="https://leetcode.com/problems/spiral-matrix-ii/">https://leetcode.com/problems/spiral-matrix-ii/</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol>
<li>cpp中sort函数的用法：sort(a.begin(), a.end())，排序后的结果就存储在a中。</li>
<li><code>vector&lt;int&gt; result(A.size(), 0);</code>的意思是创建一个长度为A.size()，数值全部为0的vector。</li>
<li><p>cpp中的问号表达式——条件运算符</p>
<p>len = sub &lt; len ? sub: len;表示若sub &lt; len，则len = sub；否则len等于len，保持不变。</p>
<p>len == INT32_MAX ? 0: len;表示若len等于INT32_MAX，则l表达式值为0，否则表达式值为len。</p>
</li>
<li><code>INT32_MAX</code>：这是一个在 C++ 中定义的常量，代表 32 位整数类型（即 <code>int</code> 类型）可以表示的最大值。</li>
<li>初始化一个二维vector，让其中的元素全部为0：<code>vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0));</code>，即初始化一个全部元素为0的一维数组，然后将其复制n遍。</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p>暴力做法，先平方，再排序。双指针做法有点思路，但由于不知道如何创建一个值为0且长度与nums相同的vector，因此不能完全正确地写出代码。</p>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h3><p>滑动窗口我听yxc讲过，但是已经完全忘了，直接看视频讲解，然后看文字版讲解。</p>
<p>暴力解法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> sub = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                s += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (s &gt;= target)</span><br><span class="line">                &#123;</span><br><span class="line">                    sub = j - i + <span class="number">1</span>;</span><br><span class="line">                    len = len &lt; sub ? len: sub;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len == INT32_MAX ? <span class="number">0</span>: len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>暴力做法超时了。还是需要滑动窗口。</p>
<h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h3><p>yxc讲过这题，我印象中涉及到一个向量，撞墙了就拐弯，遇到自己之前走过的地方也拐弯，挺生动形象的，但我已经忘记怎么写了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="977-有序数组的平方-1"><a href="#977-有序数组的平方-1" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p>取平方后，最大的元素一定在原数组的两边。故用左右指针，从数组的两边向中间推进。需要一个新的数组来存储结果，新的数组的下标由大到小来更新。</p>
<h4 id="for-if写法"><a href="#for-if写法" class="headerlink" title="for+if写法"></a>for+if写法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ans数组来存储答案</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于每次循环都要比较两个数的平方的大小关系，因此将最后一个数放入ans时</span></span><br><span class="line">        <span class="comment">// i和j都会等于该数的索引，因此要求i可以等于j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt;= j; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &lt;= nums[j] * nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[n -- ] = nums[j] * nums[j];</span><br><span class="line">                j -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans[n -- ] = nums[i] * nums[i];</span><br><span class="line">                i ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="for-while写法"><a href="#for-while写法" class="headerlink" title="for + while写法"></a>for + while写法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>; l &lt;= r; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 一定要记得加上l &lt;= r的条件</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] * nums[l] &gt;= nums[r] * nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                res[k -- ] = nums[l] * nums[l];</span><br><span class="line">                l ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] * nums[l] &lt; nums[r] * nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                res[k -- ] = nums[r] * nums[r];</span><br><span class="line">                r -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="while-while写法"><a href="#while-while写法" class="headerlink" title="while+while写法"></a>while+while写法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[i] * nums[i] &lt;= nums[j] * nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[k -- ] = nums[j] * nums[j];</span><br><span class="line">                j -- ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[i] * nums[i] &gt; nums[j] * nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[k -- ] = nums[i] * nums[i];</span><br><span class="line">                i ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="while-if写法"><a href="#while-if写法" class="headerlink" title="while + if写法"></a>while + if写法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] * nums[l] &lt;= nums[r] * nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                res[k -- ] = nums[r] * nums[r];</span><br><span class="line">                r -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[k -- ] = nums[l] * nums[l];</span><br><span class="line">                l ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="209-长度最小的子数组-1"><a href="#209-长度最小的子数组-1" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h3><p>其实核心思想也是双指针，只不过取两指针中间的集合像是一个正在滑动的窗口，因此也叫滑动窗口。用一个for循环替代暴力做法里的两个for循环。一个for循环中的循环变量j若表示滑动窗口的起始位置，则j在遍历的过程中，终止位置也需要去遍历，这与暴力做法无异。<strong>因此for循环中的循环变量j表示滑动窗口的终止位置，起始位置需要动态移动地去获得</strong>。<strong>滑动窗口的精髓在于如何移动起始位置</strong>。</p>
<p>若滑动窗口的起始位置和终止位置间的数的和&gt;=target，那么起止位置可以向后移动，即窗口可以缩小，看缩小后的窗口是否还可以符合条件。若满足条件，则可更新滑动窗口。更新滑动窗口时，需要同时更新滑动窗口的起始位置和滑动窗口中元素和的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = INT32_MAX; <span class="comment">// result</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// i是滑动窗口的起始位置</span></span><br><span class="line">        <span class="type">int</span> sub = <span class="number">0</span>; <span class="comment">// 窗口长度</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 窗口之和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// j是滑动窗口的终止位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[j]; <span class="comment">// 将新的终止位置放到窗口的和中去</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新滑动窗口</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                sub = j - i + <span class="number">1</span>; </span><br><span class="line">                len = len &lt; sub ? len: sub;</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == INT32_MAX ? <span class="number">0</span>: len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="59-螺旋矩阵II-1"><a href="#59-螺旋矩阵II-1" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h3><p>不涉及算法，是道模拟题。不易写对的原因是转圈的过程中需要处理的边界条件很多。</p>
<p>边界条件：正方形的4个边界点</p>
<p>循环不变量：<br>循环——不断转圈<br>不变量——对每条边的处理规则<br>对每条边的处理规则应该不变。<strong>按照左闭右开的规则处理正方形的每一条边，每条边只处理头节点，不处理尾节点</strong>。</p>
<p>n * n的矩阵，需要转n / 2圈，若n为奇数，则中心那个值最后单独赋即可。每一圈的终止位置在上一圈的基础上-1。</p>
<p>示意图如下所示：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-01-26_06-26-17.png?raw=true" alt="Snipaste_2024-01-26_06-26-17.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">      </span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>, count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j ++ )</span><br><span class="line">                ans[startx][j] = count ++ ;</span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i ++ )</span><br><span class="line">                ans[i][j] = count ++ ;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j -- )</span><br><span class="line">                ans[i][j] = count ++ ;</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i -- )</span><br><span class="line">                ans[i][j] = count ++ ;</span><br><span class="line">          </span><br><span class="line">            startx ++ ;</span><br><span class="line">            starty ++ ;</span><br><span class="line">            offset ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) ans[n / <span class="number">2</span>][n / <span class="number">2</span>] = count;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="977易错点"><a href="#977易错点" class="headerlink" title="977易错点"></a>977易错点</h3><ol>
<li>一定要新建一个数组ans，不能在原数组的基础上修改，否则会混乱。</li>
<li>一定要注意左指针和右指针可以相等，因为最后总要处理两个元素，两个指针最终总会移到一起去。否则当两个指针指向同一个数时，该数会被落下，不会被添加到答案数组中。</li>
<li>这道题在for/while循环内用if或者while都可以，但用while的时候需要记得加上判断条件：<code>while(l &lt;= r &amp;&amp; ....)</code>，不加l &lt;= r的条件会报错：run time error。</li>
</ol>
<h3 id="209心得"><a href="#209心得" class="headerlink" title="209心得"></a>209心得</h3><p>滑动窗口方法其实脱胎于暴力做法。要特别注意遍历的是窗口的终止位置。</p>
<p>更新窗口的起始位置时，同时需要更新窗口中元素之和。</p>
<p>不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度至多是 2 × n 也就是O(n)。</p>
<h3 id="209易错点"><a href="#209易错点" class="headerlink" title="209易错点"></a>209易错点</h3><p>一定要记得把滑动窗口的初始位置定义在循环之外。</p>
<p>一定要记得在移动窗口初始位置的同时改变窗口中元素的sum。</p>
<h3 id="59易错点"><a href="#59易错点" class="headerlink" title="59易错点"></a>59易错点</h3><ol>
<li>注意每一条边都是左开右闭</li>
<li>注意画图理解</li>
<li>注意为n为奇数时单独给中心点赋值</li>
<li>注意如何定义一个二维所有元素为0的矩阵</li>
<li>offsetx/y和startx/y不会出现在同一个式子中</li>
</ol>
<h3 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h3><p>看代码随想录的数组总结</p>
<h2 id="数组总结"><a href="#数组总结" class="headerlink" title="数组总结"></a>数组总结</h2><p>数组题目中：整数二分一道（704）。双指针三道（27, 977, 包括滑动窗口209），双指针题目的难度是递增的，27最简单，977稍难，209最难。模拟题一道：59。</p>
<p>从方法上来说，704和59都应该采用循环不变量的原则，27、977、209则都是双指针算法的应用。</p>
<p>引用总结文章：<a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80</a><br>中的一幅图片：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png" alt="img"></p>
]]></content>
      <categories>
        <category>算法（数组）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>总结</tag>
        <tag>双指针算法</tag>
        <tag>滑动窗口</tag>
        <tag>螺旋矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 19 Leetcode 654 617 700 98</title>
    <url>/2024/04/19/Day-19-Leetcode-654-617-700-98/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html">654.最大二叉树</a></p>
<p><a href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html">617.合并二叉树</a></p>
<p><a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">700.二叉搜索树中的搜索</a></p>
<p><a href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">98.验证二叉搜索树</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h3><p><strong>什么是二叉树搜索树？</strong>其根节点要比左子树里所有节点的数值大，根节点要比右子树里所有节点的数值小。同理，左右子树也符合这个规则。二叉搜索树的上述规则确定了遍历顺序（既不是前序，也不是中序、后序），而二叉搜素树的上述规则也让本题的迭代写法特别简单。</p>
<p><code>if (node != NULL)</code> 可以简写为<code>if (node)</code>。</p>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p>中序遍历一棵二叉搜索树，得到的数组中的元素是有序的。</p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h3><p>本题延续106.从中序与后序遍历序列构造二叉树的思路。步骤可以分为：</p>
<ol>
<li><p>找到nums数组中的最大值，作为root</p>
</li>
<li><p>找到root在nums中的下标</p>
</li>
<li><p>将nums按照root分为左数组和右数组</p>
</li>
<li><p>递归处理左数组和右数组，得到左右子树</p>
</li>
</ol>
<p>我独立写出了以下的代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件：数组为空，构造不出树，返回NULL</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到nums数组中的最大值，作为root</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到root在nums中的下标</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j; j &lt; nums.<span class="built_in">size</span>(); j ++ ) </span><br><span class="line">            <span class="keyword">if</span> (nums[j] == max)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> rootvalue = nums[j];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组分为左数组和右数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ml</span><span class="params">(nums.begin(), nums.begin() + j)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mr</span><span class="params">(nums.begin() + j + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归处理左数组和右数组，得到左右子树</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(ml);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(mr);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">traversal</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3><p>对于本题，我也采用前序遍历的方法，独立写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 应该采用前序遍历，先中节点，再左节点，再右节点</span></span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">NULL</span> &amp;&amp; root2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root1 == <span class="literal">NULL</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root2 == <span class="literal">NULL</span>) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootvalue = root1-&gt;val + root2-&gt;val;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左节点</span></span><br><span class="line">        <span class="keyword">if</span> (root1-&gt;left != <span class="literal">NULL</span> &amp;&amp; root2-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root1-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root2-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;left = <span class="built_in">mergeTrees</span>(<span class="literal">NULL</span>, root2-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="keyword">if</span> (root1-&gt;right != <span class="literal">NULL</span> &amp;&amp; root2-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root1-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root2-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;right = <span class="built_in">mergeTrees</span>(<span class="literal">NULL</span>, root2-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由上述代码可知，对左右节点的处理都分了三类讨论，这与终止条件中的三类相对应，这是上述代码可以正确运行的基础。本题应该也可以用层序遍历去做。</p>
<h3 id="700-二叉搜索树中的搜索-1"><a href="#700-二叉搜索树中的搜索-1" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h3><p>哈哈哈这题又给我用前序遍历的写法做出来了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历搜索整棵树</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == val) <span class="keyword">return</span> root; <span class="comment">// 中节点</span></span><br><span class="line">        TreeNode* left = <span class="built_in">searchBST</span>(root-&gt;left, val); <span class="comment">// 左节点：在左子树中搜索值为val的节点</span></span><br><span class="line">        TreeNode* right = <span class="built_in">searchBST</span>(root-&gt;right, val); <span class="comment">// 右节点：在右子树中搜索值为val的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left; <span class="comment">// 在左子树中找到目标节点，则返回之</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right; <span class="comment">// 在右子树中找到目标节点，则返回之</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 左右子树中都没找到，则返回空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题用层序遍历应该也可以做。层序遍历的写法我也独立写出来了：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(); <span class="comment">// 取出一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;val == val) <span class="keyword">return</span> node; <span class="comment">// 判断其是否为目标节点，是，则返回之</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 继续往队列中加入当前节点的非空左右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left); </span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若最后没有找到目标节点，则返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="98-验证二叉搜索树-1"><a href="#98-验证二叉搜索树-1" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p>本题我觉得应该采用中序遍历，先验证左子树是否符合要求，再验证中节点是否符合要求，最后验证右子树是否符合要求，根据这个思路，我尝试独立写出本题的代码。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有root节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 左子树为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt;= root-&gt;right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &lt;= root-&gt;left-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树都不为空</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &lt;= root-&gt;left-&gt;val || root-&gt;val &gt;= root-&gt;right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> res1 = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">                <span class="type">bool</span> res2 = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (res1 &amp;&amp; res2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述代码分了4种情况讨论：只有root节点；左子树为空；右子树为空；左右子树都不为空。但忽略了一种情况：<br>当<code>root = [5,4,6,null,null,3,7]</code>时，二叉树如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A((5)) --&gt; B((4))</span><br><span class="line">    A --&gt; C((6))</span><br><span class="line">    C --&gt; F((3))</span><br><span class="line">    C --&gt; G((7))</span><br></pre></td></tr></table></figure>
<p>此时虽然[5, 4, 6]是二叉搜索树，[6, 3, 7]也是二叉搜素树，但[6, 3, 7]中存在元素3小于root的5，因此整体并不是一棵二叉搜索树。这种局部都是二叉搜索树，但整体不是二叉搜索树的情况，在我的代码中并没有进行特判。因此我只能通过77/85个测试样例。这也是本题的坑之所在。直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="654-最大二叉树-1"><a href="#654-最大二叉树-1" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h3><p>规则：在数组中选取最大的元素作为root，最大元素的左区间用于构造左子树，规则同上；最大元素的右区间用于构造右子树，规则同上。</p>
<p>例如，321605，根据以上规则得到以下的最大二叉树：<br><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img"></p>
<p>遍历方式：前序遍历。<strong>凡是涉及构造二叉树的题目，都要用到前序遍历</strong>。原因：前序遍历顺序是中左右，先构造root节点，再去构造左子树和右子树。</p>
<p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回二叉树的root节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">construct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 确定递归的终止条件</span></span><br><span class="line">    <span class="comment">// 数组中只有一个元素，则唯一一个元素就是root节点</span></span><br><span class="line">    <span class="comment">// 本题题目中对数组的要求是非空，因此不需要考虑数组为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归的逻辑</span></span><br><span class="line">    <span class="comment">// 中节点的逻辑</span></span><br><span class="line">    <span class="comment">// 找到数组中的最大值和其下标</span></span><br><span class="line">    <span class="type">int</span> maxvalue = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxvalue)</span><br><span class="line">        &#123;</span><br><span class="line">            maxvalue = nums[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据最大值定义root节点</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(maxvalue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左子树的逻辑</span></span><br><span class="line">    <span class="comment">// 根据index切割原数组，将其分为左右数组</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) <span class="comment">// 保证左区间中至少有一个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), nums.begin() + index)</span></span>; <span class="comment">// 左区间，左闭右开</span></span><br><span class="line">        root-&gt;left = <span class="built_in">construct</span>(l); <span class="comment">// 递归构造左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右子树的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="comment">// 保证右区间中至少有一个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(nums.begin() + index + <span class="number">1</span>, nums.end())</span></span>; <span class="comment">// 右区间，左闭右开</span></span><br><span class="line">        root-&gt;right = <span class="built_in">construct</span>(r); <span class="comment">// 递归构造右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码严格按照前序遍历构造二叉树。本代码冗余，且效率低，效率低的原因是每次分割时都构造了两个新的数组。<strong>对本代码的优化是每次分割数组时不用构造新的数组，操作下标即可</strong>。</p>
<p>还有一个重要问题：左右子树的逻辑中要加上if判断。写不写if关键在于终止条件。终止条件保证了数组中至少要有一个元素，因此在左右子树的逻辑中需要加上if判断，也就是保证左右区间中至少有一个元素。当然在左右子树的逻辑中不写if也可以，那就需要在leetcode的主函数外另写一个函数。</p>
<p>完整的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历：中节点</span></span><br><span class="line">        <span class="comment">// 找到root的值和下标</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(max);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左节点</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), nums.begin() + index)</span></span>; <span class="comment">// 左区间</span></span><br><span class="line">            root-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(l); <span class="comment">// 递归构造左子树</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(nums.begin() + index + <span class="number">1</span>, nums.end())</span></span>; <span class="comment">// 右区间</span></span><br><span class="line">            root-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(r); <span class="comment">// 递归构造右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>左右子树中不加if判断的写法（关键在于终止条件<code>nums.size() == 0</code>），这也是我在初次尝试中的写法，是最不容易写错的写法。因为思路直接继承自106.从中序与后序遍历序列构造二叉树，且不需要在左右子树处加if判断。<strong>推荐这个写法</strong>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历：中节点</span></span><br><span class="line">        <span class="comment">// 找到root的值和下标</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(max);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), nums.begin() + index)</span></span>; <span class="comment">// 左区间</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(nums.begin() + index + <span class="number">1</span>, nums.end())</span></span>; <span class="comment">// 右区间</span></span><br><span class="line">        root-&gt;left = <span class="built_in">construct</span>(l); <span class="comment">// 递归构造左子树</span></span><br><span class="line">        root-&gt;right = <span class="built_in">construct</span>(r); <span class="comment">// 递归构造右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">construct</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在本写法的基础上进一步进行优化。不在分割数组时创建新的数组，只改变数组的下标。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件，区间是左闭右开的，因此是begin &gt;= end</span></span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全部操作下标，不需要操作元素的值</span></span><br><span class="line">        <span class="type">int</span> index = begin;</span><br><span class="line">        <span class="comment">// 从begin + 1开始搜索，i = begin时，index = i = begin，不需要写入循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin + <span class="number">1</span>; i &lt; end; i ++ ) </span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[index])</span><br><span class="line">                index = i;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左节点</span></span><br><span class="line">        <span class="comment">// 左闭右开</span></span><br><span class="line">        <span class="type">int</span> leftbegin = begin;</span><br><span class="line">        <span class="type">int</span> leftend = index;</span><br><span class="line">        root-&gt;left = <span class="built_in">construct</span>(nums, leftbegin, leftend); <span class="comment">// 递归构造左子树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="type">int</span> rightbegin = index + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightend = end;</span><br><span class="line">        root-&gt;right = <span class="built_in">construct</span>(nums, rightbegin, rightend); <span class="comment">// 递归构造右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要下面这句话，因为已经在construct函数中通过begin == end处理了nums.size() == 0的情况</span></span><br><span class="line">        <span class="comment">// if (nums.size() == 0) return NULL;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">construct</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本版本代码在处理左右节点时不需要进行if判断，原因是若左右区间为空，在递归调用construct函数时会因为<code>begin == end</code>直接返回<code>NULL</code>，而不会出现直接创建数组写法中的空数组的现象（终止条件中未考虑空数组的情况，因此若数组为空不能触发终止条件，会导致程序报错）。因此我也可以在终止条件中考虑空数组的情况，而不在构建左右子树时加上if判断，代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件1</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 终止条件2</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历：中节点</span></span><br><span class="line">        <span class="comment">// 找到root的值和下标</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(max);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左节点，不需加if判断，由于有终止条件1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), nums.begin() + index)</span></span>; <span class="comment">// 左区间</span></span><br><span class="line">        root-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(l); <span class="comment">// 递归构造左子树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点，不需加if判断，由于有终止条件1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(nums.begin() + index + <span class="number">1</span>, nums.end())</span></span>; <span class="comment">// 右区间</span></span><br><span class="line">        root-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(r); <span class="comment">// 递归构造右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="617-合并二叉树-1"><a href="#617-合并二叉树-1" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3><p>将两个二叉树合并为一个二叉树。有相同的节点则将两个节点数值相加，作为新节点。对于一棵树上有而另一棵树上没有的节点，将新的节点补充过来。难点：同时操作两个二叉树。本题使用前序遍历最易理解，顺序是中左右。中序和后序也可，但不太符合直观上合并两棵二叉树的过程。本题也可使用迭代法。接下来写递归的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// 遍历到t1树的某个位置为空后，需要返回t2树上相同位置的节点（遍历两树是同步的），这样才能将t2树上的该节点的子树加入到合并后的二叉树中</span></span><br><span class="line">    <span class="comment">// 已经包含了两树都为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑，前序遍历</span></span><br><span class="line">    <span class="comment">// 直接改tree1的结构，而不重新定义一棵二叉树</span></span><br><span class="line">    t1-&gt;val += t2-&gt;val; <span class="comment">// 中节点</span></span><br><span class="line">    t1-&gt;left = <span class="built_in">mergeTree</span>(t1-&gt;left, t2-&gt;left); <span class="comment">// 左节点</span></span><br><span class="line">    t1-&gt;right = <span class="built_in">mergeTree</span>(t1-&gt;right, t2-&gt;right); <span class="comment">// 右节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> t1; <span class="comment">// 返回合并后的二叉树，即t1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本题采用中序/后序遍历也可以，把单层递归逻辑的三行代码调整顺序即可。按照前序遍历的思路想即可，这符合我们正常合并二叉树的习惯。本题除了在t1上修改，也可以定义一棵新的二叉树，写法如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">root-&gt;val = t1-&gt;val + t2-&gt;val;</span><br><span class="line">root-&gt;left = <span class="built_in">mergeTree</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">root-&gt;right = <span class="built_in">mergeTree</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></p>
<p>上述写法空间复杂度是O(n)。</p>
<p>本题的迭代写法如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* r1, TreeNode* r2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="literal">NULL</span>) <span class="keyword">return</span> r2;</span><br><span class="line">        <span class="keyword">if</span> (r2 == <span class="literal">NULL</span>) <span class="keyword">return</span> r1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代写法，常用队列</span></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(r1); q.<span class="built_in">push</span>(r2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* n1 = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* n2 = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// n1和n2都不为空</span></span><br><span class="line">            n1-&gt;val += n2-&gt;val;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若n1和n2的左子树都不为空，则将它们加入队列中</span></span><br><span class="line">            <span class="keyword">if</span> (n1-&gt;left != <span class="literal">NULL</span> &amp;&amp; n2-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(n1-&gt;left);</span><br><span class="line">                q.<span class="built_in">push</span>(n2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若n1和n2的右子树都不为空，则将它们加入队列中</span></span><br><span class="line">            <span class="keyword">if</span> (n1-&gt;right != <span class="literal">NULL</span> &amp;&amp; n2-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(n1-&gt;right);</span><br><span class="line">                q.<span class="built_in">push</span>(n2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若n1的左子树为空，则将n2的左子树赋到n1上</span></span><br><span class="line">            <span class="keyword">if</span> (n1-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">                n1-&gt;left = n2-&gt;left;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 若n1的右子树为空，则将n2的右子树赋到n1上</span></span><br><span class="line">            <span class="keyword">if</span> (n1-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                n1-&gt;right = n2-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="700-二叉搜索树中的搜索-2"><a href="#700-二叉搜索树中的搜索-2" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h3><p>在二叉树中找到数值为目标值的节点然后返回。</p>
<p><strong>什么是二叉树搜索树？</strong>其根节点要比左子树里所有节点的数值大，根节点要比右子树里所有节点的数值小。同理，左右子树也符合这个规则。二叉搜索树的上述规则确定了遍历顺序，而二叉搜素树的上述规则也让本题的迭代写法特别简单。递归法的代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">search</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 两个终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;val == val) <span class="keyword">return</span> root; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归的逻辑</span></span><br><span class="line">    TreeNode* res = <span class="literal">NULL</span>; <span class="comment">// res用于存递归函数的返回值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据二叉搜索树的特性，若val &lt; root的值，则向root的左子树中去遍历</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) res = <span class="built_in">search</span>(root-&gt;left, val);</span><br><span class="line">    <span class="comment">// 根据二叉搜索树的特性，若val &gt; root的值，则向root的右子树中去遍历</span></span><br><span class="line">    <span class="keyword">if</span> (val &gt; root-&gt;val) res = <span class="built_in">search</span>(root-&gt;right, val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比于我在初次尝试中的写法，上述写法代码更简洁，效率也更高。因为我在初次尝试中的写法没有利用二叉搜索树的特性，只是单纯地先搜索root节点，再递归搜索root节点的左子树和右子树。而卡尔的写法先搜索root节点，然后根据<code>root-&gt;val</code>和<code>val</code>的大小对比，决定是在root节点的左子树中继续搜索还是在其右子树中继续搜索。卡尔的写法并不涉及前中后序，因为二叉搜索树本身的性质已经帮我们确定了遍历的顺序。</p>
<p>本题迭代法的代码也并很简单。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">search</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向左子树中搜索</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val) root = root-&gt;left;</span><br><span class="line">        <span class="comment">// 向右子树中搜索</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) root = root-&gt;right;</span><br><span class="line">        <span class="comment">// 相等，说明找到了目标节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 树中无目标节点，则返回空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迭代法中搜索的方向也由二叉搜索树的特性决定。上述迭代写法也比我在初次尝试中写的迭代写法更为简洁且效率更高，因为卡尔<strong>充分利用了二叉搜索树的特性</strong>，知道想要找到目标值应该朝着什么方向走。</p>
<h3 id="98-验证二叉搜索树-2"><a href="#98-验证二叉搜索树-2" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p>判断给定的二叉树是否是二叉搜索树。二叉搜索树的定义：左子树中的所有元素都小于root节点，右子树中的所有元素都大于root节点，左右子树都符合这个规则。<strong>中序遍历这棵二叉树，其元素是有序的</strong>。例如对以下二叉树：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[5] --&gt; B[3]</span><br><span class="line">    B[3] --&gt; H[1]</span><br><span class="line">    B[3] --&gt; I[NULL]</span><br><span class="line">    A --&gt; C[10]</span><br><span class="line">    C --&gt; F[6]</span><br><span class="line">    C --&gt; G[11]</span><br></pre></td></tr></table></figure></p>
<p>按照中序遍历，就是[1, 3, 5, 6, 10, 11]，数组是有序的。<strong>验证二叉树是否是二叉搜索树，就是验证中序遍历后得到的数组是否是单调递增的</strong>。开始写具体的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 空二叉树是二叉搜索树</span></span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">// 存放树中序遍历后的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="built_in">isvalid</span>(root-&gt;left); <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中：将遍历到的元素放入数组中</span></span><br><span class="line">    <span class="built_in">isvalid</span>(root-&gt;right); <span class="comment">// 右</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断vec是否有序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上述思路，我写下了能够运行的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">// 全局变量，用于存放中序遍历二叉树的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于中序遍历二叉树的辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断数组是否是单调递增的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>() - <span class="number">1</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[i + <span class="number">1</span>] &lt;= vec[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其实不需要将二叉树转换为数组，可以直接在遍历二叉树的过程中判断元素是否是单调递增的。接下来看如何不使用数组来判断二叉树是否是二叉搜索树。本题也可以用迭代法实现，但主要关注递归法。</p>
<p>代码误区：<code>if (root-&gt;val &gt; root-&gt;left-&gt;val &amp;&amp; root-&gt;val &lt; root-&gt;right-&gt;val) return true;</code>。实际上这样写是错误的。因为二叉搜索树要求的是root要大于左子树中的所有值，root要小于右子树中的所有值。这个错误我在初次尝试部分已经讨论过了。</p>
<p>现在开始写不额外定义数组的写法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -2^31 &lt;= Node.val &lt;= 2^31 - 1，因此maxval要小于int的最小值，因此maxval要取为long long的最小值</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> maxval = LONG_MIN; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> left = <span class="built_in">isvalid</span>(root-&gt;left); <span class="comment">// 左：左子树是否是二叉搜索树</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中</span></span><br><span class="line">    <span class="comment">// 若二叉树是二叉搜索树，在中序遍历的情况下，元素是递增的，root-&gt;val会持续大于maxval</span></span><br><span class="line">    <span class="comment">// maxval相当于记录了遍历过程中当前节点的前一个节点的数值</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; maxval)</span><br><span class="line">    &#123;</span><br><span class="line">        maxval = root-&gt;val; <span class="comment">// 更新maxval</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若元素不是递增的，则return false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右：右子树是否是二叉搜索树</span></span><br><span class="line">    <span class="type">bool</span> right = <span class="built_in">isvalid</span>(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right; <span class="comment">// 要求左右子树同时符合条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以二叉树为例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[5] --&gt; B[3]</span><br><span class="line">    B[3] --&gt; H[1]</span><br><span class="line">    B[3] --&gt; I[NULL]</span><br><span class="line">    A --&gt; C[10]</span><br><span class="line">    C --&gt; F[6]</span><br><span class="line">    C --&gt; G[11]</span><br></pre></td></tr></table></figure></p>
<p>在判断6是否合法时，拿5（root，也是maxvalue）和6进行比较了，因此不会进入初次尝试中提到的误区。若左叶子为<code>INT_MIN</code>，且<code>maxval = INT_MIN</code>，则<code>root-&gt;val == maxval</code>，就会直接返回false。因此要让<code>maxval</code>小于<code>INT_MIN</code>。</p>
<p>上述方法存在问题，若左叶子为<code>LONG_MIN</code>（改变输入节点数值的范围），则<code>maxval</code>就无法取更小的值了。我们可以对上述方法进行优化，<strong>不额外定义一个变量，而是直接让二叉树的前一个节点和后一个节点进行比较</strong>。写下如下代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TreeNode* pre = <span class="literal">NULL</span>; <span class="comment">// pre记录当前节点的前一个节点, root可以和pre进行比较</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> left = <span class="built_in">isvalid</span>(root-&gt;left); <span class="comment">// 左</span></span><br><span class="line">    <span class="comment">// 中</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 前一个节点的值大于当前节点，则return false</span></span><br><span class="line">    pre = root; <span class="comment">// 将pre从NULL移到root，即从前一个节点移到当前节点</span></span><br><span class="line">    <span class="type">bool</span> right = <span class="built_in">isvalid</span>(root-&gt;right); <span class="comment">// 右</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上方法被称为双指针优化。其实原理非常简单，就是在中序遍历的过程中一直去判断root（当前节点）和pre（前一个节点）之间的大小关系。root指针是由中序遍历的过程去移动的，pre指针是通过直接赋值去移动的。本题是二叉搜索树中的基础题。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="654-最大二叉树-2"><a href="#654-最大二叉树-2" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h3><ol>
<li><p>本题的思路和106.从中序与后序遍历序列构造二叉树的思路非常类似，理解了那题就可以顺畅的写出本题的代码。</p>
</li>
<li><p>本题的单层递归核心逻辑如下：</p>
<ol>
<li><p>找到nums数组中的最大值，作为root</p>
</li>
<li><p>找到root在nums中的下标</p>
</li>
<li><p>将nums按照root分为左数组和右数组</p>
</li>
<li><p>递归处理左数组和右数组，得到左右子树</p>
</li>
</ol>
</li>
<li><p>本题的终止条件可以写两个也可以写一个。若只有终止条件：<code>if (nums.size() == 1) return new TreeNode(nums[0]);</code>，则需要在构造左右子树时加上if判断，保证左右区间不为空。若再加上终止条件：<code>if (nums.size() == 0) return NULL;</code>，则就不需要在构造左右子树时加上if判断了。加上第二个终止条件的原因并非是为了防止传入的nums数组为空（题目限制了传入的数组中至少有1个元素），而是为了在递归时出现数组为空的情况下顺利退出递归过程。</p>
</li>
<li><p>在实现中，给出了本题的4种写法。写法1和写法4的区别在于：1有1个终止条件，有if判断。4有2个终止条件，无if判断。<strong>最推荐的写法</strong>（初学者不易写错，且可直接由106演化而来）<strong>是写法2</strong>。效率最高的写法是写法3（只操作数组下标，而不新建数组，也不操作数组中的元素）。我将在下面附上写法2的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到root的值和下标</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(max);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), nums.begin() + index)</span></span>; <span class="comment">// 左区间</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(nums.begin() + index + <span class="number">1</span>, nums.end())</span></span>; <span class="comment">// 右区间</span></span><br><span class="line">        root-&gt;left = <span class="built_in">construct</span>(l); <span class="comment">// 递归构造左子树</span></span><br><span class="line">        root-&gt;right = <span class="built_in">construct</span>(r); <span class="comment">// 递归构造右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">construct</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>本题的优化写法是只操作下标，不新建数组，也不操作数组中元素的值。这样可以降低时间和空间复杂度（我感觉时间复杂度基本没变，但空间复杂度由于不需要新建数组，大大降低了）。注意区间始终要保持左闭右开（基于循环不变量原则）。</p>
</li>
</ol>
<h3 id="617-合并二叉树-2"><a href="#617-合并二叉树-2" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3><ol>
<li>本题虽然涉及到同时操作两棵二叉树，但代码的思路和实现都非常简单。</li>
<li>本题的递归写法的思路：<ul>
<li>终止条件：若一棵树的root节点为空，则返回另一棵树的root节点</li>
<li>单层递归：前序遍历。先合并中节点的值，然后再递归处理左子树和右子树。在树1的基础上，将树1修改为合并后的树。也可定义一棵新的树作为合并后的树。</li>
</ul>
</li>
<li>本题的迭代写法较为复杂，没必要掌握。</li>
</ol>
<h3 id="700-二叉搜索树中的搜索-3"><a href="#700-二叉搜索树中的搜索-3" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h3><ol>
<li>通过本题可以了解二叉搜索树的性质：其根节点要比左子树里所有节点的数值大，根节点要比右子树里所有节点的数值小。同理，左右子树也符合这个规则。二叉搜索树的上述规则确定了遍历顺序（既不是前序，也不是中序、后序），而二叉搜素树的上述规则也让本题的迭代写法特别简单。</li>
<li>我在初次尝试中的递归写法和迭代写法并没有利用二叉搜索树的性质，因此代码较长且运行效率较低，相当于初次尝试中的代码是执行了在一般的二叉树中搜索节点的过程。而在实现中卡尔的递归写法和迭代写法则充分利用了二叉搜索树的性质，因此代码较为简洁且运行效率高。</li>
<li>本题的迭代写法尤其简单，原因是：一般二叉树遍历的迭代法，需要使用栈来模拟深度遍历，使用队列来模拟广度遍历。但对于二叉搜索树，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用辅助栈或者队列就可以写出迭代法。对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支。而<strong>对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。</strong></li>
<li>本题推荐的写法是卡尔的写法，因为充分利用了二叉搜索树的性质。但如果想不起来卡尔的写法，或者题目中的二叉树并非二叉搜索树，而是一般的二叉树，我在初次尝试中的两种写法不失为一种具有普适性的写法。</li>
</ol>
<h3 id="98-验证二叉搜索树-3"><a href="#98-验证二叉搜索树-3" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><ol>
<li>本题的递归解法有三个版本，分别是直接判断中序遍历得到的数组是否递增、<code>maxvalue</code>法和双指针法。其中最简单最直观的方法是方法1，但其也是效率最低的。因此一定要掌握方法1，接着尽力掌握方法3，最后掌握方法2即可。</li>
<li><strong>本题利用的基本原理：中序遍历一棵二叉搜索树，得到的数组中的元素是有序（递增）的</strong>。</li>
<li><code>maxvalue</code>法和双指针法本质都是在中序遍历二叉树的过程中，不用额外的数组去存储二叉树中的所有元素，而是直接判断当前节点是否大于前一个节点。但<code>maxvalue</code>法具有<code>maxvalue</code>的初始值必须小于节点的最小值的问题，因此若节点的最小值可以取到long long的最小值，则<code>maxvalue</code>的初始值无法确定（cpp不提供超出long long范围的整数类型）。<strong>因此双指针法更为完美</strong>。</li>
<li><code>maxvalue</code>法和双指针法在代码实现上略有区别。二者的单层递归逻辑都是中序遍历，但在对中节点的处理逻辑上有差异。<code>maxvalue</code>法是当元素递增时，更新<code>maxvalue</code>的值，否则返回false。双指针法则是当元素不是递增时，返回false，否则更新pre指针。</li>
<li>本题的迭代解法要用到栈，代码也比较复杂，不要求掌握。</li>
</ol>
]]></content>
      <categories>
        <category>算法（二叉树）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>双指针算法</tag>
        <tag>层序遍历</tag>
        <tag>递归解法</tag>
        <tag>迭代解法</tag>
        <tag>二叉搜索树</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 22 Leetcode 235 701 450</title>
    <url>/2024/04/23/Day-22-Leetcode-235-701-450/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">235. 二叉搜索树的最近公共祖先</a><br><a href="https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html">701.二叉搜索树中的插入操作</a><br><a href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">450.删除二叉搜索树中的节点</a></p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h3><p>拿到本题，我发现这道题和236. 二叉树的最近公共祖先基本相同，只不过二叉树的条件被增强为二叉搜索树。我首先尝试用236题的思路和代码解决本题。据此，我独立写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件1</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 终止条件2</span></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (left) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (right) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后尝试利用二叉搜索树的特性来进行优化。我想到的优化是：用双指针后序遍历二叉搜索树，若pre和cur分别指向两个目标节点，那么cur就是两节点的最近公共祖先。直接看卡尔的讲解吧。</p>
<h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h3><p>本题应该充分利用二叉搜索树的性质就可以求解。若插入节点的值大于当前节点，则向当前节点的右子树插。若插入节点的值小于当前节点，则向当前节点的左子树插。我选择的策略是尽量往叶子节点那一层插入。根据这个思路，我写下了如下的代码（迭代写法，实际上就是枚举将val节点插入二叉搜索树的各种可能）：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root为空，则直接返回由val创建的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后序移动cur指针，不要直接移动root</span></span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cur无左子节点的情况，则条件合适就将val节点作为cur的左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; val &lt; cur-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* insert = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                cur-&gt;left = insert;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// cur无右子节点的情况，则条件合适就将val节点作为cur的右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right == <span class="literal">NULL</span> &amp;&amp; val &gt; cur-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* insert = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                cur-&gt;right = insert;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则继续走到叶子节点位置，在叶子节点之下插入val节点</span></span><br><span class="line">            <span class="keyword">if</span> (val &gt; cur-&gt;val) cur = cur-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; cur-&gt;val) cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* insert = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                <span class="keyword">if</span> (val &gt; cur-&gt;val) cur-&gt;right = insert;</span><br><span class="line">                <span class="keyword">else</span> cur-&gt;left = insert;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 必须随便返回一个东西，虽然必然不会执行这行代码，但不返回一个东西本程序就会报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，<strong>上述写法一定要区分cur指针和root节点</strong>。在写出了迭代写法后，应该也可以根据相同的原理写出递归写法。递归的写法其实非常简单，我尝试了一段时间后写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要插入的节点的值小于root节点的值，则将其插入root节点的左子树</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val)  root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="comment">// 要插入的节点的值大于root节点的值，则将其插入root节点的右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h3><p>本题的难点在于删除二叉搜索树中的节点后，要调整二叉树的结构，甚至要改变root节点。我想到的办法就是中序遍历时使用双指针。当cur指针找到要删去的节点时，cur指针再向后移动一位，然后直接用cur指针指向pre指针，就完成了对要删去节点的删除。根据这个算法思路，我尝试写代码，但写不出来，直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="235-二叉搜索树的最近公共祖先-1"><a href="#235-二叉搜索树的最近公共祖先-1" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h3><p>基于236. 二叉树的最近公共祖先，要好好利用二叉搜索树的特性。<strong>思路</strong>：从上往下遍历二叉树，若当前遍历的节点的值大于p和q的值，则p和q的最近公共祖先一定在当前节点的左子树中，此时从当前遍历的节点开始向左遍历。若当前遍历的节点的值小于p和q的值，则p和q的最近公共祖先一定在当前节点的右子树中，此时从当前遍历的节点开始向右遍历。若当前遍历的节点的值在p和q之间，则当前节点就是p和q的公共节点。</p>
<p>现在的问题是，当前节点是否是p和q的最近公共祖先？其实是的。因为p和q分别在当前节点的左右子树中，如果从当前节点开始继续向下遍历，那么不是错过p就是错过q。接下来开始写递归法的代码。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑</span></span><br><span class="line">    <span class="comment">// 本题不用涉及前中后序，因为二叉搜索树本身是有序的，只要有左和右即可，中在哪里都可以</span></span><br><span class="line">    <span class="comment">// 若当前遍历的节点的值大于p和q的值，则p和q的最近公共祖先一定在当前节点的左子树中，此时从当前遍历的节点开始向左遍历</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* left = <span class="built_in">traversal</span>(cur-&gt;left, p, q);</span><br><span class="line">    	  <span class="comment">// 在向左遍历的过程中找到了p和q的最近公共祖先，则返回之</span></span><br><span class="line">    		<span class="keyword">if</span> (left != <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若当前遍历的节点的值小于p和q的值，则p和q的最近公共祖先一定在当前节点的右子树中，此时从当前遍历的节点开始向右遍历</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* right = <span class="built_in">traversal</span>(cur-&gt;right, p, q);</span><br><span class="line">        <span class="comment">// 在向右遍历的过程中找到了p和q的最近公共祖先，则返回之</span></span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剩下的情况：当前节点的值在p和q之间，则当前节点就是p和q的最近公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本题迭代法的代码也比较简单，原因是二叉搜索树确定了搜索的方向。迭代法代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) cur = cur-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) cur = cur-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 一定不要忘记这句话，否则函数会因为没有返回值报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于二叉搜索树的题目，迭代法似乎比递归法还更简单。</p>
<h3 id="701-二叉搜索树中的插入操作-1"><a href="#701-二叉搜索树中的插入操作-1" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h3><p>插入新节点的方式有多种，得到的二叉搜索树不唯一。<strong>必然可以在二叉搜索树的叶子节点处插入新的节点</strong>。若在二叉搜索树的其他位置处插入节点，则改变了二叉搜索树的结构，将本题做复杂了。递归法代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// 卡尔的理解：遍历到空节点（叶子节点的左子节点或右子节点）时，将val节点作为叶子节点的左子节点或者右子节点</span></span><br><span class="line">    <span class="comment">// 此时将val节点向上返回给叶子节点</span></span><br><span class="line">    <span class="comment">// 卡尔的理解方式比较复杂，不如直接理解为传入一个空的树，返回根据val创建的新节点即可</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 卡尔的理解：在val节点作为叶子节点的左子节点时，当前节点的左指针指向val节点</span></span><br><span class="line">    <span class="comment">// 在val节点作为叶子节点的右子节点时，当前节点的右指针指向val节点</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="built_in">insert</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">if</span> (val &gt; root-&gt;val) root-&gt;right = <span class="built_in">insert</span>(root-&gt;right, val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>卡尔相当于是从叶子节点开始，自下往上讲解递归法的原理。我的理解方式是从root节点开始，自上而下的理解递归的思路。我的理解方式要简单一些，有利于快速写出本题的递归版本的代码</strong>。本题也可以用迭代法，由于是二叉搜索树明确了搜索的方向，所以迭代法的代码也会比较简单。</p>
<p>看了代码随想录的讲解后，我独立写出了正统的迭代法的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用cur节点作为当前遍历到的节点，用parent节点作为cur节点的父节点</span></span><br><span class="line">        <span class="comment">// 因为最后是在叶子节点下插入新节点，因此cur节点必定会遍历到空节点，此时需要利用parent节点来指向新节点</span></span><br><span class="line">        TreeNode* parent = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cur == NULL时终止循环</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// parent节点随着cur节点移动，但始终落后一步，因此parent节点是当前节点的上一个节点（父节点）</span></span><br><span class="line">            parent = cur; </span><br><span class="line">            <span class="comment">// 根据二叉搜素树的有序性移动cur节点</span></span><br><span class="line">            <span class="keyword">if</span> (val &lt; cur-&gt;val) cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最终在二叉搜索树的叶子节点下插入新节点，这就需要用到parent节点，因为cur节点已经为空</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; parent-&gt;val) parent-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">else</span> parent-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>正统的迭代法采取的是<strong>双指针</strong>的思路，需要两个节点，一个是cur节点，其是遍历二叉搜索树时的当前节点。另一个是parent节点，其是当前节点的上一个节点（父节点）。</p>
<h3 id="450-删除二叉搜索树中的节点-1"><a href="#450-删除二叉搜索树中的节点-1" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h3><p>删除节点后，要保证二叉树依然是二叉搜索树。<strong>本题比较难，因为要修改二叉树的结构</strong>。删除节点后的二叉树结构不唯一，只要符合二叉搜索树的定义即可。下面开始分析可能的情况。</p>
<ul>
<li>没找到要删除的节点</li>
<li>要删除的节点是叶子节点，左为空，右也为空（此时删除节点较为简单，因为不需要改变二叉树的结构）</li>
<li>要删除的节点左不为空，右为空。则让该节点的父节点直接指向该节点的左子节点</li>
<li>要删除的节点左为空，右不空。则让该节点的父节点直接指向该节点的右子节点</li>
<li>要删除的节点左不空，右不空。本情况最复杂，因为要大幅调整二叉搜索树的结构。拿以下二叉树为例：<br><img src="D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/tstmp_20240424064451.gif" alt="tstmp_20240424064451"></li>
</ul>
<p>例如删去节点7。<strong>让7的右子树继位</strong>，那么7的左子树应该放在右子树的哪里。<strong>7的左子树应该放在右子树中的左下角（右子树中的最小值）</strong>。让7的左子树继位也可以，原理相同。</p>
<p>接下来开始写代码（代码不多但不好理解）：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不写cpp中需要释放内存的逻辑，只写核心代码</span></span><br><span class="line"><span class="comment">// 返回新二叉树的根节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">delete</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// 不需要遍历整个二叉树，找到要删除的点就是终止条件</span></span><br><span class="line">    <span class="comment">// 找到要删除的点后就要删除该点，因此删除该点的操作在终止条件中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没找到要删除的节点/传入的二叉树为空</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要删除的节点是叶子节点，左为空，右也为空</span></span><br><span class="line">        <span class="comment">// return NULL的意思是该节点的父节点指向NULL</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要删除的节点左不为空，右为空</span></span><br><span class="line">        <span class="comment">// 将要删除的节点的左孩子直接向上返回即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要删除的节点左为空，右不空</span></span><br><span class="line">        <span class="comment">// 将要删除的节点的右孩子直接向上返回即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要删除的节点左不空，右不空</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* cur = root-&gt;right; <span class="comment">// 要删除节点的右子树</span></span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;left) cur = cur-&gt;left; <span class="comment">// 让cur指向右子树的左下角</span></span><br><span class="line">            cur-&gt;left = root-&gt;left; <span class="comment">// 将要删除节点的左子树嫁接到右子树的左下角</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移除要删除的节点，此时要删除的节点左为空右不为空，因为直接向上返回其右孩子即可</span></span><br><span class="line">            <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归</span></span><br><span class="line">    <span class="comment">// 二叉搜素树确定了搜索的方向</span></span><br><span class="line">    <span class="comment">// root的左子树在删去节点后，左子树的新根节点嫁接到root-&gt;left上</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;val) root-&gt;left = <span class="built_in">delete</span>(root-&gt;left, key); </span><br><span class="line">    <span class="comment">// root的右子树在删去节点后，右子树的新根节点嫁接到root-&gt;left上</span></span><br><span class="line">    <span class="keyword">if</span> (key &gt; root-&gt;val) root-&gt;right = <span class="built_in">delete</span>(root-&gt;right, key);</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 看似没有处理root，但实际上已经在终止条件中处理了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码不算复杂，但是很难想。注意：删除节点的操作是通过返回值来进行的，然后让本层递归的上一层去接住本层递归的返回值。本题也可以用迭代法实现。本题的进阶版本：在一般的二叉树中删除节点，更难。吃透本题即可。</p>
<p>本题精简的注释版本如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件，分为五种情况</span></span><br><span class="line">        <span class="comment">// 情况1：找不到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 情况2，要删除的节点左右都为空</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 情况3，要删除的节点左为空右不空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            <span class="comment">// 情况4，要删除的节点左不空右为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            <span class="comment">// 情况5，要删除的节点左不空右不空</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* cur = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span> (cur-&gt;left) cur = cur-&gt;left;</span><br><span class="line">                cur-&gt;left = root-&gt;left;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">else</span> root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="235-二叉搜索树的最近公共祖先-2"><a href="#235-二叉搜索树的最近公共祖先-2" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h3><ol>
<li>本题和236的区别在于，本题的条件得到了强化，不仅是二叉树，而且是二叉搜索树。</li>
<li>由于二叉搜索树的方向性，本题不需要回溯，自上往下查找目标区间即可。</li>
<li>本题的核心思路：从上往下遍历二叉树，若当前节点的值大于p和q节点的值，则p和q的最近公共祖先在当前节点的左子树中，从当前节点开始向左遍历。若当前节点的值小于p和q节点的值，则p和q的最近公共祖先在当前节点的右子树中，从当前节点开始向右遍历。若当前节点的值在<code>[p-&gt;val, q-&gt;val]</code>的范围内，则当前节点就是p和q的最近公共祖先。注意区间是左闭右闭，因为存在p为q的父节点的情况。</li>
<li>为什么当前节点的值在<code>[p-&gt;val, q-&gt;val]</code>的范围内，就可以确定当前节点就是p和q的最近公共祖先，而不仅仅是一个普通的公共祖先？这个原因在于：当前节点的值&gt;<code>p-&gt;val</code>，则说明p在当前节点的左子树中；当前节点的值&lt;<code>q-&gt;val</code>，则说明q在当前节点的左子树中。因此若从当前节点开始向下移动到下一个节点处，那么不是错过p就是错过q。因此当前节点就是p和q的最近公共祖先。</li>
<li>因为二叉搜索树的有序性，本题的迭代写法也非常简单，甚至比递归解法更简单。</li>
</ol>
<h3 id="701-二叉搜索树中的插入操作-2"><a href="#701-二叉搜索树中的插入操作-2" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h3><ol>
<li>本题可以采用递归法和迭代法。但递归法的代码较为简单，因此推荐使用递归法。迭代法的代码略微复杂，但采用的双指针思路也非常清晰，因此也可以掌握迭代法。</li>
<li>插入新节点的方式有多种，得到的二叉搜索树不唯一。但必然可以在二叉搜索树的叶子节点处插入新的节点。因此不用改变二叉搜索树的结构，就可以实现插入操作。这是本题简单易解的根本所在。</li>
<li><p>本题递归法的思路：</p>
<ul>
<li>递归函数的返回值：返回插入新节点后二叉搜索树的根节点。也可以返回空，但那样写比较麻烦。</li>
<li>终止条件：root节点为空时，说明输入的二叉树为空，因此直接返回val节点即可。</li>
<li>单层递归逻辑：若<code>val &gt; root-&gt;val</code>，说明val节点应该被插入在root节点的右子树中，因此有<code>root-&gt;right = insert(root-&gt;right, val)</code>（<code>insert(root-&gt;right, val)</code>返回了root的右子树在插入新节点后的头节点，用root的右节点指向该头节点即可）。若<code>val &lt; root-&gt;val</code>，说明val节点应该被插入在root节点的左子树中，因此有<code>root-&gt;left = insert(root-&gt;left, val)</code>。最终返回root即可。</li>
</ul>
</li>
<li><p>卡尔相当于是从叶子节点开始，自下往上讲解递归法的原理。我的理解方式是从root节点开始，自上而下的理解递归的思路。我的理解方式要简单一些，有利于快速写出本题的递归版本的代码。</p>
</li>
<li><p>本题的迭代写法思路也非常清晰。迭代法采取的是<strong>双指针</strong>的思路，需要两个节点，一个是cur节点，其是遍历二叉搜索树时的当前节点。另一个是parent节点，其是当前节点的上一个节点（父节点）。我在初次尝试中实现的迭代法代码复杂且由于要考虑多种情况，非常容易写错。因此建议如果要写迭代法，就采用基于双指针思路的迭代法。</p>
</li>
</ol>
<h3 id="450-删除二叉搜索树中的节点-2"><a href="#450-删除二叉搜索树中的节点-2" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h3><ol>
<li><p>本题相比于在二叉搜索树中插入节点，复杂得多，原因是删除二叉搜索树中的节点且保持该二叉树仍为二叉搜索树，会改变二叉搜索树原本的结构。</p>
</li>
<li><p>本题的第一个难点在于分析出删除一个节点的五种情况。</p>
<ul>
<li><p>找不到要删除的节点</p>
</li>
<li><p>要删除的节点的左右子节点均为空</p>
</li>
<li><p>要删除的节点的左空右不空</p>
</li>
<li><p>要删除的节点的左不空右空</p>
</li>
<li><p>要删除的节点的左右均不空</p>
</li>
</ul>
<p>由于在终止条件中要找到需要删除的节点，因此删除节点的操作也在终止条件中完成。</p>
</li>
<li><p>本题的第二个难点在于实现第五种情况的代码。我直接附上相应的代码并进行解释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TreeNode* cur = root-&gt;right;</span><br><span class="line"><span class="keyword">while</span> (cur-&gt;left) cur = cur-&gt;left;</span><br><span class="line">cur-&gt;left = root-&gt;left;</span><br><span class="line"><span class="keyword">return</span> root-&gt;right;</span><br></pre></td></tr></table></figure>
<p>先找到要删除的节点root，然后让cur指针指向root的右子节点。接着用cur遍历root的右子树，直到cur指向右子树的左下角。将root的左子树嫁接到右子树的左下角，最后返回root的右子节点。以root的右子节点为根节点的二叉树就是一棵二叉搜索树。可以举例子画图理解上述构造二叉搜索树的操作。</p>
</li>
<li><p>本题的基本原理在于：删除节点的操作是通过返回值进行的，然后让本层递归的上一层去接住本层递归的返回值。</p>
</li>
<li>删除一般的二叉树中的节点要采用另外的算法，因此不要求掌握。</li>
<li>本题也有迭代写法，需要用到双指针算法，代码也更加复杂，因此不要求掌握。</li>
<li>按理来说，cpp中需要显式地释放被删除节点占用的内存。但不释放也不会对代码的正常运行造成影响。</li>
</ol>
]]></content>
      <categories>
        <category>算法（二叉树）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>双指针算法</tag>
        <tag>递归解法</tag>
        <tag>迭代解法</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 24 Theory of Backtracking Algorithms, Leetcode 77</title>
    <url>/2024/05/01/Day-24-Theory-of-Backtracking-Algorithms-Leetcode-77/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">理论基础</a><br><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="什么是回溯法"><a href="#什么是回溯法" class="headerlink" title="什么是回溯法"></a>什么是回溯法</h4><p>回溯算法比较抽象，因此较难。</p>
<p><strong>回溯和递归是相辅相成的，有递归就会有回溯</strong>。回溯的逻辑一般隐藏在递归函数的下面。二叉树在递归的过程中会有回溯的操作，只不过有的题目显式地用到了回溯，有的题目没有显式地用回溯。<strong>回溯函数一般指递归函数</strong>，因为没有一个函数可以完全用来回溯。</p>
<p>回溯法的效率：<strong>回溯法是纯暴力的搜索</strong>，并不是一个高效的算法。如果想让回溯法高效一些，可以加一些剪枝的操作。部分题能够用暴搜做出来就不错了，用层层嵌套的for循环都根本搜不出来，要依靠回溯法才能把所有结果搜出来。</p>
<h4 id="使用原因以及解决的问题"><a href="#使用原因以及解决的问题" class="headerlink" title="使用原因以及解决的问题"></a>使用原因以及解决的问题</h4><p>回溯法能解决的问题：</p>
<ul>
<li>组合问题。比如给定集合1234，找出长度为2的组合。</li>
<li>排列问题。<strong>排列强调元素的顺序，而组合不强调元素的顺序</strong>。比如集合12，求其组合，只有12一种组合；但若求其排列，有12/21两种排列。</li>
<li>子集问题。比如给定集合1234，问该集合有多少子集。</li>
<li>切割问题。比如给一个字符串，问有几种切割方式。或者加一些特定的条件，比如给一个字符串，如何切割才能保证它的子串都是回文子串，问有几种切割方式。</li>
<li>棋盘问题。比如N皇后、解数独。</li>
</ul>
<h4 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h4><p>回溯法特别抽象。想要清晰地了解回溯法，<strong>最好将其抽象为一个图形结构</strong>。<strong>所有的回溯法都可以抽象为一个树形结构，确切的说是N叉树</strong>。原因：回溯就是递归的过程，递归有终止。<strong>N叉树的宽度是在回溯法中处理的集合的大小</strong>，一般用for循环遍历。<strong>树的深度是递归的深度</strong>，因为递归必有终止，递归会层层向上返回。后序讲解具体问题时，都会将<strong>具体问题抽象为对应的树形结构</strong>，方便大家理解。</p>
<h4 id="回溯模板"><a href="#回溯模板" class="headerlink" title="回溯模板"></a>回溯模板</h4><p>一般来说，回溯法的递归函数都是没有返回值的，即void。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// backtracking为习惯的起名</span></span><br><span class="line"><span class="comment">// 回溯法的参数一般较多，一开始时一般无法确定所有参数，写具体逻辑时遇到想用的参数，再添加参数即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件。到终止条件时，一般来说就可以收集结果了</span></span><br><span class="line">    <span class="comment">// 除去子集问题和部分棋盘问题，我们一般在叶子节点收集结果</span></span><br><span class="line">    <span class="comment">// 对于子集问题，则需要在每个节点处收集结果</span></span><br><span class="line">    <span class="keyword">if</span> (终止条件)</span><br><span class="line">    &#123;</span><br><span class="line">        (叶子节点处)收集结果 <span class="comment">// 例如将子集12从数组中放入结果集中</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索的逻辑</span></span><br><span class="line">    <span class="comment">// for循环用于遍历本层集合中的每个元素，对应一个节点的所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (集合元素)</span><br><span class="line">    &#123;</span><br><span class="line">        处理节点 <span class="comment">// 例如将子集12放进数组中</span></span><br><span class="line">        递归函数 <span class="comment">// 树形结构往深处走</span></span><br><span class="line">        回溯操作 <span class="comment">// 撤销对节点的处理，例如从子集12中弹出2，再加入3，才能得到新的子集13。同理，还需要撤销3加入4，得到14的组合。没有回溯操作，就会一直加入新的元素，就不会求出所有的组合情况。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每道回溯法的题目都有各自的特点，但最终的代码都离不开上述模板的风格。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>后序会用本期视频讲解的理论知识求解具体问题，就可以加深对本期视频讲解的理论知识的理解。</p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h3><p>根据回溯模板，我写下了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 结果集</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp; <span class="comment">// 暂时存储数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> ()</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            tmp.<span class="built_in">push_back</span>(i);</span><br><span class="line">            k -- ;</span><br><span class="line">            <span class="comment">// 递归函数</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k);</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            k ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>尽管和最终版本的代码已经非常接近，但是我不知道怎么写终止条件，也无法确定传入的参数是否齐全。先来看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="77-组合-1"><a href="#77-组合-1" class="headerlink" title="77. 组合"></a>77. 组合</h3><p>组合中的元素是无序的。给定集合1234，找出所有大小为2的组合。有12，13，14；23，24；34。暴力做法：两层for循环。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j ++ )</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; j &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>两层for循环即可求解k=2下的所有组合。三层for循环即可求解k=3下的所有组合。若k很大，则要嵌套很多层for循环。因此直接用for循环是无法解决本题的，就需要用到回溯算法。</p>
<p>回溯算法也是一个纯暴力的方式，模拟的也是嵌套for循环的过程。回溯算法是利用递归来控制有多少层for循环。递归里的每一层都是一个for循环。<strong>嵌套n层for循环即相当于递归n层</strong>。</p>
<p>所有的回溯法都可以抽象为一个树形结构。以本题为例，画回溯算法搜索的过程。</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-01_19-07-25.png?raw=true" alt="Snipaste_2024-05-01_19-07-25.png"></p>
<p>上述树形结构的叶子节点就是要求的所有组合。第一次取数是从集合中依次取，第二次取数是取第一次取的数的后面一个数，这样才能保证不重不漏。通过传入参数<code>startIndex</code>来实现这点，即控制每次搜索的起始位置。</p>
<p>二叉树的题目有递归三部曲，回溯算法也有回溯三部曲（回溯函数即递归函数，二者不作区分）：</p>
<ul>
<li>递归函数的参数和返回值，返回值一般为void</li>
<li>确定递归的终止条件</li>
<li>单层搜索（递归）的逻辑</li>
</ul>
<p>根据回溯三部曲对着上述图示写组合问题的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个组合存放在一个一维数组中，名为path</span></span><br><span class="line"><span class="comment">// 还需要一个二维数组res，将所有集合放在一起，作为结果集返回</span></span><br><span class="line"><span class="comment">// 上述两个数组可以作为加引用的参数，也可以作为全局变量。但参数不宜过多，会影响代码的可读性，因此将它们放入全局变量中</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n是集合中数的个数，k是组合的大小</span></span><br><span class="line"><span class="comment">// startIndex的作用：本层递归结束后，下一层递归如何知道从哪个数开始取，就要用到startIndex</span></span><br><span class="line"><span class="comment">// startIndex是本层递归搜索的起始位置，初始时为1，即从1开始搜索</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件，到叶子节点时，收集结果并返回</span></span><br><span class="line">    <span class="comment">// path的大小为k，说明找到了大小为k的组合，将之放入结果集并返回</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path); <span class="comment">// 收集结果</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索的逻辑</span></span><br><span class="line">    <span class="comment">// 每层都是一个for循环，起始点从startIndex开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex, i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// 递归过程, i + 1才能让下一层递归从下一个节点开始搜索</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回溯过程。不可以一直往里加，得到一个结果后需要弹出旧的元素</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度：$O(n \times 2^n)$<br>空间复杂度：$O(n)$<br>原因：</p>
<ul>
<li><p>对时间复杂度</p>
<ul>
<li><p><strong>解空间的大小</strong></p>
<p>对于组合问题，如生成一个集合的所有子集，解空间包含了该集合的所有可能子集。对于包含$n$个元素的集合，其子集总数是$2^n$。这是因为每个元素在每个子集中都有出现或不出现两种可能，因此，子集的总数是$2^n$。</p>
</li>
<li><p><strong>每个解的生成时间</strong></p>
<p>虽然生成每个子集看起来很快，但是实际上，为了构建每个子集，可能需要遍历所有元素来决定每个元素是否包含在当前子集中，这需要$O(n)$的时间。因此，对于所有子集，生成时间是每个子集的生成时间与子集总数的乘积，即$O(n \times 2^n)$。</p>
</li>
</ul>
</li>
<li><p>对空间复杂度<br> 在讨论空间复杂度时，我们通常关注的是算法在执行过程中需要额外分配的空间量。<strong>对于回溯算法来说，主要的空间消耗源于两部分：递归调用的栈空间和用于存储当前解的路径</strong>（在此例中为 path）。以下是详细分析：</p>
<ul>
<li><p>递归栈空间<br>在回溯算法中，递归的深度决定了栈空间的使用量。在这个特定的问题中（从 n 中选择 k 个数的组合），递归的最大深度是 k，因为每一层递归对应于选择一个元素，直到选择了 k 个元素。因此，递归栈的空间复杂度是 O(k)。</p>
</li>
<li><p>存储当前解的路径空间<br>path 变量用于存储当前的部分解，即已选择的元素集合。因为一次最多选择 k 个元素，所以 path 的最大长度也是 k。因此，存储 path 所需的空间也是 O(k)。</p>
</li>
<li><p>结果集 result<br>虽然result用来存储所有可能的组合，其大小可以达到组合数$C(n, k)$，<strong>但在分析空间复杂度时，我们通常不把输出空间计算在内，因为这部分空间是用来存储算法的最终结果，而非算法执行过程中的临时数据</strong>。如果包括result的空间，空间复杂度确实是$O(C(n, k))$，但这不是额外的空间，而是算法结果的必要空间。</p>
</li>
</ul>
</li>
</ul>
<p>本题的完整代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 结果集</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 存放一个集合</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path); <span class="comment">// 收集结果</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 递归函数，下一层搜索从i + 1开始</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题的代码并不复杂，基本是按照回溯法的模板来的。本题还可以做剪枝。回溯法是一个纯暴力的算法，想优化就要做剪枝。<strong>接着详细讲如何做剪枝，以及回溯算法常见的剪枝套路</strong>。</p>
<h3 id="组合问题的剪枝操作"><a href="#组合问题的剪枝操作" class="headerlink" title="组合问题的剪枝操作"></a>组合问题的剪枝操作</h3><p>回溯算法是一种纯暴力的算法，优化就是做剪枝，但也改变不了其暴力算法的本质。如何做剪枝操作？</p>
<p>以n=4, k = 4为例。</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-01_21-14-10.png?raw=true" alt="Snipaste_2024-05-01_21-14-10.png"></p>
<p>对取2，取3和取4的分支，可以做剪枝。若不做剪枝，回溯算法会搜索整个树形结构，因此剪枝的效果非常明显。剪枝的代码该怎么写？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 剪枝操作在单层搜索逻辑中</span></span><br><span class="line"><span class="comment">// for循环的逻辑在当前层的节点上，i对应于节点的每一个孩子，即for循环遍历了当前节点的所有孩子</span></span><br><span class="line"><span class="comment">// 要对节点的子孩子进行剪枝，因此对for循环的范围里进行优化即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点</span></span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>); <span class="comment">// 沿着当前分支继续往下搜索</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在的具体问题是：如何缩小i的范围？<br>总共要选取k个元素，当前选取了<code>path.size()</code>个元素，还剩下<code>k - path.size()</code>个元素有待选取。因此i至多从<code>n - (k - path.size()) + 1</code>开始。加1的原因是起始位置包括了<code>startIndex</code>。也可以举具体的例子。以<code>n=4, k=3, path.size()=0</code>为例，i至多从2开始枚举（这意味着i可以从1开始枚举，也可以从2开始枚举，但若从3开始枚举，则必然搜索不到大小为3的组合）。因此对上述代码修改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i ++ )</span><br></pre></td></tr></table></figure>
<p>这样可以确保在搜索的范围中可以找到大小为k的组合。剪枝的操作改动本处即可，代码其他地方不需要做改动。</p>
<p>上述剪枝操作在回溯算法的剪枝操作中特别常见。<strong>大部分回溯算法的剪枝操作都是在i的范围里做文章，即缩小i的范围</strong>。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="77-组合-2"><a href="#77-组合-2" class="headerlink" title="77. 组合"></a>77. 组合</h3><ol>
<li>本题的一个直接的想法是用k层for循环暴力解决，然而由于k的大小不确定，有待输入，因此需要用回溯法。回溯算法也是一个纯暴力的方式，模拟的也是嵌套for循环的过程。回溯算法是利用递归来控制有多少层for循环。递归里的每一层都是一个for循环。<strong>嵌套n层for循环即相当于递归n层</strong>。</li>
<li>所有回溯法的题目都可以抽象为一个树形结构，本题的树形结构参加实现部分。</li>
<li>基于本题的树形示意图，以及回溯法的模板代码，就可以写出本题的具体代码。需要特别注意的是，本题的递归函数需要传入三个参数，除去n和k外，还需要传入<code>startIndex</code>。这是因为每层递归的起始点都需要在上一层递归起始点的基础上加1，因此需要一个参数来标明当前这层递归的起始点。</li>
<li>本题可以进行剪枝优化。</li>
</ol>
<h3 id="组合问题的剪枝操作-1"><a href="#组合问题的剪枝操作-1" class="headerlink" title="组合问题的剪枝操作"></a>组合问题的剪枝操作</h3><ol>
<li><p>可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。<strong>如果for循环选择的起始位置之后的元素个数已经不足我们需要的元素个数了，那么就没有必要搜索了</strong>。</p>
</li>
<li><p>注意代码中i，就是for循环里选择的起始位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) </span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来看一下优化过程如下（可以画<strong>线段图</strong>理解）：</p>
<ul>
<li>已经选择的元素个数：<code>path.size()</code>;</li>
<li>还需要的元素个数为: <code>k - path.size()</code>;</li>
<li>在集合n中至多要从该起始位置: <code>n - (k - path.size()) + 1</code>，开始遍历。若i超过了这个最大的起始位置，则组合中凑不齐k个元素</li>
</ul>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
<p>举个例子，<code>n = 4，k = 3</code>， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p>
</li>
<li><p>上述剪枝操作在回溯算法的剪枝操作中特别常见。<strong>大部分回溯算法的剪枝操作都是在i的范围里做文章，即缩小i的范围</strong>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法（回溯算法）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>回溯算法</tag>
        <tag>理论基础</tag>
        <tag>组合问题</tag>
        <tag>剪枝操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 20 Leetcode 530 501 236</title>
    <url>/2024/04/21/Day-20-Leetcode-530-501-236/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html">530.二叉搜索树的最小绝对差</a><br><a href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html">501.二叉搜索树中的众数</a><br><a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. 二叉树的最近公共祖先</a></p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h3><p>本题虽然是个easy题，但我想不出来怎么做。唯一的思路是双指针，至于怎么递归，按照怎样的顺序，我想不出来。</p>
<h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h3><p>本题显然又要充分利用二叉搜索树的特性：中序遍历二叉搜索树，得到的数组是递增的，统计数组中出现频次最高的元素即可。本题我目前发现了两个需要注意的点：</p>
<ol>
<li>出现频次最高的元素可能不止一个，因此需要返回一个数组。</li>
<li>本二叉搜索树的性质为：左子树中的所有节点<strong>小于等于</strong>根节点，右子树中的所有节点<strong>大于等于</strong>根节点。</li>
</ol>
<p>本题似乎也应该采用双指针的做法。若<code>pre-&gt;val</code>和<code>cur-&gt;val</code>相等，则<code>cnt</code>数组（用于统计元素值出现的次数）中<code>pre-&gt;val</code>的值加1。但这里有两个问题：</p>
<ul>
<li>节点的值可能为负数，因此不能将节点的值直接映射为数组的下标</li>
<li>若出现次数最多的元素不止一个，该如何返回数组</li>
</ul>
<p>上述两个问题都不好解决，我直接看卡尔的讲解吧。</p>
<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h3><p>本题比较难，我拿到后没有什么想法，猜测可能要用到回溯。直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="530-二叉搜索树的最小绝对差-1"><a href="#530-二叉搜索树的最小绝对差-1" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h3><p>目标：求任意两节点间的最小绝对差。由于是二叉搜索树，用中序遍历会成为一个有序的序列，据此思路尝试解出此题。我独立写出了本题的第一种解法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> min = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>() - <span class="number">1</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; vec[i + <span class="number">1</span>] - vec[i]) min = vec[i + <span class="number">1</span>] - vec[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>和98.验证二叉搜索树相同，本题应该也可以用<code>maxvalue</code>法和双指针法。这两种方法本质上都是不用额外的数组，直接在中序遍历时计算两个相邻节点的差值，然后选取最小的差值。现在我来尝试这两种解法。这两种解法我还是想不出来，看卡尔的讲解。</p>
<p>接下来讲解如何在中序遍历时利用两个指针直接得出最小绝对差，而不用把二叉树转变为数组。难点：中序遍历二叉树时前后指针如何移动（控制）。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> res = INT_MAX;</span><br><span class="line"></span><br><span class="line">TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回二叉树的某一特性或者二叉树节点的某个数值，才需要返回值。本题的情况不需要返回值</span></span><br><span class="line"><span class="comment">// 确切来说，一找到就需要立刻去返回的才需要返回值。需要遍历整棵二叉树且用全局变量来记录返回结果的，函数就不需要返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑：中序遍历</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">    <span class="comment">// 中</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) res = <span class="built_in">min</span>(res, cur-&gt;val - pre-&gt;val);</span><br><span class="line">    pre = cur;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移动pre和cur的核心在于：cur由中序遍历来移动，pre由赋值移动。cur是当前节点，pre是当前节点的上一个节点。</p>
<p>根据上述核心代码，我写下了本题的完整代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = INT_MAX;</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; cur-&gt;val - pre-&gt;val &lt; res)</span><br><span class="line">            res = cur-&gt;val - pre-&gt;val;</span><br><span class="line">        <span class="comment">// 也可写作</span></span><br><span class="line">        <span class="comment">// if (pre != NULL) res = min(res, cur-&gt;val - pre-&gt;val);</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题也可以用迭代法，但不推荐。</p>
<h3 id="501-二叉搜索树中的众数-1"><a href="#501-二叉搜索树中的众数-1" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h3><p>二叉搜索树中可能有重复的元素。众数可能不止一个，因此输出众数的集合。暴力做法：对一棵普通的二叉树，遍历二叉树，用map统计每个元素出现的频次，然后将map转换为vector，对vector进行排序，然后在数组中求众数。</p>
<p>如何利用二叉搜索树的特性去求众数的集合？遍历顺序：中序遍历。中序遍历得到的数组中的所有元素是单调递增的。<strong>求众数的具体方法：先遍历一遍二叉树，记录下所有元素出现的最高频率。再遍历一遍二叉树，将出现频率为最高频率的元素放入结果集中。</strong>其实可以不遍历两遍二叉树，遍历一遍二叉树即可，需要用到一些代码技巧。</p>
<p>双指针算法的思路：用count来统计当前元素出现的次数。当<code>pre-&gt;val == cur-&gt;val</code>时，当前元素出现的次数加1。当<code>pre-&gt;val != cur-&gt;val</code>，则count归一。初始时，pre指向NULL，count指向左叶子节点，count也为一。当<code>count == maxcount</code>时，将当前元素放入结果集中。</p>
<p>这里有个问题：如果不事先遍历一遍二叉树，怎么知道<code>maxcount</code>一定是真正的最高频率？后面的具体代码实现中会处理这个问题。现在开始写具体的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 当前元素出现的频率</span></span><br><span class="line"><span class="type">int</span> maxcount = <span class="number">0</span>; <span class="comment">// 整个二叉树中（已经遍历过的节点）的元素出现的最高频率</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 结果集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历整个二叉树，结果放入全局变量中，因此递归函数不需要返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层的递归逻辑</span></span><br><span class="line">    <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">    <span class="comment">// 中：处理逻辑</span></span><br><span class="line">    <span class="comment">// 统计count</span></span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) count = <span class="number">1</span>; <span class="comment">// 双指针的初始位置：pre为NULL，cur指向左叶子节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) count += <span class="number">1</span>; <span class="comment">// 当前元素出现的次数+1</span></span><br><span class="line">    <span class="keyword">else</span> count = <span class="number">1</span>; <span class="comment">// 双指针指向的节点的值不相等，则count又回到1</span></span><br><span class="line">    pre = cur; <span class="comment">// pre跟随cur移动</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若当前节点的出现次数等于整个二叉树中元素出现的最大次数，则将其放入结果集中</span></span><br><span class="line">    <span class="keyword">if</span> (count == maxcount) res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时存在问题：maxcount不是真正的maxcount，因此需要代码去更新res数组</span></span><br><span class="line">    <span class="comment">// 实时更新res数组，就不需要遍历两遍二叉树了</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; maxcount) </span><br><span class="line">    &#123;</span><br><span class="line">        maxcount = count; <span class="comment">// 更新maxcount</span></span><br><span class="line">        <span class="comment">// maxcount都被更新了，原先的结果集中的结果全废了，清空res</span></span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 将当前节点的数值放入结果集中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我也写出了遍历两次二叉树的代码，如下所示。需要特别注意的是，<code>getmaxcount</code>后需要重置pre和count。遍历两次二叉树的代码显得很冗余，因为基本相同的逻辑写了两遍。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次遍历二叉树，得到maxcount</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getmaxcount</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">getmaxcount</span>(cur-&gt;left);</span><br><span class="line">        <span class="comment">// 中节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> count = <span class="number">1</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxcount) maxcount = count;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">getmaxcount</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次遍历二叉树，得到结果集</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> count = <span class="number">1</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span> (count == maxcount) res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">getmaxcount</span>(root);</span><br><span class="line">        pre = <span class="literal">NULL</span>; <span class="comment">// getmaxcount后重置pre</span></span><br><span class="line">        count = <span class="number">0</span>; <span class="comment">// getmaxcount后重置count</span></span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题也可以采用迭代法，基本上是迭代的模板加上递归法对中节点的处理逻辑。但本题推荐掌握递归法即可。</p>
<h3 id="236-二叉树的最近公共祖先-1"><a href="#236-二叉树的最近公共祖先-1" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h3><p>找两个节点p和q的最近公共祖先。条件：二叉树中所有节点的值都是不同的，二叉树中一定存在p和q。根节点是任何两个节点的公共祖先，所以求公共祖先没有意义，求最近公共祖先才有意义。简单的想法：找到节点p和节点q后，从下往上去遍历，直到找到公共的节点。但对二叉树，一般大家熟悉的是从根节点开始从上往下去遍历，实际上也无法从下往上去遍历，但处理顺序可以是从下往上的。<strong>回溯的过程就可以让我们去从下往上地处理结果</strong>。具体来说，可以判断某个节点的左子树是否出现过p，右子树是否出现过q，如果都出现了，就将该节点向上返回。看该节点的父节点，若父节点的左子树中没出现p，或者右子树中没出现q，则说明该节点是p和q的最近公共祖先。父节点继续将最近公共祖先节点的值向上返回，直到返回到根节点。</p>
<p>从下往上传递p和q节点的最近公共祖先的逻辑写在回溯过程中。<strong>想在回溯过程中达到从下往上处理的效果，一定要用后序遍历</strong>。后序遍历是左右中，中：处理逻辑。<strong>中的具体处理逻辑</strong>：判断某个节点的左子树是否出现过p，右子树是否出现过q。即在终止条件中，如果遇到了p或者q，就往上返回。如果一个节点的左子树的返回值不为空，则左子树中出现了p或者q；如果一个节点的右子树的返回值不为空，则右子树中出现了p或者q。<strong>如果当前中节点的左右子树的返回值都不为空，则当前的中节点就是p和q最近的公共祖先</strong>。还有一种情况。即p就是q的公共祖先。但本情况的处理逻辑和上面是相同的。</p>
<p>具体的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回最近的公共祖先</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件1</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 终止条件2：遇到节点p或者q，则将它们向上返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归的逻辑：后序遍历</span></span><br><span class="line">    <span class="comment">// 左：可以告诉我们左子树中是否出现过p或者q</span></span><br><span class="line">    TreeNode* left = <span class="built_in">traversal</span>(root-&gt;left, p, q);</span><br><span class="line">    <span class="comment">// 右：可以告诉我们右子树中是否出现过p或者q</span></span><br><span class="line">    TreeNode* right = <span class="built_in">traversal</span>(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">// 中</span></span><br><span class="line">    <span class="comment">// 左右子树中出现了p和q，则root是最近公共祖先，将root返回</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 左子树中没有p和q，右子树为最近公共祖先，则继续将right（即最近公共祖先）向上返回，可以参见下面的实例</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="comment">// 左子树为最近公共祖先，右子树中没有p和q，则继续将left(即最近公共祖先)向上返回，和上面一行代码同理</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="comment">// 左右子树都为空，则return NULL</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 7, q = 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<p>以上面的二叉树为例，2的左子树返回7，右子树返回4，则2是最近公共祖先。5的左子树返回空，右子树返回2，2是7和4的最近公共祖先，则将2继续向上返回。</p>
<p>为什么上述代码将另一种情况也包含了？以上图为例，若p=7, q=2，则q就是最近的公共祖先。<strong>一旦遇到q就返回，就不继续向下遍历了</strong>。最终就将q返回到root节点，作为结果了。因此另一种情况不需要特别考虑。</p>
<p>本题的难点：</p>
<ul>
<li>回溯的过程可以将结果逐层从下往上返回。</li>
<li>从下往上返回结果需要用到后序遍历。先进行左右子树的判断逻辑，再进行中节点的逻辑。只有左右子树的返回值不为空，才将中节点作为最近公共祖先返回。</li>
<li>可以举实例画图理解本题的回溯过程和后序遍历中节点的处理（返回）逻辑。</li>
<li>情况2的处理逻辑包含于情况1中。</li>
</ul>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="530-二叉搜索树的最小绝对差-2"><a href="#530-二叉搜索树的最小绝对差-2" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h3><ol>
<li>遇到二叉搜索树，首先需要注意其在中序遍历后得到的数组是递增的这一特性。</li>
<li>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值。</li>
<li><strong>我之所以一开始没有写出本题的双指针解法，原因在于</strong>忘记了如何确定递归函数的返回值。对于本题，需要遍历整棵二叉树且用全局变量来记录返回结果，因此递归函数不需要返回值。</li>
<li>本题的双指针法的思路和98.验证二叉搜索树相同，但两题的区别在于本题的递归函数没有返回值，而98题的递归函数返回值为bool类型。</li>
<li>移动pre和cur的核心在于：cur由中序遍历来移动，pre由赋值移动。cur是当前节点，pre是当前节点的上一个节点。</li>
</ol>
<h3 id="501-二叉搜索树中的众数-2"><a href="#501-二叉搜索树中的众数-2" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h3><ol>
<li>本题虽然是easy难度，但其实是<strong>比较难</strong>的。</li>
<li>若是一般的二叉树，而非二叉搜索树，则本题的思路为：首先遍历二叉树，用map统计每个元素出现的次数。然后对map按照value进行排序，将排序后的map的(key, value)中最大的一个（或几个）value对应的key放入结果集中。原理不复杂，但代码实现起来比较麻烦。</li>
<li>本题是二叉搜索树，因此想要充分利用了其性质的话，肯定要采用<strong>中序遍历</strong>。本题的核心思路依然是<strong>双指针算法</strong>。需要一个<code>count</code>来存储当前节点出现的次数，一个<code>maxcount</code>来存储整棵二叉树中出现次数最多的节点出现的次数。如果采用两次遍历的做法，那么需要先遍历一遍二叉树得到<code>maxcount</code>，然后再遍历一遍二叉树，将<code>count == maxcount</code>的节点的值存入结果集中。但实际上，遍历一遍二叉树即可完成上述操作。</li>
<li>遍历一遍二叉树的做法：初始时，<code>count = 1</code>；<code>pre-&gt;val == cur-&gt;val</code>时，<code>count += 1</code>；否则，<code>count = 1</code>。若<code>count == maxcount</code>，则将当前节点的值放入结果集中。此时出现问题：<code>maxcount</code>不一定是整棵二叉树出现次数最多的节点出现的次数。可以用一个简单的办法解决这个问题：若<code>count &gt; maxcount</code>，则更新<code>maxcount</code>，清空结果集，然后再往结果集中插入当前节点的值。通过这样的操作，就可以动态地去更新结果集，从而避免了对二叉树的两次遍历。</li>
</ol>
<h3 id="236-二叉树的最近公共祖先-2"><a href="#236-二叉树的最近公共祖先-2" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h3><ol>
<li><p>本题需要自下往上处理节点，自然而然想到用<strong>回溯</strong>的思想。</p>
</li>
<li><p><strong>后序遍历</strong>（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。因此本题采用后序遍历。</p>
</li>
<li><p>理解以下的示意图就理解了本题：<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151125844.png" alt="236.二叉树的最近公共祖先1"></p>
</li>
<li><p>本题的代码实际上非常简单而清晰，可以根据代码来理解上面的图片，本题的核心代码为中节点的处理逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终止条件1</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 终止条件2：遇到节点p或者q，则将它们向上返回，对应于节点6和5将它们自身向节点7返回的过程</span></span><br><span class="line"><span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单层递归的逻辑：后序遍历</span></span><br><span class="line"><span class="comment">// 左：可以告诉我们左子树中是否出现过p或者q</span></span><br><span class="line">TreeNode* left = <span class="built_in">traversal</span>(root-&gt;left, p, q);</span><br><span class="line"><span class="comment">// 右：可以告诉我们右子树中是否出现过p或者q</span></span><br><span class="line">TreeNode* right = <span class="built_in">traversal</span>(root-&gt;right, p, q);</span><br><span class="line"><span class="comment">// 中</span></span><br><span class="line"><span class="comment">// 左右子树中出现了p和q，则root是最近公共祖先，将root返回，对应于节点7将其自身向节点10返回的过程</span></span><br><span class="line"><span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"><span class="comment">// 左子树中没有p和q，右子树为最近公共祖先，则继续将right（即最近公共祖先）向上返回</span></span><br><span class="line"><span class="comment">// 对应于节点10将节点7向节点8返回的过程</span></span><br><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="comment">// 左子树为最近公共祖先，右子树中没有p和q，则继续将left(即最近公共祖先)向上返回，和上面一行代码同理</span></span><br><span class="line"><span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line"><span class="comment">// 左右子树都为空，则return NULL</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>用文字来描述，本题的关键代码实现了以下功能：</p>
<ul>
<li>遇到节点p或q，就将其向上返回</li>
<li>某个节点的左右子树中包含p和q，则该节点就是p和q的最近公共祖先，将该节点向上返回</li>
<li>某个节点的左右子节点中的一个的返回值不为空，则说明那个返回值不为空的左/右节点为p和q的最近公共祖先，将该节点进一步向上返回</li>
<li>其他情况下均返回空即可</li>
</ul>
</li>
<li><p>还有一种情况，即p是q的父节点，此时遍历到p的父节点时，p的父节点就会向上返回p，而不会继续遍历p和其下面的子树。因此本情况也包含在上述代码的逻辑中。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法（二叉树）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>双指针算法</tag>
        <tag>递归解法</tag>
        <tag>二叉搜索树</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 25 Leetcode 216, 17</title>
    <url>/2024/05/02/Day-25-Leetcode-216-17/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III</a><br><a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">17.电话号码的字母组合</a></p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h3><p>针对本题，我沿用上题77. 组合的代码，只是在终止条件中添加了条件：<code>sum(path) == n</code>，并在单层搜索逻辑中将终止条件改为<code>i = 9</code>，即可解决本题。据此，我独立写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            s += path[i];</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k &amp;&amp; <span class="built_in">sum</span>(path) == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(k, n, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题应该也是可以进行剪枝优化的。首先的要求当然还是k个数，因此i最大只能取到<code>9 - k + path.size() + 1</code>，即<code>10 - k + path.size()</code>。但这样会导致TLE（超时），原因尚不清楚。直接看卡尔的讲解。</p>
<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><p>本题应该还是属于组合问题的范畴。先尝试画出本题的树形结构。相当于每个数字对应三个字母，第一个数字对应的三个字母和第二个数组对应的三个字母间进行组合。若有n个数字，则有3n个字母，放入一个<code>string a</code>中，第一个字母从<code>a[0]-a[2]</code>中取，第二个字母从<code>a[3]-a[5]</code>中取，以此类推。相当于依然是一个组合问题，只不过每一层递归for循环的开始和结束是不固定的，需要用上述规则进行更新。据此，我尝试独立写出本题的代码框架：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string path;</span><br><span class="line">    string all;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将digits按照数字和字母间的对应关系转换为all字符串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(string digits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: digits)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;2&#x27;</span>) all += <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;3&#x27;</span>) all += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;4&#x27;</span>) all += <span class="string">&quot;ghi&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;5&#x27;</span>) all += <span class="string">&quot;jkl&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;6&#x27;</span>) all += <span class="string">&quot;mno&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;7&#x27;</span>) all += <span class="string">&quot;pqrs&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;8&#x27;</span>) all += <span class="string">&quot;tuv&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> all += <span class="string">&quot;wxyz&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == digits.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= endIndex; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path += all.<span class="built_in">substr</span>(startIndex, endIndex);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(digits, startIndex, endIndex);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path -= all.<span class="built_in">substr</span>(startIndex, endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>遇到的难点：<code>startIndex</code>和<code>endIndex</code>不好确定，因为部分数字不止对应三个字母。直接看卡尔的讲解。果然涉及字符串的题目都不好做啊。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="216-组合总和III-1"><a href="#216-组合总和III-1" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h3><p>[1, 9]。和为n，个数为k的所有组合。本题和上题77. 组合的区别：限制和为n，集合是固定的（1-9），因此相当于在77. 组合的基础上加了一个和的限制。组合不强调元素间的顺序，排列强调元素间的顺序。暴力做法，当k=2时，两层for循环遍历1-9，找到两个相加等于n的数。暴力的想法代码没法写，所有要用回溯算法。回溯算法也是暴力的方式，只不过回溯算法通过递归的方式帮助我们控制for循环的嵌套层数，递归n层即相当于模拟了n层嵌套的for循环。</p>
<p>本题的树形结构如下所示：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-02_03-55-06.png?raw=true" alt="Snipaste_2024-05-02_03-55-06.png"></p>
<p>树的深度为k，树的宽度是当前层的集合中的元素的个数。现在来写具体的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum为当前路径已有的和, 将其与targetSum(即n)做一个比较，相等即符合题目的要求</span></span><br><span class="line"><span class="comment">// 本题的startIndex用途同77. 组合中的startIndex，初始值为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k)</span><br><span class="line">        <span class="keyword">if</span> (targetSum == sum)</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        sum += i;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(targetSum, k, sum, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        sum -= i;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k &amp;&amp; sum == n)</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            sum += i;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(k, n, i + <span class="number">1</span>, sum);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            sum -= i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(k, n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来对上述代码进行剪枝优化。第一个剪枝在于满足targetSum的要求。剪枝代码放在终止条件之前：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum &gt; targetSum)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>还有一个剪枝（满足集合中元素个数的要求），和77.组合中的剪枝是相同的。当前组合中有<code>path.size()</code>个元素，还需要<code>k - path.size()</code>个元素，因此i的最大起始位置为<code>9 - (k - path.size()) + 1</code>。因此：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i ++ )</span><br></pre></td></tr></table></figure></p>
<p>加上完整的剪枝优化后的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 剪枝操作1</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k &amp;&amp; sum == n)</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i ++ ) <span class="comment">// 剪枝操作2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="comment">// if (sum &gt; n) return;也可以放在此处</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(k, n, i + <span class="number">1</span>, sum);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            sum -= i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(k, n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我发现，若仅仅进行剪枝操作2，但不进行剪枝操作1，程序就会报错：TLE。</p>
<p>我还发现，尽管<code>if (sum &gt; n) return;</code>放在<code>sum += i</code>之后，程序可以通过测评。但正统的写法应当为在剪枝前，先把回溯给做了，否则可能会漏掉满足要求的组合（程序没有进行回溯，就试图去寻找新的满足要求的组合了）：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当然这个剪枝也可以放在调用递归之前，只不过要记得把回溯操作给做了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) &#123; </span><br><span class="line">    <span class="comment">// 处理节点</span></span><br><span class="line">    sum += i; </span><br><span class="line">    path.<span class="built_in">push_back</span>(i); </span><br><span class="line">    <span class="keyword">if</span> (sum &gt; targetSum) &#123; <span class="comment">// 剪枝操作</span></span><br><span class="line">        sum -= i; <span class="comment">// 剪枝之前先把回溯做了</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 剪枝之前先把回溯做了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="built_in">backtracking</span>(targetSum, k, sum, i + <span class="number">1</span>); </span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    sum -= i; </span><br><span class="line">    path.<span class="built_in">pop_back</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本题的时间和空间复杂度同77.组合的时空复杂度。</p>
<h3 id="17-电话号码的字母组合-1"><a href="#17-电话号码的字母组合-1" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><p>电话拨号盘，每个数字代表一个字符串。首先需要做映射。将输入的字符串（一串数字）映射为对应的字符串。可以用map或者二维数组做映射，这里使用二维数组。数组中的每个元素是字符串。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot; &quot;</span>, <span class="comment">// 0</span></span><br><span class="line">    <span class="string">&quot; &quot;</span>, <span class="comment">// 1</span></span><br><span class="line">    abc, <span class="comment">// 2</span></span><br><span class="line">    def, <span class="comment">// 3</span></span><br><span class="line">    ghi, <span class="comment">// 4</span></span><br><span class="line">    jkl, <span class="comment">// 5</span></span><br><span class="line">    mno, <span class="comment">// 6</span></span><br><span class="line">    pqrs, <span class="comment">// 7</span></span><br><span class="line">    tuv, <span class="comment">// 8</span></span><br><span class="line">    wxyz, <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样拿到<code>digits</code>中的数字，将其作为下标放入字符串，即可得到数字对应的字符串（举例：<code>letterMap[2] = &quot;abc&quot;</code>）。</p>
<p>暴力做法：输入两个数字，则要进行两重for循环。输入n个数字，则要进行n重for循环。此时想到用回溯算法进行暴力求解。回溯算法可通过递归的方式实现对for循环的嵌套。以输入2，3为例，尝试画出本题的树形结构：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-02_22-19-15.png?raw=true" alt="Snipaste_2024-05-02_22-19-15.png"></p>
<p>结果就在树形结构的叶子节点中。树的深度是输入数字的个数，树的宽度由每一个数字对应的字符串的长度控制。现在尝试写本题的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s; <span class="comment">// 用于存储单个结果</span></span><br><span class="line">vector&lt;string&gt; res; <span class="comment">// 收获结果集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index用于标识传入的字符串digits在当前递归中遍历到哪一个字符（实际上是数字）了</span></span><br><span class="line"><span class="comment">// startIndex一般用于一个集合中求组合，避免得到重复的组合</span></span><br><span class="line"><span class="comment">// 本题是在多个集合中各取一个元素出来做组合，因此不需要startIndex来帮助控制集合中之前遍历过哪些元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// index指向digits的最后一位的下一位，才终止。若index指向digits的最后一位，其后应该还有处理最后一位的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(s); <span class="comment">// 收获结果</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">    <span class="comment">// 取出digits中的数字</span></span><br><span class="line">    <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 字符转换为数字</span></span><br><span class="line">    <span class="comment">// 找出digit对应的字符串</span></span><br><span class="line">    string letter = letterMap[digit];</span><br><span class="line">    <span class="comment">// 遍历digit对应的字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letter.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        s.<span class="built_in">push_back</span>(letter[i]);</span><br><span class="line">        <span class="comment">// 下一层递归，index后移一位</span></span><br><span class="line">        <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本题看似复杂，但画图理解后逻辑清晰，代码也不长。</p>
<p>可以将代码写得更简洁，递归函数传入三个参数：<code>void backtracking(string digits, int index, string s)</code>，然后单层搜索逻辑的三行代码写成一行：<code>backtracking(digits, index + 1, s + letter[i]);</code>。<code>s</code>的值本身并没有改变，这就是将回溯的过程隐藏在参数中了。</p>
<p>本题完整可运行的程序如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s; <span class="comment">// 存储单个组合</span></span><br><span class="line">    vector&lt;string&gt; res; <span class="comment">// 结果集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储数字和字符串之间的映射关系</span></span><br><span class="line">    vector&lt;string&gt; letterMap = &#123;</span><br><span class="line">        <span class="string">&quot; &quot;</span>, <span class="comment">// 0 </span></span><br><span class="line">        <span class="string">&quot; &quot;</span>, <span class="comment">// 1</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span> <span class="comment">// 9</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index用于标记当前层遍历到了digits中的哪个位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 这个return不能去掉，否则程序会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 取出当前层的数字</span></span><br><span class="line">        string letter = letterMap[digit]; <span class="comment">// 取出当前层需要遍历的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letter.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            s.<span class="built_in">push_back</span>(letter[i]);</span><br><span class="line">            <span class="comment">// 向下一层递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 这个return可要可不要，但为了和回溯法模板保持一致，因此还是加上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> res; <span class="comment">// 必须加上这句话，特判digits为空的情况</span></span><br><span class="line">        <span class="built_in">backtracking</span>(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>简化后的写法（隐藏回溯逻辑）：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; all = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits, <span class="type">int</span> index, string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        string letter = all[digit];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letter.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>, s + letter[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits, <span class="number">0</span>, s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>时间复杂度分析</strong></p>
<p>对于每个按键，电话按键可能对应不同数量的字母：</p>
<ul>
<li>按键 2, 3, 4, 5, 6, 8 每个都对应 3 个字母。</li>
<li>按键 7 和 9 对应 4 个字母。</li>
</ul>
<p>如果输入的字符串中有 <code>m</code> 个按键对应 4 个字母，<code>n</code> 个按键对应 3 个字母，那么所有可能的组合数量是 <code>4^m * 3^n</code>。因为这是回溯算法的常见分析模式，每一步选择会进入下一层递归，直到达到输入字符串的长度。在每一层递归中，根据当前按键可能的字母数量，我们有不同的选择分支。</p>
<p>因此，整个算法需要考虑的总路径数或调用次数是 <code>O(4^m * 3^n)</code>。</p>
<p><strong>空间复杂度分析</strong></p>
<p>空间复杂度主要由两部分构成：</p>
<ol>
<li><p><strong>递归调用栈</strong>：最大深度为输入字符串的长度，即 <code>m + n</code>。然而，这通常认为是 O(m+n)，不是主要的空间消耗部分。</p>
</li>
<li><p><strong>输出存储空间</strong>：存储所有可能组合的空间，这是算法的主要空间消耗。每个组合都是一个新的字符串，因此需要的总空间是与生成的组合数量相同，即 <code>O(4^m * 3^n)</code>。</p>
</li>
</ol>
<p>如果空间复杂度中不计入输出存储空间，则空间复杂度是O(m+n)。若计入，则是O(4^m * 3^n)。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="216-组合总和III-2"><a href="#216-组合总和III-2" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h3><ol>
<li>本题的思路和77.组合的完全相同，只不过加了限制条件：组合中所有元素之和为n。</li>
<li>本题有两种写法。第一种是我在初次尝试中的写法，最大限度地沿用了77.组合的代码，只不过另外实现了一个sum函数来统计path数组中所有元素之和，并在终止条件中与n进行比较。这种写法存在一个巨大的缺陷，就是无法进行剪枝。因为只有实现了剪枝操作1：<code>if (sum &gt; n) return;</code>后，才能实现剪枝操作2：<code>for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i ++ )</code>，而写法1的递归函数的参数中没有<code>sum</code>，因此剪枝操作1必然无法实现，这导致剪枝操作2也无法实现（强行添加剪枝操作2，程序直接报错TLE（超时））。</li>
<li>本题的第二种写法更为正统，递归函数传入的参数中包含了<code>sum</code>，即当前path数组中元素之和。需要特别注意的是，处理节点的过程和回溯过程是一一对应的，<code>sum</code>在处理有加，在回溯就要有减。</li>
<li>基于本题的第二种写法，可以对代码进行两种剪枝操作。剪枝操作1：<code>if (sum &gt; n) return;</code>。该操作可以放在终止条件之前，也可以放在单层搜索逻辑中处理节点时对<code>sum</code>的计算之后（具体细节详见实现部分，建议不要纠结这里的细节）。剪枝操作2：<code>for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i ++ )</code>。这和77.组合中的剪枝操作完全相同。</li>
<li>只有实现了剪枝操作1后，才能实现剪枝操作2。若单独实现剪枝操作2，会导致程序超时（TLE）。</li>
</ol>
<h3 id="17-电话号码的字母组合-2"><a href="#17-电话号码的字母组合-2" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><ol>
<li><p>本题的<strong>两大创新之处</strong>：<code>index</code>和<code>letterMap</code>。前者用于表示遍历<code>digits</code>遍历到了哪一位，后者用于表示数字和字符串之间的映射关系。</p>
</li>
<li><p>画出树形结构对于解决回溯法问题的帮助：确定树形结构的宽度，可以确定单层搜索逻辑中的for循环怎么写；确定树形结构的深度，可以确定单层搜索逻辑中的递归部分怎么写。</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-02_22-19-15.png?raw=true" alt="Snipaste_2024-05-02_22-19-15.png"></p>
<p>在本题中，树的当前层中的各个节点是<code>letters</code>中的各个元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">string letters = letterMap[digit];</span><br></pre></td></tr></table></figure>
<p>树的深度是<code>digits.size()</code>，可通过<code>index + 1</code>不断向树的下一层递归。</p>
</li>
<li><p>如果输入的字符串中有 <code>m</code> 个按键对应 4 个字母，<code>n</code> 个按键对应 3 个字母，则本题的时间复杂度和空间复杂度都是$O(4^m \times 3^n)$。</p>
</li>
<li><p>本题看题意较为麻烦，但如果能画出树形结构，同时学会使用<code>vector&lt;string&gt;</code>来存储数字和字符串之间的映射关系，然后通过<code>index</code>来取出特定数字对应的字符串，就可以写出简明而清晰的代码。</p>
</li>
<li><p>写本题代码时，最好参照回溯法的模板代码，不要省略return，否则可能导致报错。另外，在主函数中要特判<code>digits</code>为空的情况。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法（回溯算法）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>回溯算法</tag>
        <tag>组合问题</tag>
        <tag>剪枝操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 23 Leetcode 669 108 538 summary</title>
    <url>/2024/04/24/Day-23-Leetcode-669-108-538-summary/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">669. 修剪二叉搜索树</a><br><a href="https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">108.将有序数组转换为二叉搜索树</a><br><a href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html">538.把二叉搜索树转换为累加树 </a><br><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html">总结篇 </a></p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a>669. 修剪二叉搜索树</h3><p>本题据说比增加和删除节点更难，我拿到后没有思路，直接看卡尔的讲解。</p>
<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><p>虽然这是道简单题，但我也没想出来怎么做。</p>
<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h3><p>本题的基本思路是：累加树中的新节点（除叶子节点外）是其本身加上其右子树的所有节点之和。叶子节点如果是他父节点的左孩子，则值为他的父节点的新值减去原本父节点的值。叶子节点若是他父节点的右孩子，则值为他的父节点的新值加上叶子节点原本的旧值。要计算右子树的值，应当用双指针算法加上中序遍历。</p>
<p>本题还有另一种思路，更加简单粗暴。直接将二叉搜索树转换为一个递增的数组。然后某个节点的新值就是从其本身到数组末尾的所有元素之和。根据上述原理，我写下了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将二叉搜索树通过中序遍历转换为有序的数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left); <span class="comment">// 左</span></span><br><span class="line">        nums.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新节点的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; root-&gt;val)</span><br><span class="line">                root-&gt;val += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过层次遍历，遍历每个节点，依次更新所有节点的值</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">sum</span>(node);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>虽然从原理上来说，上述做法应该是没有问题的，但因为并发修改之类的问题，上述代码的实际运行结果和预期就是不同。我搞不清楚为什么，暂且记录下来。直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="669-修剪二叉搜索树-1"><a href="#669-修剪二叉搜索树-1" class="headerlink" title="669. 修剪二叉搜索树"></a>669. 修剪二叉搜索树</h3><p>给二叉搜索树，给定范围，在范围内修剪二叉搜索树，使得二叉搜索树中所有节点的数值都在范围内。本题不仅要删除不止一个节点，还要改变树的结构。</p>
<p>450.删除二叉搜索树中的节点的原理：通过递归，从当前层往上一层返回值，上一层的左/右孩子来接住返回值，达到删除节点的效果。</p>
<p>常见的误区：常见的错误代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回修剪后二叉树的根节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 修剪二叉搜索树</span></span><br><span class="line">    <span class="comment">// 当前遍历的节点不在[low, high]的范围内</span></span><br><span class="line">    <span class="comment">// 这样写很明显是错误的，若根节点的两个子节点都返回NULL，那么二叉树就只剩下根节点了，其他节点全部被删除</span></span><br><span class="line">    <span class="comment">// 实际上根节点的两棵子树中都可能有范围内的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; low || root-&gt;val &gt; high) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(root-&gt;left, low, high);</span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(root-&gt;right, low, high);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正确的思路</strong>为：若发现某个节点小于范围的左边界，那么该节点的右子树中可能有范围内的节点，因为该节点中右子树的值都要大于该节点的值。因此尽管要删除这个节点，但还需要继续在其右子树中遍历，来挑出其中符合条件的节点。现在来写正确的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回修剪后二叉树的根节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 本题的终止条件和删除二叉搜索树中的节点的终止条件类似，分类讨论，先发现要删除的节点然后完成删除操作</span></span><br><span class="line">    <span class="comment">// 终止条件1</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 终止条件2</span></span><br><span class="line">    <span class="comment">// root节点的值小于左边界，但其右子树中可能有符合要求的节点，故应该继续向右遍历</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; low)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// root节点的右子树在修剪后的根节点</span></span><br><span class="line">        TreeNode* right = <span class="built_in">traversal</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">return</span> right; <span class="comment">// 向上返回该根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 终止条件3</span></span><br><span class="line">    <span class="comment">// root节点的值大于右边界，但其左子树中可能有符合要求的节点，故应该继续向左遍历</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// root节点的左子树在修剪后的根节点</span></span><br><span class="line">        TreeNode* left = <span class="built_in">traversal</span>(root-&gt;left, low, high);</span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// 向上返回该根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑，分别修剪根节点的左右子树，然后将修剪后的左右子树接上去</span></span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(root-&gt;left, low, high);</span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(root-&gt;right, low, high);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// root在终止条件中处理了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题的代码其实不复杂，特别是相比于450.删除二叉搜索树中的节点。那题的终止条件需要分5种情况讨论，本题的终止条件只需要分3种情况讨论。本题也有迭代写法。本题掌握递归法即可。本题代码量不多，但很考察大家对二叉树移除节点和二叉搜索树特性的理解。</p>
<p>我独立写下了精简注释版本的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件1</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件2，root节点的值小于左边界</span></span><br><span class="line">        <span class="comment">// 此时root节点的右子树中依然可能有符合要求的节点在，因此还需对右子树进行修剪</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; low)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件3，root节点的值大于右边界</span></span><br><span class="line">        <span class="comment">// 此时root节点的左子树中依然可能有符合要求的节点在，因此还需对左子树进行修剪</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="comment">// 用来接住3个终止条件的返回值</span></span><br><span class="line">        root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题的迭代法代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保root在[low, high]的区间内</span></span><br><span class="line">        <span class="comment">// 以下写法可以避免死循环</span></span><br><span class="line">        <span class="keyword">while</span> (root &amp;&amp; (root-&gt;val &lt; low || root-&gt;val &gt; high))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &lt; low) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保cur的左子树中没有小于low的节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val &lt; low)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;left = cur-&gt;left-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = root; <span class="comment">// 恢复cur</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接着检查cur的右子树中没有大于high的节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &gt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;right = cur-&gt;right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>迭代法原理不复杂，但代码非常容易写错，因此不推荐迭代写法。</p>
<h3 id="108-将有序数组转换为二叉搜索树-1"><a href="#108-将有序数组转换为二叉搜索树-1" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><p>要构造的二叉搜索树是平衡二叉树。做这个要求的原因是任何有序数组都能够轻易构造成链式的二叉搜索树。</p>
<p><strong>构造二叉树的一般思路</strong>：在数组中选取一个中间节点，将数组分为左区间和右区间。递归遍历左区间，构成左子树。递归遍历右区间，构成右子树。</p>
<p>解题思路：root节点选取为数组中间位置的节点。因为只有这样选才可以保证左右区间中节点的数量相同，构造的二叉树才是平衡二叉树。再根据二叉搜索树的性质：中节点的值大于左子节点，小于右子节点来构造二叉搜索树。构造出的二叉搜索树的结构不唯一。对于数组中有偶数个元素的情况，root节点可以选取为中间偏左那个节点，也可以选取为中间偏右那个节点。代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意引用&amp;。如果每层递归不用引用，就需要在内存空间中重复复制数组，导致程序的性能很差</span></span><br><span class="line"><span class="comment">// 使用引用后，递归遍历时都在同一个内存地址里操作数组</span></span><br><span class="line"><span class="comment">// 区间左右边界的定义很重要，此处对区间的定义是左闭右闭</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件：非法区间</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">// 数组下标相加不可能爆内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造二叉树的根节点</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]); </span><br><span class="line">    <span class="comment">// 利用左区间构造左子树</span></span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(nums, left, mid - <span class="number">1</span>); <span class="comment">// 因为是左闭右闭的区间，所以right = mid - 1</span></span><br><span class="line">    <span class="comment">// 同理，利用右区间构造右子树</span></span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(nums, mid + <span class="number">1</span>, right); <span class="comment">// 因为是左闭右闭的区间，所以left = mid + 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 区间定义左闭右闭，因此right = nums.size() - 1</span></span><br><span class="line">    TreeNode* root = <span class="built_in">traversal</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本代码并不复杂。本题也可用迭代法实现，但较为复杂。本题优先掌握递归法即可。</p>
<p>本题的精简版本代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 区间左闭右闭</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造root节点</span></span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造左子树</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 构造右子树</span></span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        TreeNode* root = <span class="built_in">traversal</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="538-把二叉搜索树转换为累加树-1"><a href="#538-把二叉搜索树转换为累加树-1" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h3><p>换个思路：给一个有序的数组，将其变成一个累加数组。<strong>倒序遍历</strong>即可，将前一个节点加到本节点中。倒序遍历有序数组，<strong>本质就是按照右中左的顺序遍历二叉搜索树</strong>。将前一个节点的值加到本节点中，就需要用到<strong>双指针</strong>。pre指针指向前一个节点，cur指针指向当前节点。现在开始写递归法的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pre = <span class="number">0</span>; <span class="comment">// 记录前一个节点的数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于要遍历整个二叉树，在遍历的过程中去更新节点数值即可，因此不需要返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑：右中左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line">    cur-&gt;val += pre; <span class="comment">// 中</span></span><br><span class="line">    pre = cur-&gt;val; <span class="comment">// 移动pre</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在对二叉搜索树的遍历不够熟悉的情况下，可以将二叉搜索树想象成一个有序的数组。</p>
<p>将pre定义为指针也是可行的，代码会略微复杂，因为要判断指针是否为空：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (pre) cur-&gt;val += pre-&gt;val;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题用迭代法也可以做，而且是迭代法的模板题，但我用迭代法写本题总是容易写错。因此还是推荐递归法。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="669-修剪二叉搜索树-2"><a href="#669-修剪二叉搜索树-2" class="headerlink" title="669. 修剪二叉搜索树"></a>669. 修剪二叉搜索树</h3><ol>
<li>本题乍一看非常简单，结果就是掉进常见误区中，即发现一个节点不在区间内，就直接返回NULL。这样的问题在于以该节点为根节点的子树中可能有满足条件的节点。如果直接返回NULL，相当于把可能满足条件的节点一并删除了。</li>
<li><p>从常见误区中爬出来，又会觉得本题非常难，因为似乎要调整二叉树的结构。其实本题不需要像450.删除二叉搜索树中的节点那样分五种情况讨论来调整二叉树的结构。本题只需要在终止条件中分出三种情况讨论：</p>
<ul>
<li>root节点为空，则返回空</li>
<li>root节点小于区间左边界，则root节点的右子树中可能存在符合要求的节点。此时调用递归函数对root节点的右子树进行修剪，将修剪后右子树的头节点向上返回。</li>
<li>root节点大于区间右边界，则root节点的左子树中可能存在符合要求的节点。此时调用递归函数对root节点的左子树进行修剪，将修剪后左子树的头节点向上返回。</li>
</ul>
<p>最后在单层递归逻辑中，分别让root节点的左右指针接住修剪后的左右子树即可。终止条件负责返回，单层递归逻辑负责接收。</p>
</li>
<li>本题的基本原理和450.删除二叉搜索树中的节点相同，都是通过递归函数的返回值来移除节点，然后在单层递归逻辑中接住上一层递归的返回值。</li>
<li>本题的迭代法思路简单（终止条件-&gt;确保root在[low, high]的区间内-&gt;确保cur的左子树中没有小于low的节点-&gt;接着检查cur的右子树中没有大于high的节点），但代码非常容易写错（while循环中套着while，循环条件写得不对容易出现死循环），因此不推荐。还是建议老老实实地用递归法完成本题。</li>
</ol>
<h3 id="108-将有序数组转换为二叉搜索树-2"><a href="#108-将有序数组转换为二叉搜索树-2" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><ol>
<li>构造二叉树的一般思路：取数组最中间的元素作为二叉树的root节点。利用数组的左区间构造root节点的左子树，利用数组的右区间构造root节点的右子树。</li>
<li>在数组中元素个数为偶数时，数组最中间的元素有两个。此时，选取这两个元素中的任意一个作为root节点都可以。这样会构造出两棵不同的二叉搜索树，因此本题的结果不唯一。</li>
<li>本题递归函数的传入参数为数组和左右下标。在构造二叉树的时候尽量不要重新定义左右区间数组，而是用下标来操作原数组。</li>
<li><p><code>int mid = (left + right) / 2</code>最好写成<code>int mid = left + (right - left) / 2</code>。原因是两个整数相加可能会超出整数的最大范围。本题虽然采取第一种写法没事，但要有清醒的意识，避免出事。</p>
</li>
<li><p>注意循环不变量原则：区间要么一直保持为左闭右闭，要么一直保持为左闭右开。这关乎到终止条件的具体写法、递归时传入的区间下标以及主函数中调用递归函数时传入的下标。</p>
</li>
<li>本题的递归写法思路非常简单：先写终止条件，再取数组最中间的元素作为二叉树的root节点，再利用数组的左区间构造root节点的左子树，最后利用数组的右区间构造root节点的右子树，最后返回root节点即可。</li>
<li>本题的迭代写法代码比较复杂，不要求掌握。还是优先掌握递归写法。</li>
</ol>
<h3 id="538-把二叉搜索树转换为累加树-2"><a href="#538-把二叉搜索树转换为累加树-2" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h3><ol>
<li>先想如何把有序（递增）数组变为累加数组：<strong>倒序遍历数组，然后用双指针算法即可</strong>，即当前元素的新值等于当前元素的旧值加上前一个元素的值。根据这个思路解决本题。二叉搜索树通过中序遍历可以转换为有序数组，倒序遍历数组即相当于<strong>反中序遍历二叉搜索树</strong>。对树中节点值的累加也是通过<strong>双指针</strong>实现的。</li>
<li>本题的<strong>递归函数不需要返回值</strong>，原因：由于要遍历整个二叉树，在遍历的过程中去更新节点数值即可，因此不需要返回值。</li>
<li>本题的pre指针可以是整数类型的变量，也可以是指针类型的变量。若采用整数类型的变量，可以避免对指针是否为空的判断（整数的初始值为0），因此采用整数类型的变量作为pre更加方便。</li>
<li>本题是迭代的模板题，但我用迭代法写本题总是容易写错。因此还是推荐递归法。</li>
</ol>
<h3 id="总结篇"><a href="#总结篇" class="headerlink" title="总结篇"></a>总结篇</h3><ol>
<li><p>解决二叉树类题目的基本方法是递归法。一般使用了<strong>递归三部曲</strong>来分析题目，看到二叉树，看到递归，都应该想：返回值、参数是什么？终止条件是什么？单层逻辑是什么？</p>
</li>
<li><p>大多数题也都有迭代解法，但是一般代码更长也更容易写错，可以用于提升自己。</p>
</li>
</ol>
<p>二叉树类的题目可以分为以下几类：</p>
<h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>深度优先遍历<br>   二叉树：前中后序递归法：递归三部曲初次亮相<br>   二叉树：前中后序迭代法（一）：通过栈模拟递归<br>   二叉树：前中后序迭代法（二）统一风格</p>
<p>广度优先遍历<br>   二叉树的层序遍历：通过队列模拟</p>
<h4 id="求二叉树的属性"><a href="#求二叉树的属性" class="headerlink" title="求二叉树的属性"></a>求二叉树的属性</h4><p>二叉树：是否对称<br>递归：后序，比较的是根节点的左子树与右子树是不是相互翻转</p>
<p>二叉树：求最大深度<br>递归：后序，求根节点最大高度就是最大深度，通过递归函数的返回值做计算树的高度<br>迭代：层序遍历</p>
<p>二叉树：求最小深度<br>递归：后序，求根节点最小高度就是最小深度，注意最小深度的定义<br>迭代：层序遍历</p>
<p>二叉树：求有多少个节点<br>递归：后序，通过递归函数的返回值计算节点数量<br>迭代：层序遍历</p>
<p>二叉树：是否平衡<br>递归：后序，注意后序求高度和前序求深度，递归过程判断高度差</p>
<p>二叉树：找所有路径<br>递归：前序，方便让父节点指向子节点，涉及回溯处理根节点到叶子的所有路径</p>
<p>二叉树：递归中如何隐藏着回溯<br>详解二叉树：找所有路径中递归如何隐藏着回溯</p>
<p>二叉树：求左叶子之和<br>递归：后序，必须三层约束条件，才能判断是否是左叶子。</p>
<p>二叉树：求左下角的值<br>递归：顺序无所谓，优先左孩子搜索，同时找深度最大的叶子节点。<br>迭代：层序遍历找最后一行最左边</p>
<p>二叉树：求路径总和<br>递归：顺序无所谓，递归函数返回值为bool类型是为了搜索一条边，没有返回值是搜索整棵树。</p>
<h4 id="二叉树的修改与构造"><a href="#二叉树的修改与构造" class="headerlink" title="二叉树的修改与构造"></a>二叉树的修改与构造</h4><p>翻转二叉树<br>递归：前序，交换左右孩子</p>
<p>构造二叉树<br>递归：前序，重点在于找分割点，分左右区间构造</p>
<p>构造最大的二叉树<br>递归：前序，分割点为数组最大值，分左右区间构造</p>
<p>合并两个二叉树<br>递归：前序，同时操作两个树的节点，注意合并的规则</p>
<h4 id="求二叉搜索树的属性"><a href="#求二叉搜索树的属性" class="headerlink" title="求二叉搜索树的属性"></a>求二叉搜索树的属性</h4><p>二叉搜索树中的搜索<br>递归：二叉搜索树的递归是有方向的<br>迭代：因为有方向，所以迭代法很简单</p>
<p>是不是二叉搜索树<br>递归：中序，相当于变成了判断一个序列是不是递增的</p>
<p>求二叉搜索树的最小绝对差<br>递归：中序，双指针操作</p>
<p>求二叉搜索树的众数<br>递归：中序，清空结果集的技巧，遍历一遍便可求众数集合</p>
<p>二叉搜索树转成累加树<br>递归：中序，双指针操作累加</p>
<h4 id="二叉树公共祖先问题"><a href="#二叉树公共祖先问题" class="headerlink" title="二叉树公共祖先问题"></a>二叉树公共祖先问题</h4><p>二叉树的公共祖先问题<br>递归：后序，回溯，找到左子树出现目标值，右子树节点目标值的节点。</p>
<p>二叉搜索树的公共祖先问题<br>递归：顺序无所谓，如果节点的数值在目标区间就是最近公共祖先</p>
<h4 id="二叉搜索树的修改与构造"><a href="#二叉搜索树的修改与构造" class="headerlink" title="二叉搜索树的修改与构造"></a>二叉搜索树的修改与构造</h4><p>二叉搜索树中的插入操作<br>递归：顺序无所谓，通过递归函数返回值添加节点</p>
<p>二叉搜索树中的删除操作<br>递归：前序，想清楚删除非叶子节点的情况</p>
<p>修剪二叉搜索树<br>递归：前序，通过递归函数返回值删除节点</p>
<p>构造二叉搜索树<br>递归：前序，数组中间节点分割</p>
]]></content>
      <categories>
        <category>算法（二叉树）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>双指针算法</tag>
        <tag>递归解法</tag>
        <tag>迭代解法</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 26 Leetcode 39, 40, 131</title>
    <url>/2024/05/03/Day-26-Leetcode-39-40-131/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">39.组合总和</a><br><a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II</a><br><a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><p>创建一个和a数组大小相同的b数组，将其中的元素全部置为0。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a.size(), <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><p><code>substr(i, j)</code> 会从索引 <code>i</code> 开始，取长度为 <code>j</code> 的子字符串。</p>
<p><code>void backtracking(const string&amp; s, int startIndex)</code>中使用<code>const</code>的原因：</p>
<ol>
<li><strong>防止修改</strong>：<code>const</code> 关键字确保 <code>s</code> 字符串在 <code>backtracking</code> 函数中不会被修改。这是一种安全措施，可以防止函数意外地更改输入数据，从而保持数据的完整性。在处理函数参数时，尤其是在不应该或不需要修改输入的情况下，使用 <code>const</code> 可以提供这种保护。</li>
<li><strong>接口设计</strong>：在函数原型中使用 <code>const</code> 声明参数可以<strong>向函数的用户清楚地表明这个参数是用来输入数据的，不应该被函数改变</strong>。这有助于提高代码的可读性和可维护性，使得其他开发者更容易理解每个函数的作用和行为。</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h3><p>本题是集合里元素可以用无数次，那么和组合问题的差别，其实仅在于<code>startIndex</code>上的控制。本题若是想不重不漏，则下一层遍历的起始位置应该与上一层取出的数相同。而对于组合问题，下一层遍历的起始位置应该是上一层取出的数的下一个（因为组合问题中的元素不能重复使用）。据此，我写出了以下的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (s == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            s += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, s, i);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            s -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="40-组合总和II-1"><a href="#40-组合总和II-1" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><p>本题我能顺畅地写出不加去重的版本，如下所示。但对去重没有思路。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == target) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            s += candidates[i];</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, s, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            s -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对以下测试样例会出现报错：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">candidates =</span><br><span class="line">[10,1,2,7,6,1,5]</span><br><span class="line">target =</span><br><span class="line">8</span><br><span class="line">Output</span><br><span class="line">[[1,2,5],[1,7],[1,6,1],[2,6],[2,1,5],[7,1]]</span><br><span class="line">Expected</span><br><span class="line">[[1,1,6],[1,2,5],[1,7],[2,6]]</span><br></pre></td></tr></table></figure></p>
<p>很明显，上述代码是需要去重的。</p>
<h3 id="131-分割回文串-1"><a href="#131-分割回文串-1" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><p>拿到本题，我没有思路，因为没有做过分割问题，直接看卡尔的讲解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="39-组合总和-1"><a href="#39-组合总和-1" class="headerlink" title="39.组合总和"></a>39.组合总和</h3><p>本题与组合问题的区别：集合中的元素可以重复选取，组合中元素的数量不加限定。集合中都是正整数（若有0，则会进入死循环），且集合中没有重复的元素（这意味着不用做去重的操作）。</p>
<p>本题通过和来限制树的深度，而组合问题通过组合中元素的数量来限制树的深度。本题的树形结构如下所示：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-05-03_08-36-04.png?raw=true" alt="Snipaste_2024-05-03_08-36-04.png"></p>
<p>由于集合中的元素可以重复使用，因此下一层的集合中应该包括本层选取的元素。现在开始写本题的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用sum表示组合的和，也可以不用sum，让target不断做减法，直到target == 0</span></span><br><span class="line"><span class="comment">// startIndex用于设置下一层递归的起点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidate, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == target)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidate.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(candidate[i]);</span><br><span class="line">        sum += candidate[i];</span><br><span class="line">        <span class="comment">// 递归，注意下一层的startIndex是从i开始，因为集合中的元素可以重复选取</span></span><br><span class="line">        <span class="built_in">backtracking</span>(candidate, target, sum, i);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        sum -= candidate[i];</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码和回溯算法的模板是类似的。本题依然可以做剪枝的操作。具体来说，是对for循环进行剪枝。对<code>candidate</code>数组进行排序后，若某个分支的和大于target，那么就没必要对其后面的分支进行搜索了。加入剪枝操作的完整代码如下所示（注意添加了注释的部分，就是实现剪枝的具体代码）：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; s + candidates[i] &lt;= target; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            s += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, s, i);</span><br><span class="line">            s -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>剪枝操作总结：<strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]，相当于把下一层组合可能的sum从小到大扫了过去）已经大于target，就可以结束本轮for循环的遍历</strong>。</p>
<ul>
<li><p>时间复杂度: $O(n \times 2^n)$，注意这只是复杂度的上界，因为剪枝的存在，真实的时间复杂度远小于此。本题的时间复杂度分析同77. 组合。</p>
</li>
<li><p>空间复杂度: $O(target)$</p>
</li>
</ul>
<p><strong>为何是$O(target)$:</strong></p>
<ol>
<li><strong>递归栈深度：</strong> 空间复杂度首先取决于递归调用的最大深度，因为这直接影响了调用栈的大小。在组合总和问题中，你可以多次选择同一个数字，直到其和超过目标值 <code>target</code> 或恰好等于 <code>target</code>。最糟糕的情况发生在选择了最小元素直到达到 <code>target</code> 时，这种情况下，递归的最大深度大约是 <code>target / min(candidates)</code>。如果最小的候选数很小，理论上递归的深度可以接近 <code>target</code>。</li>
<li><strong>路径存储：</strong> 在递归过程中，我们还需要存储当前的组合路径（即当前选取的数字集合）。在最坏的情况下，即当所有选取的数字加起来等于 <code>target</code> 时，路径的长度也可以接近于 <code>target / min(candidates)</code>。尽管路径的具体长度依赖于候选数字的大小，但在分析空间复杂度时，我们考虑最坏情况，即多次选取最小值，使得路径长度和递归深度都接近于 <code>target</code>。</li>
</ol>
<h3 id="40-组合总和II-2"><a href="#40-组合总和II-2" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><p>本题差别：本题的集合中有重复的元素（之前的所有组合问题的集合中都没重复元素），<strong>不能有重复的组合</strong>。这说明我们要去重。另外，集合中的元素在组合中只能使用一次，这需要用一个变量进行控制。</p>
<p>一种朴素的想法：用之前的方法搜索组合，搜索出若干组合，其中肯定有重复的。用map或者set进行去重，输出去重后的所有组合。本方法实现起来较麻烦，且特别容易超时。</p>
<p>接下来介绍在搜索的过程中直接去重的方法：使用过的元素不重复使用。为了讲清楚本题的去重过程，卡尔自创了两个词汇：<strong>树层去重，树枝去重</strong>。去重要考虑到这两个维度。接下来画树形图，从两个维度看如何去重。去重前还需要对集合进行排序。去重需要一个数组<code>used</code>来告诉我们哪些元素使用过，哪些元素没用过。用过的元素的下标在<code>used</code>中对应的值为1，没用过的元素的下标在<code>used</code>中对应的值为0。<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/20230310000918.png?raw=true" alt="20230310000918.png"></p>
<p>上述树除去<code>used</code>数组外的基本部分，还是下一层第一个取的数是上一层取的数往后挪一位（即<code>backtracking(candidates, target, s, i + 1)</code>）。这样的目的是避免重复。对于树枝（树往深度方向走），是可以重复取值的，因为取的是一个集合中不同位置的数值相同的元素。对于树层（同一层树往横向走），不可以重复取值，必然会与之前的某个组合重复。对集合排序的目的就是将值相邻的元素放在一起，若同一层的两个分支的值相同，那么靠左边的分支会包含靠右边的分支的所有情况。<strong>因此去重的关键在于树层去重</strong>。具体的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本代码的重点在于树层去重的过程</span></span><br><span class="line"><span class="comment">// used数组用于标记某个元素是否使用过，用过1，没用过0</span></span><br><span class="line"><span class="comment">// 调用本函数前需要对集合做排序，目的是让值相同的元素在位置上相邻，方便做树层去重</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> targetSum, <span class="type">int</span> sum, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt; used)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (sum &gt; targetSum) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == targetSum) </span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">    <span class="comment">// for循环是在同一层遍历各个节点，因此接下来就要写树层去重的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 树层去重, i &gt; 0的目的是让i - 1 &gt;= 0，也可以写作i &gt; startIndex</span></span><br><span class="line">        <span class="comment">// used[i - 1] == 0对应于上面树的情况，就是第1个1没用，直接用了第2个1，此时重复读取，需要树层去重</span></span><br><span class="line">        <span class="comment">// 若nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 1，则说明是树枝的状态，由于不需要树枝去重，所以此时不需要去重</span></span><br><span class="line">        <span class="comment">// 后续在回溯算法中遇到去重问题并使用used数组时，基本都是这种写法</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 收集元素</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        used[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, targetSum, sum, i + <span class="number">1</span>, used);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        sum -= nums[i];</span><br><span class="line">        used[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以用<code>used</code>数组进行去重，也可以用<code>startIndex</code>进行去重，这里不再深入讲解。用<code>startIndex</code>去重比较抽象，因此理解用<code>used</code>数组去重即可，更易于理解且通用。本题的关键在于理解去重的思路。</p>
<p>本题的完整代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == target) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 树层去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            s += candidates[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, s, i + <span class="number">1</span>, used);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">            s -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// used数组用于标记candidates数组中的元素是否使用过，因此used数组大小应该与candidates数组大小保持相同</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(candidates.size(), <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>()); <span class="comment">// 别忘记排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度: $O(n \times 2^n)$。同77.组合和39.组合总和。<br>空间复杂度：$O(n)$。原因：树的最大深度为n（同<code>candidates</code>数组的长度）。</p>
<h3 id="131-分割回文串-2"><a href="#131-分割回文串-2" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><p>aab。有两种分割方案：aa|b和a|a|b。本题要求我们返回所有的分割方案。如何使用回溯算法解决这个问题？</p>
<p>分割问题和组合问题非常相似。例如abcdef，对组合问题，如果选择了a，则在bcdef中选择下一个字母；如果选择了b，则在cdef中选择下一个字母。同理，对于分割问题，如果分割了a，则接下来分割bcdef。再分割b，则接下来分割cdef。接下来画分割问题的树形结构。</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg?raw=true" alt="131.分割回文串.jpg"></p>
<p>切割线到了字符串的末尾，则切割完毕。结果都在叶子节点。画树形结构较为简单，具体的代码实现中有几个难点，现在开始写具体的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; path;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意传入的变量类型是const string，再加上引用</span></span><br><span class="line"><span class="comment">// startIndex控制下一次切割的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// 切割线到字符串的末尾，则终止</span></span><br><span class="line">    <span class="comment">// 切割线用startIndex表示</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将判断是否是回文的逻辑放入单层搜索的逻辑中</span></span><br><span class="line">        <span class="comment">// 因此终止条件中的path都是符合回文条件的</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如何用代码表示切割出的子串</span></span><br><span class="line">        <span class="comment">// 切割的子串：[startIndex, i]，左闭右闭的区间</span></span><br><span class="line">        <span class="comment">// 用于判断是否回文的函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, startIndex, i)) <span class="comment">// 传入字符串，子串的起始位置，子串的终止位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(子串); <span class="comment">// 是回文，则将子串放入path中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>); <span class="comment">// 下一层切割点从上一层切割点的下个位置开始，否则会重复</span></span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>isPalindrome</code>函数用双指针算法可以轻松实现。注意本题的两个细节：</p>
<ul>
<li><p><code>startIndex</code>是切割线</p>
</li>
<li><p>如何表示子串的范围：<code>[startIndex, i]</code></p>
</li>
</ul>
<p>完整的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断[start, end]是否是回文子串</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt;= j; i ++ , j -- )</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 是回文子串，则将其加入path中</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, startIndex, i))</span><br><span class="line">                path.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>时间复杂度: $O(n \times 2^n)$，时间复杂度同77.组合、39.组合总和、40.组合总和II。</p>
</li>
<li><p>空间复杂度: $O(n^2)$，原因解释如下：</p>
<ol>
<li><strong>递归栈的空间</strong>：最深的递归发生在当字符串每个字符都被分割时，因此递归深度最大为$n$（其中$n$是字符串的长度）。每一层递归需要保存当前索引和路径，这些额外的空间可以认为是常数级别的。</li>
<li><strong>路径存储空间</strong> (<code>path</code> 和 <code>res</code>):<ul>
<li><code>path</code> 变量在最坏情况下（每个字符都独立成一个回文串时）会存储$n$个元素。</li>
<li><code>res</code> 变量存储的是所有可能的分割方案。在极端情况下，如输入字符串完全由相同字符组成（例如 “aaaa”），<strong>分割方案的数量和其中每个方案的长度都可能接近$n$</strong>。但通常来说，我们只计算这个变量直接占用的空间，即指针或引用的空间，这通常也是$O(n^2)$，因为每个回文分割的保存都可能需要一个长度为 的$n$字符串的复制。</li>
</ul>
</li>
<li><strong>辅助空间</strong>：<ul>
<li>检查回文所用的额外空间是常量级的，不随输入大小变化。</li>
</ul>
</li>
</ol>
<p>将以上所有考虑结合，整个算法的空间复杂度主要由存储所有分割方案的数组 <code>res</code> 决定。由于每个分割方案可能包含多个字符串，而每个字符串又可能需要$O(n)$的空间，因此在最坏情况下，这部分的空间复杂度为$O(n⋅k)$，其中 $k$是分割方案的数量，这在极端情况下可以达到$O(n^2)$。</p>
</li>
</ul>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="39-组合总和-2"><a href="#39-组合总和-2" class="headerlink" title="39.组合总和"></a>39.组合总和</h3><ol>
<li>本题通过<code>target</code>来限制树的深度，而77. 组合通过组合中元素的个数来限制树的深度。</li>
<li>本题是集合里元素可以用无数次，那么和组合问题的差别，其实仅在于<code>startIndex</code>上的控制。本题若是想不重不漏，则下一层遍历的起始位置应该与上一层取出的数相同。而对于组合问题，下一层遍历的起始位置应该是上一层取出的数的下一个（因为组合问题中的元素不能重复使用）。</li>
<li>本题的时间复杂度：$O(n \times 2^n)$，空间复杂度：$O(target)$。</li>
<li>本题可以进行剪枝操作。具体来说，是对for循环进行剪枝。对<code>candidate</code>数组进行排序后，若某个分支的和大于target，那么就没必要对其后面的分支进行搜索了。体现在代码上，就是对总集合排序之后，如果下一层的sum（就是本层的sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历。<strong>本题的剪枝不好想，要多加注意</strong>。</li>
</ol>
<h3 id="40-组合总和II-3"><a href="#40-组合总和II-3" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><ol>
<li><p>本题的难点：集合有重复元素，但组合不能重复。</p>
</li>
<li><p>本题需要对组合去重，但不能在搜索完整棵树后用哈希法去重，容易超时。需要在搜索的过程中去重，这需要用到<code>used</code>数组。其中用过的元素标记为1，没用过的元素标记为0。</p>
</li>
<li><p>去重：只需要树层去重（树的同一层若两元素值相同，则右侧的值所在的路径必然被包含在左侧的值所在的路径中），不需要树枝去重（集合中的元素值可以相同，每个元素均可以使用一次，因此不需要对树枝去重）。</p>
</li>
<li><p>本题不可忽视的几个细节：</p>
<ul>
<li><p>集合需要进行排序，这是为了将值相同的元素放在集合中相邻的位置，便于树层去重</p>
</li>
<li><p><code>used</code>数组的大小需要与<code>candidates</code>数组保持相同，因为其是用来标记<code>candidates</code>数组中元素的使用情况的</p>
</li>
<li><p>注意树层去重的代码的写法，建议结合实际例子（实现中的图片）进行理解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树层去重</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == 0</code>说明同一树层上相邻的两个元素相同，此时需要进行树层去重</li>
<li><code>used[i - 1] == 1</code>，说明同一树枝上的<code>candidates[i - 1]</code>被使用过（同一树枝从上往下遍历，未进行回溯，因此<code>candidates[i - 1]</code>始终被标记为被使用过，即<code>used[i - 1] = 1</code>）</li>
<li><code>used[i - 1] == 0</code>，说明同一树层上的<code>candidates[i - 1]</code>被使用过（同一树层从左往右经历过回溯的过程：先对<code>candidates[i - 1]</code>所在的树枝从上往下遍历，然后回溯，再对<code>candidates[i]</code>所在的树枝从上往下遍历。在回溯的过程中，<code>candidates[i - 1]</code>被重新标记为未被使用过，即<code>used[i - 1] = 0</code>）</li>
</ul>
</li>
</ul>
</li>
<li><p>本题的去重代码不好写，同时细节较多需要注意。因此本题容易写错，需要时常复习。</p>
</li>
<li><p>后续在回溯算法中遇到去重问题并使用<code>used</code>数组时，基本都是这种写法：<code>if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == 0) continue;</code>。</p>
</li>
<li><p>本题也可以用<code>startIndex</code>进行去重，但比较难理解，因此不要求掌握。</p>
</li>
<li><p>本题可以像39.组合总和一样进行剪枝操作，只需要在for循环中对i加上限制条件：<code>s + candidates[i] &lt;= target</code>即可。</p>
</li>
</ol>
<h3 id="131-分割回文串-3"><a href="#131-分割回文串-3" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><ol>
<li><p>首先，切割问题其实本质和组合问题是相同的。</p>
<p>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…..。接着选取一个b后，再从cdef中再去选取第二个，以此类推。</p>
<p>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…..。接着从b那里切下去，在cded中再去切割第二段，以此类推。</p>
<p>可以观察本题的树形结构图，能够更加直观地理解切割问题和组合问题的相似。</p>
</li>
<li><p>什么是切割线？</p>
<p>递归参数需要传入<code>startIndex</code>，表示下一轮递归遍历的起始位置，这个<code>startIndex</code>就是切割线。</p>
</li>
<li><p>终止条件：切割线<code>startIndex</code>移动到了字符串的末尾，即<code>startIndex &gt;= s.size()</code></p>
</li>
<li><p>如何截取子串？<code>[startIndex, i]</code>之间的字符串就是子串。用<code>substr</code>函数截取即可。需要判断子串是否是回文串，是则放入<code>path</code>中，不是则<code>continue</code>。</p>
</li>
<li><p>使用最简单的双指针算法即可写出判断字符串是否是回文串的函数。</p>
</li>
<li><p>本题的空间复杂度$O(n^2)$。是极端情况下的空间复杂度，原因参见本题的实现部分。</p>
</li>
<li><p>从主函数传入的参数，在定义其他函数时若需要这个参数，则需要将其设置为<code>const</code>类型。目的是防止其他函数对这个参数的修改，同时向函数的用户清楚地表明这个参数是用来输入数据的。不加<code>const</code>不影响代码的正常运行，但加了<code>const</code>后代码更加规范。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法（回溯算法）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>回溯算法</tag>
        <tag>组合问题</tag>
        <tag>剪枝操作</tag>
        <tag>分割问题</tag>
        <tag>去重</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 3 | Leetcode 203, 707, 206</title>
    <url>/2024/01/26/Day-3-Leetcode-203-707-206/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">链表理论基础</a><br><a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">203.移除链表元素</a><br><a href="https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html">707.设计链表</a><br><a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">206.反转链表</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>链表是一种通过指针串联在一起的线性结构。每个节点等于数据域+指针域（存放指向下一个节点的指针）。最后一个节点的指针域指向null。头节点head。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png" alt="img"></p>
<p>单链表、双链表：既可以向前查询也可以向后查询。<br>循环链表：链表首尾相连（解决约瑟夫环问题）</p>
<p>链表在内存中不是连续分布的。其通过指针域的指针链接在内存中的各个节点。</p>
<p>链表的定义：<br>手写链表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过上述构造函数初始化节点：<code>ListNode* head = new ListNode(5);</code><br>使用默认构造函数初始化节点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p>
<p>添加节点：见图</p>
<p>数组和链表有不同的适用场景。数组适合数据量固定，频繁查找，较少增删的场景；链表适合数据量不固定，频繁增删，较少查询的场景。</p>
<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体中定义了两个变量和三个构造函数。class Solution中的removeElements函数返回的变量类型是ListNode*，即这个函数返回一个指向ListNode对象的指针。</p>
<p>如果使用C，C++编程语言的话，不要忘了还要从内存中删除这两个移除的节点。如果移除一个节点之后，没有手动在内存中删除这个节点，leetcode依然也是可以通过的，只不过，内存使用的空间大一些而已，但建议依然要养成手动清理内存的习惯。</p>
<p>删除头节点：</p>
<ul>
<li>直接使用原来的链表来进行删除操作：头节点后移一位</li>
<li>设置一个虚拟头结点在进行删除操作：原链表的所有节点就都可以按照统一的方式进行移除了，最后<code>return dummyNode-&gt;next;</code></li>
</ul>
<h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><ul>
<li>void函数可以直接return，表示退出</li>
<li>统一使用虚拟头节点的方式，便于进行增删改的操作</li>
<li>变量名前加_表示是这个类的变量，而非局部变量，这是cpp中的一种约定俗成</li>
</ul>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="203-移除链表元素-1"><a href="#203-移除链表元素-1" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p>对链表题我一直有点懵，不太熟悉链表题的格式，但是对用数组模拟链表倒是挺熟悉的。我知道算法的思路大致是：先定义一个虚的头节点，然后遍历链表，删去值等于val的节点，然后返回头节点指针指向的节点，就是新的头节点，但我不知道这种代码怎么写。</p>
<h3 id="707-设计链表-1"><a href="#707-设计链表-1" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p>这题yxc也教过，但是在他那里似乎是用数组模拟链表，实现链表的各种功能，而这里是调用链表完成函数中的功能，我认为这题不难，只是多个功能需要分别实现，单个功能的代码较为简单。这道题我基本会做，但<strong>处理边界条件时要倍加注意</strong>！！</p>
<h3 id="206-反转链表-1"><a href="#206-反转链表-1" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p>yxc也讲过这个题，但我也给完全忘了</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="203-移除链表元素-2"><a href="#203-移除链表元素-2" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><h4 id="方法1-特判头节点"><a href="#方法1-特判头节点" class="headerlink" title="方法1: 特判头节点"></a>方法1: 特判头节点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head -&gt; val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            head = head -&gt; next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除非头节点</span></span><br><span class="line">        ListNode* cur = head; <span class="comment">// cur存储要删去的节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 要删的节点cur-&gt;next不可为空, cur != NULL是考虑空链表的情况</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; cur -&gt; next != <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; next -&gt; val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* tmp = cur -&gt; next;</span><br><span class="line">                cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cur = cur -&gt; next; <span class="comment">// 后移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2-加入虚拟头节点"><a href="#方法2-加入虚拟头节点" class="headerlink" title="方法2: 加入虚拟头节点"></a>方法2: 加入虚拟头节点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建虚拟头节点</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead -&gt; next = head;</span><br><span class="line">        <span class="comment">// 上面的两行代码：创建虚拟头节点可以简写为：</span></span><br><span class="line">        <span class="comment">// ListNode* dummyHead = new ListNode(0, head);</span></span><br><span class="line">        <span class="comment">// 或者ListNode* dummyHead = new ListNode();</span></span><br><span class="line">        <span class="comment">// dummyHead -&gt; next = head;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统一方法删去值为val的节点</span></span><br><span class="line">        <span class="comment">// 从虚拟头节点开始遍历, cur为目标节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 此时因为加入了虚拟头节点，因此链表不可能为空，因此不再需要考虑链表为空的判断条件：cur != NULL</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur -&gt; next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; next -&gt; val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* tmp = cur -&gt; next;</span><br><span class="line">                cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head = dummyHead -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以方法2为主。</p>
<h3 id="707-设计链表-2"><a href="#707-设计链表-2" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 记住struct的写法</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedList* next;</span><br><span class="line">        <span class="built_in">LinkedList</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化, 带下划线的变量表示类中的变量，而非局部变量</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(<span class="number">0</span>); <span class="comment">// 虚拟头节点</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; ( _size - <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        LinkedList* cur = _dummyHead -&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index -- ) cur = cur -&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedList* head = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line">        head -&gt; next = _dummyHead -&gt; next;</span><br><span class="line">        _dummyHead -&gt; next = head;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedList* tail = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line"></span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        <span class="comment">// while循环中的条件不能是_size -- ，不然会破坏链表长度的准确性</span></span><br><span class="line">        <span class="keyword">while</span>(cur -&gt; next != <span class="literal">NULL</span>) cur = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = tail;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size || index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        LinkedList* node = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(index -- ) cur = cur -&gt; next;</span><br><span class="line"></span><br><span class="line">        node -&gt; next = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = node;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= _size) <span class="keyword">return</span>;</span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index -- ) cur = cur -&gt; next;</span><br><span class="line">        LinkedList* tmp = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        _size -- ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LinkedList* _dummyHead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="206-反转链表（常考）"><a href="#206-反转链表（常考）" class="headerlink" title="206.反转链表（常考）"></a>206.反转链表（常考）</h3><p>是考察对基础数据结构操作非常好的一道题目。先掌握双指针解法，再掌握递归的解法。根据双指针代码写出递归代码。</p>
<h4 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h4><p><img src="https://github.com/yfchenkeepgoing/image/blob/main/leetcode206.png?raw=true" alt="leetcode206.png"></p>
<p>具体解法：由于不需要让翻转以后的链表的头节点为空，因此当cur指向NULL时，遍历结束。因此循环为：<code>while(cur)</code>，cur == NULL为遍历的终止条件。</p>
<p>更新cur和pre的方式：用临时节点将cur的下一个节点保存下来。否则一旦反转后cur的写一个节点就会丢失（反转后的链表的下一个节点是pre）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = cur -&gt; next;</span><br><span class="line">            cur -&gt; next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归解法1"><a href="#递归解法1" class="headerlink" title="递归解法1"></a>递归解法1</h4><p>按照双指针的思路写递归的代码。递归的代码更简短但更难懂。</p>
<p>具体解法：定义一个reverse函数，其中有两个参数，即<code>reverse(cur, pre)</code>。</p>
<p>在主函数中调用reverse函数，需要传入两个参数cur和pre，前者对应于双指针解法中的head，后者对应于双指针解法中的null。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 仿照双指针解法，递归函数中需要传入两个参数：cur和pre</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* cur, ListNode* pre)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 先检查递归的终止条件，同双指针解法</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再执行递归的步骤</span></span><br><span class="line">        <span class="comment">// 同双指针解法中tmp = cur -&gt; next, cur -&gt; next = pre, pre = cur, cur = tmp</span></span><br><span class="line">        ListNode* tmp = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(tmp, cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 双指针解法中初始时cur = head, pre = NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(head, <span class="literal">NULL</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归解法2"><a href="#递归解法2" class="headerlink" title="递归解法2"></a>递归解法2</h4><p>另一种递归解法，思路和递归解法1完全不同，我认为相比于递归解法1更好理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断终止条件是否成立</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 空链表，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head; <span class="comment">// 递归结束，返回反转后链表的head</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行递归流程</span></span><br><span class="line">        ListNode* last = <span class="built_in">reverseList</span>(head-&gt;next); <span class="comment">// 从第二个节点开始反转链表</span></span><br><span class="line">        <span class="comment">// 将原来的头节点接到反转后链表的尾节点之后，反转后链表的尾节点是head-&gt;next</span></span><br><span class="line">        head-&gt;next-&gt;next = head; </span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 尾节点指向空</span></span><br><span class="line">        <span class="keyword">return</span> last; <span class="comment">// 返回反转后链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h3><ol>
<li>插入虚拟头节点dummyHead，可以避免空链表并避免对头节点操作的特判</li>
<li>创建一个当前节点cur，对整个链表进行遍历（<code>cur = cur-&gt;next</code>），而不用链表中原本存在的节点对链表进行遍历</li>
<li>NULL节点表示不存在的节点；虚拟节点实际上是存在的，其值为0，是人为创建的节点</li>
<li>递归时，需要先检查递归的终止条件，然后执行递归步骤</li>
</ol>
<h3 id="203-移除链表元素-3"><a href="#203-移除链表元素-3" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><ol>
<li>想要删除一个节点，需要先用tmp存下它，然后再delete删去之。</li>
<li>以后写，尽量采用方法2，即加入虚拟头节点。</li>
<li>cur -&gt; next表示的是cur节点的next变量（即指针域），而cur -&gt; val表示的是cur节点的val变量（即节点的值）。通过构造函数也可以给这两个变量直接赋值。</li>
<li>在方法1中，一定要加上判断条件<code>cur != NULL</code>，因为当链表为空时，<code>while (cur -&gt; next != NULL)</code> 这个条件将尝试访问 <code>NULL</code> 指针的 <code>next</code> 成员，这将触发未定义行为，从而导致程序报错。在方法2中，则不需要加上判断条件<code>cur != NULL</code>，因为有虚拟头节点的存在，链表不可能为空，至少有一个节点（即虚拟头节点）。当然，在方法2中加上这个判断条件也不会影响程序的正常运行。</li>
</ol>
<h3 id="707-设计链表-3"><a href="#707-设计链表-3" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><ol>
<li>想清楚一个极端情况：返回第0个节点的值，是否会出现空指针异常等错误。</li>
<li>cur节点都赋值为_dummyHead</li>
<li>注意删除第n个节点时的内存释放问题</li>
<li>在第n个节点前增加或者删除一个节点，应该让cur指向第n-1个节点，cur-&gt;next指向第n个节点。</li>
<li>注意插入节点时先更新后面的边，再更新前面的边</li>
<li>只要传入参数index，就要记得对index进行判断，排除掉不需处理的情况。对get函数和deleteAtIndex函数，判断条件都是<code>index &lt; 0 || index &gt; _size - 1</code>，但对addAtIndex函数，判断条件是<code>index &lt; 0 || index &gt; _size</code>，因为<code>index = _size</code>表示将节点插入到链表的末尾。</li>
<li>别忘记_size ++ / _size — </li>
</ol>
<h3 id="206-反转链表-2"><a href="#206-反转链表-2" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><h4 id="双指针解法-1"><a href="#双指针解法-1" class="headerlink" title="双指针解法"></a>双指针解法</h4><p>代码量少，思维量大！需要明确：cur和pre初始的取值；循环终止的条件；如何更新pre和cur。画图理解即可。</p>
<h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><p>递归解法1参照双指针解法写。<strong>这题推荐就用双指针解法，比较清楚明白</strong>，且空间复杂度为O(1)，优于递归解法的空间复杂度O(n)。递归解法2相比于递归解法1更好理解。</p>
]]></content>
      <categories>
        <category>算法（链表）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>双指针算法</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 27 Leetcode 93, 78, 90</title>
    <url>/2024/05/06/Day-27-Leetcode-93-78-90/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html">93.复原IP地址</a><br><a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集</a><br><a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><ol>
<li><p>cpp中的string是有pop_back方法的，用于弹出字符串中的最后一个元素。</p>
</li>
<li><p>字符串中在i的后面插入一个逗点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span> , <span class="string">&#x27;.&#x27;</span>);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>删除特定位置处的逗点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);       </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="93-复原IP地址-1"><a href="#93-复原IP地址-1" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><p>我尝试按照131.分割回文串的思路做本题，也写出了相应的代码，但运行结果和答案相差很大，而且代码非常复杂。我来看看卡尔的解法，看看如何写出正确而简单地处理这种字符串类型的回溯题的代码。</p>
<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h3><p>据卡尔说，子集问题，就是收集树形结构中，每一个节点的结果。 整体代码其实和回溯模板都是差不多的。 对于本题的树形结构，我有一个想法：以1, 2, 3为例，首先选中1前面的空位，则要收集空和123。然后选中1，则要收集1和23。然后选中2，则要收集2和13。然后选中3，则要收集3和12。共有8个子集。但本题的代码我写不出来，直接看卡尔的视频讲解。</p>
<h3 id="90-子集II"><a href="#90-子集II" class="headerlink" title="90.子集II"></a>90.子集II</h3><p>本题是40.组合总和II再加上78.子集。利用40题的去重办法（树层去重，用<code>used</code>数组，即<code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 0)</code>），利用78题的子集问题的解法（主要是在所有节点而不仅仅是叶子节点上收集答案）。据此，我独立写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 树层去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>, used);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 一定记得要对nums排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="93-复原IP地址-2"><a href="#93-复原IP地址-2" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><p>合法的IP地址：</p>
<ul>
<li>每个整数位于 0 到 255 之间组成</li>
<li>数字前不能有0，即不能有先导0</li>
<li>不能出现非0-9的字符</li>
</ul>
<p>因此本题不仅需要对字符串进行切割，还要对子串进行合法性的判断。本题在回溯算法的切割问题中是一道较有难度的题。做了131.分割回文串后，再来做本题，会易于理解一些。使用回溯算法暴力枚举分割的每一种情况。画树形结构图。</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/20201123203735933.png?raw=true" alt="20201123203735933.png"></p>
<p>画出了上述树形图后，写代码还会有疑惑：</p>
<ul>
<li><p>如何模拟切割线</p>
</li>
<li><p>怎么固定切割线，再在剩余的字符串中进行切割</p>
</li>
<li><p>切割出的子串如何表达</p>
</li>
</ul>
<p>接下来写具体的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// startIndex表示下一层递归切割的位置，即切割线</span></span><br><span class="line"><span class="comment">// 一个IP需要有三个逗点进行分割，pointSum用于统计逗点的数量, pointSum决定了树的深度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> startIndex, <span class="type">int</span> pointSum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="comment">// 每次加逗点，都是对其前面的子串做合法性判断</span></span><br><span class="line">    <span class="comment">// 此时还需要专门对最后一个子串做合法性判断，最后一个子串合法了，才能将整个IP地址加入结果集中</span></span><br><span class="line">    <span class="comment">// isvalid用于判断一个子串是否合法：数字前不能有0，数字在0-255之间，子串中不能有非法字符</span></span><br><span class="line">    <span class="keyword">if</span> (pointSum == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isvalid</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) <span class="comment">// 左闭右闭</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s); <span class="comment">// s会在后面被修改，具体来说是被切割并加上逗点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 切割后，对产生的第一个子串的合法性进行判断。子串的区间：[startindex, i]</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isvalid</span>(s, startIndex, i))</span><br><span class="line">        &#123;</span><br><span class="line">        	  <span class="comment">// 进入下一层递归前，需要在子串后面加上逗点</span></span><br><span class="line">            <span class="comment">// 将.插入到s.begin() + i的后面，故传入的参数是s.begin() + i + 1</span></span><br><span class="line">            s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            pointSum += <span class="number">1</span>; <span class="comment">// 逗点数量+1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="comment">// 由于给字符串s额外加了一个逗点，因此是i + 2（本来是i + 1）</span></span><br><span class="line">            <span class="built_in">backtracking</span>(s, i + <span class="number">2</span>, pointSum);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>); <span class="comment">// 删除s中插入的逗点</span></span><br><span class="line">            pointSum -= <span class="number">1</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码的精妙之处在于，就是在原来的字符串<code>s</code>的基础上进行修改，修改就是在合适的位置上添加逗点。本题的关键在于如何模拟切割的过程。切割的过程本质上和组合问题的取数的过程是一样的。另外还需要对子串进行合法性的判断，子串是<code>[startIndex, i]</code>。子串合法后再加上逗点。</p>
<p>根据上述核心代码，我独立写出了解决本题的完整的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接在s的基础上添加逗号，得到可能的IP地址</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断区间[start, end]的合法性</span></span><br><span class="line">    <span class="comment">// 三个要求：1. 没有非数字的字符</span></span><br><span class="line">    <span class="comment">// 2. 在0-255之间</span></span><br><span class="line">    <span class="comment">// 3. 没有先导0</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        string tmp = s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先导0</span></span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; tmp[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = tmp.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 非数字的字符</span></span><br><span class="line">            <span class="keyword">if</span> (tmp[i] &lt; <span class="string">&#x27;0&#x27;</span> || tmp[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            sum += (tmp[i] - <span class="string">&#x27;0&#x27;</span>) * d;</span><br><span class="line">            d = d * <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// startIndex为分割线，dotSum为逗点数目</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> startIndex, <span class="type">int</span> dotSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (dotSum == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对第四段(s的最后一段)做合法性判断</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isvalid</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">        <span class="comment">// 区间[startIndex, i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对区间合法性进行判断</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isvalid</span>(s, startIndex, i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 合法，则插入逗点</span></span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                dotSum ++ ;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递归，本区间终止于i, 故下一个区间开始于i + 2</span></span><br><span class="line">                <span class="built_in">backtracking</span>(s, i + <span class="number">2</span>, dotSum);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);</span><br><span class="line">                dotSum -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>isvalid</code>函数可以写的更简洁更自然：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先导0</span></span><br><span class="line">    <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 非数字字符</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 在0-255之间</span></span><br><span class="line">        num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度: $O(3^4)$，IP地址最多包含4个数字，每个数字最多有3种可能的分割方式（1位，2位，3位）；<strong>则搜索树的最大深度为4，每个节点最多有3个子节点</strong>（对应每个数字可能是1位，2位，3位的情况）。</li>
<li>空间复杂度: $O(n)$，原因如下：<ul>
<li><strong>递归栈</strong>：递归的深度固定，最多为4，因为IP地址由四部分组成。但这并不直接决定空间复杂度，因为递归深度很小。</li>
<li><strong>存储当前解</strong>：在递归过程中，需要存储当前正在构建的IP地址，这需要额外的空间。此外，每次递归调用时，都可能创建字符串的子串来表示IP地址的某一部分。字符串的最大长度为输入字符串的长度n，因此需要额外的空间来存储这些子串。</li>
<li><strong>输出解的集合</strong>：输出的解的数量并不直接影响空间复杂度的理论计算，但实际上会使用额外空间来存储所有可能的IP地址。然而，这些空间通常不计入空间复杂度计算中，因为它不依赖于递归过程中的临时存储需求。</li>
</ul>
</li>
</ul>
<h3 id="78-子集-1"><a href="#78-子集-1" class="headerlink" title="78.子集"></a>78.子集</h3><p>之前讲的组合问题、分割问题，我们都是在树形结构的叶子节点上收获结果，因此在终止条件处收获结果。可以画出如下的树形结构：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png" alt="78.子集"></p>
<p>观察如上树形结构，发现我们想收获的结果其实在每一个节点中。因此不是在终止条件中收获结果，而是每进入一层递归就将单个结果放入结果集中。现在开始对着树形结果写代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一维数组存放单个结果</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="comment">// 二维数组作为结果集</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// startIndex：下一层递归从哪里开始取数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每进入一层递归，都要将当前的path放入结果集中</span></span><br><span class="line">    <span class="comment">// 因为要将叶子节点的集合放入结果集中，然后再结束，因此先有本逻辑，再有终止条件</span></span><br><span class="line">    res.<span class="built_in">push_back</span>(path); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 终止条件：走到叶子节点，叶子节点的剩余集合都为空</span></span><br><span class="line">    <span class="comment">// 本终止条件可以不写，因为单层搜索逻辑中的for循环已经对startIndex的大小进行了限制</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层搜索逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每进入一层递归，都要收获当前节点的结果，放入单个结果数组中</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不写终止条件的写法如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="90-子集II-1"><a href="#90-子集II-1" class="headerlink" title="90.子集II"></a>90.子集II</h3><p>与78的区别：给的集合中允许有重复的元素，因此需要对重复子集去重。本题的关键在于去重，本题是子集+组合总和II（树层去重）的结合，并没有新的知识点。</p>
<p>本题的树形结构。<code>used</code>数组用于记录某个元素是否出现过。因为去重要让大小相邻的元素挨在一起，因此需要先对数组进行排序。本题的去重是树层去重（树层上相邻的元素如果相等，则不能重复取，否则会得到重复的子集），树枝不需要去重。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124195411977.png" alt="90.子集II"></p>
<p>现在开始写代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 单个结果</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 结果集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件不需要写，在for循环中实际上已经限制了startIndex的大小</span></span><br><span class="line">    res.<span class="built_in">push_back</span>(path); <span class="comment">// 收获结果，需要在每个节点都收获结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 树层去重, used[i - 1] == 0意味着第i - 1个元素是第i个元素的回溯</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] = <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        used[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>, used);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回溯中的去重逻辑都这么写。本题去重也可以用startIndex和i进行比较来实现，但这种去重写法并不通用，遇到排列问题时依然要用used数组的写法进行去重。去重的写法掌握<code>used</code>数组写法即可。</p>
<p>本题的时间和空间复杂度和78相同。时间复杂度: $O(n\times2^n)$，空间复杂度: $O(n)$。</p>
<p>本题也可以用哈希法去重，但时间复杂度更高，虽然也能够通过所有测试样例且不超时，代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// set去重</span></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(nums[i]) != s.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            s.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// set去重依然需要排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因此，本题的去重写法有三种：</p>
<ul>
<li><code>used</code>数组去重</li>
<li><code>startIndex</code>去重</li>
<li><code>set</code>去重</li>
</ul>
<p>掌握第一种即可。第一种是思路最清晰也最通用的。</p>
<p>本题像78一样，也可以不写终止条件，因为<code>startIndex</code>的大小在for循环中已经得到了限制。精简版本的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>, used);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="93-复原IP地址-3"><a href="#93-复原IP地址-3" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><ol>
<li>本题是131.分割回文串的加强版。因为和131同样是用回溯法求解的分割问题，所以基本原理是相同的，比如<code>startIndex</code>用于作为分割线，分割的区间是<code>[startIndex, i]</code>。</li>
<li>本题的终止条件和131有显著地不同。131的终止条件是<code>startIndex</code>移动到字符串的末尾，而本题的终止条件是添加了3个逗点，且最后一段区间是合法的。3个逗点的终止条件也限制了树的深度。</li>
<li>一般处理字符串的问题都比较复杂。本题对字符串处理的精妙之处在于直接在原本的字符串<code>s</code>上进行修改，添加逗点，作为分隔符从而得到合法的IP地址。本题还用到了两个和字符串有关的STL，分别是<code>insert</code>和<code>erase</code>函数。</li>
<li>本题对区间合法性的判断较为复杂，共有3个要求：<ul>
<li>段位以0为开头的数字不合法</li>
<li>段位里有非正整数字符不合法</li>
<li>段位如果大于255了不合法</li>
<li>段位若大于255，则立即判断为不合法，<code>return false</code>。若完成for循环后再对<code>num</code>进行判断，可能出现整数型变量溢出</li>
</ul>
</li>
<li>本题的时间复杂度：$O(3^4)$，空间复杂度：$O(n)$</li>
<li>本题的细节比较多，比较容易写错，属于回溯法解决分割问题中的难题，需要不断复习。</li>
</ol>
<h3 id="78-子集-2"><a href="#78-子集-2" class="headerlink" title="78.子集"></a>78.子集</h3><ol>
<li>子集是收集树形结构中树的所有节点的结果。而组合问题、分割问题是收集树形结构中叶子节点的结果。</li>
<li>子集也是一种组合问题，因为它的集合是无序的，子集{1,2}和子集{2,1}是一样的。那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始。</li>
<li>先收集结果集，再写终止条件的原因：当递归到叶子节点时，要先将叶子节点的结果放入结果集中，再终止，因此先写收集结果集的逻辑，再写终止条件。否则叶子节点的结果无法被放入结果集中。</li>
<li>本题也可以不写终止条件，因为单层递归逻辑的for循环中实际上限制了<code>startIndex</code>的大小，因此最后<code>return</code>即可。但初学者还是建议写终止条件，和标准的回溯模板保持一致。</li>
<li>本题的时间复杂度: $O(n\times2^n)$，空间复杂度: $O(n)$。时间和空间复杂度的分析同<a href="https://yfchenkeepgoing.github.io/2024/05/01/Day-24-Theory-of-Backtracking-Algorithms-Leetcode-77/">77.组合</a>。</li>
</ol>
<h3 id="90-子集II-2"><a href="#90-子集II-2" class="headerlink" title="90.子集II"></a>90.子集II</h3><ol>
<li><p>本题是40.组合总和II与78.子集这两题的结合。</p>
</li>
<li><p>40的精华在于去重（树层去重），78的精华在于在每个节点处都收集结果（而不是像组合、分割问题那样在叶子节点，即终止条件处收集结果），而是在递归函数的开始处（进入递归相当于进入一个节点）收集结果。本题结合了两题的精华。</p>
</li>
<li><p>树层去重掌握<code>used</code>数组写法即可，具体代码为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure></li>
<li>树层去重前，需要对<code>nums</code>数组进行排序。</li>
<li>本题的时间和空间复杂度和上一题（78）相同。</li>
<li>去重共有三种写法，掌握思路最清晰也最通用的<code>used</code>数组写法即可。</li>
<li>本题像78一样，也可以不写终止条件，因为<code>startIndex</code>的大小在for循环中已经得到了限制。</li>
</ol>
]]></content>
      <categories>
        <category>算法（回溯算法）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>回溯算法</tag>
        <tag>切割问题</tag>
        <tag>子集问题</tag>
        <tag>树层去重</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 18 Leetcode 513, 112, 106</title>
    <url>/2024/03/12/Day-18-Leetcode-513-112-106/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html">513.找树左下角的值</a><br><a href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">112. 路径总和，113. 路径总和ii</a><br><a href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html">106.从中序与后序遍历序列构造二叉树，105.从前序与中序遍历序列构造二叉树</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h3><p><code>vector&lt;int&gt; lm(inorder.begin(), inorder.begin() + i);</code>创建了一个左闭右开的区间。在C++中，<code>std::vector</code>的这个构造函数接受两个迭代器作为参数，分别表示要复制的范围的开始和结束。这个范围遵循左闭右开的原则，即包括开始位置的元素，但不包括结束位置的元素。</p>
<p><strong>注意：不可以写作<code>vector&lt;int&gt; lm(0, i)</code>。传入数字的功效和传入迭代器的功效是完全不同的，传入数字的写法无法运行出正确的结果。只有传入两个迭代器的写法是表示创建了一个左闭右开的区间。</strong></p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h3><p>拿到本题后，我先复习了层序遍历的代码，然后先拿层序遍历法尝试一下。本题果然可以简单地用层序遍历解决：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (size -- )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面两行代码可以简写为return res.back().front();</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans = res.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在尝试用递归做本题。首先需要考虑前/中/后序遍历。发现确实不好写，不知道该采用怎样的遍历顺序，且终止条件也不知道该怎么写，直接看卡尔的讲解。</p>
<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h3><p>本题用层序遍历肯定不好做，因为涉及到从root节点到叶子节点。我尝试用递归解决本题。本题肯定涉及到回溯，搜索完一条root节点到叶子节点的和之后，若没找到targetSum，还需要返回root节点，寻找到新的叶子节点的路径。我不会做此题，直接看卡尔的讲解。</p>
<h3 id="113-路径总和ii"><a href="#113-路径总和ii" class="headerlink" title="113. 路径总和ii"></a>113. 路径总和ii</h3><p>本题我尝试用112的方法独立完成，但是没有成功，其实我写的代码离能成功运行的代码已经很接近了，思路没错就是部分细节不对。本题的方法应该和112相同，但代码实现上会复杂一些。</p>
<h3 id="106-从中序与后序遍历序列构造二叉树-1"><a href="#106-从中序与后序遍历序列构造二叉树-1" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h3><p>本题是二叉树中的难题，我没有什么思路，直接来看卡尔的视频。</p>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h3><p>本题的核心思路和106完全一致，我独立写出了本题的代码。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="513-找树左下角的值-1"><a href="#513-找树左下角的值-1" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h3><p>树左下角的值：树的最后一行最靠左侧的值（不一定是左孩子）。本题用层序遍历（迭代法）最合适，目标值就是最后一层的第一个值。<strong>本题用迭代法比用递归法更简单直观</strong>。现在主要讲解递归法。</p>
<p>如何用递归法找到树左下角的值？深度最大的叶子节点一定在最后一行。因为本题不需要处理中节点，只需要先遍历左节点即可，<strong>因此本题使用前中后序遍历都可</strong>。<strong>只要保证先遍历左节点，且得到的是深度最大的节点</strong>，找到的就是最后一行最靠左侧的节点。现在开始写代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录二叉树最大深度的全局变量</span></span><br><span class="line"><span class="type">int</span> maxDepth = INT_MIN; <span class="comment">// 初始化为int中的最小值</span></span><br><span class="line"><span class="type">int</span> res; <span class="comment">// 若当前深度大于maxDepth，则更新res为当前节点的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// depth用于记录当前遍历的节点的深度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件：遍历到叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若当前深度大于maxDepth，则更新res为当前节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; maxDepth) </span><br><span class="line">        &#123;</span><br><span class="line">            maxDepth = depth;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 单层递归的逻辑，前中后序遍历皆可，本题不需要中节点的处理逻辑</span></span><br><span class="line">    <span class="comment">// 左节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        depth ++ ;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, depth); <span class="comment">// 递归</span></span><br><span class="line">        depth -- ; <span class="comment">// 回溯，即回退到左节点的父节点，然后遍历父节点的右节点，不回溯则会一直向左遍历</span></span><br><span class="line">        <span class="comment">// 以上三行代码可以简写为traversal(root-&gt;left, depth + 1)</span></span><br><span class="line">        <span class="comment">// 因为depth + 1并没有改变depth的值，相当于在traversal中+1，在traversal之后复原</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 右节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        depth ++ ;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, depth);</span><br><span class="line">        depth -- ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题的递归解法同样显示地展现了回溯。根据上述核心代码，我写出了本题递归解法的完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth = INT_MIN; <span class="comment">// 直接int maxDepth = 0也可以</span></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件，遍历到叶子节点</span></span><br><span class="line">        <span class="comment">// 若当前深度大于最大深度，则需要更新最大深度和结果</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth &gt; maxDepth)</span><br><span class="line">            &#123;</span><br><span class="line">                res = root-&gt;val;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归的逻辑</span></span><br><span class="line">        <span class="comment">// 左节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            depth ++ ;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;left, depth);</span><br><span class="line">            depth -- ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            depth ++ ;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;right, depth);</span><br><span class="line">            depth -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root, <span class="number">1</span>); <span class="comment">// root节点的深度一般被规定为1，当然规定为0也可以</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题的层序遍历解法其实也有更简便的写法，不需要浪费空间复杂度来存储树中的所有元素的值。代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) res = node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="112-路径总和-1"><a href="#112-路径总和-1" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h3><p>题意：有无从root节点到叶子节点的一条路径，路径上所有元素之和等于目标和。推荐使用递归法。本题使用前中后序遍历皆可，因为不涉及中节点的处理逻辑，因此中节点放在哪里都可以。规则看似简单，但代码不好写。现在开始写代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值为bool类型，找到一条符合条件的路径，立即从下（叶子节点）往上（根节点）返回true</span></span><br><span class="line"><span class="comment">// cnt：计数器，在主函数中传入目标值</span></span><br><span class="line"><span class="comment">// 如果传入0，从上往下遍历每遍历到一个节点就加上这个节点的值，看遍历到叶子节点时cnt是否等于target，这样代码更复杂，不如直接传入target，每次遍历到一个节点就在target中减去该节点的值，看到叶子节点时cnt是否为0</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> cnt)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件：遇到叶子节点且cnt=0</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span> &amp;&amp; cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span> &amp;&amp; cnt != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 单层递归逻辑</span></span><br><span class="line">    <span class="comment">// 左节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt -= node-&gt;left-&gt;val; <span class="comment">// 从cnt中减去左节点的值</span></span><br><span class="line">        <span class="comment">// 若返回true，则说明node的左孩子到叶子节点的路径中有符合题目要求的路径</span></span><br><span class="line">        <span class="comment">// 此时目标值为cnt -= node-&gt;left-&gt;val</span></span><br><span class="line">        <span class="comment">// 此时应该继续向上返回true，这样才能一层层将true的结果返回给根节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">traversal</span>(node-&gt;left, cnt)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 回溯，遍历到叶子节点后，需要回退到根节点去遍历一条新的路径，因此需要回溯</span></span><br><span class="line">        <span class="comment">// 若不回溯，则cnt一直做减法，则遍历完左子树后，遍历右子树时根本不可能找到符合条件的路径</span></span><br><span class="line">        cnt += node-&gt;left-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 右节点，逻辑同上</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt -= node-&gt;right-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">traversal</span>(node-&gt;right, cnt)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        cnt += node-&gt;right-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一直不return true, 则return false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码没有对中节点的处理逻辑，因此前中后序都可以。对左右节点的处理逻辑可以简写为一句话，我以左节点为例：<code>if (traversal(node-&gt;left, cnt -= node-&gt;left-&gt;val)) return true;</code>，但不建议这样写，因为无法清晰地看到回溯的逻辑。</p>
<p>本题的完整代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件：遍历到叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span> &amp;&amp; cnt == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL &amp;&amp; cnt != 0)</span></span><br><span class="line">        <span class="comment">//     return false;</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 左节点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt -= node-&gt;left-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(node-&gt;left, cnt)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            cnt += node-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt -= node-&gt;right-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(node-&gt;right, cnt)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            cnt += node-&gt;right-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="113-路径总和ii-1"><a href="#113-路径总和ii-1" class="headerlink" title="113. 路径总和ii"></a>113. 路径总和ii</h3><p>本题由于要遍历整棵树，找到所有路径，因此递归函数不要返回值，遍历完整棵树后，在函数外定义好的 <code>path</code>和 <code>res</code>中自然会被递归函数写入应有的结果。如果只是要找树中符合条件的一条路径，那么递归函数就要返回值，一旦遍历到叶子节点时找到了合适的路径，就立即返回true，要是一直找不到符合条件的路径，再返回false。</p>
<p>本题的代码相较于上一题要复杂一些，但<strong>核心思路其实是相同的</strong>。以下几点是与112的主要差异。</p>
<ul>
<li>首先定义一个 <code>vector&lt;int&gt; path</code>来存放一条符合条件的路径，再定义一个 <code>vector&lt;vector&lt;int&gt;&gt; res</code>来存放树中所有符合条件的路径。</li>
<li>在针对左右节点的操作中，需要回溯，但与112不同的是，本题中的回溯不仅需要回溯 <code>cnt</code>，还需要回溯 <code>path</code>中的元素（先将左右节点放入path中，回溯时又从path中弹出左右节点）。</li>
<li>由于本题的递归函数没有返回值，因此只需要返回空即可，即 <code>return;</code>。</li>
<li>本题需要在主函数中在path中事先插入根节点的值，作为启动的引线（可以想想极端情况，树中只有一个节点，即根节点，如果不在path中事先插入根节点的值，那么即使根节点的值等于 <code>targetSum</code>，res中也不会存有根节点的值）。</li>
</ul>
<p>本题的具体代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 本题的递归函数不需要返回值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span> &amp;&amp; node-&gt;left == <span class="literal">NULL</span> &amp;&amp; cnt == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span> &amp;&amp; node-&gt;left == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左节点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(node-&gt;left-&gt;val);</span><br><span class="line">            cnt -= node-&gt;left-&gt;val;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;left, cnt); <span class="comment">// 递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">            cnt += node-&gt;left-&gt;val; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(node-&gt;right-&gt;val);</span><br><span class="line">            cnt -= node-&gt;right-&gt;val;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;right, cnt); <span class="comment">// 递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">            cnt += node-&gt;right-&gt;val; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 事先把根节点放进路径</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root, targetSum - root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="106-从中序与后序遍历序列构造二叉树-2"><a href="#106-从中序与后序遍历序列构造二叉树-2" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h3><p>任务：从中序和后序数组中构造出一棵唯一的二叉树。思路：如何用两个数组构造二叉树？<br>中序：左中右，例：9 3 15 20 7<br>后序：左右中，例：9 15 7 20 3<br>由于需要确定根节点，根节点是中节点，而根据中序数组无法确定出根节点的位置，这时就需要后序数组。后序数组的最后一个元素一定是中节点，也就是根节点。以上述两数组为例，根节点就是3。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[3]</span><br></pre></td></tr></table></figure>
<p>再看中序数组，root是3，则左节点是9，右节点是15，20，7。这一步操作就是利用后序数组中找到的root节点在中序数组中完成切割的任务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[3] --&gt; B[9];</span><br><span class="line">    A --&gt; C[x];</span><br></pre></td></tr></table></figure>
<p>再利用中序数组中切割出的两部分在后序数组中完成切割。由上一步知，左节点是9，右节点是15，20，7。结合后序数组知，右节点是15，7，20。右节点中最后一个元素是20，因此20是右子树的中节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[3] --&gt; B[9];</span><br><span class="line">    A --&gt; C[20];</span><br></pre></td></tr></table></figure>
<p>再利用后序数组去切割中序数组。20是右子树的中节点，中序数组中的右区间为15，20，7，因此左节点是15，右节点是7。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[3] --&gt; B[9];</span><br><span class="line">    A --&gt; C[20];</span><br><span class="line">    C --&gt; F[15];</span><br><span class="line">    C --&gt; G[7];</span><br></pre></td></tr></table></figure>
<p>关键：先通过后序数组找到root节点，再利用root节点切割中序数组，再利用中序数组切割出的左右区间切割后序数组，交替进行。可以具体为以下六步：</p>
<ol>
<li>后序数组为空，说明无root节点，返回空的树</li>
<li>后序数组最后一个元素作为root</li>
<li>寻找中序数组中root的位置作为切割点</li>
<li>切割中序数组，切为左右区间</li>
<li>根据切割中序数组得到的左右区间切割后序数组</li>
<li>递归处理，构造下一层子树</li>
</ol>
<p>现在开始写本题的伪代码（注重整体思路而非细节）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确定递归函数的参数和返回值</span></span><br><span class="line"><span class="comment">// 返回值：二叉树的根节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt; inorder, vector&lt;<span class="type">int</span>&gt; postorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件：后序数组为空</span></span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 后序数组的最后一个元素为root节点的值</span></span><br><span class="line">    <span class="type">int</span> rootvalue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 优化：若postorder中只有一个元素，则该元素必为叶子节点（root节点也是叶子节点）</span></span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 单层递归的逻辑</span></span><br><span class="line">    <span class="comment">// 寻找中序数组中root的位置作为切割点</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 返回中序数组中root的index</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 根据root切中序数组，得到一个左中序数组和一个右中序数组</span></span><br><span class="line">    <span class="comment">// 切后序数组，拿上一步得到的左中序数组来切出后序数组的左区间和右区间，得到一个左后序数组和一个右后序数组</span></span><br><span class="line">    <span class="comment">// 递归处理左区间和右区间，即递归构建root的左右子树</span></span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(左中序, 左后序);</span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(右中序, 右后序);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>切中序数组和切后序数组时需要有统一的区间定义。要么都坚持左闭右开，要么都坚持左闭右闭。</li>
<li>先切中序数组，再切后序数组。因为中序数组中的左区间和后序数组中的左区间一定相同。</li>
<li>建议debug时打印切中序数组得到的左中序和右中序数组，打印切后序数组的左后序和右后序数组。</li>
</ul>
<p>中序和前序数组也可以唯一地确定一棵二叉树。前序数组是中左右，拿着前序数组的第一个元素，即为root元素，拿去切中序数组。剩下的思路是相同的。</p>
<p>中序和后序数组可以唯一地确定二叉树，中序和前序数组也可以唯一地确定二叉树，<strong>但后序和前序数组不能唯一地确定二叉树</strong>。原因：前序数组和后序数组都可以直接知道root在哪里，但前序和后序数组的左右区间的分割点我们找不到。中序数组的重要性在于其把左右区间给分隔开了。举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[1] --&gt; B[2];</span><br><span class="line">    B[2] --&gt; C[3]</span><br><span class="line">    B[2] --&gt; E[null]</span><br><span class="line">    A --&gt; D[null];</span><br></pre></td></tr></table></figure>
<p>对以上二叉树，前序数组：123，后序数组：321</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[1] --&gt; B[null];</span><br><span class="line">    A[1] --&gt; C[2]</span><br><span class="line">    C[2] --&gt; D[null]</span><br><span class="line">    C[2] --&gt; E[3]</span><br></pre></td></tr></table></figure>
<p>对以上二叉树，前序数组：123，后序数组：321<br>虽然两棵二叉树的前序数组和后序数组完全一致，但这两棵二叉树完全不同，<strong>因此仅靠前序和后序数组不能唯一地确定二叉树</strong>。</p>
<p>本题是二叉树中的难题、复杂题，需要经常复习。以上笔记cover了易错点。</p>
<p>根据上述原理，我写出了以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootvalue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到inorder中root的下标</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将inorder根据i分为左中数组和右中数组</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; lm;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            lm.<span class="built_in">push_back</span>(inorder[j]); </span><br><span class="line">            cout &lt;&lt; inorder[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 打印lm数组中的所有元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; inorder.<span class="built_in">size</span>(); j ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            rm.<span class="built_in">push_back</span>(inorder[j]); </span><br><span class="line">            cout &lt;&lt; inorder[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 打印rm数组中的所有元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将postorder根据上一步的结果分为左后数组和右后数组</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; lb;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rb;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; lm.<span class="built_in">size</span>(); l ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            lb.<span class="built_in">push_back</span>(postorder[l]); </span><br><span class="line">            cout &lt;&lt; postorder[l] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 打印lb数组中的所有元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = lm.<span class="built_in">size</span>(); l &lt; postorder.<span class="built_in">size</span>(); l ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            rb.<span class="built_in">push_back</span>(postorder[l]); </span><br><span class="line">            cout &lt;&lt; postorder[l] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 打印rb数组中的所有元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(lm, lb);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rm, rb);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该代码可以通过201 / 202个测试样例，但有一个测试样例超时了，这就需要对上述代码进行优化。写出上述代码时，我犯了一个错误。在将 <code>postorder</code>根据 <code>inorder</code>的结果分为左后数组和右后数组的过程中，我的第一版代码采用了以下的写法（逻辑：把左中数组的最后一个元素作为分界点，在后序数组中查询之，并以此分界点将后序数组划分为左后数组和右后数组）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; lb;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rb;</span><br><span class="line"><span class="type">int</span> value = lm[lm.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; lm.<span class="built_in">size</span>(); k ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (postorder[k] == value)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;k=&quot; &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; k; l ++ ) </span><br><span class="line">&#123;</span><br><span class="line">    lb.<span class="built_in">push_back</span>(postorder[l]);</span><br><span class="line">    cout &lt;&lt; postorder[l] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = k + <span class="number">1</span>; l &lt; postorder.<span class="built_in">size</span>(); l ++ ) </span><br><span class="line">&#123;</span><br><span class="line">    rb.<span class="built_in">push_back</span>(postorder[l]);</span><br><span class="line">    cout &lt;&lt; postorder[l] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>当左中序数组 <code>lm</code>为空时，<code>int value = lm[lm.size() - 1];</code>会访问 <code>lm[-1]</code>。该元素显然不存在，故会报错：index error。因此不能这样写，应该采用按照左中序数组的元素数量分割后序数组的写法。</p>
<p>我对上述代码进行简易的优化后（将resize函数改为pop_back函数，时间复杂度略微降低），就可以通过本题，代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootvalue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; lm, rm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ ) lm.<span class="built_in">push_back</span>(inorder[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; inorder.<span class="built_in">size</span>(); j ++ ) rm.<span class="built_in">push_back</span>(inorder[j]);</span><br><span class="line"></span><br><span class="line">        postorder.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; lb, rb;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; lm.<span class="built_in">size</span>(); j ++ ) lb.<span class="built_in">push_back</span>(postorder[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = lm.<span class="built_in">size</span>(); j &lt; postorder.<span class="built_in">size</span>(); j ++ ) rb.<span class="built_in">push_back</span>(postorder[j]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(lm, lb);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rm, rb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，还有进一步优化的空间，代码也可以写得更为简洁。我写下了如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件1：postorder中为空</span></span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 终止条件2：postorder中只有一个元素，即为root</span></span><br><span class="line">        <span class="type">int</span> rootvalue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// postorder中的最后一个元素为root，在inorder中找到root的下标</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 将inorder以root作为分割点分割为左中序数组和右中序数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lm</span><span class="params">(inorder.begin(), inorder.begin() + i)</span></span>; <span class="comment">// 左中序数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rm</span><span class="params">(inorder.begin() + i + <span class="number">1</span>, inorder.end())</span></span>; <span class="comment">// 右中序数组</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 删去postorder的最后一个元素（即root）</span></span><br><span class="line">        <span class="comment">// 也可写作postorder.resize(postorder.size() - 1);</span></span><br><span class="line">        postorder.<span class="built_in">pop_back</span>();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 将postorder以上一步分割得到的左中序数组分割为左后序数组和右后序数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lb</span><span class="params">(postorder.begin(), postorder.begin() + lm.size())</span></span>; <span class="comment">// 左后序数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rb</span><span class="params">(postorder.begin() + lm.size(), postorder.end())</span></span>; <span class="comment">// 右后序数组</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 递归构建root的左子树和右子树</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(lm, lb); <span class="comment">// 构建左子树，传入的参数为左中序数组和左后序数组</span></span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rm, rb); <span class="comment">// 构建右子树，传入的参数为右中序数组和右后序数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 中序数组或后序数组为空，则树不存在，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码的运行时间基本可以减半，我觉得主要原因是 <code>vector&lt;int&gt; lm(inorder.begin(), inorder.begin() + i);</code>这种写法的时间复杂度要优于遍历数组然后赋值。</p>
<p>本题的下标索引写法（能大大降低空间复杂度，不需要每层递归产生新的数组，只需要对索引重新赋值即可，本写法的代码逻辑和上面的写法完全一致）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> inbegin, <span class="type">int</span> inend, <span class="type">int</span> postbegin, <span class="type">int</span> postend)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postend == postbegin) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="type">int</span> rootvalue = postorder[postend - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">        <span class="keyword">if</span> (postend - postbegin == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inorder中找到root</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = inbegin; i &lt; inend; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// root分割inorder为左中序数组和右中序数组</span></span><br><span class="line">        <span class="type">int</span> leftinorderbegin = inbegin;</span><br><span class="line">        <span class="type">int</span> leftinorderend = i;</span><br><span class="line">        <span class="type">int</span> rightinorderbegin = i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightinorderend = inend;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序数组删去root</span></span><br><span class="line">        postend -- ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将postorder分割为左后序数组和右后序数组</span></span><br><span class="line">        <span class="type">int</span> leftpostorderbegin = postbegin;</span><br><span class="line">        <span class="type">int</span> leftpostorderend = postbegin + leftinorderend - leftinorderbegin;</span><br><span class="line">        <span class="type">int</span> rightpostorderbegin = postbegin + leftinorderend - leftinorderbegin;</span><br><span class="line">        <span class="type">int</span> rightpostorderend = postend;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(inorder, postorder, leftinorderbegin, leftinorderend, leftpostorderbegin, leftpostorderend);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(inorder, postorder, rightinorderbegin, rightinorderend, rightpostorderbegin, rightpostorderend);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), <span class="number">0</span>, postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="105-从前序与中序遍历序列构造二叉树-1"><a href="#105-从前序与中序遍历序列构造二叉树-1" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h3><p>本题的代码思路和上题完全一致，我独立一遍写出了本题的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本题类似于106：利用中序数组和后序数组构造二叉树</span></span><br><span class="line"><span class="comment">// 本题关键思路：前序数组第一位是root</span></span><br><span class="line"><span class="comment">// 在inorder中查找root</span></span><br><span class="line"><span class="comment">// 以root作为分割点，将inorder分为左中序数组和右中序数组</span></span><br><span class="line"><span class="comment">// 根据上一步结果，将preorder分为左前序数组和右前序数组</span></span><br><span class="line"><span class="comment">// 递归处理左右子树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootvalue = preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在inorder中查找root</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以root作为分割点，将inorder分为左中序数组和右中序数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lm</span><span class="params">(inorder.begin(), inorder.begin() + i)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rm</span><span class="params">(inorder.begin() + i + <span class="number">1</span>, inorder.end())</span></span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 删去preorder的头元素（即root元素）</span></span><br><span class="line">        <span class="built_in">reverse</span>(preorder.<span class="built_in">begin</span>(), preorder.<span class="built_in">end</span>());</span><br><span class="line">        preorder.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(preorder.<span class="built_in">begin</span>(), preorder.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据上一步结果，将preorder分为左前序数组和右前序数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lf</span><span class="params">(preorder.begin(), preorder.begin() + lm.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rf</span><span class="params">(preorder.begin() + lm.size(), preorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归处理左右子树</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(lf, lm);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rf, rm);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">0</span> || inorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题的下标索引写法如下所示。用下标索引写法，本题删去前序数组中的第一个元素（root）就非常简单，只需要 <code>prebegin ++</code>即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> prebegin, <span class="type">int</span> preend, <span class="type">int</span> inbegin, <span class="type">int</span> inend)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prebegin == preend) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootvalue = preorder[prebegin];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootvalue);</span><br><span class="line">        <span class="keyword">if</span> (prebegin - preend == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inorder中找root</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = inbegin; i &lt; inend; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootvalue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用root划分inorder</span></span><br><span class="line">        <span class="type">int</span> leftinbegin = inbegin;</span><br><span class="line">        <span class="type">int</span> leftinend = i;</span><br><span class="line">        <span class="type">int</span> rightinbegin = i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightinend = inend;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// preorder中删去root</span></span><br><span class="line">        prebegin ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用划分inorder的结果划分preorder</span></span><br><span class="line">        <span class="type">int</span> leftprebegin = prebegin;</span><br><span class="line">        <span class="type">int</span> leftpreend = prebegin + leftinend - leftinbegin;</span><br><span class="line">        <span class="type">int</span> rightprebegin = prebegin + leftinend - leftinbegin;</span><br><span class="line">        <span class="type">int</span> rightpreend = preend;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(preorder, inorder, leftprebegin, leftpreend, leftinbegin, leftinend);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(preorder, inorder, rightprebegin, rightpreend, rightinbegin, rightinend);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">0</span> || inorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(preorder, inorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>(), <span class="number">0</span>, inorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="513-找树左下角的值-2"><a href="#513-找树左下角的值-2" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h3><ol>
<li>本题用层序遍历法解决更简单，用递归法解决更麻烦。</li>
<li>本题的层序遍历解法不需要浪费空间复杂度来存储整棵二叉树中的元素值或者二叉树中某一层的元素值。直接存储每一层最左侧元素的值，然后一层层从上往下遍历即可，最后自然会更新为树左下角的值。</li>
<li>本题的递归解法的核心在于：保证优先左边搜索，然后记录深度最大的叶子节点，此时得到的节点就是树的最后一行最左边的节点。</li>
<li><p>递归三部曲：</p>
<ul>
<li>确定函数的返回值和传入的参数<br>本题可以用全局变量记录树的最大深度和结果，这样traversal函数就不需要返回值，只需要在函数中更新记录结果的全局变量即可。传入的参数为根节点和当前节点的深度。</li>
<li>确定终止条件<br>当遍历到叶子节点时，终止。若叶子节点的深度大于最大深度，则更新最大深度和结果。</li>
<li>单层递归逻辑<br>前中后序遍历都可以，只需要保证优先遍历左节点即可。注意要显式地回溯，这样遍历完父节点的左节点后才能回到父节点，然后接着遍历父节点的右节点。否则会一直向左遍历。</li>
</ul>
</li>
</ol>
<h3 id="112-路径总和-2"><a href="#112-路径总和-2" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h3><ol>
<li>本题推荐用递归解，因为不需要处理中节点，所以前中后序遍历都可。</li>
<li>本题的递归函数的返回值为bool类型。因为一旦找到一条符合条件的路径，要立即从下（叶子节点）往上（根节点）返回true，因此递归函数需要返回值。</li>
<li>本题传入递归函数的参数除去node外，还需要传入cnt。cnt直接是targetSum（确切来说是 <code>targetSum - root-&gt;val;</code>），遍历到一个节点就减去该节点的值（从根节点开始遍历，因此传入时就要减去根节点的值），观察遍历到叶子节点时cnt是否为0即可。</li>
<li><p>递归三部曲：</p>
<ul>
<li>确定函数的返回值和传入的参数：返回值bool，传入的参数node和cnt</li>
<li>确定终止条件：遍历到叶子节点且cnt == 0，则返回true</li>
<li><p>单层递归逻辑</p>
<p>先处理左节点，首先cnt值减去左孩子的值，然后递归判断左孩子到叶子节点的路径中是否有满足条件的路径，若有，则需要从下往上返回true。然后再回溯，将减去的cnt值加回来。若不回溯，cnt就一直减小，导致右孩子到叶子节点的路径中不可能有满足条件的路径。对右节点的处理也是类似的。</p>
</li>
</ul>
</li>
<li>本题需要特别注意：调用递归函数时，传入的参数是 <code>targetSum - root-&gt;val</code>，而不是 <code>targetSum</code>。原因是在递归函数的终止条件中，若二叉树中只有root节点不为NULL，且cnt为零时，就返回true，因此本处的cnt应该已经将root节点的值排除在外了。若cnt不把root节点的值排除在外，则在二叉树只有root节点的情况下，永远不可能返回true，因为cnt不可能为0。</li>
</ol>
<h3 id="113-路径总和ii-2"><a href="#113-路径总和ii-2" class="headerlink" title="113. 路径总和ii"></a>113. 路径总和ii</h3><ol>
<li>本题和112的基本思路完全一致，但应当关注和112的差异，主要有以下5点差异。</li>
<li>本题需要在函数外先定义一个 <code>vector&lt;int&gt; path</code>来存放一条符合条件的路径，再定义一个 <code>vector&lt;vector&lt;int&gt;&gt; res</code>来存放树中所有符合条件的路径。</li>
<li>本题的递归函数不需要返回值，112的递归函数需要返回值。具体原因见本题的实现部分。</li>
<li>由于本题的递归函数不需要返回值，因此本题的递归函数在返回时只需要写 <code>return;</code>。</li>
<li>在处理左右节点的逻辑中，需要对 <code>cnt</code>操作并将左右节点的值放入 <code>path</code>中，然后再调用递归函数。因此在回溯时，也需要同时恢复 <code>cnt</code>的值和 <code>path</code>数组。</li>
<li>本题需要在主函数中在path中事先插入根节点的值，作为启动的引线。</li>
</ol>
<h3 id="106-从中序与后序遍历序列构造二叉树-3"><a href="#106-从中序与后序遍历序列构造二叉树-3" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h3><ol>
<li><p>本题的具体操作过程可以举一个具体的例子来展现，参见本题的实现部分。</p>
</li>
<li><p>本题的核心思路在于以下五步：</p>
<ul>
<li>根据后序数组找到root（后序数组中的最后一位）</li>
<li>在中序数组中查找root的下标</li>
<li>以root为分割点，将中序数组分割为左中序数组和右中序数组</li>
<li>在后序数组中找到与左中序数组相同的一段，即为左后序数组，剩下的后序数组为右后序数组</li>
<li>递归构建root的左右子树（根据左右中序数组和左右后序数组）</li>
</ul>
</li>
<li><p>本题的调试方法：打印出左右中序数组和左右后序数组，观察它们是否符合预期</p>
</li>
<li><p>中序和后序数组可以唯一地确定一棵二叉树，前序和中序数组也可以唯一地确定一棵二叉树，但前序和后序数组不可以唯一地确定一棵二叉树，我在实现部分举出了反例。原因：前序数组和后序数组都可以直接知道root在哪里，但前序和后序数组的左右区间的分割点我们找不到。中序数组的重要性在于其把左右区间给分隔开了。</p>
</li>
<li><p>本题和下一题的更佳写法是下标索引写法，即每次用下标索引来分割。虽然时间复杂度基本保持不变，但空间复杂度相比于传统写法大大降低了，因为不需要每层递归产生新的数组，只需要对索引重新赋值即可。</p>
</li>
<li><p>下标索引写法挺容易出错的，特别是在确定左右区间的边界上，搞不定的话就采用简单直接的普通写法。</p>
</li>
<li><p>我写的下标索引写法，还可以做进一步优化，若将划分postorder的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> leftpostorderbegin = postbegin;</span><br><span class="line"><span class="type">int</span> leftpostorderend = postbegin + leftinorderend - leftinorderbegin;</span><br><span class="line"><span class="type">int</span> rightpostorderbegin = postbegin + leftinorderend - leftinorderbegin;</span><br><span class="line"><span class="type">int</span> rightpostorderend = postend;</span><br></pre></td></tr></table></figure>
<p>直接写作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> leftpostorderbegin = postbegin;</span><br><span class="line"><span class="type">int</span> leftpostorderend = postbegin + i - inbegin;</span><br><span class="line"><span class="type">int</span> rightpostorderbegin = postbegin + i - inbegin;</span><br><span class="line"><span class="type">int</span> rightpostorderend = postend - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>即将</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">postend -- ;</span><br><span class="line"><span class="type">int</span> leftinorderbegin = inbegin;</span><br><span class="line"><span class="type">int</span> leftinorderend = i;</span><br><span class="line"><span class="type">int</span> rightinorderbegin = i + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> rightinorderend = inend;</span><br></pre></td></tr></table></figure>
<p>直接代入划分postorder的代码中，时间复杂度可以进一步降低。对于106题的下标索引写法也是如此。</p>
</li>
</ol>
<h3 id="105-从前序与中序遍历序列构造二叉树-2"><a href="#105-从前序与中序遍历序列构造二叉树-2" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h3><ol>
<li><p>本题的核心思路和上题完全相同，也是在于以下五步：</p>
<ul>
<li>前序数组第一位是root</li>
<li>在inorder中查找root</li>
<li>以root作为分割点，将inorder分为左中序数组和右中序数组</li>
<li>根据上一步结果，将preorder分为左前序数组和右前序数组</li>
<li>递归处理左右子树</li>
</ul>
</li>
<li>本题和上题的不同之处在于，上题在分割出左右中序数组后，需要删去后序数组的最后一个元素，即root元素。本题则是在分割出左右中序数组后，需要删去前序数组的第一个元素，即root元素。删去数组的最后一个元素的操作相对简单，只需要 <code>pop_back</code>即可，但删去数组的第一个元素的操作相对复杂。我想到的办法是翻转数组，删去数组最后一个元素，再翻转数组。</li>
<li>用下标索引写法，本题删去前序数组中的第一个元素（root）就非常简单，只需要 <code>prebegin ++</code>即可。</li>
</ol>
]]></content>
      <categories>
        <category>算法（二叉树）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>层序遍历</tag>
        <tag>递归解法</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 29 Leetcode 491, 46, 47</title>
    <url>/2024/05/26/Day-29-Leetcode-491-46-47/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html">491.递增子序列</a><br><a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">46.全排列</a><br><a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html">47.全排列 II</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h3><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h3><h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h3><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="491-递增子序列-1"><a href="#491-递增子序列-1" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h3><p>本题的关键：递增、至少两个元素、去重。但本题存在一个很大的问题，就是去重的时候不能对原数组进行排序，否则会打乱原数组的顺序，以以下测试样例为例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,4,3,2,1]</span><br><span class="line">Output: [[4,4]]</span><br></pre></td></tr></table></figure></p>
<p>一旦顺序被打乱，实际输出和理论输出就会不同，会多出很多递增的子序列。</p>
<p>本题和90.子集II非常像，但又很不一样，很容易掉坑里。直接看卡尔的讲解吧。</p>
<h3 id="46-全排列-1"><a href="#46-全排列-1" class="headerlink" title="46.全排列"></a>46.全排列</h3><p>本题是排列问题，不需要<code>startIndex</code>，但我写不出代码，直接看卡尔的讲解。经过卡尔的提示用<code>used</code>数组避免重复取元素后，我独立写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="47-全排列-II-1"><a href="#47-全排列-II-1" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h3><p>本题中的数组中会有重复元素，因此本题需要去重逻辑。本题相当于40.组合总和II去重逻辑和46.全排列的结合。我先尝试用<code>set</code>去重。我独立写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>() || used[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再接着尝试写出<code>used</code>数组去重的代码。我独立写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="number">1</span> || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于本题中<code>nums[i]</code>的数据范围在-10-10之间，所以可以不用<code>set</code>去重，而是用数组去重（将数据范围-10-10映射到数组下标范围0-20），这样效率更高，代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组去重</span></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">21</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="number">1</span> || hash[nums[i] + <span class="number">10</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            hash[nums[i] + <span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="491-递增子序列-2"><a href="#491-递增子序列-2" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h3><p>列出递增子序列，子序列元素数量大于等于2。有以下测试样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [4, 7, 6, 7]</span><br><span class="line">Output: [4, 7, 7], [4, 7], [4, 6], [4, 6, 7], [6, 7], [7, 7]</span><br></pre></td></tr></table></figure></p>
<p>要求不能有重复的子序列，因此需要去重。本题和90.子集II，只不过要求元素有顺序，且元素个数大于等于2。<strong>实际上，本题的细节和90有很大区别</strong>。<strong>本题的去重思路不可以沿用先排序再去重的做法，因为会改变原数组中元素的顺序，导致递增子序列的改变</strong>。例如对上述测试样例排序后，递增子序列会包括<code>[4, 6, 7, 7]</code>，实际上原本的输出不包含<code>[4, 6, 7, 7]</code>。</p>
<p>所有的回溯算法都是深搜，所有的深搜都可以说是递归。画本题的树形结构：<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124200229824.png" alt="491. 递增子序列1"></p>
<p>去重为树层去重。现在开始写代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 单个结果</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 结果集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 子集类问题可以不写终止条件，具体原因参见78/90</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) res.<span class="built_in">push_back</span>(path); <span class="comment">// 子集中元素数量大于等于2</span></span><br><span class="line">    </span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; uset; <span class="comment">// set去重</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 剪枝条件1：所取元素小于子序列最后一个元素，此时要求子序列非空，否则path.back()会报错</span></span><br><span class="line">        <span class="comment">// 剪枝条件2：用set做树层去重</span></span><br><span class="line">        <span class="keyword">if</span> (!path.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>() || uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        <span class="comment">// 记录每一层取的数(for循环中除去递归部分外都是横向遍历的)，每一层不能重复取相同的数</span></span><br><span class="line">        uset.<span class="built_in">insert</span>(nums[i]); </span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么没有对uset做回溯操作？<br>原因：上述代码中，每进入一层递归，都会重新定义一个<code>uset</code>。因此<code>uset</code>就是确保同一层中没有取到相同的元素，在进入下一层递归时，<code>uset</code>会被刷新。因此<code>uset</code>并不会对树枝去重，只会对树层去重。而<code>used</code>数组需要做回溯，因为<code>used</code>数组记录的是元素是否在<code>path</code>中被使用过，因此<code>path</code>中加减元素都需要对<code>used</code>数组进行修改。</p>
<p>本题的去重方式也可以应用于40.组合总和II和90.子集II。本题也可以用数组取代<code>set</code>进行去重，用数组的效率会更高些。</p>
<p>本题的完整代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 收集结果</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 剪枝条件1：所取元素小于子序列最后一个元素，此时要求子序列非空，否则path.back()会报错</span></span><br><span class="line">            <span class="comment">// 剪枝条件2：用set做树层去重</span></span><br><span class="line">            <span class="comment">// cpp中&amp;&amp;的优先级高于||，因此是先与后或，不需要给剪枝条件1加括号</span></span><br><span class="line">            <span class="keyword">if</span> (!path.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>() || uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于本题<code>nums[i]</code>的数据范围很小，因此可以用数组做去重，运行效率也更高。只需要将<code>set</code>替换为普通数组，然后做一个偏移（数值-100-100映射到数组下标0-200上）即可。代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() &gt; <span class="number">1</span>) res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!path.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>() || cnt[nums[i] + <span class="number">100</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cnt[nums[i] + <span class="number">100</span>] = <span class="number">1</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="46-全排列-2"><a href="#46-全排列-2" class="headerlink" title="46.全排列"></a>46.全排列</h3><p>题目中明确说了给定的集合中没有重复元素，因此不用去重。</p>
<p>排列相对于组合的区别：<code>[2, 1], [1, 2]</code>是同一个组合，但是两个排列。排列是强调元素顺序的，组合不强调元素顺序。接下来画本题的树形结构。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p>
<p>排列问题中也需要用到<code>used</code>数组，用于标记哪些元素被使用过，因为在排列问题中同一个元素不能重复使用。组合问题中是用<code>startIndex</code>来避免取同一个元素和避免产生相同组合的情况。树的深度由<code>nums</code>的长度来控制。</p>
<p><code>used</code>数组用来标记哪些元素被取过，取过的元素不能重复取，但所有没取过的元素都可以重复取，而不需要像组合问题那样用<code>startIndex</code>来控制只能取当前元素的下一个元素。具体的代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 放单个结果</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 结果集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path); <span class="comment">// 收获结果</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑</span></span><br><span class="line">    <span class="comment">// 排列问题不需要startIndex，只要不重复取同一个元素即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i] == <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 不重复取同一个元素</span></span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        used[i] = <span class="number">1</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        used[i] = <span class="number">0</span>;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="47-全排列-II-2"><a href="#47-全排列-II-2" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h3><p>上一题给定的集合中没有重复元素，本题给定的集合中有重复元素。以<code>[1, 1, 2]</code>为例，如果依然用上一题的办法求解本题，结果集中会出现两个<code>[1, 1, 2]</code>，因此本题需要做去重。如果对去重的思路不够了解，可以看40.组合总和II。回溯的所有题目中，去重的逻辑都是相同的。本题等于排列+去重。<strong>但排列问题中的去重会有些与之前不同的地方</strong>。</p>
<p>画出本题的树形结构：<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201331223.png" alt="47.全排列II1"></p>
<p>用<code>used</code>数组做树层去重前，记得对<code>nums</code>数组进行排序。本题中的<code>used</code>数组有两个作用：</p>
<ul>
<li>避免同一个元素被重复使用</li>
<li>做树层去重</li>
</ul>
<p>接下来写具体的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 树层去重</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 同一个元素不能被重复取，因此取过的数直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (used[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        used[i] = <span class="number">1</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        used[i] = <span class="number">0</span>;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>细节：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树层去重</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure></p>
<p>可以通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树枝去重</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>也可以通过。这意味着树层去重和树枝去重都可以解决本题。但树层去重的效率更高，树层去重会剪掉更多分支，而树枝去重要一直到最后一个树枝才会列出所有的结果。因此还是推荐树层去重的写法。以<code>[1, 1, 1]</code>为例，画出<strong>树层去重和树枝去重</strong>的树形结构：<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201406192.png" alt="47.全排列II2"></p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201431571.png" alt="47.全排列II3"></p>
<p>很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。</p>
<p>时间复杂度和空间复杂度分析：</p>
<ul>
<li>时间复杂度: 最差情况所有元素都是唯一的，时间复杂度为$O(n!\times n)$。 对于n个元素一共有n!中排列方案。而对于每一个答案，我们需要$O(n)$去复制最终放到<code>res</code>数组。</li>
<li>空间复杂度: $O(n)$。空间复杂度即为回溯树的深度，其取决于<code>nums</code>数组中有多少个元素。</li>
</ul>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="491-递增子序列-3"><a href="#491-递增子序列-3" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h3><p>关键点：<code>set</code>去重-&gt;剪枝-&gt;数组去重取代<code>set</code>去重</p>
<ol>
<li><p>本题和90.子集II乍一看非常相似，但细节上有很大不同，解决本题时不能有惯性思维。</p>
</li>
<li><p>之前<strong>去重</strong>的方法都是利用<code>used</code>数组，这意味着需要对<code>nums</code>数组进行排序。在本题中，如果对<code>nums</code>数组进行排序，就会打乱原数组中元素的顺序，导致递增子序列发生改变。因此，本题不能用<code>used</code>数组去重，而需要用<code>set</code>去重。因为用<code>set</code>去重不需要对原数组排序。</p>
</li>
<li><p>本题有两个<strong>剪枝</strong>条件：</p>
<ul>
<li><p>剪枝条件1：若所取元素小于子序列最后一个元素，则需要剪枝。此时要求子序列非空，否则<code>path.back()</code>会报错。剪枝条件1的原因是本题要求子序列是递增的。</p>
</li>
<li><p>剪枝条件2：用set做树层去重</p>
</li>
</ul>
<p>两个剪枝条件用||相连。</p>
</li>
<li><p>为什么不需要对<code>set</code>进行回溯？</p>
<p>每进入一层递归，都会重新定义一个<code>set</code>。因此<code>set</code>就是确保同一层中没有取到相同的元素。在进入下一层递归时，<code>set</code>会被刷新（重新定义）。因此<code>set</code>并不会对树枝去重，只会对树层去重。而<code>used</code>数组需要做回溯，因为<code>used</code>数组记录的是元素是否在<code>path</code>中被使用过，因此<code>path</code>中加减元素都需要对<code>used</code>数组进行相应的修改。</p>
</li>
<li><p>本题的去重方法也可以应用于40.组合总和II和90.子集II。</p>
</li>
<li><p>由于本题<code>nums[i]</code>的数据范围很小，因此可以用数组做去重，运行效率也更高。只需要将<code>set</code>替换为普通数组，然后做一个偏移（数值-100-100映射到数组下标0-200上）即可。</p>
</li>
<li><p>本题的时间和空间复杂度分别为$O(n\times2^n)$和$O(n)$。同90和78。</p>
</li>
</ol>
<h3 id="46-全排列-3"><a href="#46-全排列-3" class="headerlink" title="46.全排列"></a>46.全排列</h3><ol>
<li>排列问题和组合问题的两大区别：<ul>
<li>每层都是从0开始搜索而不是<code>startIndex</code></li>
<li>需要used数组记录<code>path</code>里都放了哪些元素了</li>
</ul>
</li>
<li>不需要<code>startIndex</code>的原因：<code>[1, 2]</code>和<code>[2, 1]</code>是同一个组合，但却是不同的排列，因此排列问题不能像组合问题那样从当前元素的下一个元素开始取，而是要取<code>nums</code>数组中所有当前没有取过的元素。</li>
<li>需要<code>used</code>数组的原因：<code>used</code>数组记录了此时<code>path</code>里都有哪些元素使用了，一个排列里一个元素只能使用一次。</li>
<li>终止条件为<code>path.size() == nums.size()</code>，<code>nums</code>数组的大小限制了树的深度。</li>
<li>本题的时间复杂度为$O(n!)$，空间复杂度为$O(n)$。时间复杂度的原因是有$n$个元素的<code>nums</code>数组共有$n!$种排列。空间复杂度的原因是递归的深度（即树的深度）为$n$。</li>
</ol>
<h3 id="47-全排列-II-3"><a href="#47-全排列-II-3" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h3><ol>
<li>本题相当于40.组合总和II（树层去重）和46.全排列的结合。</li>
<li>本题的去重有三种写法：<code>set</code>去重、数组去重、<code>used</code>数组去重。三种写法我都在初次尝试中给出了。</li>
<li>用<code>used</code>数组去重前，一定要记得对<code>nums</code>数组进行排序。另外两种去重写法则不需要对<code>nums</code>数组进行排序。</li>
<li>由于本题是在叶子节点处收集结果，因此需要终止条件。</li>
<li>本题的时间复杂度为$O(n!\times n)$，空间复杂度为$O(n)$。具体原因参见实现部分。</li>
<li>本题用树层去重和树枝去重都可以，具体原因参见实现部分。<strong>但树层去重的效率远高于树枝去重</strong>，因此采用一贯以来的<code>used</code>数组树层去重写法即可，不要纠结树枝去重的原理和合理性。</li>
</ol>
]]></content>
      <categories>
        <category>算法（回溯算法）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>回溯算法</tag>
        <tag>子集问题</tag>
        <tag>树层去重</tag>
        <tag>排列问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 31 Leetcode Basics of Greedy Algorithms, 455, 376, 53</title>
    <url>/2024/09/09/Day-31-Leetcode-Basics-of-Greedy-Algorithms-455-376-53/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">理论基础</a></p>
<p><a href="https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html">455.分发饼干</a></p>
<p><a href="https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html">376. 摆动序列</a></p>
<p><a href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html">53. 最大子序和</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="什么是贪心"></a>什么是贪心</h4><p>贪心算法的本质是找到每个阶段的<strong>局部最优</strong>，从而去推导<strong>全局最优</strong>。</p>
<p>例如：</p>
<ul>
<li>10张面值不同的钞票，如何取能取到总数最多的钱？每次取面额最大的钞票即可，这就是局部最优。取10次后拿到最多的钱，就是全局最优。这是贪心的思路。</li>
<li>背包最大承重是n。有一系列物品，其重量和价值各不相同，问这个背包能装的最大价值是多少？这需要用动态规划的思路来解决。</li>
</ul>
<h4 id="贪心的两个极端"><a href="#贪心的两个极端" class="headerlink" title="贪心的两个极端"></a>贪心的两个极端</h4><p>贪心的题目要么太简短，要么太难。</p>
<h4 id="贪心的套路"><a href="#贪心的套路" class="headerlink" title="贪心的套路"></a>贪心的套路</h4><p>不像二叉树或者回溯算法的套路，<strong>贪心是没有套路的</strong>。部分较难的贪心题目，做过了才知道怎么做，否则完全想不到。非要说有套路，就是要想清楚每个阶段的局部最优，能否由局部最优推出全局最优。怎么由局部最优推出全局最优，也没有固定的思考方式。不需要做数学证明（数学证明的常用方法是数学归纳法和反证法），浪费时间。面试时，<strong>只要想到局部最优，可以推出全局最优，没有明显的反例，就已经可以试试</strong>，面试官不会要求严谨的数学证明。文字版讲解中有解决贪心算法的四个步骤，但实际做题时无法严格遵循四个步骤，实操性不强。</p>
<h3 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h3><h3 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376.摆动序列"></a>376.摆动序列</h3><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="455-分发饼干-1"><a href="#455-分发饼干-1" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h3><p>本题我的思路是，找出s数组的最大值，然后看g数组中有几个数小于等于s数组中的最大值，即为结果。我写了如下的代码，但只通过了23/25个测试样例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = s[s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i] &lt;= max)</span><br><span class="line">                res ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= res) <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>直接看代码随想录的讲解吧。</p>
<h3 id="376-摆动序列-1"><a href="#376-摆动序列-1" class="headerlink" title="376.摆动序列"></a>376.摆动序列</h3><h3 id="53-最大子序和-1"><a href="#53-最大子序和-1" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="455-分发饼干-2"><a href="#455-分发饼干-2" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h3><p>例子：<br>胃g: 1, 2, 7, 10<br>饼s: 1, 3, 5, 9<br>输出：3</p>
<p><strong>策略：尽量用大饼干去喂胃口大的孩子，这样就可以充分利用饼干</strong>。</p>
<p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对两个数组进行排序</span></span><br><span class="line"><span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> index = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 饼干的index</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先用大饼干喂胃口大的小孩，因此倒序遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">    <span class="comment">// 饼干成功投喂后，再向前遍历小孩数组，否则不能向前</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123;</span><br><span class="line">        res ++ ;</span><br><span class="line">        index -- ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p>
<p>一定要外层循环遍历胃口，内层循环遍历饼干。如果外层循环遍历饼干，内层循环遍历胃口，拿上面的例子模拟就知道不可行。拿外层循环遍历饼干，内层循环遍历胃口，代码为：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对两个数组进行排序</span></span><br><span class="line"><span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> index = g.<span class="built_in">size</span>() - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; s[i] &gt;= g[index]) &#123;</span><br><span class="line">        res ++ ;</span><br><span class="line">        index -- ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p>
<p>对于上面的例子，上述写法返回值为0。核心在于，要尝试去喂饱胃口大的孩子，而我们无法确保最大的饼干一定能喂饱胃口最大的孩子，如果最大的饼干无法喂饱胃口最大的孩子，那么上述写法的返回值恒为0。</p>
<p><strong>另一种思路：尽量用小饼干去满足胃口小的孩子，这样可以充分利用小饼干</strong>。</p>
<h3 id="376-摆动序列-2"><a href="#376-摆动序列-2" class="headerlink" title="376.摆动序列"></a>376.摆动序列</h3><h3 id="53-最大子序和-2"><a href="#53-最大子序和-2" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3><h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="455-分发饼干-3"><a href="#455-分发饼干-3" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h3><ol>
<li>一定要外层循环遍历胃口，内层循环遍历饼干。</li>
<li>内存循环用if判断而不用while循环，因为要一个小孩一个小孩地喂过去。</li>
<li>两种思路：先去满足大胃口的孩子，先去使用小饼干。两种思路遍历的顺序不同。</li>
</ol>
<h3 id="376-摆动序列-3"><a href="#376-摆动序列-3" class="headerlink" title="376.摆动序列"></a>376.摆动序列</h3><h3 id="53-最大子序和-3"><a href="#53-最大子序和-3" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3>]]></content>
      <categories>
        <category>算法（贪心算法）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>理论基础</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 30 Leetcode 332, 51, 37</title>
    <url>/2024/05/27/Day-30-Leetcode-332-51-37/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html">332.重新安排行程</a><br><a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html">51. N皇后</a><br><a href="https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html">37. 解数独</a><br><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html">总结</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h3><p>初始化一个<code>vector&lt;string&gt;</code>，其中的元素全是字符<code>.</code>（共有n行，每行是一个字符串，每个字符串由n个<code>.</code>构成）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">chessboard</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>今天这三道题都非常难，那么这么难的题，为啥一天做三道？</strong> </p>
<p>因为一刷也不求能把这么难的问题解决，所以一刷的时候，就了解一下题目的要求，了解一下解题思路，不求能直接写出代码，先大概熟悉一下这些题，二刷的时候，随着对回溯算法的深入理解，再去解决如下三题。 </p>
<h3 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.重新安排行程</h3><p>本题的思路不难，但选择的数据结构和初始化、遍历等操作非常复杂，是一道难题。</p>
<p>本题需要一个特殊的数据结构来存储一个机场映射多个机场，机场之间要靠字母序排列的这种复杂关系，选择的数据结构是<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>。其具体的含义为<code>unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</code>。在遍历 <code>unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</code>的过程中，<strong>可以使用”航班次数”这个字段的数字做相应的增减，来标记到达机场是否使用过了。</strong>如果“航班次数”大于零，说明目的地还可以飞，如果“航班次数”等于零说明目的地不能飞了，而不用对集合做删除元素或者增加元素的操作。有如下代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span></span><br><span class="line"><span class="comment">// 使用map的原因是为了让其key有序（字典序）</span></span><br><span class="line"><span class="comment">// 第一个unordered_map是为了存储出发机场和到达机场间的映射关系，第二个map是为了对到达机场按照字典序排序，且记录到达机场在输入数据中出现的次数</span></span><br><span class="line">unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; targets;</span><br></pre></td></tr></table></figure></p>
<p>本题的树形结构如下所示，以输入：<code>[[&quot;JFK&quot;, &quot;KUL&quot;], [&quot;JFK&quot;, &quot;NRT&quot;], [&quot;NRT&quot;, &quot;JFK&quot;]</code>为例：<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020111518065555-20230310121223600.png" alt="332.重新安排行程1"></p>
<p>对上述树形结构的解释：始终从<code>JFK</code>出发，输入中<code>JFK</code>可以到<code>KUL</code>或者<code>NRT</code>，因此可以有这两个选择。输入中没有以<code>KUL</code>作为出发点的航班，因此飞向<code>KUL</code>的那一枝结束。飞向<code>NRT</code>的一枝，输入中以<code>NRT</code>为出发点的航班的终点是<code>JFK</code>，因此有行程：<code>JFK-&gt;NRT-&gt;JFK</code>。输入中以<code>JFK</code>为出发点的航班的终点可以是<code>KUL</code>或者<code>NRT</code>，因此分为两枝。<code>JKF</code>已经飞过<code>NRT</code>，因此剪枝；<code>JKF</code>飞<code>KUL</code>构成了行程：<code>JFK-&gt;NRT-&gt;JFK-&gt;KUL</code>，三趟航班，形成中有四个机场，说明找到了结果。</p>
<p>通过上述分析，我们可以得出代码的终止条件：n张机票，即有n个航班，则行程中有n + 1个机场（机场可重复）时，收集结果。原因是行程是由若干个向量组成的，每个向量都是一个航班，行程是单向的，不会形成环。因此，若有n个向量（即n个航班），那么就会有n + 1个节点（即单个向量的首尾），即n + 1个机场。有如下代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; res; <span class="comment">// 存放结果，即由n个航班拼接成的行程，其中有n + 1个机场</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ticketNum为票数，即航班数</span></span><br><span class="line"><span class="keyword">if</span> (result.<span class="built_in">size</span>() == ticketNum + <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在写单层递归逻辑前，需要先对<code>res</code>数组和<code>targets</code>数组进行初始化，代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> vector&lt;string&gt;&amp; vec : tickets) &#123;</span><br><span class="line">    targets[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]]++; <span class="comment">// 记录映射关系</span></span><br><span class="line">&#125;</span><br><span class="line">result.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>); <span class="comment">// 起始机场</span></span><br></pre></td></tr></table></figure></p>
<p><code>tickets</code>数组是输入，其类型是<code>vector&lt;vector&lt;string&gt;&gt;</code>。由于输入不可更改，且其中的每个元素的类型都是<code>vector&lt;string&gt;</code>，因此用类型为<code>const vector&lt;string&gt;</code>的变量对其进行遍历，这里的引用就不加都可以，不会影响运行结果。<code>vec[0]</code>为出发机场，<code>vec[1]</code>为到达机场。<code>targets</code>中存储的是出发机场与到达机场的映射关系。对一个出发机场，若输入中存在其的到达机场，则在<code>targets</code>中记录这个映射关系，且<code>map&lt;string, int&gt;</code>中的<code>string</code>存储到达机场（<code>vec[1]</code>），<code>int</code>存储次数（有出发机场和其对应的到达机场，则该<code>int</code>存1）。这实现了对每一个航线（从某个出发机场到某个目的地机场）的航班次数进行计数。</p>
<p>根据树形结构，可以写出单层递归的逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (pair&lt;<span class="type">const</span> string, <span class="type">int</span>&gt;&amp; target : targets[result[result.<span class="built_in">size</span>() - <span class="number">1</span>]]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.second &gt; <span class="number">0</span> ) &#123; <span class="comment">// 记录到达机场是否飞过了</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(target.first);</span><br><span class="line">        target.second--;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketNum, result)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        result.<span class="built_in">pop_back</span>();</span><br><span class="line">        target.second++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里特别需要注意的是：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (pair&lt;<span class="type">const</span> string, <span class="type">int</span>&gt;&amp; target : targets[result[result.<span class="built_in">size</span>() - <span class="number">1</span>]])</span><br></pre></td></tr></table></figure></p>
<p>其含义为：<code>result[result.size() - 1]</code> 获取 <code>result</code> 向量的最后一个元素，即当前路径中最新的机场。然后，使用这个机场名称作为键，从 <code>targets</code> 映射中检索对应的内层 <code>map</code>，这个内层 <code>map</code> 包含所有从该机场出发的航班及其次数。<code>for</code> 循环遍历这个内层 <code>map</code>，即遍历从当前结果集中的最新机场可以直接到达的所有机场及对应的航班次数。一定要加上引用即 <code>&amp; target</code>，因为后面有对 <code>target.second</code> 做减减操作，如果没有引用，单纯复制，这个结果就没记录下来，那最后的结果就不对了。加上引用之后，就必须在<code>string</code>前面加上<code>const</code>，因为map中的key是不可修改了，这就是语法规定了。</p>
<p>还需要注意本题的递归函数的返回值和参数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意函数返回值用的是bool！</strong>因为我们只需要找到一个行程，就是在树形结构中唯一的一条通向叶子节点的路线。所以找到了这个叶子节点了直接返回。</p>
<p>拆分地写好了各部分的代码之后，整合起来就是本题的完整代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; targets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> ticketSum, vector&lt;string&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (ticketSum + <span class="number">1</span> == res.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="comment">// 以res中最新机场为出发点，遍历targets寻找可能的目的地</span></span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="type">const</span> string, <span class="type">int</span>&gt;&amp; target: targets[res[res.<span class="built_in">size</span>() - <span class="number">1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// target.second &gt; 0说明目的地可用</span></span><br><span class="line">            <span class="keyword">if</span> (target.second &gt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理节点</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(target.first);</span><br><span class="line">                target.second -- ;</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketSum, res)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                target.second ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化res</span></span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化targets</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vec: tickets)</span><br><span class="line">            targets[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用递归函数并返回结果</span></span><br><span class="line">        <span class="built_in">backtracking</span>(tickets.<span class="built_in">size</span>(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>auto</code>来简化上述代码，避免需要手写复杂的变量类型：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提取输入数据中的信息：构造出发机场和到达机场间的映射，到达机场按照字典序排序并记录到达机场出现的次数</span></span><br><span class="line">    unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; targets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> ticketSum, vector&lt;string&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (ticketSum + <span class="number">1</span> == res.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; target: targets[res[res.<span class="built_in">size</span>() - <span class="number">1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.second &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                target.second -- ;</span><br><span class="line">                res.<span class="built_in">push_back</span>(target.first);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketSum, res)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                target.second ++ ;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化res</span></span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化targets</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ticket: tickets) targets[ticket[<span class="number">0</span>]][ticket[<span class="number">1</span>]] ++ ;</span><br><span class="line">        <span class="built_in">backtracking</span>(tickets.<span class="built_in">size</span>(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="51-N皇后-1"><a href="#51-N皇后-1" class="headerlink" title="51. N皇后"></a>51. N皇后</h3><p>本题是回溯中较难的题目。题意：给一个n*n的棋盘，在其中放n个皇后，要求同一行、同一列、同意斜线上不能有两个皇后，将放置皇后的结果返回。难点：之前讲的组合问题、分割问题、子集问题和排列问题，都是一个一维的集合按照条件输出若个子集，本题则是一个二维的集合（数组）。</p>
<p>首先想如何暴力枚举，以4*4的棋盘为例，需要4个for循环，每一行每个位置尝试放皇后，根据规则判断能否放皇后。回溯算法的本质和暴力枚举没有区别，但回溯算法用递归的方式控制嵌套for循环的层数。</p>
<p>本题的树形结构如下所示，以3*3的棋盘为例：<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130182532303.jpg" alt="51.N皇后" style="zoom: 50%;" /></p>
<p><strong>第n层递归对应着尝试在第n行中放置皇后</strong>。3*3的N皇后问题是无解的，画其只是为了展现其树形结构。树的深度为棋盘的行数，树的宽度为棋盘的列数。接下来写本题的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个棋盘是一个二维数组，放置若干棋盘，因此需要三维数组</span></span><br><span class="line">vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; res; <span class="comment">// 三维数组收集所有可能的摆放结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// chessboard为棋盘，n为棋盘的大小, row为行，第n层递归负责处理第n行，用row来记录当前处理到了第几行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; chessboard, <span class="type">int</span> n, <span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件: 叶子节点收获结果</span></span><br><span class="line">    <span class="keyword">if</span> (row == n) </span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(chessboard); <span class="comment">// 单层递归逻辑中会对合法性进行判断，保证放入res中的chessboard都是合法的</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单层递归逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 合法性判断</span></span><br><span class="line">        <span class="comment">// 判断在第row行，第i个位置放皇后是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(row, i, chessboard, n))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 放皇后</span></span><br><span class="line">            chessboard[row][i] = <span class="string">&#x27;Q&#x27;</span>; </span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtracking</span>(chessboard, n, row + <span class="number">1</span>); <span class="comment">// 下一层递归, row-&gt;row + 1</span></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            chessboard[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：回溯法解决二维数组问题，第n层递归处理第n行，每层递归中遍历每一行中的每个元素。</p>
<p>在理解了本题的主题思路后，独立写出代码依然有难度，因为本题返回的变量类型是<code>vector&lt;vector&lt;string&gt;</code>，chessboard的变量类型应该为<code>vector&lt;string&gt;</code>，对其进行初始化有一定难度。另外，<code>isValid</code>函数的实现我第一次写也有一定的困难，直接看文字版讲解。</p>
<p>我独立写出的本题的代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结果集</span></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;string&gt;&amp; chessboard, <span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 同一列中不能有两个皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主对角线不能有两个皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i -- , j -- )</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 副对角线不能有两个皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i -- , j ++ )</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入棋盘，棋盘大小，行数（即递归层数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;string&gt;&amp; chessboard, <span class="type">int</span> n, <span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (row == n) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(chessboard);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 合法性判断</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(chessboard, n, row, i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 放皇后</span></span><br><span class="line">                chessboard[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="built_in">backtracking</span>(chessboard, n, row + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                chessboard[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">chessboard</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(chessboard, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要特别注意的是，在放皇后时，每次只在一行中的某个位置放一个皇后，且放完后会回溯，因此同一行中不会出现两个皇后，因此不需要在<code>isValid</code>函数中对同一行中出现两个皇后的情况进行判断。另外，放皇后的顺序是从行数小放到行数大，从列数小放到列数大。在不同行中，行数小的位置会被优先尝试放置皇后。在同一行的不同列中，列数小的位置会被优先尝试放置皇后。因此，<code>isValid</code>函数中对同一列判断，只需要判断从0-row列；对主对角线判断，只需要判断i从row-1到0，j从col-1到0；对副对角线判断，只需要判断i从row - 1到0，j从col + 1到n（由于优先放小的行，所以<code>i &lt; row, j &gt; col</code>的位置可能已经放置了皇后）。</p>
<h3 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h3><p>给一个9<em>9的棋盘，用1-9填满这个棋盘，规则为：同一行中不能有重复的数字，同一列中不能有重复的数字，九宫格中不能有重复的数字。本题求出一个填满的方案即可。本题是回溯章节的难题，和上一题N皇后类似。但用N皇后的思路做本题做不出来。<em>*本题比N皇后多一个维度</em></em>。N皇后用for循环遍历行，递归遍历列。本题不仅行要放满数字，列也要放满数字，整个棋盘都要放满数字。</p>
<p><strong>本题解法被称为二维递归</strong>，即两个for循环，下面是一个递归函数。一个for循环来遍历行，一个for循环来遍历列，这样才能确定一个空格。递归用来确定空格中应该放的数字。本题的树形结构如下所示：<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020111720451790-20230310131816104.png" alt="37.解数独"></p>
<p>现在开始写本题的代码，本题的代码其实并不复杂。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确定递归函数的返回值和参数</span></span><br><span class="line"><span class="comment">// 返回值为bool类型，原因是本题求数独的一个解即可，一旦棋盘被填满，立即返回</span></span><br><span class="line"><span class="comment">// 若一题有多个结果，多个结果散落在树形结构里，需要将树形结构全都搜索一遍，然后将结果放入结果集中，因此返回值为void类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> <span class="comment">// board要引用，这样才会修改board</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 本题不需要写终止条件，棋盘被填满后会直接return true，若无法满足填充规则，则会return false</span></span><br><span class="line">    <span class="comment">// 两个for循环，一个遍历行，另一个遍历列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            <span class="comment">// 棋盘中的点表示空格</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k ++ )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 检查在board的(i, j)处放置数字k是否合法</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isValid</span>(i, j, k, board)) </span><br><span class="line">                    &#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">            					 <span class="comment">// 进入下一层递归</span></span><br><span class="line">                        <span class="type">bool</span> res = <span class="built_in">backtracking</span>(board);</span><br><span class="line">                        <span class="comment">// 找到一个结果就立即停止搜索，返回</span></span><br><span class="line">                        <span class="keyword">if</span> (res == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">// 回溯</span></span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 在空格处将9个数字都尝试了，无法填入，则说明该棋盘没有结果，返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 若没有走到return false，则return true（若棋盘一直被填充直到被填满，则不会走if (board[i][j] == &#x27;.&#x27;)）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的核心代码，我自己实现了<code>isValid</code>函数，写出了本题的完整代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span> k, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检查第i行能否放入k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == k)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查第j列能否放入k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == k)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查九宫格能否放入k</span></span><br><span class="line">        <span class="type">int</span> starti = i / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> startj = j / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> endi = starti + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> endj = startj + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = starti; i &lt;= endi; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = startj; j &lt;= endj; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == k)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 处理节点</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k ++ )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">isValid</span>(i, j, k, board))</span><br><span class="line">                        &#123;</span><br><span class="line">                            board[i][j] = k;</span><br><span class="line">                            <span class="comment">// 递归</span></span><br><span class="line">                            <span class="type">bool</span> res = <span class="built_in">backtracking</span>(board);</span><br><span class="line">                            <span class="keyword">if</span> (res == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            <span class="comment">// 回溯</span></span><br><span class="line">                            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="332-重新安排行程-1"><a href="#332-重新安排行程-1" class="headerlink" title="332.重新安排行程"></a>332.重新安排行程</h3><ol>
<li>本题的解题思路其实不难，画出树形结构后，是一道经典的回溯问题。本题的难点在于选用怎样的数据结构来有效地存放和处理输入的数据。</li>
<li>因为本题是hard题，且由于使用了较为复杂的数据结构，因此我觉得在hard中都算是难题，显著比N皇后困难。因此，第一遍学习本题，了解本题的思路和核心代码即可，不要求能够将本题完整地写出来。</li>
<li><p>本题的实现部分对代码进行了细致的拆分讲解，大致可以分为以下几个要点：</p>
<ul>
<li>用怎样的数据结构存储输入数据中出发机场和到达机场间的映射关系，且要求同一个出发机场的到达机场按照字典序排列，同时记录到达机场的使用次数</li>
<li>如何对结果集和上面的数据结构进行初始化</li>
<li>根据树形结构写出终止条件和单层搜索逻辑，并确定递归函数的返回值和传入的参数。本题递归函数的返回值是罕见的bool类型，而非void类型</li>
</ul>
<p>明确上述三个问题，即可理解本题的思路和实现细节，进而顺畅地写出本题的代码。</p>
</li>
<li><p>在初始化targets时，范围遍历可以直接采用<code>auto</code>类型的变量，避免需要手写复杂的变量类型。但在单层递归逻辑中遍历<code>targets</code>时，不能直接采用<code>auto</code>，因为for循环中涉及到了对遍历的值的修改操作，因此一定要使用引用，可以使用<code>auto&amp;</code>。</p>
</li>
</ol>
<h3 id="51-N皇后-2"><a href="#51-N皇后-2" class="headerlink" title="51. N皇后"></a>51. N皇后</h3><ol>
<li><p>本题的新奇之处在于：之前用回溯法解决过组合、切割、子集、排列问题，处理的对象都是一维数组，N皇后问题处理的对象却是<strong>二维数组</strong>。</p>
</li>
<li><p>本题的原理实际上非常简单，理解本题的<strong>树形结构</strong>即可：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130182532303.jpg" alt="51.N皇后" style="zoom:50%;" /></p>
</li>
<li><p>由上述树形结构可知，<strong>树的宽度是棋盘的列数，树的深度是棋盘的行数</strong>。据此，可以轻松地写出<code>backtracking</code>函数的终止条件和单层递归逻辑。</p>
</li>
<li><p>对棋盘合法性的判断其实是比较容易写错的。按照以下标准验证棋盘是否合法，两皇后：</p>
<ul>
<li><p>不能同行</p>
</li>
<li><p>不能同列</p>
</li>
<li><p>不能同斜线 （主对角线和副对角线）</p>
</li>
</ul>
<p>在<code>isValid</code>函数中，不能同行的判断不需要写。因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，且后序还会回溯释放掉这个元素。因此只需要写不能同列、不能同主对角线、不能同副对角线的判断。这三个判断的书写依据如<strong>下图</strong>所示。</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/n_queen_revised_2.png?raw=true" alt="n_queen_revised_2.png"></p>
<p>当我们尝试在<code>(row, col)</code>处放置皇后时，只有绿色部分可能在之前被放置过皇后。原因是：递归到当前层，只有行数&lt;row的格点上可能被放置过皇后。根据三条黄线，可以方便地写出三个判断。</p>
</li>
<li><p>本题的时间复杂度O(n!)，空间复杂度O(n)。</p>
<ul>
<li>时间复杂度：由于回溯法的本质依然是暴搜，因此，在棋盘的第一行，有n种放置皇后的方式；第二行最多有n - 1种，依次类推，得到时间复杂度为O(n!)。</li>
<li>空间复杂度即为树的深度，即为棋盘的行数，故空间复杂度为O(n)。</li>
</ul>
</li>
</ol>
<h3 id="37-解数独-1"><a href="#37-解数独-1" class="headerlink" title="37. 解数独"></a>37. 解数独</h3><ol>
<li>和之前的递归题目不同，本题的递归是<strong>二维递归</strong>。一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性。</li>
<li>本题递归函数的函数返回值类型为<code>bool</code>类型。原因是本题只需要找到一个解，就立即返回。如果需要搜索整棵二叉树，找到所有的解，然后将结果记录在结果集中，那么递归函数的返回值类型为<code>void</code>。</li>
<li>本题不需要写终止条件。因为在递归逻辑中，如果找到了满足条件的解，就会直接<code>return true</code>。如果某个空格中无论填入哪个数字都无法满足条件，就会直接<code>return false</code>。</li>
<li>注意<code>return true</code>和<code>return false</code>的位置。前者放在递归函数末尾，意思是若棋盘一直被填充直到被填满，则不会走<code>if (board[i][j] == &#39;.&#39;)</code>，就<code>return true</code>。后者放在<code>for (char k = &#39;1&#39;; k &lt;= &#39;9&#39;; k ++ )</code>的结束之处，意思是在空格处将9个数字都尝试了，无法填入，则说明该棋盘没有结果，<code>return false</code>。</li>
<li>时间复杂度：O(9^m) , m是’.’的数目。空间复杂度：$O(n^2)$，原因是递归的深度是n^2（原因是第一层<code>for</code>循环代表树的宽度，后面两层<code>for</code>循环代表了树的深度。由于本题中数独的长宽固定为9，因此本题中的<code>n = 9</code>）。</li>
<li>回溯的题目到此结束，总体来说比较简单，有统一的模板，但每个题目又有一些需要注意的小细节。</li>
</ol>
]]></content>
      <categories>
        <category>算法（回溯算法）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>总结</tag>
        <tag>回溯算法</tag>
        <tag>hard题</tag>
        <tag>二维递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 4 | Leetcode 24, 19, 160, 142</title>
    <url>/2024/01/27/Day-4-Leetcode-24-19-160-142/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">24. 两两交换链表中的节点</a><br><a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">19.删除链表的倒数第N个节点</a><br><a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">面试题 02.07. 链表相交</a><br><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">142.环形链表II</a><br><a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87.html">链表总结篇</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><ol>
<li>两个链表的交点不是数值相等，而是指针相等。</li>
<li>本题在构造测试样例时，会输入两个单链表和两个单链表的交叉点，以及交叉点到两个链表头节点的距离。因此，只有指定的交叉点才是真正的交叉点，仅仅是值相等的节点并不一定是真正的交叉点。指定的交叉点被构造出来时在内存中的地址相同，而仅仅是值相等的两个节点在内存中的地址不一定相同。</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>应该和交换数组中的两个元素相同。需要创建一个额外的节点tmp，然后若要交换a节点和b节点，则进行：<code>tmp = b, a = b, b = tmp</code>即可。</p>
<h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p>我能想到的办法：先遍历一遍列表，返回列表有几个节点。然后再遍历一遍列表，当cur指向倒数第N个节点的前一个节点时，停止遍历链表，删除cur-&gt;next，然后返回链表的头节点即可。应该也要用到虚拟头节点，避免删除链表的第一个节点时需要特判。我按照上述思路写了代码，可以成功通过测评！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建虚拟头节点</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 统计链表中的节点数量</span></span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            size ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 将cur指向倒数第n个节点的前一个节点</span></span><br><span class="line">        ListNode* cur1 = dummyHead;</span><br><span class="line">        <span class="type">int</span> size1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (size1 &lt; size - n)</span><br><span class="line">        &#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            size1 ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 删除倒数第n个节点，并释放其占用的内存</span></span><br><span class="line">        ListNode* tmp = cur1-&gt;next;</span><br><span class="line">        cur1-&gt;next= cur1-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更好的办法是采用双指针算法，见实现部分。</p>
<h3 id="面试题-02-07-链表相交-1"><a href="#面试题-02-07-链表相交-1" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p>我的第一想法是采用暴力解法。一个指针指向链表A的头节点，一个指针指向链表B的头节点，移动两个指针，当两个指针指向同一个节点时，说明该节点是两个链表相交的节点。据此，我写出了暴力解法的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* dummyHead2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead1-&gt;next = headA;</span><br><span class="line">        dummyHead2-&gt;next = headB;</span><br><span class="line"></span><br><span class="line">        ListNode* cur1 = dummyHead1;</span><br><span class="line">        ListNode* cur2 = dummyHead2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (cur1 = dummyHead1; cur1 != <span class="literal">NULL</span>; cur1 = cur1-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (cur2 = dummyHead2; cur2 != <span class="literal">NULL</span>; cur2 = cur2-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur1 == cur2)</span><br><span class="line">                    <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>暴力解法的时间复杂度是O(n^2)，应该有时间复杂度为O(n)的解法。时间复杂度更低的代码参见代码随想录。</p>
<h3 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><p>从没有见过这类题目，拿到题目毫无思路，直接看视频讲解和文字题解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="24-两两交换链表中的节点-1"><a href="#24-两两交换链表中的节点-1" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>注意：是交换链表中的节点，而不仅仅交换节点的数值。偶数个节点则正好两两交换，奇数个节点则最后一个点不参与交换。一定需要dummyHead，因为要交换节点1、2，就一定要用到它们之前的那个节点，即dummyHead（dummyHead-&gt;2-&gt;1-&gt;3-&gt;…）。同理，要交换节点3、4，就一定要用到它们之前的那个节点，即节点2。<strong>因此当前指针一定要指向要反转的两个节点中的前一个节点，且当前指针每次移动两位</strong>。</p>
<p>若链表中的节点个数为奇数，则cur-&gt;next-&gt;next == NULL时循环结束，若链表中的节点个数为偶数，则cur -&gt; next == NULL时循环结束。如下图所示。故遍历结束的条件为 <code>while (cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL)</code>。两个条件不可以反过来写，否则当出现空链表时，cur-&gt;next-&gt;next没有被定义，会出现空指针异常。<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/%E7%BB%98%E5%9B%BE1.png?raw=true" alt="绘图1.png"></p>
<p>接下来是两两交换节点的逻辑。改变后的链表为dummyHead-&gt;2-&gt;1-&gt;3，由于dummyHead-&gt;1改变为dummyHead-&gt;2后，原本的节点1已经不能被访问到了，因此需要先用tmp存下节点1。同理，由于要将2-&gt;3改为2-&gt;1，因此需要先用tmp1存下节点3。交换完节点的链表为：dummyHead-&gt;2-&gt;1-&gt;4-&gt;3…..。对于两两交换节点的逻辑，可以参考代码随想录教程中的三幅图片。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png" alt="24.两两交换链表中的节点3"></p>
<p>交换3和4节点的步骤时：cur目前为1，我们让1指向4，4再指向3，3再指向5（如果有5的话）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 交换两个节点需要用到这两个节点前的那个节点</span></span><br><span class="line">        <span class="comment">// 因此定义虚拟头节点，用于交换节点1和节点2</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="comment">// 搞清楚遍历的终止条件，参见笔记的图示</span></span><br><span class="line">        <span class="comment">// 以下两个终止条件分别针对节点数目为偶数和奇数的情况</span></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// dummyHead-&gt;2时，dummyHead-&gt;1不再存在，无法访问到1，因此需要事先存储节点1</span></span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 同理，2-&gt;1时，2-&gt;3不再存在，无法访问到3，因此需要事先存储节点3</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// dummyHead-&gt;2-&gt;1-&gt;3</span></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">// dummyHead-&gt;1变为dummyHead-&gt;2</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp; <span class="comment">// dummyHead-&gt;2-&gt;3变成dummyHead-&gt;2-&gt;1</span></span><br><span class="line">            tmp-&gt;next = tmp1; <span class="comment">//dummyHead-&gt;2-&gt;1再在末尾接上3</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">// cur指针后移两位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="19-删除链表的倒数第N个节点-1"><a href="#19-删除链表的倒数第N个节点-1" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p>看了代码随想录的思路之后，我独立写出了快慢指针解法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast先向后移动n位</span></span><br><span class="line">        <span class="keyword">while</span> (n -- ) fast = fast-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast移动到链表的最后一个节点（非空节点），此时slow移动到链表的倒数第n个节点前面的那个节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除倒数第n个节点</span></span><br><span class="line">        ListNode* tmp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以让fast先向后移动(n + 1)位，然后让fast和slow同时移动，直到fast移动到NULL为止，此时slow指向的也是倒数第n个节点的前一个节点。对这种办法，可以在移动fast指针前先让n ++ , 也可以在第一个while循环后让fast指针多向后移动一位。<strong>最稳妥的写法</strong>如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先将快指针移动n + 1步</span></span><br><span class="line">        n ++ ;</span><br><span class="line">        <span class="keyword">while</span> (n -- &amp;&amp; fast != <span class="literal">NULL</span>) fast = fast-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针同时移动，直到快指针指向NULL。此时慢指针指向要删除的节点前面那个节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存并删除倒数第n个节点</span></span><br><span class="line">        ListNode* tmp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于题目有如下限制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The number of nodes in the list is sz.</span><br><span class="line">1 &lt;= sz &lt;= 30</span><br><span class="line">0 &lt;= Node.val &lt;= 100</span><br><span class="line">1 &lt;= n &lt;= sz</span><br></pre></td></tr></table></figure>
<p>因此即使不加上fast != NULL，也可以通过，但如果题目没有n &lt;= sz的限制，那么必须加上fast != NULL，且不能使用以下写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (n -- &amp;&amp; fast != <span class="literal">NULL</span>) fast = fast-&gt;next;</span><br><span class="line">fast = fast-&gt;next;</span><br></pre></td></tr></table></figure>
<p>因为若采用以上写法，当n &gt; sz时，当while循环结束后，fast已经指向了NULL，此时再做fast = fast-&gt;next操作，会导致空指针异常。</p>
<h3 id="面试题-02-07-链表相交-2"><a href="#面试题-02-07-链表相交-2" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p>代码随想录的思路：求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB末尾对齐的位置。此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。否则循环退出返回空指针。</p>
<p>看了代码随想录的思路后，我独立写出了代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sizea = <span class="number">0</span>, sizeb = <span class="number">0</span>;</span><br><span class="line">        ListNode* cura = headA;</span><br><span class="line">        ListNode* curb = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算a链表的长度</span></span><br><span class="line">        <span class="keyword">while</span> (cura != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cura = cura-&gt;next;</span><br><span class="line">            sizea ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算b链表的长度</span></span><br><span class="line">        <span class="keyword">while</span> (curb != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curb = curb-&gt;next;</span><br><span class="line">            sizeb ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cura = headA, curb = headB;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> delta = <span class="built_in">abs</span>(sizea - sizeb); <span class="comment">// 两链表长度的差值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sizea &gt;= sizeb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (delta -- ) cura = cura-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sizeb -- )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cura == curb) <span class="keyword">return</span> cura;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cura = cura-&gt;next;</span><br><span class="line">                    curb = curb-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (delta -- ) curb = curb-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sizea -- )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cura == curb) <span class="keyword">return</span> cura;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cura = cura-&gt;next;</span><br><span class="line">                    curb = curb-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里特别需要注意的是，在计算完a链表和b链表的长度后，需要让 <code>cura = headA, curb = headB</code>。</p>
<p>代码随想录的写法更见简洁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* cura = headA, * curb = headB;</span><br><span class="line">        <span class="type">int</span> sizea = <span class="number">0</span>, sizeb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算a链表和b链表的长度</span></span><br><span class="line">        <span class="keyword">while</span> (cura != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cura = cura-&gt;next;</span><br><span class="line">            sizea ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curb != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curb = curb-&gt;next;</span><br><span class="line">            sizeb ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 始终保证链表a的长度大于等于链表b的长度</span></span><br><span class="line">        <span class="keyword">if</span> (sizea &lt; sizeb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(sizea, sizeb);</span><br><span class="line">            <span class="built_in">swap</span>(headA, headB);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 交换cura和curb后，再恢复cura和curb的指向</span></span><br><span class="line">        <span class="comment">// 也可以在上面直接swap(cura, curb)，那这句话就可以写到if判断的前面去</span></span><br><span class="line">        cura = headA, curb = headB;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 计算两链表的长度之差</span></span><br><span class="line">        <span class="type">int</span> delta = sizea - sizeb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指向链表a的指针，让链表a和b的尾部对齐</span></span><br><span class="line">        <span class="keyword">while</span> (delta -- ) cura = cura-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cura != <span class="literal">NULL</span>) <span class="comment">// 写作while (sizeb -- )也可</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cura == curb) <span class="keyword">return</span> cura;</span><br><span class="line">            cura = cura-&gt;next;</span><br><span class="line">            curb = curb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="142-环形链表II-1"><a href="#142-环形链表II-1" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><p>有两问：</p>
<ol>
<li><p>判断链表中是否有环</p>
<p>用快慢指针来判断是否有环。若链表是一条直线，则快慢指针永远不会相遇。只有当链表中有环存在时，快指针先进入了环且在环中浪费了时间，快慢指针才会相遇。快指针从头节点开始，每次移动两位，慢指针也从头节点开始，每次移动一位，二者若相遇则一定在环里相遇，相遇则说明有环。快指针是一个节点一个节点的靠近慢指针，因此二者一定会在环中相遇。</p>
</li>
<li><p>找到环的入口</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></p>
<p>列方程即可解出x：<code>x = n (y + z) - y, (n &gt;= 1)</code>，由于看不出x和负数-y之间的关系，我们让出一圈，看x和z的关系：<code>x = (n - 1) (y + z) + z, (n &gt;= 1)</code>。这就意味着：<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是环形入口的节点</strong>。</p>
<p>为什么第一次在环中相遇，slow的步数是x+y而不是 x + 若干环的长度 + y 呢？”这个问题，可以这样解释，设快指针每秒移动2格，慢指针每秒移动1格，圆的周长是k。则慢指针走一圈需要的时间是k，设两指针之间的距离为m(m &lt; k)，则快指针追上慢指针的时间是m（快指针相对于满指针每秒移动1格），此时慢指针走过的距离是m，由于m &lt; k，因此慢指针在遇到快指针之前走过的距离小于圆的周长。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head, * slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面两个循环条件保证了fast指针可以指向NULL，但不能指向NULL的next，这样就不会导致空指针异常</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next; <span class="comment">// 快指针每次移动两位</span></span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 慢指针每次移动一位</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 快慢指针相遇，说明链表中有环</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 一指针从相遇处开始移动，一指针从head处开始移动，二者相遇的位置就是环的入口，数学推导见笔记</span></span><br><span class="line">                ListNode* index1 = fast, * index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2)</span><br><span class="line">                &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 若没有返回环的入口节点，则说明没有环，返回空指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我自研的另一种写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head, * slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 判断链表中是否有环</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 有环，则返回环的起点，无环，则返回空指针</span></span><br><span class="line">        <span class="keyword">if</span> (flag &amp;&amp; fast == slow)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* index1 = head, * index2 = slow;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(index1 != index2)</span><br><span class="line">            &#123;</span><br><span class="line">                index1 = index1-&gt;next;</span><br><span class="line">                index2 = index2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，一定要通过flag判断，只有当fast和slow相等且二者都在第一个while循环中转过时，才能确保链表中有环，若fast和slow相等，则可能是链表中只有一个节点的情况，此时fast和slow都没有在第一个循环中转过，因此二者相等且都等于head。</p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="24-两两交换链表中的节点-2"><a href="#24-两两交换链表中的节点-2" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><ol>
<li>注意cur应该指向哪里。</li>
<li>注意遍历的终止条件（奇数/偶数个节点）</li>
<li>若原先的两节点之间的连接被断开，则需要在断开前保存两节点中后面那个节点，否则后面的那个节点无法被访问到</li>
</ol>
<h3 id="面试题-02-07-链表相交-3"><a href="#面试题-02-07-链表相交-3" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><ol>
<li>本题的关键思路在于：<strong>对齐两个链表的尾部</strong>。本题的算法实际上也是（快慢）双指针算法。</li>
<li>比较链表中的两个节点是否相同，直接用 <code>cura == curb</code>即可，不能用 <code>cura-&gt;val == curb-&gt;val &amp;&amp; cura-&gt;next == curb-&gt;next</code>，因为比较两个节点除去比较val和next这两个参数外，还需要比较其本身的内存地址。</li>
<li>本题的时间复杂度分析：<br>计算两个链表的长度：O(n) + O(m)<br>调整指针以对齐两个链表：O(n - m)或O(m - n)<br>同时遍历两个链表寻找交点：O(min(n, m))<br>第一步和第三步的时间复杂度加在一起是 <code>O(n) + O(m) + O(min(n, m))</code>。但是，因为 <code>O(min(n, m))</code>在 <code>O(n) + O(m)</code>中已经被包含（总是小于或等于 <code>n</code>和 <code>m</code>），所以总的时间复杂度简化为 <code>O(n) + O(m)</code>。第二步（调整指针以对齐两个链表）的时间复杂度实际上也包含在 <code>O(n) + O(m)</code>中，因为无论是 <code>n - m</code>还是 <code>m - n</code>，它的值总是小于或等于 <code>n</code>和 <code>m</code>。因此，整个函数的总时间复杂度为 <code>O(n + m)</code>，这里 <code>n</code>和 <code>m</code>分别是两个链表的长度。这个时间复杂度已经涵盖了所有的主要操作，包括计算长度、对齐链表和寻找交点。<strong>时间复杂度的计算应当关注主要操作，省略次要操作</strong>。</li>
<li>在leetcode中调用swap，abs等函数时，不需要自行引用头文件，基本的函数和数据结构（STL）已经默认被引用了，因此直接写出来即可。</li>
</ol>
<h3 id="142-环形链表II-2"><a href="#142-环形链表II-2" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><ol>
<li>记住使用快慢双指针算法，有环的情况下快慢指针必然会相遇。</li>
<li>画图理解如何求环的起点的index。</li>
<li><strong>记得复习时着重看这道题</strong></li>
</ol>
<h2 id="总结：链表"><a href="#总结：链表" class="headerlink" title="总结：链表"></a>总结：链表</h2><ol>
<li>插入虚拟头节点dummyHead，可以避免空链表并避免对头节点操作的特判</li>
<li>创建一个当前节点cur，对整个链表进行遍历（<code>cur = cur-&gt;next</code>），而不用链表中原本存在的节点对链表进行遍历</li>
<li>NULL节点表示不存在的节点；虚拟节点实际上是存在的，其值为0，是人为创建的节点</li>
<li>递归时，需要先检查递归的终止条件，然后执行递归步骤</li>
<li>想要删除哪个节点，就用cur指针指向其前面的那个节点</li>
<li><strong>链表中最常用的算法是双指针算法</strong>，在206.反转链表，19.删除链表的倒数第N个节点，面试题 02.07. 链表相交，142.环形链表II中都用到了，其他题目基本不需要算法，利用链表的一些基本性质进行增删改查即可。</li>
<li><strong>记得复习142.环形链表II和24.两两交换链表中的节点</strong>，前者是链表中最独特也最难的一道题，难在数学推导和想清楚细节；后者在退出循环的条件和用tmp保存节点方面需要特别注意。</li>
</ol>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png" alt="img"></p>
]]></content>
      <categories>
        <category>算法（链表）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>总结</tag>
        <tag>双指针算法</tag>
        <tag>环形链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 7 | Leetcode 454, 383, 15, 18</title>
    <url>/2024/01/31/Day-7-Leetcode-454-383-15-18/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">454.四数相加II</a><br><a href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">383. 赎金信</a><br><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15. 三数之和</a><br><a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">18. 四数之和</a><br><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%BB%E7%BB%93.html">哈希表总结篇</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><p>cpp中的map中的value是支持++操作的，且value可以通过key直接索引到，就像普通的数组那样。</p>
<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><ol>
<li><p>不仅对vector可以用范围遍历，对string类型的变量和普通的数组也可以用范围遍历的写法来简化代码。似乎范围遍历的速度要稍快于普通的for循环遍历。</p>
</li>
<li><p>cpp中，可以用erase函数来删除string类型变量的第j个字符，有两种写法：<br><code>string.erase(j, 1);</code><br><code>string.erase(s.begin() + j);</code></p>
</li>
<li><p>cpp中，如果想使用变量类型来给变量命名，需要使用std，有如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set; <span class="comment">// 使用 &quot;set&quot; 作为变量名</span></span><br><span class="line">    set.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    set.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>set</code>是作为<code>std::set&lt;int&gt;</code>类型的变量名使用的。由于<code>std::set</code>是在<code>std</code>命名空间中定义的，而变量<code>set</code>是在局部作用域中定义的，所以编译器能够区分这两者。</p>
</li>
</ol>
<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><ol>
<li>将四数之和由int类型转换为long类型：<code>(long) nums[i] + nums[j] + nums[l] + nums[r] &gt; target</code></li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="454-四数相加II-1"><a href="#454-四数相加II-1" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><p>这道题肯定是要用map做哈希的，且map的key用来存储元素的值，map的value用来存储元素的索引。此题和两数之和为target有较多的相同点，但也有些不同。若四个数相加为0，则其中的数两两互为相反数。但这种想法是不对的，可以存在2, 4, -3, -3的情况。对这题的算法我暂时想不出来什么好主意。</p>
<h3 id="383-赎金信-1"><a href="#383-赎金信-1" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p>看着就是242.有效的字母异位词的变式，若前面那个字符串可以由后面那个字符串中的字母构成，则返回true，否则返回false。本质就是看后面的字符串是否包含前面的字符串。因为两个字符串都只是由小写字母构成，因此用数组做哈希足矣。根据这个思路，我写出了如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本题的本质是判断后面的字符串是否包含前面的字符串，即后面的字符串中出现的所有字符是否在前面的字符串中出现过</span></span><br><span class="line">        <span class="type">int</span> N[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ransomNote.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            N[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            N[magazine[i] - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 数组N中有元素大于0，说明ransomNote中出现了magazine中未出现的字母</span></span><br><span class="line">        <span class="comment">// 说明前者不能完全由后者组成，返回false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (N[i] &gt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>采用范围遍历的方法，可以把上述代码写得更简洁：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ransomNote &lt; magazine return true</span></span><br><span class="line">        <span class="comment">// else return false</span></span><br><span class="line">        <span class="type">int</span> N[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> r: ransomNote)</span><br><span class="line">            N[r - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> m: magazine)</span><br><span class="line">            N[m - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: N)</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><p>这道题的题目我都不太理解，什么叫答案中不可以包含重复的三元组。直到我看到了示例1，明白了这个意思是可能存在情况：两个三元组，它们的索引组成的三元组可能不同，但这两个三元组本身的数值是完全相同的（忽略顺序），此时这两个三元组只能算作一个。这道题应该可以用哈希法，但需要去重。本题我认为有三个难点：</p>
<ul>
<li>枚举完一个数，怎么去寻找另外两个数</li>
<li>用什么数据结构维护另外两个数</li>
<li>如何去重</li>
</ul>
<h3 id="18-四数之和-1"><a href="#18-四数之和-1" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><p>本题应该依然是双指针算法。但需要注意去重的操作。我的思路是先对数组进行排序，然后让<code>a = i, b = i + 1, c = i + 2, d = nums.size() - 1</code>。然后一边向后移动a, b和c，一边对a,b和c去重，一边向前移动d，一边对d去重。根据以上思路，我写下了以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="comment">// 对i去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 对j去重</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left = j + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[left] + nums[right] &gt; target) right -- ;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[left] + nums[right] &lt; target) left ++ ;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对left和right进行去重</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left ++ ;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right -- ;</span><br><span class="line">                        left ++ ;</span><br><span class="line">                        right -- ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码测试样例通过了229 / 294，可见思路是对的，但细节仍不完美。我将在实现部分进一步优化细节。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="454-四数相加II-2"><a href="#454-四数相加II-2" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><p>四数相加和四数之和题目看起来相似，但前者是哈希表中的经典题目，后者用哈希表的方法不太合适。其实只需要知道有多少对四数之和为0，不需要知道每一对的具体数值。</p>
<p><strong>本题不需要去重</strong>，因此相对简单，四数之和则需要考虑去重。举例：四个数组，每个数组中都有n个0，则返回的结果是n。</p>
<p><strong>思路</strong>：遍历数组A和B，将从这两个数组取出的元素a + b放入map中；再遍历数组C和D，求得c + d，再判断map中有无我们想要的元素-(c + d)，有则count += -(c+d)出现过的次数（即map中key为-(c+d)的元素的value）。</p>
<p>本题的数据范围很大，因此用数组来做哈希不可取，只能考虑set/map。<strong>因为不仅需要将a + b放入哈希结构中，还需要统计a + b出现过多少次，因此用map</strong>。用map的key存a + b的值，用map的value存a + b出现的次数。</p>
<p>时间复杂度：<code>O(n^2) + O(n^2)</code>，还是<code>O(n^2)</code>。如果先遍历一个数组，再遍历三个数组，则时间复杂度是O(n^3)。</p>
<p>我知道上述思路后，尝试写代码，出现一个问题：不知道如何统计数组A和数组B中各取一个元素求和后的值出现的次数。我把简单的问题想复杂了，map中的value是支持++操作的，且value可以通过key索引到，因此直接：<code>map[num1 + num2] ++ ;</code>即可，这个代码的意思是：若<code>num1 + num2</code>的值出现过，则其<code>value += 1</code>；若没出现过，则相当于：<code>map.insert(&#123;num1 + num2, 1&#125;)</code>。写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历nums1和nums2数组，将两个数组各取一个值的和作为key，和出现的次数作为value存入map中</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num1: nums1)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num2: nums2)</span><br><span class="line">                sum[num1 + num2] ++ ; <span class="comment">// 和为num1 + num2的值的出现次数 + 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历nums3和nums4数组，设两个数组各取一个值的和是c + d</span></span><br><span class="line">        <span class="comment">// 若map中出现了-(c + d)，则count += value</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num3: nums3)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num4: nums4)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> s = num3 + num4;</span><br><span class="line">                <span class="keyword">auto</span> it = sum.<span class="built_in">find</span>(-s);</span><br><span class="line">                <span class="keyword">if</span> (it != sum.<span class="built_in">end</span>())</span><br><span class="line">                    count += it-&gt;second; <span class="comment">// it-&gt;second也可以写作sum[-s]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>更简洁的写法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num1: nums1)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num2: nums2)</span><br><span class="line">                map[num1 + num2] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num3: nums3)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num4: nums4)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> target = -(num3 + num4);</span><br><span class="line">                <span class="keyword">if</span> (map.<span class="built_in">find</span>(target) != map.<span class="built_in">end</span>())</span><br><span class="line">                    count += map[target];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="383-赎金信-2"><a href="#383-赎金信-2" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p>注意，本题的题干中虽然强调了<code>Each letter in magazine can only be used once in ransomNote</code>，但这个条件在写代码时实际上并不需要考虑。这应该只是生成测试样例时需要遵守的规则。</p>
<p>本题用暴力做法也可以过，但暴力做法的代码写起来似乎还更麻烦一点。暴力做法就是两重for循环，若ransomNote中出现了magazine中出现过的字符，则从ransomNote中移除该字符，最后判断ransomNote的长度是否为0即可。暴力做法的代码可以参见代码随想录。</p>
<p>至于时间复杂度为O(n)的哈希解法，我在初次尝试中写的就已经很完美了。若想进一步优化，可以加上判断：若ransomNote的长度大于magazine的长度，则可以直接return false。若在遍历字符串时就对数组中元素的正负进行判断，那需要注意：只能在ransomNote中对数组中元素的正负进行判断，为负则说明赎金信中有magazine中没有的字符。若在magazine中对数组中元素的正负进行判断，可能存在问题：数组中的元素为正不一定代表赎金信中有magazine中没有的字符，可能仅仅是因为尚未遍历完成，数组中的元素还没被减到负数。因此，下面的代码是错误的：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> r: ransomNote)</span><br><span class="line">            N[r - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> m: magazine)</span><br><span class="line">        &#123;</span><br><span class="line">            N[m - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">            <span class="keyword">if</span> (N[m - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以通过测试样例轻而易举地看出上述解法的漏洞，比如<br>ransomNote =”aa”<br>magazine =”aab”<br>Output false<br>Expected true<br>而代码随想录上的哈希解法的代码是正确的。</p>
<p>若想避免上述问题，最直接的办法就是等到N数组中的元素全部计算完成后，另开一个循环来判断其中是否有为正的元素。</p>
<h3 id="15-三数之和-1"><a href="#15-三数之和-1" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><p>本题可以用哈希法做，但比较复杂。本题需要返回的三元组，其中的元素是数组中元素的值，而非下标。<strong>注意：三元组是去重的。本题相较于两数之和的难点就在于去重</strong>。</p>
<p>哈希法的大致思路：用两重for循环，第一重确定a，第二重确定b，然后看-(a + b)是否在map中出现过。但这里的难点在于：需要同时对a, b和c（-a - b）去重。去重的细节太多了，基本上都会遇到小问题，难以一次想周全。<strong>因此推荐使用更易于理解的双指针法</strong>。</p>
<p>双指针法的思路：<strong>使用双指针法之前需要对数组进行排序</strong>。for循环遍历数组，得到a；left指针从数组的第2个位置开始向后移动，得到b；right指针从数组的最后一个位置开始向前移动，得到c。若<code>num[i] + num[left] + num[right] &gt; 0</code>，说明三数之和大了，i是固定的（for循环从头开始遍历），因此应当让<code>right --</code>。若<code>num[i] + num[left] + num[right] &lt; 0</code>，说明三数之和小了，应该让其变大，则应当让<code>left ++</code>。若三数之和为0，则将三者放入二维数组res中。注意细节：去重。num[i], num[left], num[right]三个数都需要去重，因为res中不能有重复的三元组。</p>
<p>伪代码：（注：<code>a = num[i], b = num[left], c = num[right]</code>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 存储结果</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 排序后，若最小值仍大于0，说明不存在三数之和等于0的情况，返回现有的res即可</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// nums[i]即a，需要对a去重</span></span><br><span class="line">    <span class="comment">// 三元组之间不可重复，但三元组内部可以有重复的数字，比如000</span></span><br><span class="line">    <span class="comment">// 去重是nums[i] == nums[i + 1] continue还是nums[i] == nums[i - 1] continue</span></span><br><span class="line">    <span class="comment">// 应该是后者。若是前者，由于left指针指向nums[i + 1]，因此若b和a相同，则会跳过这个结果集，这显然是错误的</span></span><br><span class="line">    <span class="comment">// 因为三元组内部是可以有重复的数字的</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 当前三元组的a和上一个三元组的a重复，则进入下一个循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 求三个数，因此是left &gt; right。若left = right，则三个数变为了两个数</span></span><br><span class="line">    <span class="keyword">while</span> (right &gt; left)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right -- ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left ++ ;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;); <span class="comment">// 三者之和等于0.则放入结果数组中，收获结果</span></span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">        		<span class="keyword">while</span> (right &gt; left &amp;&amp; right[i] == right[i - <span class="number">1</span>]) right -- ; <span class="comment">// 对c去重</span></span><br><span class="line">        		<span class="keyword">while</span> (right &gt; left &amp;&amp; left[i] == left[i + <span class="number">1</span>]) left ++  ; <span class="comment">// 对b去重</span></span><br><span class="line">            <span class="comment">// 收获一个结果后，left和right都向着数组的中间位置移动</span></span><br><span class="line">            left ++ ;</span><br><span class="line">            right -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<p>细节：</p>
<ul>
<li><p>如何对a去重：<code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</code></p>
</li>
<li><p>如何对b和c去重：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (right &gt; left &amp;&amp; right[i] == right[i - <span class="number">1</span>]) right -- ; <span class="comment">// 对c去重</span></span><br><span class="line"><span class="keyword">while</span> (right &gt; left &amp;&amp; left[i] == left[i + <span class="number">1</span>]) left ++  ; <span class="comment">// 对b去重</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对b和c去重的代码放在哪里<br> 必须先收获结果，再去重。否则若出现数组中全是0的情况，就会一直运行去重的逻辑，而不收获结果。</p>
</li>
</ul>
<p>根据上述伪代码，我独立写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 用双指针算法前需要先排序</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 二维数组，存放结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三元组&#123;a, b, c&#125;，i指向a, left指向b, right指向c</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若最小的a都大于0，则三数之和不可能等于0，不需要继续循环，返回现有的res即可</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对a去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right -- ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left ++ ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;); <span class="comment">// 收获结果</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 对b和c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left ++ ;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right -- ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 移动left和right指针</span></span><br><span class="line">                    left ++ ;</span><br><span class="line">                    right -- ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="18-四数之和-2"><a href="#18-四数之和-2" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><p>和三数之和思路相同，但多一重for循环。共有i, j, left, right四个指针，前三者初始时分别指向数组的前三个元素，right指向数组最后一个元素。left和right向中心靠拢，使得<code>nums[i] + nums[j] + nums[left] + nums[right] = target</code>。</p>
<p>细节：剪枝和去重。</p>
<ul>
<li>一级剪枝：不能延续三数之和的剪枝操作：<code>if(nums[i] &gt; target) return res;</code>。这没有考虑到数组中可能有负数的情况，若数组中有负数，几个元素相加是越加越小的，因此即使最小的数大于target，通过加上一些负数，四数之和依然可能为target。正确的剪枝操作应该为：<code>if (nums[i] &gt; target &amp;&amp; nums[i] &gt; 0 &amp;&amp; target &gt; 0) break;</code>。其实这里写break（即最后返回）和写return res都是可以的，并不会影响运行结果。</li>
<li>二级剪枝：<code>if (nums[i] + nums[j] &gt; target &amp;&amp; nums[i] + nums[j] &gt; 0 &amp;&amp; target &gt; 0) break;</code><strong>二级剪枝完成后只能写break，写return res会有几个测试样例无法通过</strong>。原因：一级剪枝条件时直接return res，相当于结束所有循环，返回结果，不会漏掉部分四元组；二级剪枝时直接return res，同样相当于结束所有循环，返回结果，此时就会漏掉部分四元组。<strong>正确的做法应该是结束第二重循环，继续进行第一重循环</strong>。</li>
</ul>
<p>其实还有一个细节需要注意，在求四数之和<code>nums[i] + nums[j] + nums[left] + nums[right]</code>时，若四个数都是10亿，加起来就会超过int的限制（大约21亿），因此需要把四数之和转化为<code>long</code>类型：<code>(long) nums[i] + nums[j] + nums[l] + nums[r] &gt; target</code>。如果不将int转换为long，会报错：整数溢出，同时有几个测试样例无法通过。代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a = i, b = j(i + 1), c = l(i + 2), d = r(nums.size() - 1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target &amp;&amp; target &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; <span class="comment">// 一级剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 一级去重</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] &gt; target &amp;&amp; target &gt; <span class="number">0</span> &amp;&amp; nums[i] + nums[j] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; <span class="comment">// 二级剪枝</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 二级去重</span></span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> l = j + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[j] + nums[l] + nums[r] &gt; target) r -- ;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[j] + nums[l] + nums[r] &lt; target) l ++ ;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[l], nums[r]&#125;);</span><br><span class="line">                        <span class="comment">// 对l和r去重</span></span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) l ++ ;</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) r -- ;</span><br><span class="line">                        l ++ ;</span><br><span class="line">                        r -- ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="454-四数相加II-3"><a href="#454-四数相加II-3" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><ol>
<li><p>本题的大体思路？<br>遍历前两个数组A和B，将a + b的值存入map<br>再遍历后两个数组C和D，在map中查找-(c + d)的值</p>
</li>
<li><p>为什么选择map做哈希？<br>因为不仅需要存储a + b的值，还需要存储这个值出现的次数(<code>map[a + b] ++</code>)，用于在4中统计元组的个数</p>
</li>
<li><p>map中的key放什么？value放什么？<br>map中的key放a + b的值，map中的value放这个值出现的次数</p>
</li>
<li><p>如何统计元组的个数？<br><code>count += map[-(c + d)]</code></p>
</li>
<li><p>如何统计a和b的和出现的次数？<br><code>map[a + b] ++</code></p>
</li>
</ol>
<h3 id="383-赎金信-3"><a href="#383-赎金信-3" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p>代码随想录上的哈希解法不如我在初次尝试部分写的哈希解法简洁，而且代码随想录的哈希解法在颠倒遍历两个字符串的顺序时容易出错。<strong>本题的最佳解法是我在初次尝试部分写的第二个版本的代码</strong>。</p>
<h3 id="15-三数之和-2"><a href="#15-三数之和-2" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><ol>
<li>采用双指针法，不要用哈希法，哈希法写起来复杂，去重麻烦、难以做剪枝操作，故效率显著低于双指针法</li>
<li>双指针法思路简单，但要注意去重的细节</li>
<li>排序的目的是方便剪枝，且一个三元组只会有唯一的顺序</li>
<li><strong>双指针法只适用于返回的结果是数而不是索引的题目</strong>，因为双指针法使用前必须对数组进行排序，排序后索引会被打乱，因此返回的结果不能是索引。若两数之和要求返回的结果是数，那么也可以用双指针算法。这不禁让我思考，若本题要求返回的结果是索引，那么也只能用哈希法。但如果要求返回的结果是索引，那么就不需要有复杂的去重操作，因此实际上是简化了本题。</li>
<li>对于<code>nums[i]</code>（即a）去重的代码，可以用if判断写：<code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</code>，也可以用while循环写：<code>while (i &lt; nums.size() &amp;&amp; i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) i ++ ;</code>。一般在写while循环时，都需要加上<strong>对数组索引不可越界的限制</strong>：<code>i &lt; nums.size()</code>。如果出现报错：<code>Runtime Error: AddressSanitizer</code>，大概率是因为数组索引越界了，此时需要检查是否加上了限制条件<code>i &lt; nums.size()</code>和<code>i &gt; 0</code>。</li>
</ol>
<h3 id="18-四数之和-3"><a href="#18-四数之和-3" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><ol>
<li>本题思路和三数之和相同，但需要注意剪枝的细节</li>
<li>还需要注意在求四数之和时将int类型转换为long类型，避免整数溢出。</li>
<li>若采用双指针算法，三数之和的时间复杂度是<code>O(n^2)</code>，四数之和的时间复杂度是<code>O(n^3)</code>。用暴力做法的时间复杂度则分别为<code>O(n^3)</code>和<code>O(n^4)</code>。</li>
<li>本题相比于四数相加，由于要考虑去重问题，所以更加复杂，因此无法（不推荐）使用哈希法，推荐使用双指针算法。</li>
<li>剪枝方面可以做进一步的优化，但属实没有必要。</li>
<li>本题写剪枝统一用break，不要用return res，以免方式意外的错误</li>
<li>本题如果有几个测试样例总是过不了，可以直接删去剪枝的代码，一般就可以通过了。剪枝是优化，即使不加，依然可以轻松通过。剪枝部分是易错点。</li>
</ol>
<h2 id="哈希表总结"><a href="#哈希表总结" class="headerlink" title="哈希表总结"></a>哈希表总结</h2><ol>
<li>哈希表的使用场景：快速判断一个元素是否在集合中出现过。</li>
<li>哈希的三重境界：普通数组-&gt;set-&gt;map。</li>
<li>目前哈希中用到的set和map实际上是unordered_set和unordered_map，相对于set和map中的另外两种数据结构（set, multiset, map, multimap），unordered_set和unordered_map的查询效率和增删效率都是最高的。选择set类型的三种数据结构时，若我们不需要数据有序，且需要去重，且希望效率高，则用unordered_set。选择map类型的三种数据结构时，若我们不需要key有序，且希望效率高，则用unordered_map。</li>
<li>遇到哈希问题时，首先想想能不能用数组做哈希（比如题目中提到字符串中全是小写英文字母，就果断用数组做哈希）。用数组做哈希最直接，运行速度也最快，用set做哈希速度更慢，但遇到大规模的索引，数组放不下时，只能用set。</li>
<li>什么时候用map做哈希？当对一个元素需要同时存储两个值时，就必须用map做哈希。这两个值一个作为key，一个作为value存入map中。key中一般存储的是元素的值（便于查询），value中可以存放元素的索引（如1. 两数之和），也可以存放元素出现的次数（如454.四数相加II）。</li>
<li>map可以当作普通数组一样使用，忘了STL的用法可以复习知识部分。</li>
<li>哈希表部分的八道算法题，前六道都使用的是正统的哈希法，最后两道（三树之和&amp;四数之和）并非不可以使用哈希法，但使用哈希法需要进行复杂的去重操作，代码容易写错，且运行效率低下，因此推荐使用双指针算法。</li>
<li>三数之和&amp;四数之和的易错点在于剪枝和去重。每重for循环都需要剪枝和去重，while循环进行去重即可，但其实剪枝是一种优化，并不是必须的。但去重是必须的！</li>
</ol>
]]></content>
      <categories>
        <category>算法（哈希表）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>总结</tag>
        <tag>双指针算法</tag>
        <tag>数组哈希</tag>
        <tag>map哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 9 | Leetcode 28, 459, summary</title>
    <url>/2024/02/03/Day-9-Leetcode-28-459-summary/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">28. 实现 strStr()</a><br><a href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html">459.重复的子字符串</a><br><a href="https://programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html">字符串：总结篇</a><br><a href="https://programmercarl.com/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93.html">双指针总结篇</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="KMP算法理论"><a href="#KMP算法理论" class="headerlink" title="KMP算法理论"></a>KMP算法理论</h3><h4 id="KMP与解决的问题"><a href="#KMP与解决的问题" class="headerlink" title="KMP与解决的问题"></a>KMP与解决的问题</h4><p>KMP：发明本算法的三位学者的英文名首字母</p>
<p>应用：字符串匹配问题</p>
<p>经典例子：</p>
<ul>
<li><p>给出文本串: aabaabaaf</p>
</li>
<li><p>给出模式串: aabaaf<br>求在文本串中是否出现过模式串</p>
</li>
</ul>
<h4 id="暴力方法与KMP"><a href="#暴力方法与KMP" class="headerlink" title="暴力方法与KMP"></a>暴力方法与KMP</h4><p>暴力解法：两重for循环，先遍历文本串，再遍历模式串，挨个匹配。从文本串的首位开始，若模式串不匹配文本串，则将模式串后移一位，直到匹配上。时间复杂度O(m * n)，m和n分别是文本串和模式串的长度。</p>
<p>KMP算法：跳到之前已匹配的地方，继续匹配。</p>
<h4 id="前缀表的由来"><a href="#前缀表的由来" class="headerlink" title="前缀表的由来"></a>前缀表的由来</h4><p>KMP算法如何知道我们之前已匹配过哪些，且跳到已匹配的内容后面继续匹配？</p>
<p>前缀表有什么特性，可以让我们找到之前已匹配过的内容？</p>
<p>在f处不匹配，找到f前面子串的后缀是aa，找到与该后缀相等的前缀的后面开始匹配。故我们要求一个字符串中的最长相等前后缀，重新匹配时跳到最长前缀之后开始匹配。</p>
<h4 id="前缀与后缀"><a href="#前缀与后缀" class="headerlink" title="前缀与后缀"></a>前缀与后缀</h4><p>前缀：包含首字母，不包含尾字母的所有子串。</p>
<p>后缀：包含尾字母，不包含首字母的所有子串。</p>
<h4 id="最长相等前后缀"><a href="#最长相等前后缀" class="headerlink" title="最长相等前后缀"></a>最长相等前后缀</h4><p>最长相等的前缀和后缀的长度。以模式串aabaaf为例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>子串</th>
<th>前缀</th>
<th>后缀</th>
<th>最长相等的前缀和后缀的长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>无</td>
<td>无</td>
<td>0</td>
</tr>
<tr>
<td>aa</td>
<td>a</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>aab</td>
<td>a, aa</td>
<td>b, ab</td>
<td>0</td>
</tr>
<tr>
<td>aaba</td>
<td>a, aa, aab</td>
<td>a, ba, aba</td>
<td>1</td>
</tr>
<tr>
<td>aabaa</td>
<td>a, aa, aab, aaba</td>
<td>a, aa, baa, abaa</td>
<td>2</td>
</tr>
<tr>
<td>aabaaf</td>
<td>a, aa, aab, aaba, aabaa</td>
<td>f, af, aaf, baaf, abaaf</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>得到模式串的前缀表：010120。</p>
<h4 id="使用前缀表的匹配过程"><a href="#使用前缀表的匹配过程" class="headerlink" title="使用前缀表的匹配过程"></a>使用前缀表的匹配过程</h4><p>模式串 aabaaf<br>前缀表 010120<br>发现f不匹配，要找f前的最长相等前后缀，由前缀表得到最长相等前后缀为2。2意味着有一个后缀aa，前面也有一个与之相等的前缀aa。在后缀aa的后面不匹配了，就要从与后缀相等的前缀的后面继续开始匹配。最长相等前后缀为2，故从<code>s[2] = &#39;b&#39;</code>处开始重新匹配。</p>
<h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><p>next/prefix都可以用来表示前缀表。在遇到不匹配的地方，next数组告诉我们要回退到哪里。前缀表为010120，对其的处理包括：右移/统一减一。不处理前缀表，就将其作为next数组，依然可以完成KMP算法。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>KMP算法-&gt;能解决哪些问题-&gt;为什么KMP算法匹配失败后可以跳到某个位置-&gt;前缀表-&gt;前缀表的特性及如何求取前缀表-&gt;用前缀表完成一次匹配的操作-&gt;实现KMP算法时，有时对前缀表统一减一，有时右移，这不设计KMP算法原理性的东西，只是实现上方法不同而已。</p>
<h3 id="KMP算法的代码实现"><a href="#KMP算法的代码实现" class="headerlink" title="KMP算法的代码实现"></a>KMP算法的代码实现</h3><h4 id="next数组不同的实现方式"><a href="#next数组不同的实现方式" class="headerlink" title="next数组不同的实现方式"></a>next数组不同的实现方式</h4><p>模式串：aabaaf</p>
<p>文本串：aabaabaaf</p>
<p>前缀表：010120，用next数组表示。</p>
<p>如何求next数组？</p>
<ul>
<li>有人会把前缀表右移，第一位放上-1，得到-101012，作为next数组。</li>
<li>有人会把前缀表整体-1，得到-10-101-1，作为next数组。</li>
<li>有人会直接拿前缀表做Next数组。<br>上述实现方式都可以，但具体处理逻辑会略有差别。</li>
</ul>
<p>模式串与文本串在模式串的最后一位f处发生了冲突，<strong>看f的前一位的前缀表的值是多少</strong>，发现是2，于是跳转到下标为2的位置，即b。如果next数组是前缀表右移得到，<strong>就直接比较f对应的next数组的值</strong>，发现是2，于是也跳转到b的位置。若next数组是前缀表-1得到，那么就把f的前一位的next数组的值+1，依然跳转到b的位置。</p>
<p>next数组的核心：遇到冲突向前回退。<strong>本节我们就拿前缀表作为next数组</strong>。</p>
<h4 id="求Next数组的具体代码"><a href="#求Next数组的具体代码" class="headerlink" title="求Next数组的具体代码"></a>求Next数组的具体代码</h4><p>共4步：</p>
<ol>
<li>初始化</li>
<li>处理前后缀不相同的情况</li>
<li>处理前后缀相同的情况</li>
<li>更新next数组的值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入的参数：next数组，我们需要对其进行赋值，模式串s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(vector&lt;<span class="type">int</span>&gt; next, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 指针i：指向后缀末尾位置</span></span><br><span class="line">    <span class="comment">// 指针j：指向前缀末尾位置，还代表着i之前（包括i）的子串的最长相等前后缀的长度</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 前缀从0开始</span></span><br><span class="line">    <span class="type">int</span> next[N]; </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// next数组初始位置为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较前后缀所对应的字符是否相等，故i从1开始，这样i和j才能进行比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理前后缀末尾不相同的情况</span></span><br><span class="line">        <span class="comment">// 因为在一次循环中，i相当于是固定不动的，所以此时j回退</span></span><br><span class="line">        <span class="comment">// j回退到next[j - 1]指向的位置，即遇见冲突，就看next数组（即前缀表）的前一位</span></span><br><span class="line">        <span class="comment">// 不止回退一步，而要连续回退，不能写if，而要写while</span></span><br><span class="line">        <span class="keyword">while</span> ( j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = next[j - <span class="number">1</span>]; <span class="comment">// 因为要求j - 1 &gt;= 0，因此要求j &gt; 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理前后缀相同的情况</span></span><br><span class="line">        <span class="comment">// j代表着i之前（包括i）的子串的最长相等前后缀的长度</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) j ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新next数组，在其中存储i之前（包括i）的子串的最长相等前后缀的长度</span></span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模拟运行过程"><a href="#模拟运行过程" class="headerlink" title="模拟运行过程"></a>模拟运行过程</h4><p>当j指向s[1]，i指向s[2]时，前后缀不匹配，此时next[j - 1] = next[0] = 0，j回退到s[0]，再次比较前后缀是否匹配，发现仍不相同，此时j无法继续回退，我们就更新next数组的值，next[2] = 0，这就代表i = 2之前包括i的子串的最长相等前后缀为0，这与表格中的结果相同。此时i后移一位，指向s[3]，有s[3] == s[0]，j ++，j = 1，next[3] = 1，说明aaba的最长相等前后缀长度是1，这与表格中的结果相同。进入下一轮循环，i = 4，同理。最终用getNext函数完成了对next数组的求值。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>用上述函数，求得了next数组，即前缀表。</p>
<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p>求next数组的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入的参数：next数组，我们需要对其进行赋值，模式串s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(vector&lt;<span class="type">int</span>&gt; next, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 前缀从0开始</span></span><br><span class="line">    <span class="type">int</span> next[N]; </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// next数组初始位置为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较前后缀所对应的字符是否相等，故i从1开始，这样i和j才能进行比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = next[j - <span class="number">1</span>]; <span class="comment">// 因为要求j - 1 &gt;= 0，因此要求j &gt; 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) j ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新next数组，在其中存储i之前（包括i）的子串的最长相等前后缀的长度</span></span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用next数组做匹配的代码（文本串s，模式串t）：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 因为next数组里记录的起始位置为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// i从0开始，遍历文本串</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != t[j]) &#123; <span class="comment">// 不匹配, j - 1 &gt;= 0 =&gt; j &gt; 0</span></span><br><span class="line">        j = next[j - <span class="number">1</span>]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == t[j]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">        j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了</span></span><br><span class="line">    <span class="keyword">if</span> (j == t.<span class="built_in">size</span>()) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">        <span class="comment">// 返回当前在文本串匹配模式串的位置i-模式串的长度 + 1，就是文本串字符串中出现模式串的第一个位置（位置从0开始）</span></span><br><span class="line">        <span class="keyword">return</span> (i - t.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况，模式串长度为0，则返回0，本处是一个易错点</span></span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义next数组</span></span><br><span class="line">        <span class="type">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="comment">// 填充next数组</span></span><br><span class="line">        <span class="built_in">getNext</span>(next, needle);</span><br><span class="line">        <span class="comment">// 用next数组做匹配</span></span><br><span class="line">        <span class="comment">// j指向模式串，i指向文本串</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 模式串匹配不上文本串，则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>n为文本串长度，m为模式串长度</p>
<ul>
<li>时间复杂度: 生成next数组，时间复杂度是O(m)；根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)。所以总共的时间复杂度为O(n + m)</li>
<li>空间复杂度: 开辟空间用于存储next数组，即模式串的前缀表，因此是O(m)</li>
</ul>
<h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>枚举所有的子串，看能否构成字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 子串结束位置</span><br><span class="line">	<span class="keyword">for</span> 子串与主串比较</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n^2)。目标子串的开始位置必然是主串最前面的元素，因此只需要枚举子串的结束位置即可。</p>
<h4 id="移动匹配"><a href="#移动匹配" class="headerlink" title="移动匹配"></a>移动匹配</h4><p>设一个可由重复的子串构成的字符串为s，那么两个s拼接起来，前一个s的后半部分和后一个s的前半部分又可以构成一个新的字符串s。s由重复子串构成的判据：两个s相加起来，若其中出现了s，那么s就是由重复子串构成的。</p>
<p>注意：在(s + s)中去搜索s时，一定要把(s + s)的首元素和尾元素删去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ss = s + s;</span><br><span class="line">        ss.<span class="built_in">erase</span>(ss.<span class="built_in">begin</span>());</span><br><span class="line">        ss.<span class="built_in">erase</span>(ss.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// string::npos 是 std::string 类型的一个静态成员常量，表示字符串中不存在匹配的位置。在 find() 函数中，如果没有找到匹配的子串，则返回 string::npos。这个值通常是一个很大的无符号整数，表示找不到匹配的位置。</span></span><br><span class="line">        <span class="keyword">if</span> (ss.<span class="built_in">find</span>(s) != string::npos)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>find函数的实现其实就是28. 实现strStr()。若用KMP实现find函数，那么时间复杂度是O(m + n)，find函数的其他实现方法时间复杂度大抵也是O(m + n)。</p>
<h4 id="KMP解法"><a href="#KMP解法" class="headerlink" title="KMP解法"></a>KMP解法</h4><p>KMP算法的应用场景：模式串是否在文本串中出现过，即上面的find函数的一种实现方式。</p>
<p>前缀：不包含尾字母，一定包含首字母的所有子串。<br>后缀：包含尾字母，不包含首字母的所有子串。</p>
<p>结论：若s由重复子串组成，那么它的最小重复单位就是它的最长相等前后缀不包含的那个子串。后缀不包含和前缀不包含的部分是相同的，都是最小重复子串。</p>
<p>举例：abababab，最长相等前缀是ababab，最长相等后缀是ababab，剩余的部分ab即为最小重复子串。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728205249.png" alt="图三"></p>
<p>推导：设原字符串是s，标出其下标；设最长相等前缀是t，最长相等后缀是f，也分别标出下标。利用最长相等前缀和最长相等后缀的下标之间的对应关系和最长相等前后缀和原字符串下标之间的对应关系推导即可。</p>
<p>实现：设s存在最小重复单位，len为s的长度，则<code>next[len - 1]</code>为s的最长相等前后缀的长度，最小重复单位的长度为：<code>len - next[len - 1]</code>，若该长度能被原字符串的长度整除：<code>len % (len - next[len - 1]) == 0</code>，那么return true。有如下代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求next数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span> <span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 处理前后缀不相同的情况</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理前后缀相同的情况</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新next数组</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span> <span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next, s);</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 核心代码</span></span><br><span class="line">        <span class="keyword">if</span> (next[len - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; len % (len - (next[len - <span class="number">1</span>] )) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="28-实现-strStr-1"><a href="#28-实现-strStr-1" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p>直接听卡尔讲，尝试去理解，不要求独立写出代码。</p>
<h3 id="459-重复的子字符串-1"><a href="#459-重复的子字符串-1" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><p>直接听卡尔讲，尝试去理解，不要求独立写出代码。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="28-实现-strStr-2"><a href="#28-实现-strStr-2" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p>因为KMP算法很难，大家别奢求一次就把kmp全理解了，大家刚学KMP一定会有各种各样的疑问，先留着，别期望立刻啃明白，第一遍了解大概思路，二刷的时候，再看KMP会懂很多。或者说大家可以放弃一刷可以不看KMP，今天来回顾一下之前的算法题目就可以。</p>
<p>因为大家算法能力还没到，细扣很难的算法，会把自己绕进去，就算别人给解释，只会激发出更多的问题和疑惑。所以大家先了解大体过程，知道这么回事， 等自己有算法基础和思维了，在看多看几遍视频，慢慢就理解了。</p>
<h3 id="459-重复的子字符串-2"><a href="#459-重复的子字符串-2" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><p>本题算是KMP算法的一个应用，不过对KMP了解不够熟练的话，理解本题就难很多。 </p>
<p>建议是 <strong>KMP和本题，一刷的时候 ，可以适当放过，了解怎么回事就行，二刷的时候再来硬啃</strong></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="28-实现-strStr-3"><a href="#28-实现-strStr-3" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><ol>
<li>我觉得KMP算法很想一种特殊的双指针算法。一个指针i用于遍历文本串，另一个指针j用于根据next数组的指引在模式串中移动。这种双指针算法可以把时间复杂度从暴力算法的O(n * m)优化为O(n + m)。</li>
<li>代码分为独立的两部分，第一部分是求next数组（即前缀表），第二部分是同时在两个字符串中移动指针并使用next数组。</li>
<li>当模式串为空时，应当返回0。因为空字符串被认为是任何字符串的子串，所以文本串中最开始与模式串匹配的字符的索引就是0。如果文本串中不存在与之匹配的模式串，则返回 -1。</li>
</ol>
<h3 id="459-重复的子字符串-3"><a href="#459-重复的子字符串-3" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><ol>
<li>本题有两种解法：移动匹配和KMP解法。如果忘记了KMP算法的next数组怎么写，可以使用移动匹配方法（最难写的KMP部分可以用find函数来代劳）。</li>
<li>注意string中find函数的用法：在 find() 函数中，如果没有找到匹配的子串，则返回 string::npos。</li>
<li>本题的KMP解法的关键在于结论：若s由重复子串组成，那么它的最小重复单位就是它的最长相等前后缀不包含的那个子串。</li>
</ol>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><h3 id="字符串总结"><a href="#字符串总结" class="headerlink" title="字符串总结"></a>字符串总结</h3><p>常见题型和常用方法：</p>
<ol>
<li>花式反转字符串（整体&amp;局部反转，有时还要搭配双指针算法删除空格）</li>
<li>后续处理字符串</li>
<li>KMP算法（匹配模式串和文本串）</li>
<li>移动匹配（核心也是KMP算法，只不过核心由库函数find实现）</li>
</ol>
<p>小知识：</p>
<ol>
<li>substr，split，reverse, erase这四个库函数的时间复杂度都是O(n)，在循环中使用会使得程序的时间复杂度达到O(n^2)。此时需要双指针算法等进行优化。</li>
<li>字符串本质为字符数组，数据结构基本等用于普通数组，因此普通数组中常用的双指针算法也常用于字符串中。</li>
</ol>
<h3 id="双指针总结"><a href="#双指针总结" class="headerlink" title="双指针总结"></a>双指针总结</h3><p>双指针应用于：</p>
<ol>
<li>数组：移除元素</li>
<li>字符串：反转字符串、替换数字、翻转字符串里的单词</li>
<li>链表：反转链表、环形链表II</li>
<li><p>哈希表章节：三数之和、四数之和，两数之和若要求返回两数的值而非索引，也可以用双指针做，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 存储结果</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 先排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] + nums[right] &gt; target) right -- ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) left ++ ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;nums[left], nums[right]&#125;); <span class="comment">// 收获答案</span></span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left ++ ;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right -- ;</span><br><span class="line">            <span class="comment">// 寻找新的答案</span></span><br><span class="line">            left ++ ;</span><br><span class="line">            right -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码本质上就是三数之和、四数之和的一部分（for循环中的while循环）。相比于两数之和的哈希写法，新增了值去重的功能。</p>
<p>双指针的题目中，以三数、四数之和以及反转链表最容易写错，一定要多复习。三数、四数之和的易错点在于剪枝、去重和求四数之和时的int类型变量的溢出。反转链表的易错点在于搞错了tmp, cur-&gt;next, prev和cur更新的先后顺序。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法（字符串）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>总结</tag>
        <tag>KMP算法</tag>
        <tag>find函数</tag>
        <tag>移动匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 6 | Leetcode 242, 349, 202, 1</title>
    <url>/2024/01/29/Day-6-Leetcode-242-349-202-1/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">哈希表理论基础</a><br><a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词</a><br><a href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集</a><br><a href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">202. 快乐数</a><br><a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1. 两数之和</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h3><p>哈希表-&gt;哈希函数-&gt;哈希碰撞-&gt;拉链法/线性探测法-&gt;常见的三种哈希结构-&gt;set &amp; map及如何选取-&gt;总结</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表是根据关键码的值而直接进行访问的数据结构。举例：其实数组就是一张哈希表。哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。</p>
<p>哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数：哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。如果hashCode得到的数值大于哈希表的大小了，也就是大于tableSize了，此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。</p>
<p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。接下来<strong>哈希碰撞</strong>登场。</p>
<h4 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h4><p>小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p>
<h4 id="拉链法-线性探测法"><a href="#拉链法-线性探测法" class="headerlink" title="拉链法/线性探测法"></a>拉链法/线性探测法</h4><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放冲突的数据了。</p>
<h4 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h4><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p>
<ul>
<li>数组</li>
<li>set （集合）</li>
<li>map(映射)</li>
</ul>
<h4 id="set-amp-map及如何选取"><a href="#set-amp-map及如何选取" class="headerlink" title="set &amp; map及如何选取"></a>set &amp; map及如何选取</h4><p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-01-29_09-29-58.png?raw=true" alt="Snipaste_2024-01-29_09-29-58.png"></p>
<p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<p><img src="https://raw.githubusercontent.com/yfchenkeepgoing/image/main/image.png" alt="img"></p>
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>
<p>两个unordered都是哈希表实现的,其他四个都是红黑树实现的。三类set和三类map性质上是类似的。</p>
<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>
<p>那么再来看一下map ，在map 是一个key-value 的数据结构，map中，对key是有限制，因为key的存储方式使用红黑树实现的，对value没有限制。</p>
<p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下，==当我们遇到了<strong>要快速判断一个元素是否出现集合里</strong>的时候，就要考虑哈希法==。哈希法的查询速度很快：O(1)。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h4><ol>
<li>将一个数组中的元素全部置为0：<code>int hash[26] = &#123;0&#125;;</code>。实际上，直接写<code>int hash[26]</code>也可以，不给数组中的值赋值，数组中的值默认为0。</li>
<li>求字符串<code>string s</code>的长度，可以用<code>s.size()</code>，也可以用<code>s.length()</code>。</li>
<li><code>s[i] - &#39;a&#39;</code>：编译器会自动用ascii码进行计算，不需要手动将变量类型转换为整数。</li>
<li>一个有返回值的函数，如果执行了return语句，函数直接结束，不需要再break。</li>
<li>定义一个常量大小的数组，空间复杂度是O(1)。</li>
</ol>
<h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h4><ol>
<li>set, multiset, unordered_set。前两者底层实现是红黑树，最后一个的底层实现是哈希值直接映射。unordered_set就是一个可以无限存装的数组。本题用unordered_set，因为其做映射和取值时效率最高，前两者的底层实现是树，因此取值是还要有查找的过程。unordered_set中的元素不可重复，相当于自动帮我们做去重；而multiset中的元素可以重复。</li>
<li>可以直接将set类型的数据转换为vector类型：<code>return vector&lt;int&gt;(set.begin(), set.end())</code>。</li>
<li>cpp中的vector中既有insert方法，又有push_back方法，前者需要指定插入元素的具体位置，后者直接将元素插入到vector的末尾。cpp的set（包括set, multiset, unordered_set）中只有insert方法，传入的参数为要插入的值，不需要指定插入元素的具体位置。</li>
<li>将vector转换为unordered_set: <code>unordered_set&lt;int&gt; nums1_set(nums1.begin(), nums1.end())</code>。</li>
<li>在unordered_set中查找元素：<code>nums1_set.find(nums2[i])</code>，返回的结果是一个迭代器（指针）。如果找到该值，<code>find</code>返回一个指向该元素的迭代器；如果未找到，则返回一个指向<code>unordered_set</code>末尾的迭代器，即<code>end()</code>迭代器。</li>
</ol>
<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h4><ol>
<li>返回一个vector可以直接将vector的内容写入大括号中，然后返回，比如<code>return &#123;a[i], b[i]&#125;</code>，返回一个空数组可以直接写成<code>return &#123;&#125;</code>，而不用定义一个vector再利用push_back方法向其中插入数，然后再返回这个vector。</li>
<li>定义的<code>vector&lt;int&gt; a</code>，若不给其赋值，则该vector长度为0。可见vector是动态地被分配内存，如果不给其赋值，则其长度为0，不占用内存，这与普通数组需要在定义时声明长度有所不同。</li>
<li>定义unordered_map的方式：<code>unordered_map&lt;int, int&gt; map</code>；unordered_map中有insert函数和find函数，用法同unordered_set；遍历这些STL容器都要用迭代器，相当于是一种加强版的指针；访问unordered_map的key和value：<code>map-&gt;first</code>和<code>map-&gt;second</code>。</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="242-有效的字母异位词-1"><a href="#242-有效的字母异位词-1" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p>想到一个办法，用两个数组分别统计两个字符串中出现的字母和字母出现的频次，然后判断两个数组是否完全相同。代码如下所示，可以成功运行：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash1[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> hash2[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash1[s[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash2[t[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (hash1[i] != hash2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>稍微麻烦了点，实际上用一个数组就够了。</p>
<h3 id="349-两个数组的交集-1"><a href="#349-两个数组的交集-1" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p>暂时还不会用set做哈希，因此先尝试用数组做哈希。我写下了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash1[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> hash2[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计两个数组nums1和nums2中每个数值出现的频次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash1[nums1[i]] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash2[nums2[i]] ++ ;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若一个数同时在nums1和nums2数组中出现的频次&gt;=1，则该数是两数组的重叠，放入结果数组res中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash1[i] &amp;&amp; hash2[i])</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题其实是使用set的好题，但是后来力扣改了题目描述和测试用例，添加了 0 &lt;= nums1[i], nums2[i] &lt;= 1000 条件，所以使用数组也可以了，不过建议大家忽略这个条件。 尝试去使用set。</p>
<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p>尽管说这道题和上一道题原理上差不多，只是套了快乐数的壳子，但我看不出这题怎么用set来进行哈希。直接看讲解吧。</p>
<h3 id="1-两数之和-1"><a href="#1-两数之和-1" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>看到的第一想法是类似滑动窗口，但滑动窗口（209.长度最小的子数组）返回的是长度最小的子数组的长度，这道题却要返回两个整数的下标，因此还是有很大不同的。如果要快速在集合中查找一个元素是否出现过，那么应该采用哈希表的方法。我产生了一个想法，将nums数组中的所有数一对一对不重不漏地取出，将每一对数的和作为索引（key），将它们的下标作为（value）存入map中，然后通过查询map的索引来找到目标对，进而返回目标对的下标。实现起来有两个难点：</p>
<ul>
<li>如何不重不漏地枚举所有的数对？</li>
<li>如何将两个下标存入一个value里？</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="242-有效的字母异位词-2"><a href="#242-有效的字母异位词-2" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p><strong>判断两个字符串是否由相同的字母组成</strong>，但字母的位置可以不同。两个完全一样的字符串也是有效异位词。由于字符串中都是小写字母，因此a可以对应数组中索引为0的位置，z可以对应数组中索引为25的位置。用数组hash[26]统计第一个数组中每个字母出现的频率，然后第二个字符串中每个字母出现的频率再在hash数组中做对应的减法，若最后数组中所有元素均为0，则说明两个字符串互为有效的字母异位词。</p>
<p><strong>什么时候用数组/set/map：当哈希值较小，且范围也较小且可控；若哈希值很大，则用set；若是key-value对，则用map</strong>。</p>
<p>根据上述思路，我独立写出了代码，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 数组中的元素全部初始化为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash[s[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            hash[t[j] - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (hash[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="349-两个数组的交集-2"><a href="#349-两个数组的交集-2" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p>返回两个数组的交集。注意要去重。虽然可以用数组哈希，但还是建议用set。若保持之前的题目描述，让两个数组中的数值可能非常大，比如上亿，此时就必须要用set了，因为数组下标放不下那么大的数，同时会浪费很多存储空间。</p>
<p>哈希表善于解决判断一个元素是否在一个集合中出现过的题目。<strong>集合中的数值很大时，或者集合中的元素数量很少但数值很分散时，用数组不合适，要用set</strong>。先将数组nums1中的所有数值放到哈希表中，再遍历num2，查看其中的元素的数值是否在哈希表中出现过，出现过则放入res集合中。</p>
<p>因为要<strong>去重</strong>，所以定义unordered_set来存储result。哈希表也用unordered_set。直接将nums1转化为unordered_set的存储结构。接着遍历nums2，看哈希表中是否出现了nums2中的元素，出现了则将其放入result中。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220707173513.png" alt="set哈希法"></p>
<p>代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储答案的unordered_set，因为是unordered_set所以自动去重</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将nums1从vector转换为unordered_set</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums1_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在nums1_set中查找nums2中的数据，如果出现过，则将其插入res中</span></span><br><span class="line">        <span class="comment">// 也可以用范围遍历for (int num: nums2)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1_set.<span class="built_in">find</span>(nums2[i]) != nums1_set.<span class="built_in">end</span>())</span><br><span class="line">                res.<span class="built_in">insert</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将res从unordered_set类型转换回vector类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<br>构建<code>nums_set</code>：O(n)<br>遍历<code>nums2</code>并检查元素是否在<code>nums_set</code>中：O(m)<br>构建结果向量：O(k)，其中k是结果集中元素的数量<br>综上所述，总的时间复杂度是O(n + m + k)。但是由于k（结果集的大小）是由n和m决定的，并且在大多数情况下k会小于n和m，所以可以近似地认为时间复杂度主要由n和m决定，即O(n + m)。</p>
<p>如果用数组做哈希的话，除了我在初次尝试中写的那种方式，其实还有另一种方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res; <span class="comment">// 存储结果，去重</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nums1中出现过的数，则将其在哈希数组中的值标记为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums1)</span><br><span class="line">            hash[num] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若nums2中的数在nums1中出现过，则将其插入res中  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums2)</span><br><span class="line">            <span class="keyword">if</span> (hash[num] == <span class="number">1</span>)</span><br><span class="line">                res.<span class="built_in">insert</span>(num);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// unordered_set-&gt;vector</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="202-快乐数-1"><a href="#202-快乐数-1" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p>题目中说：Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.本题本来是一个数学问题，可以得到严格的数学证明，但我们不需要懂数学，可以用编程的思维去解决它。</p>
<p>因此，一个数进行如题的操作后，要么会陷入死循环，要么会在某个时刻等于1并保持。因此，可以写一个循环来持续对输入的数进行如题的操作，如果某次操作的结果在之前出现过，那么该数就不是快乐数；如果操作的结果为1，那么该数就是快乐数。要快速判断一个元素是否在集合中出现过，就应该用一个set将集合中的所有元素维护起来。代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 用于求一个数每一位的平方之和的函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSumofDigits</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            s += (n % <span class="number">10</span>) * (n % <span class="number">10</span>); <span class="comment">// 求每一位的平方</span></span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; loop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 持续循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">getSumofDigits</span>(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 结束循环，是快乐数</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 若发现出现死循环，则立即返回不是快乐数</span></span><br><span class="line">                <span class="keyword">if</span> (loop.<span class="built_in">find</span>(s) != loop.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 尚未出现死循环，则继续</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    loop.<span class="built_in">insert</span>(s);</span><br><span class="line">                    n = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以将上述代码写得更见简练，更好理解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            s += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">getSum</span>(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 退出条件1，是快乐数</span></span><br><span class="line">            <span class="keyword">if</span> (set.<span class="built_in">find</span>(s) != set.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 退出条件2，不是快乐数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不满足两个退出条件，则继续循环</span></span><br><span class="line">            n = s;</span><br><span class="line">            set.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里主要处理的是数字 n 的每一位，一个数字n它的位数可以认为是logn（一个d位的数大约是10的d次方，n = 10^d =&gt; d = logn）。每次进行快乐数的判断会执行一次该计算操作，但是因为快乐数的范围有限，总体来看不会超过 logn 的常数倍，因此时间复杂度是O(log n)。</p>
<p>所以随着<code>n</code>的增加，存储在<code>unordered_set</code>中的不同可能结果的数量实际上是有限的。事实上，随着<code>n</code>的增长，这个数量的增长速度接近于对数增长。换句话说，即使<code>n</code>非常大，经过<code>getSum</code>处理后的结果仍然是一个相对较小的数字集合。因此空间复杂度为<code>O(logn)</code>。至于为什么是<code>logn</code>，我认为原因是其增长速度最慢，这比<code>sqrt(n)</code>等其他形式更符合n较大时set中存储的元素的数量接近一个常数的事实。</p>
<h3 id="1-两数之和-2"><a href="#1-两数之和-2" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>本题需要用map解决。判断一个元素是否在一个集合中出现过：用哈希法。假设target = 9，当遍历到元素3时，我们需要去寻找元素6是否被遍历过。把遍历过的元素加到一个集合（哈希表结构）中，每次遍历新元素a时，判断(target - a)是否在集合中出现过。若出现过，我们需要知道其下标，因此集合中既要存储元素的值，又要存储元素的下标。此时想到用map，存储元素的值用map的key，存储元素的下标用map的value（因为要查找元素是否出现过，因此以元素的值作为key，map能以最快的速度找到这个key是否在这个map中出现过）。</p>
<p>看完上述思路后，我独立写出了以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; store;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有元素的值作为key，索引作为value存入map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            store.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每遍历到一个元素nums[i]，查找target - nums[i]是否在map中</span></span><br><span class="line">        <span class="comment">// 是则返回结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = store.<span class="built_in">find</span>(t);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意除去第一个条件外，还需要保证查找到的元素并非当前元素本身</span></span><br><span class="line">            <span class="comment">// 否则会出现target = 两倍当前元素而导致的误判</span></span><br><span class="line">            <span class="keyword">if</span> (it != store.<span class="built_in">end</span>() &amp;&amp; it-&gt;second != i)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继续听讲解，<strong>map用于存放遍历过的元素的值和索引</strong>。本题使用unordered_map，其存和读的效率是最高的。因此写出了以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; store;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每遍历到一个元素nums[i]，查找target - nums[i]是否在map中</span></span><br><span class="line">        <span class="comment">// 是则返回结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = store.<span class="built_in">find</span>(t);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若找到了target - nums[i]，则将其索引和当前遍历的元素的索引返回</span></span><br><span class="line">            <span class="keyword">if</span> (it != store.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将已经遍历过的元素的值作为key，索引作为value存入map中</span></span><br><span class="line">            store.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我的第一版代码在store中存储了数组中所有元素的值和索引，因此需要保证查找到的元素并非当前元素本身。第二版代码在store中存储的是已经遍历过的元素，故天然满足查找到的元素并非当前元素本身的条件。两版代码都是对的，但后者更为简洁。最简洁版本的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// 用于存储已遍历过的元素的值和索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 用于查找map中是否有目标元素</span></span><br><span class="line">            <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="comment">// 有，则返回两个索引构成的vector</span></span><br><span class="line">            <span class="keyword">if</span> (it != map.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123;i, it-&gt;second&#125;;</span><br><span class="line">            <span class="comment">// 无，则将当前元素的值和索引插入map中，然后开始循环的下一轮</span></span><br><span class="line">            map.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成循环后还没找到两个索引，则返回空vector</span></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="242-有效的字母异位词-3"><a href="#242-有效的字母异位词-3" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><ol>
<li>本题的本质是判断两个字符串是否由相同的字母组成。</li>
<li>本题用数组实现哈希。</li>
<li>遇到哈希问题时，首先想想能不能用数组做哈希。用数组做哈希最直接，运行速度也最快，用set做哈希速度更慢，但遇到大规模的索引，数组放不下时，只能用set。</li>
</ol>
<h3 id="349-两个数组的交集-3"><a href="#349-两个数组的交集-3" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><ol>
<li>本题本来不改测试数据，数组中的数值可能很大时，只能用set做哈希。现在对数组中的数值做了限制，最大不超过1000，则可以用数组做哈希。</li>
<li>用数组做哈希比用set做哈希效率更高，因为用set的话每次往里Insert一个值，都需要对这个值做一次哈希运算，同时还要开辟一个新的空间。用数组的下标做哈希映射永远是最快的。</li>
<li>本题适合用来衔接用数组做哈希和用set做哈希。</li>
<li>本题用set做哈希时，要记住set的各种用法：vector和unordered_set互相转化，在unordered_set中查找元素。这些用法归纳在知识中。</li>
<li>本题有三种解法：一种是用set哈希，另外两种是用数组做哈希。用数组做哈希建议采用我在初次尝试中的做法，只需要用到数组，不需要用到unordered_set去重。</li>
<li>采用范围遍历的写法可以简化代码。</li>
</ol>
<h3 id="202-快乐数-2"><a href="#202-快乐数-2" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p>这道题的逻辑其实非常简单。若各个位上的平方和为1，则退出循环，返回是快乐数；若平方和之前出现过，则说明进入了死循环，也退出循环，返回不是快乐数；其他情况下，继续循环。由于本题的<code>1 &lt;= n &lt;= 2^31 - 1</code>，各个位的平方和的数据范围非常大，因此必须用set做哈希，不能再用数组做哈希。注意本题时间复杂度和空间复杂度的分析。时间复杂度和空间复杂度不存在<code>sqrt(n)</code>等表达式，要么是1, 要么是logn，要么是n，要么nlogn或者更大。</p>
<h3 id="1-两数之和-3"><a href="#1-两数之和-3" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>四个重要问题：</p>
<ol>
<li>为什么用哈希法：快速查找一个元素（目标元素）是否在集合（unordered_map存放已遍历过的元素）中出现过。</li>
<li>为什么要用map（unordered_map）：因为既需要存储元素的值，也需要存储元素的索引。这道题目中并不需要key有序，选择unordered_map 效率更高。</li>
<li>map的作用：存储<strong>已遍历过</strong>的元素的值和索引。</li>
<li>map中的key存了元素的值（便于查询），value存了元素的索引（作为结果返回）。</li>
</ol>
]]></content>
      <categories>
        <category>算法（哈希表）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>数组哈希</tag>
        <tag>map哈希</tag>
        <tag>set哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 8 | Leetcode 344, 541, k54, 151, k55</title>
    <url>/2024/02/01/Day-8-Leetcode-344-541-k54-151-k55/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">344.反转字符串</a><br><a href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">541. 反转字符串II</a><br><a href="https://programmercarl.com/kama54.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html">卡码网：54.替换数字</a><br><a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">151.翻转字符串里的单词</a><br><a href="https://programmercarl.com/kama55.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html">卡码网：55.右旋转字符串</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p>一般来说，编程语言自己实现的库函数都是左闭右开的，因此<code>reverse(s, i, i + k)</code>表示的是反转字符串s的第i位到第i + k位，不包含第i + k位。</p>
<h3 id="卡码网：54-替换数字"><a href="#卡码网：54-替换数字" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><ol>
<li>注意，cpp中比较大小不能写作<code>48 &lt;= s[i] &lt;= 57</code>，而是要写作<code>s[i] &gt;= 48 &amp;&amp; s[i] &lt;= 57</code>。表达式<code>48 &lt;= s[i] &lt;= 57</code>实际上会先计算<code>48 &lt;= s[i]</code>，这个表达式的结果是一个布尔值<code>true</code>或<code>false</code>，在C++中，这个布尔值会被隐式转换为整数，<code>true</code>转换为<code>1</code>，<code>false</code>转换为<code>0</code>。然后，该整数（<code>0</code>或<code>1</code>）会与<code>57</code>进行比较，所以条件几乎总是为真（除非<code>s[i]</code>是字符<code>&#39;0&#39;</code>）。</li>
<li>扩容字符串的函数为<code>resize</code>函数。</li>
<li>cpp中是可以不遍历字符串中的每个字符，就直接cout输出整个字符串的。</li>
<li>字符串和数组的区别（摘自代码随想录）：<br>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，接下来我来说一说C/C++中的字符串。<br>在C语言中，把一个字符串存入一个数组时，也把结束符 ‘\0’存入数组，并以此作为该字符串是否结束的标志。<br>在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，<strong>就不用’\0’来判断是否结束</strong>。<br>那么vector&lt; char &gt; 和 string 又有什么区别呢？<br>其实在基本操作上没有区别，但是<strong>string提供更多的字符串处理的相关接口</strong>，例如string 重载了+，而vector却没有。所以想处理字符串，我们还是会定义一个string类型。</li>
<li>若要求某个字符在0-9之间，既可以写<code>s[i] &gt;= 48 &amp;&amp; s[i] &lt;= 57</code>（’0’的ascii码是48，’1’的ascii码是57），也可以写<code>s[i] &gt;= &#39;0&#39; &amp;&amp; s[i] &lt;= &#39;9&#39;</code>。</li>
</ol>
<h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><ol>
<li>erase函数的时间复杂度是O(n)</li>
<li>本题可以用split函数来从字符串中分割出单词，但那样就失去了意义</li>
<li>若给一个函数传入的参数加上引用<code>&amp;</code>，那么在函数中对这个参数进行了修改，调用该函数后该参数也会被修改。</li>
</ol>
<h3 id="卡码网：55-右旋转字符串"><a href="#卡码网：55-右旋转字符串" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h3><ol>
<li>注意：若在ACM模式中调用<code>reverse</code>函数，必须<code>#include &lt;algorithm&gt;</code>，否则会报错。但若调用<code>swap</code>函数，不需要引用任何头文件，直接使用即可。</li>
</ol>
<h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>先尝试用reverse函数秒杀，顺便复习reverse函数的用法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>reverse函数相当于把字符串反转以后，将新的字符串存入了旧的字符串中。</p>
<p>我曾经做过反转链表的题，猜测用双指针可以解决这道题。写下了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = s.<span class="built_in">size</span>() - <span class="number">1</span>; l &lt; r; l ++ , r -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// swap(s[l], s[r]);</span></span><br><span class="line">            <span class="type">int</span> tmp = s[l];</span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>直接用swap函数或者手写swap函数都是可以的。<code>l &lt; r</code>或者<code>l &lt;= r</code>都可以。因为字符串中字符的个数为奇数时，中间那个字符交换不交换都一样；字符个数为偶数时，交换最后两个成对的字符即可。</p>
<h3 id="541-反转字符串II-1"><a href="#541-反转字符串II-1" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p>拿到这道题，我的第一想法是分类讨论。设字符串的长度是<code>len</code>。若<code>len &lt; k</code>，则全部反转；若<code>k &lt;= len &lt; 2k</code>，则反转前k个字母；若<code>len &gt;= 2k</code>，则按照题意反转。本题在反转的逻辑上没有困难，但问题在于如何分割出需要反转的子字符串。我没想出来什么好办法，写的逻辑太复杂又容易出错。</p>
<h3 id="卡码网：54-替换数字-1"><a href="#卡码网：54-替换数字-1" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><p>我先输入字符串s，然后定义每个元素由char类型变量组成的vector。遍历字符串s，若其中的某个字符的ascii码在48-57之间，说明该字符是数字0-9，那么向vector中依次插入number这6个字符。其他情况下，向vector中插入原始字符即可。据此思路写下以下的代码，可以通过评测。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="number">48</span> &amp;&amp; s[i] &lt;= <span class="number">57</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">            out.<span class="built_in">push_back</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            out.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; out.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        cout &lt;&lt; out[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="151-翻转字符串里的单词-1"><a href="#151-翻转字符串里的单词-1" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p>这道题yxc应该讲过,要么通过流的方式读入为一个个单词，样例代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span> <span class="comment">// 引入 stringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line); <span class="comment">// 使用 getline 读取一整行</span></span><br><span class="line"></span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(line)</span></span>; <span class="comment">// 使用 stringstream 来分割字符串</span></span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; word) &#123; <span class="comment">// 从 stringstream 中读取单词，直到结束</span></span><br><span class="line">        cout &lt;&lt; word &lt;&lt; endl; <span class="comment">// 输出单个单词</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>要么通过双指针算法找出一个个单词并存储之。然后再将一个个单词逆序拼接为字符串并输出。我先尝试后一种方法。但没有做出来。</p>
<h3 id="卡码网：55-右旋转字符串-1"><a href="#卡码网：55-右旋转字符串-1" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h3><p>本题我下意识地使用substr来写，得到如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    string s1 = s.<span class="built_in">substr</span>(s.<span class="built_in">size</span>() - k, s.<span class="built_in">size</span>()); <span class="comment">// 后面k个字符</span></span><br><span class="line">    string s2 = s.<span class="built_in">substr</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - k); <span class="comment">// 字符串在后面k个字符前的字符</span></span><br><span class="line">    cout &lt;&lt; s1 + s2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>向substr中传入的区间是左闭右开的。</p>
<p>若不借助库函数，我还有一个想法。先拿一个字符串保存输入字符串的后面k个字符。然后在输入字符串的基础上，从尾部倒着插入前面的那些字符，最后再将另一个字符串保存的原字符串的后面k个字符插到新字符串的前面去。其实倒着插入和顺着插入也没什么区别。</p>
<p>我还想到一种做法。受到151. 翻转字符串里的单词启发，首先反转整个字符串，然后反转字符串的前k位，最后反转字符串的后(n - k)位。由此写出了两个版本的代码，第一版是直接调用reverse函数，第二版是手动实现reverse函数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + k);</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + k, s.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动实现reverse函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(string &amp;s, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = i, b = j; a &lt; b; a ++ , b -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = s[a];</span><br><span class="line">        s[a] = s[b];</span><br><span class="line">        s[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverseString</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverseString</span>(s, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverseString</span>(s, k, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="344-反转字符串-1"><a href="#344-反转字符串-1" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>在算法的思路上，字符串和数组非常类似。本题应用双指针法即可：首尾交换，再次一级交换，以此类推。因此首尾各有一个指针，两指针交换，然后两指针同时向中间移动。若库函数直接把题目解决了，就不要用库函数。若库函数是题目的一部分，且我们知道库函数的大体实现逻辑和时间复杂度，那就可以用。代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>() / <span class="number">2</span>; i ++ , j -- )</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>swap函数有两种方法，一种是常见的交换数值，另一种是位运算，可参见代码随想录。</p>
<h3 id="541-反转字符串II-2"><a href="#541-反转字符串II-2" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p>模拟题，模拟复杂的规则下，如何反转字符串。题意：每2k段的前k个字符进行反转，尾部如果剩下的字符超过长度超过k，则反转k个字符，剩下的不动。尾部如果剩下的字符长度小于k，则全部反转。本题的代码可以很简洁。</p>
<p>本题每次取2k段，因此按照2k来遍历：<code>for (int i = 0; i &lt; s.size(); i += 2k)</code>。然后在for循环中操作前k个字符即可。边界条件想不明白可以带一个具体的例子来试。代码和注释如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每隔2k个字符跳转一次，即每次取出2k个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += <span class="number">2</span> * k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对2k个字符的前k个字符进行反转</span></span><br><span class="line">            <span class="comment">// 由于每次取2k，取若干次后。字符串的尾部剩下的字符长度l可能l &lt; k 或 k &lt;= l &lt; 2k</span></span><br><span class="line">            <span class="comment">// 对前一种情况，需要将尾部全部反转，对后一种情况，需要反转尾部剩下字符的前k个字符</span></span><br><span class="line">            <span class="comment">// 先处理后一种情况，注意加上条件i + k &lt;= s.size()，这可以避免对索引超出范围的元素进行反转</span></span><br><span class="line">            <span class="comment">// 至于i + k是否能取到s.size()，可以举例子：k = 3, s = &#123;a, b, c&#125;，由此可见可以取等于</span></span><br><span class="line">            <span class="comment">// 也可以从理论上分析，由于reverse的区间是左闭右开的，因此s.begin() + i + k实际上取不到，因此可以让i + k = s.size() </span></span><br><span class="line">            <span class="comment">// 处理完后continue即可，除去反转2k个字符中的前k个字符的一般情况，尾部剩下的字符的长度的第一种情况和第二种情况只可能有一种发生</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k); <span class="comment">// 左闭右开</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再处理前一种情况，当剩余的字符长度l &lt; k时，反转剩余的全部字符</span></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>也可以不用continue，直接采用if-else写法，参见代码随想录的写法（代码随线录的注释也更加简洁明了）：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="卡码网：54-替换数字-2"><a href="#卡码网：54-替换数字-2" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><p>本题的最佳解法不需要额外的辅助空间。首先扩充原字符串到每个数字字符替换成 “number” 之后的大小。然后用<strong>双指针算法</strong>，指针i指向旧字符串的末尾，指针j指向新字符串的末尾。用指针i遍历旧字符串，若遇到字母，则原样填入指针j指向的位置；若遇到数字，则从后往前将number填入到指针j指向的位置。直到i和j都指向新旧字符串的开头为止。这里的新旧字符串其实是扩容之后和扩容之前的同一字符串，只是为了方便区分称它们为新旧字符串。根据这个思路，我写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// count为字符串中数字的数量</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="number">48</span> &amp;&amp; s[i] &lt;= <span class="number">57</span>)</span><br><span class="line">            count ++ ;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> oldSize = s.<span class="built_in">size</span>();</span><br><span class="line">    s.<span class="built_in">resize</span>(oldSize + count * <span class="number">5</span>); <span class="comment">// 字符串扩容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双指针算法，i指向旧字符串，j指向新字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = oldSize - <span class="number">1</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &lt; <span class="number">48</span> || s[i] &gt; <span class="number">57</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            s[j] = s[i];</span><br><span class="line">            i -- ;</span><br><span class="line">            j -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[j] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">3</span>] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">4</span>] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">            s[j - <span class="number">5</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">            i -- ;</span><br><span class="line">            j -= <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以直接写作cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        cout &lt;&lt; s[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码随想录的代码本质上和我写的是一样的，但他写的更见简洁一些，我写的更易于理解一些。</p>
<p>我的写法中，必须让<code>i &gt;= 0</code>，不能写成<code>i &gt; 0</code>，否则答案错误。例子，输入1，输出本来应该为number，若for循环的条件为<code>i &gt; 0</code>，则不会进入for循环，直接输出1，这显然是不对的。但对于代码随想录的写法：<code>for (int i = sNewSize - 1, j = sOldSize - 1; j &lt; i; i--, j--)</code>，则<code>j &lt; i</code>是正确的，若首字符为字母，则j = i时两指针均以指向首字符，首字符保留即可，不需要处理；若首字符为数字，则逻辑也可以正确执行。若<code>j &lt;= i</code>，则反而会出现越界的问题，因为当j和i都指向首字符后，for循环的条件依然满足，此时完成当前循环后，i和j继续-1，再次判断时，i依然等于j，再次进入循环，此时s[i]和s[j]就不存在了（s[-1]不存在）。</p>
<h3 id="151-翻转字符串里的单词-2"><a href="#151-翻转字符串里的单词-2" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p>是字符串中操作比较复杂的题目，给的字符串中在开头、中间、结尾都可能有空格。反转字符串里的单词后，要将多余的空格都删掉。</p>
<p>整体思路：先让单词的顺序和目标相同，即将整个字符串都反转。再对每个单词做反转，就得到了目标字符串。<strong>将原字符串整体反转，再将每一个单词反转</strong>。</p>
<p>难点：如何删去多余的空格。要求空间复杂度O(1)，即不能申请新的字符串来放置删去多余空格后的字符串。且不能使用库函数。使用快慢双指针算法，删除多余空格的时间复杂度为O(n)。<strong>快指针用于遍历旧字符串，慢指针用于依次指向新字符串中的各个元素</strong>。（新字符串在旧字符串的基础上修改，并不需要另外创建字符串来存储新字符串）。双指针的用法同数组章节的移除元素。</p>
<p>根据上述思路，我写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpace</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; s.<span class="built_in">size</span>(); fast ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[fast] != <span class="string">&#x27; &#x27;</span>) <span class="comment">// 去除字符串开头的空格</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每复制完一个单词后，加一个空格</span></span><br><span class="line">                <span class="comment">// 这句话不可以放在while循环后，否则会在最后一个单词后面增加一个多余的空格</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow ++ ] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将旧字符串的非空部分复制到新字符串中</span></span><br><span class="line">                <span class="keyword">while</span> (fast &lt; s.<span class="built_in">size</span>() &amp;&amp; s[fast] != <span class="string">&#x27; &#x27;</span>) s[slow ++ ] = s[fast ++ ];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpace</span>(s); <span class="comment">// 删去所有多余的空格</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); <span class="comment">// 反转整个字符串，注意reverse函数是左开右闭的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转每个单词</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) i ++ ; <span class="comment">// 找到空格</span></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + start, s.<span class="built_in">begin</span>() + i); <span class="comment">// 反转start到空格之间的单词</span></span><br><span class="line">            start = i + <span class="number">1</span>; <span class="comment">// 更新start</span></span><br><span class="line">            i = start; <span class="comment">// 更新i</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>代码随想录中的反转每个单词的写法和我的略有不同，他用的是for循环，但本质是一样的。</p>
<h3 id="卡码网：55-右旋转字符串-2"><a href="#卡码网：55-右旋转字符串-2" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h3><p>我在初次尝试中已经给出了空间复杂度为O(1)的最优解法，下面两幅图（对应两种等效的方法）可以帮助理解：</p>
<ol>
<li><p>先反转整个字符串，再反转两个子串</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20231106172058.png" alt="img"></p>
</li>
<li><p>先反转子串，再反转整个字符串</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20231106172534.png" alt="img"></p>
</li>
</ol>
<h2 id="心得与备忘录"><a href="#心得与备忘录" class="headerlink" title="心得与备忘录"></a>心得与备忘录</h2><h3 id="344-反转字符串-2"><a href="#344-反转字符串-2" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>两种for循环的写法：<code>for (int i = 0, j = s.size() - 1; i &lt; s.size() / 2; i ++ , j -- )</code>和<code>for (int l = 0, r = s.size() - 1; l &lt; r; l ++ , r -- )</code>都可以。</p>
<h3 id="541-反转字符串II-3"><a href="#541-反转字符串II-3" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><ol>
<li>for循环每次以2k为长度去跳转</li>
<li><p>本题反转字符的<strong>三种情况</strong>：</p>
<ul>
<li>每隔 2k 个字符的前 k 个字符进行反转</li>
<li>剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</li>
<li>剩余字符少于 k 个，则将剩余字符全部反转</li>
</ul>
<p>三种情况每次只可能出现一种，即出现了一种情况，另外两种情况就不会出现了。据此，我写出了<strong>结构分明的三段式代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += <span class="number">2</span> * k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 情况1</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">2</span> * k &lt;= s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 可以省略</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 可以省略</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况3</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>情况1和情况2可以合并（即剩余字符的长度l满足l &gt;= k时，都是反转剩下字符的前k个；只有当l满足l &lt; k时，才要反转剩下的所有字符），因此产生了实现部分中的第二版代码。每次思考时应该先想到三种情况，再写出结构分明的三段式代码，然后对其进行简化。<strong>能够写出三段式代码即可，虽然不简洁但思路清晰简单、不容易出错</strong>。</p>
</li>
<li>如果要求一段段地操作字符串或数组，那么for循环中的i变量是可以一段段增加的，而没必要每次+1</li>
</ol>
<h3 id="卡码网：54-替换数字-3"><a href="#卡码网：54-替换数字-3" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><ol>
<li>本题注意使用<strong>双指针做法</strong>。代码推荐参考我在实现中的写法，虽然和代码随想录的代码略有差别，但本质是完全一样的。</li>
<li>本题注意考虑边界条件，在我的写法中，是<code>i &gt;= 0</code>而非<code>i &gt; 0</code>；在代码随想录的写法中，是<code>j &lt; i</code>而非<code>j &lt;= i</code>。如果边界条件写得不对会导致发生指针异常或者部分样例无法通过。考虑边界条件时，可以举特例，也可以让代码先运行，若发生错误则修改相应的边界条件。</li>
<li><p><strong>很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong>对于线性数据结构，填充或者删除，后序处理会高效的多。</p>
<p>这么做有两个好处：</p>
<ol>
<li>不用申请新数组。算法的空间复杂度从O(N)降到了O(1)。</li>
<li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。算法的时间复杂度从O(n^2)降到了O(n)。</li>
</ol>
</li>
</ol>
<h3 id="151-翻转字符串里的单词-3"><a href="#151-翻转字符串里的单词-3" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><ol>
<li>本题的总体思路：移除多余的空格-&gt;反转整个字符串-&gt;反转字符串中的每个单词</li>
<li>利用快慢双指针移除多余的空格有两种写法，一种较为复杂，需要分别移除字符串前面的空格和字符串中间和最后的连续的不止一个的空格，最后再移除字符串最后可能存在的一个空格。<strong>另一种较为简单，思路和<a href="https://programmercarl.com/0027.移除元素.html">27.移除元素</a>是相同的</strong>。<strong>快指针用于遍历旧字符串，慢指针用于依次指向新字符串中的各个元素</strong>。时间复杂度O(n)</li>
<li><strong>推荐使用较为简单的双指针写法</strong>。除去从旧字符串中复制每个单词到新字符串中的代码，还需要加上用于在新字符串中添加每个单词尾部的空格的代码。<strong>注意这两行代码的顺序不能写反，必须是先有添加空格的代码，再有复制单词的代码，否则会导致在新字符串的末尾多添加一个空格</strong>。</li>
<li>上面提到的新旧字符串只是有时间上的先后，没有空间上的拷贝。新字符串就是在旧字符串的基础上利用双指针算法通过删除和改动部分元素得到的。因此空间复杂度为O(1)。</li>
</ol>
<h3 id="卡码网：55-右旋转字符串-3"><a href="#卡码网：55-右旋转字符串-3" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h3><ol>
<li>本题加上限制条件：不能申请额外空间，只能在本串上操作（对cpp）。</li>
<li>可以先反转总串，再反转子串；也可以先反转子串，再反转总串。</li>
<li>右旋转字符串和左旋转字符串方法完全相同，就是反转的区间不同。</li>
</ol>
]]></content>
      <categories>
        <category>算法（字符串）</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>双指针算法</tag>
        <tag>花式反转字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Experiences of OAs</title>
    <url>/2024/02/27/Experiences-of-OAs/</url>
    <content><![CDATA[<h2 id="Amazon-SDE-OA"><a href="#Amazon-SDE-OA" class="headerlink" title="Amazon SDE OA"></a>Amazon SDE OA</h2><ol>
<li>题目不难，简单的算法</li>
<li>第二题涉及到链表的增加头、尾节点和删去头节点，但用最简单直接的做法会超时</li>
<li>第二题的优化做法没有完全实现（出现报错），导致第二题没有完美地做出来，应该会被拒</li>
<li>时间一共70分钟，乍一看很充裕，但是如果碰到要优化的地方，时间就不够用了，因此下次做OA一定要做快一些，留出充足的时间给可能需要的优化和debug。</li>
</ol>
]]></content>
      <categories>
        <category>找工记录</category>
      </categories>
      <tags>
        <tag>OA</tag>
        <tag>经验与教训</tag>
      </tags>
  </entry>
  <entry>
    <title>Detailed Explanation of Java Stream</title>
    <url>/2024/10/13/Detailed-Explanation-of-Java-Stream/</url>
    <content><![CDATA[<h1 id="Details-Explanation-of-Java-Stream"><a href="#Details-Explanation-of-Java-Stream" class="headerlink" title="Details Explanation of Java Stream"></a>Details Explanation of Java Stream</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>wsl和本地上用IDEA运行java代码，最新修改的结果往往都无法被正常运行出来，我推测是缓存没有及时刷新之类的。有两个解决办法：</p>
<ul>
<li>每次运行前按下快捷键：ctrl + shift + f9，达到rebuild project的目的</li>
<li>手动点击上边栏，选择build-rebuild project，选择build project没有作用</li>
</ul>
<p>根据这个<a href="https://youtrack.jetbrains.com/issue/IDEA-339871/Line-numbers-are-likely-diverged...-tooltip-is-wrong">帖子</a>，要彻底解决这个问题，恐怕要更新到2024.1以后的版本，我暂时不要更新自己的IDEA，因为当前的IDEA还能够正常使用，而我使用的是破解版的密钥，贸然更新可能会导致反而无法正常使用的情况出现。</p>
<h2 id="不可变集合详解"><a href="#不可变集合详解" class="headerlink" title="不可变集合详解"></a>不可变集合详解</h2><h3 id="创建不可变集合"><a href="#创建不可变集合" class="headerlink" title="创建不可变集合"></a>创建不可变集合</h3><p>不可变集合：不可以被修改的集合。其长度和内容都不可以被修改。</p>
<p>创建不可变集合的应用场景：</p>
<ul>
<li>如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。</li>
<li>当集合对象被不可信的库调用时，不可变形式是安全的。</li>
<li>某些确定的规则。</li>
<li>电脑中的硬件信息。</li>
</ul>
<p><strong>简单理解</strong>：不想让别人修改集合中的内容，就可以给他提供一个不可变的集合。拿到不可变集合的人只能做查询操作，不能删除、修改、添加。</p>
<p>创建不可变集合的书写格式：<br>在List, Set, Map接口中，都存在静态的of方法，可以获取一个不可变的集合。<br>|                  方法名称                  |                说明                |<br>| :————————————————————: | :————————————————: |<br>|   <code>static &lt;E&gt; List&lt;E&gt; of(E...elements)</code>    | 创建一个具有指定元素的List集合对象 |<br>|    <code>static &lt;E&gt; Set&lt;E&gt; of(E...elements)</code>    | 创建一个具有指定元素的Set集合对象  |<br>| <code>static &lt;K, V&gt; Map&lt;K, V&gt; of(E...elements)</code> | 创建一个具有指定元素的Map集合对象  |</p>
<p><code>List of</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyf.a01immutable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建不可变的List集合</span></span><br><span class="line"><span class="comment">        &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ctrl + alt + v可以自动生成List&lt;String&gt; list，只需要自己写List.of即可</span></span><br><span class="line">        <span class="comment">// 一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作</span></span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;赵六&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询</span></span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(list.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器遍历</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通for循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// list.remove(&quot;李四&quot;);</span></span><br><span class="line">        <span class="comment">// list.add(&quot;aaa&quot;);</span></span><br><span class="line">        <span class="comment">// list.set(0, &quot;aaa&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Set of</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyf.a01immutable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableDemo2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建不可变的Set集合</span></span><br><span class="line"><span class="comment">        &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ctrl + alt + v可以自动生成List&lt;String&gt; list，只需要自己写List.of即可</span></span><br><span class="line">    <span class="comment">// 一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作</span></span><br><span class="line">    <span class="comment">// 细节：当我们要获取一个不可变的Set集合时，里面的参数一定要保证唯一性</span></span><br><span class="line">    Set&lt;String&gt; set = Set.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;赵六&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set中没有索引，因此查询只能遍历</span></span><br><span class="line">    <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">      System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">      System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能删除、添加、修改</span></span><br><span class="line">    <span class="comment">// set.remove(&quot;王五&quot;);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Map.of</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyf.a01immutable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableDemo3</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建Map的不可变集合</span></span><br><span class="line"><span class="comment">    细节1：键是不能重复的</span></span><br><span class="line"><span class="comment">    细节2：Map里面的of方法，参数是有上限的，最多只能传递20个参数，即10个键值对</span></span><br><span class="line"><span class="comment">    细节3：如果我们要传递多个键值对对象，数量大于10个，在Map接口中还有一个方法：Map.ofEntries()</span></span><br><span class="line"><span class="comment">    其将键和值看作一个整体，由于形参中可以有一个可变参数，因此可以实现传递多个键值对对象的功能</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作</span></span><br><span class="line">    Map&lt;String, String&gt; map =</span><br><span class="line">        Map.of(</span><br><span class="line">            <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;南京&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;赵六&quot;</span>, <span class="string">&quot;广州&quot;</span>, <span class="string">&quot;孙七&quot;</span>, <span class="string">&quot;深圳&quot;</span>, <span class="string">&quot;周八&quot;</span>, <span class="string">&quot;杭州&quot;</span>, <span class="string">&quot;吴九&quot;</span>, <span class="string">&quot;宁波&quot;</span>,</span><br><span class="line">            <span class="string">&quot;郑十&quot;</span>, <span class="string">&quot;苏州&quot;</span>, <span class="string">&quot;刘一&quot;</span>, <span class="string">&quot;无锡&quot;</span>, <span class="string">&quot;陈二&quot;</span>, <span class="string">&quot;嘉兴&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map.keySet获取所有的键</span></span><br><span class="line">    Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">      System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map的第二种遍历方式</span></span><br><span class="line">    <span class="comment">// map.entrySet()获取所有键值对</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">      <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">      System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果我想让这个方法能够接收多个键和值</span></span><br><span class="line">  <span class="comment">// 解决方案：</span></span><br><span class="line">  <span class="comment">// 键 可变参数</span></span><br><span class="line">  <span class="comment">// 值 可变参数</span></span><br><span class="line">  <span class="comment">// 键和值的类型不确定：泛型方法&lt;&gt;</span></span><br><span class="line">  <span class="comment">// 由于两个可变参数无法在形参中共存，因此无法设计这个方法</span></span><br><span class="line">  <span class="comment">//  public static&lt;K, V&gt; void of(K...keys, V...values) &#123;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Map.ofEntries</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyf.a01immutable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableDemo4</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建Map的不可变集合，键值对的数量超过10个</span></span><br><span class="line"><span class="comment">    细节3：如果我们要传递多个键值对对象，数量大于10个，在Map接口中还有一个方法：Map.ofEntries()</span></span><br><span class="line"><span class="comment">    其将键和值看作一个整体，由于形参中可以有一个可变参数，因此可以实现传递多个键值对对象的功能</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建一个普通的Map集合</span></span><br><span class="line">    HashMap&lt;String, String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    hm.put(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;南京&quot;</span>);</span><br><span class="line">    hm.put(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line">    hm.put(<span class="string">&quot;王五&quot;</span>, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">    hm.put(<span class="string">&quot;赵六&quot;</span>, <span class="string">&quot;广州&quot;</span>);</span><br><span class="line">    hm.put(<span class="string">&quot;孙七&quot;</span>, <span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">    hm.put(<span class="string">&quot;周八&quot;</span>, <span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">    hm.put(<span class="string">&quot;吴九&quot;</span>, <span class="string">&quot;宁波&quot;</span>);</span><br><span class="line">    hm.put(<span class="string">&quot;郑十&quot;</span>, <span class="string">&quot;苏州&quot;</span>);</span><br><span class="line">    hm.put(<span class="string">&quot;刘一&quot;</span>, <span class="string">&quot;无锡&quot;</span>);</span><br><span class="line">    hm.put(<span class="string">&quot;陈二&quot;</span>, <span class="string">&quot;嘉兴&quot;</span>);</span><br><span class="line">    hm.put(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 利用上面的数据来获取一个不可变的集合</span></span><br><span class="line">    <span class="comment">// 获取所有的键值对对象（Entry对象）</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = hm.entrySet();</span><br><span class="line">    <span class="comment">// 由于可变参数在底层就是一个数组，因此需要将上面的entries变成数组</span></span><br><span class="line">    <span class="comment">// 需要调用指定类型的toArray函数，类型是Map.Entry</span></span><br><span class="line">    Map.Entry[] arr1 = <span class="keyword">new</span> <span class="title class_">Map</span>.Entry[<span class="number">0</span>]; <span class="comment">// 将map中的所有数据放到arr中</span></span><br><span class="line">    <span class="comment">// toArray方法在底层会比较集合的长度跟数组的长度两者的大小</span></span><br><span class="line">    <span class="comment">// 如果集合的长度11 &gt; 数组的长度0：数据在数组中放不下，此时会根据实际数据的个数11，重新创建数组</span></span><br><span class="line">    <span class="comment">// 如果集合的长度&lt;=数组的长度：数据在数组中放得下，此时不会创建新的数组，而是直接用</span></span><br><span class="line">    <span class="comment">// 因此数组的长度直接写成0就可以，不用想数组的长度是否和集合的长度匹配</span></span><br><span class="line">    Map.Entry[] arr2 = entries.toArray(arr1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可变的map集合</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> Map.ofEntries(arr2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可增删改，只可查</span></span><br><span class="line">    <span class="comment">// map.put(&quot;bbb&quot;, &quot;222&quot;);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码非常麻烦，可以简化。</p>
<h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><h2 id="初爽Stream流"><a href="#初爽Stream流" class="headerlink" title="初爽Stream流"></a>初爽Stream流</h2><h2 id="Stream流的思想和获取Stream流"><a href="#Stream流的思想和获取Stream流" class="headerlink" title="Stream流的思想和获取Stream流"></a>Stream流的思想和获取Stream流</h2>]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Dublin Restaurant Recommendations</title>
    <url>/2024/07/15/Dublin-Restaurant-Recommendations/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>都柏林，素有美食荒漠、欧洲宁古塔之称。然而，经过本人和好友长期约饭探店的实地考察之后，发现都柏林的中餐馆门类齐全、品种多样，除去价格稍贵外相比于国内并无显著的短板和缺憾。因此，本人维护本帖用于记录都柏林吃喝之旅，并为读者提供一份尽可能详细的都柏林美食推荐清单。</p>
<p>本人向来赞同孔夫子“食不厌精，脍不厌细”的名言，因此，性价比是这份排行榜中相对次要的因素，食物的调味、口感、精细和新颖程度是更重要的。本帖中的五星代表着这个饭店的食物有独道之处，甚至超过了国内同种食物之最。四星代表着这个饭店的食物在味道或性价比方面至少有一个非常出众，而另一个也至少在平均水平之上。三星代表着值得一试，但并不惊艳。果腹则代表着仅供日常果腹之用，胜在量大管饱。心愿清单则是我早有耳闻，但还未成行的餐馆。本帖中推荐的餐馆会附带有谷歌地图的位置信息和一句简短的点评。本帖中也会提到一些国内的餐馆，主要分布在南昌、西安和合肥，都是本人曾经久居过的城市。本帖中评分点评随性，主观色彩浓重，愿博看官一笑。</p>
<h2 id="五星"><a href="#五星" class="headerlink" title="五星"></a>五星</h2><ol>
<li>四川</li>
<li>川九香</li>
</ol>
<h2 id="四星"><a href="#四星" class="headerlink" title="四星"></a>四星</h2><h2 id="三星"><a href="#三星" class="headerlink" title="三星"></a>三星</h2><h2 id="果腹"><a href="#果腹" class="headerlink" title="果腹"></a>果腹</h2><h2 id="国内"><a href="#国内" class="headerlink" title="国内"></a>国内</h2><h2 id="心愿清单"><a href="#心愿清单" class="headerlink" title="心愿清单"></a>心愿清单</h2><ol>
<li>日料Omakase</li>
<li>西餐Shanahan’s on the Green</li>
</ol>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>美食</tag>
        <tag>中餐</tag>
        <tag>西餐</tag>
        <tag>日料</tag>
        <tag>都柏林</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Migrate and Restart a Cloud Server</title>
    <url>/2024/01/21/How-to-Migrate-and-Restart-a-Cloud-Server/</url>
    <content><![CDATA[<h1 id="迁移云服务器"><a href="#迁移云服务器" class="headerlink" title="迁移云服务器"></a>迁移云服务器</h1><h2 id="1、租云服务器，配置其免密登录"><a href="#1、租云服务器，配置其免密登录" class="headerlink" title="1、租云服务器，配置其免密登录"></a>1、租云服务器，配置其免密登录</h2><p>将本地的公钥复制到云服务器的~/.ssh/authorized_keys中，或者使用云服务器平台提供的密钥，在本地的.ssh文件夹中添加密钥在本地的位置<br>第一次登录云服务器（未配置免密登录）的具体流程可以参照以下步骤：</p>
<p>IR_Group_7_project Demo Instruction</p>
<ol>
<li>Login our VM instance<br>Move key to secure location (eg. ~/.ssh in linux), then</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 path/to/shaoxi_key.pem</span><br><span class="line">ssh -i path/to/shaoxi_key.pem shaoxi@52.174.147.101</span><br></pre></td></tr></table></figure>
<h2 id="2、在云服务器中安装docker"><a href="#2、在云服务器中安装docker" class="headerlink" title="2、在云服务器中安装docker"></a>2、在云服务器中安装docker</h2><p>安装步骤参见官网：<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a><br>一般安装的版本为20.10.9，使用命令：<code>VERSION_STRING=5:20.10.9~3-0~ubuntu-focal</code><br>查看docker是否安装成功：<code>docker --version</code></p>
<h2 id="3、在云服务器平台开放以下端口"><a href="#3、在云服务器平台开放以下端口" class="headerlink" title="3、在云服务器平台开放以下端口"></a>3、在云服务器平台开放以下端口</h2><p>22， 8000， 443， 80， 20000，协议均为TCP，源和目的地都为任何（0.0.0.0）</p>
<h2 id="4、将本地的C-Users-chen-yi-fan-django-lesson-1-tar上传到云服务器里"><a href="#4、将本地的C-Users-chen-yi-fan-django-lesson-1-tar上传到云服务器里" class="headerlink" title="4、将本地的C:\Users\chen yi fan\django_lesson_1.tar上传到云服务器里"></a>4、将本地的C:\Users\chen yi fan\django_lesson_1.tar上传到云服务器里</h2><p>在powershell中执行的具体的命令为：<br><code>scp .\django_lesson_1.tar azureuser@20.123.135.13:~/</code></p>
<h2 id="5、将镜像xxxx从本地文件xxxx-tar中加载出来"><a href="#5、将镜像xxxx从本地文件xxxx-tar中加载出来" class="headerlink" title="5、将镜像xxxx从本地文件xxxx.tar中加载出来"></a>5、将镜像xxxx从本地文件xxxx.tar中加载出来</h2><p><code>sudo docker load -i xxxx.tar</code></p>
<h2 id="6、查看镜像是否成功加载出来"><a href="#6、查看镜像是否成功加载出来" class="headerlink" title="6、查看镜像是否成功加载出来"></a>6、查看镜像是否成功加载出来</h2><p>查看所有镜像的命令: <code>sudo docker images</code></p>
<h2 id="7、使用镜像重新创建并运行容器"><a href="#7、使用镜像重新创建并运行容器" class="headerlink" title="7、使用镜像重新创建并运行容器"></a>7、使用镜像重新创建并运行容器</h2><p><code>docker run -p 20000:22 -p 8000:8000 -p 80:80 -p 443:443 --name django_server -itd django_lesson:1.1</code></p>
<h2 id="8、登录到容器中"><a href="#8、登录到容器中" class="headerlink" title="8、登录到容器中"></a>8、登录到容器中</h2><p><code>sudo docker attach django_server</code><br>登录为root用户</p>
<h2 id="9、创建非root用户"><a href="#9、创建非root用户" class="headerlink" title="9、创建非root用户"></a>9、创建非root用户</h2><p><code>adduser acs</code><br>赋予其sudo权限：<code>usermod -aG sudo acs</code><br>设置密码</p>
<h2 id="10、配置容器的免密登录"><a href="#10、配置容器的免密登录" class="headerlink" title="10、配置容器的免密登录"></a>10、配置容器的免密登录</h2><p>配置免密登录的过程是：在容器的.ssh/authorized_keys中写入本地的.ssh文件夹（C:\Users\chen yi fan.ssh）中的公钥的内容<br>然后修改本地的.ssh/config文件，添加容器的信息，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host django_azure</span><br><span class="line">    HostName 20.123.135.13</span><br><span class="line">    User acs</span><br><span class="line">    Port 20000</span><br></pre></td></tr></table></figure>
<h2 id="11、从本地-其他云服务器上登录到容器的命令"><a href="#11、从本地-其他云服务器上登录到容器的命令" class="headerlink" title="11、从本地/其他云服务器上登录到容器的命令"></a>11、从本地/其他云服务器上登录到容器的命令</h2><p><code>ssh acs@ip -p 20000</code><br>退出容器时注意不要关闭容器，而是挂起容器：ctrl+p ctrl+q</p>
<h2 id="12、完成容器的一些配置："><a href="#12、完成容器的一些配置：" class="headerlink" title="12、完成容器的一些配置："></a>12、完成容器的一些配置：</h2><p>nginx配置：<br>（1）修改yxc的acapp中的服务器IP<br>（2）将服务器的IP添加到项目的settings.py的ALLOWED_HOSTS中<br>（3）将yxc提供的nginx.conf写入容器的/etc/nginx/nginx.conf文件中<br>（4）将yxc提供的acapp.key写入容器的/etc/nginx/cert/acapp.key文件中<br>（5）将yxc提供的acapp.pem写入容器的/etc/nginx/cert/acapp.pem文件中<br>（6）启动nginx服务：<code>sudo /etc/init.d/nginx start</code><br>（7）启动uwsgi服务：<code>uwsgi --ini scripts/uwsgi.ini</code></p>
<p>redis配置：<br>（1）安装redis：<code>pip install django_redis</code><br>（2）启动redis-server：<code>sudo redis-server /etc/redis/redis.conf</code><br>（3）用<code>top</code>命令看有没有进程叫redis-server</p>
<p>django channels配置：<br>（1）安装channels_redis：<code>pip install channels_redis</code><br>（2）启动django_channels：<br>  在~/acapp目录下执行：<code>daphne -b 0.0.0.0 -p 5015 acapp.asgi:application</code></p>
<p>同时启动https（uwsgi）和wss（daphne）协议的服务后，项目就应该可以正常运行</p>
<h2 id="13、启动https和wss服务"><a href="#13、启动https和wss服务" class="headerlink" title="13、启动https和wss服务"></a>13、启动https和wss服务</h2><p>启动https服务：<code>uwsgi --ini scripts/uwsgi.ini</code></p>
<p>启动wss服务：<code>daphne -b 0.0.0.0 -p 5015 acapp.asgi:application</code></p>
<hr>
<h1 id="重启云服务器"><a href="#重启云服务器" class="headerlink" title="重启云服务器"></a>重启云服务器</h1><p>在云平台暂停云服务器后重新启动服务器并进入容器</p>
<h2 id="1-在云平台启动云服务器"><a href="#1-在云平台启动云服务器" class="headerlink" title="1. 在云平台启动云服务器"></a>1. 在云平台启动云服务器</h2><p>需要等待5-10分钟才能完成重启的过程</p>
<h2 id="2-查看云服务器中已有的容器"><a href="#2-查看云服务器中已有的容器" class="headerlink" title="2. 查看云服务器中已有的容器"></a>2. 查看云服务器中已有的容器</h2><p>运行命令：<code>sudo docker ps -a</code></p>
<h2 id="3-启动被暂停-退出的容器"><a href="#3-启动被暂停-退出的容器" class="headerlink" title="3. 启动被暂停/退出的容器"></a>3. 启动被暂停/退出的容器</h2><p>运行命令：<code>sudo docker start django_server</code></p>
<h2 id="4-进入容器"><a href="#4-进入容器" class="headerlink" title="4. 进入容器"></a>4. 进入容器</h2><p>在vscode上选择django_azure，点击进入即可</p>
<h2 id="5-启动容器中的服务"><a href="#5-启动容器中的服务" class="headerlink" title="5. 启动容器中的服务"></a>5. 启动容器中的服务</h2><p>主要需要启动以下五个服务：</p>
<p>启动nginx服务：<code>sudo /etc/init.d/nginx start</code></p>
<p>启动redis-server：<code>sudo redis-server /etc/redis/redis.conf</code></p>
<p>启动uwsgi（https）服务：<code>uwsgi --ini scripts/uwsgi.ini</code></p>
<p>启动wss服务：<code>daphne -b 0.0.0.0 -p 5015 acapp.asgi:application</code></p>
<p>启动match system服务：<code>./main.py</code></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Cloud Server</tag>
      </tags>
  </entry>
  <entry>
    <title>Django Project Summary</title>
    <url>/2024/01/21/Django-Project-Summary/</url>
    <content><![CDATA[<h1 id="Django项目总结"><a href="#Django项目总结" class="headerlink" title="Django项目总结"></a>Django项目总结</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>Game based on Django framework, developed by yifanChen</p>
<h3 id="Website"><a href="#Website" class="headerlink" title="Website"></a>Website</h3><p><a href="https://app5894.acapp.acwing.com.cn/">https://app5894.acapp.acwing.com.cn/</a></p>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p><a href="https://github.com/yfchenkeepgoing/Django_app">https://github.com/yfchenkeepgoing/Django_app</a></p>
<h3 id="Gameplay"><a href="#Gameplay" class="headerlink" title="Gameplay"></a>Gameplay</h3><ol>
<li>Right-click to move</li>
<li>Left-click plus ‘Q’ for the skill: Fireball, with a cooldown of 3 seconds</li>
<li>Left-click plus ‘F’ for the skill: Flash, with a cooldown of 5 seconds</li>
<li>In multiplayer mode, the winning player gains 10 points, and the losing player loses 5 points</li>
</ol>
<h3 id="Technology-Stack"><a href="#Technology-Stack" class="headerlink" title="Technology Stack"></a>Technology Stack</h3><ol>
<li>Frontend: JQuery</li>
<li>Backend: Django</li>
<li>Database: SQLite, Redis</li>
<li>Network Protocols: HTTPS, WSS</li>
<li>RPC: Thrift</li>
<li>Authorization Protocol: OAuth</li>
<li>Authentication: JWT</li>
</ol>
<h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ol>
<li>Complete menu interface and game interface</li>
<li>Frontend and backend separation, with AcApp and Web versions on the frontend</li>
<li>Deployed with Nginx to interface with the AcApp</li>
<li>Comprehensive account system, username and password login, and one-click login with AcWing &amp; GitHub OAuth</li>
<li>Online multiplayer and chat system implemented via WSS protocol</li>
<li>Matchmaking system implemented through Thrift service</li>
<li>Cross-origin issues resolved through Rest Framework and JWT authentication, achieving complete frontend-backend separation</li>
<li>The ranking board displays the top ten players ranked by score</li>
</ol>
<h2 id="Django项目的框架"><a href="#Django项目的框架" class="headerlink" title="Django项目的框架"></a>Django项目的框架</h2><p>一个Django项目，大致由以下六部分组成：</p>
<ol>
<li>templates目录：管理html文件</li>
<li>urls目录：管理路由，即链接与函数的对应关系，即每个链接交给哪个函数处理的信息，存储在urls文件夹中。</li>
<li>views目录：视图，管理http函数（函数实现在views目录中）</li>
<li>models目录：管理数据库数据。</li>
<li>consumers目录：管理websocket函数（views管理http函数，即负责单向连接的函数；consumers管理双向连接的函数，比如联机对战和聊天的逻辑）</li>
<li>static目录：管理静态文件，比如：</li>
</ol>
<ul>
<li>css文件：对象的格式（网页每部分的格式），比如位置、长宽、颜色、背景、字体大小等</li>
<li>js：对象的逻辑（项目的核心），比如对象的创建与销毁、事件函数、移动、变色等，渲染html也会在js部分（前端）</li>
<li>image：图片</li>
<li>audio：声音</li>
</ul>
<p>urls文件夹、views文件夹、models文件夹和consumers文件夹都由python文件组成，如果想通过import将文件导入，则需要在文件夹下创建 <code>__init__.py</code>文件（即索引文件，内容为空即可）。在所有python文件夹中都需要创建这样的函数，否则在import时就无法进去，会报错。</p>
<h2 id="项目核心逻辑"><a href="#项目核心逻辑" class="headerlink" title="项目核心逻辑"></a>项目核心逻辑</h2><p>本项目由于是一个小游戏，因此前端的js代码占比较大。游戏单人模式的实现纯粹由前端完成，我用js代码实现了一个简易的游戏引擎。游戏的单人模式不需要前后端交互。</p>
<p>需要前后端交互的部分有：</p>
<ol>
<li>注册与登录：涉及到写入、读取、查询数据库</li>
<li>acwing和GitHub一键登录：即OAuth授权登录</li>
<li>实现联机对战和聊天系统：涉及到在多名玩家之间同步五个事件（函数）：create_player, move_to, shoot_fireball, attack, message。前四个用于实现联机对战，最后一个用于实现聊天系统。</li>
<li>Rest Framework与JWT身份验证：是对第一点和第二点的补充。</li>
</ol>
<ul>
<li>JWT（json web token）相比于django自带的登录验证方式（通过session_id）安全性更高。</li>
<li>方便实现真正意义上的前后端分离，即后端只需要提供实现好的api给前端调用，而Rest Framework为这些api的调试提供了可视化界面。</li>
<li>JWT可以解决跨域产生的问题。</li>
<li>可以使用http的四大类请求方法：get, post, delete, put，而不像之前仅仅使用get方法，这又提高了令牌的安全性。</li>
</ul>
<p>纯后端的部分只有匹配系统的实现。匹配系统的实现涉及到两个后端（即django web server和match system）之间的通信，匹配系统本身涉及到多线程和锁等方面的知识。</p>
<p>我认为本项目的重点主要在于前后端交互的部分，前后端交互其实有一套统一的范式：先在views中实现后端的函数；然后在urls中为后端的函数定义url链接；再在前端代码中利用ajax技术通过url获得后端传来的数据（前后端一般以json的格式传递数据）；最后通过前端使用或展示数据。如果给用户设计了一套通过点击鼠标或者使用键盘向后端请求数据的模式，那么还需要在前端进行按键索引和绑定监听函数等操作。</p>
<h2 id="改进项目"><a href="#改进项目" class="headerlink" title="改进项目"></a>改进项目</h2><ol>
<li>使用功能更强大的前端框架，比如Vue或者React，取代简单的JQuey。</li>
<li>使用更多种类型的数据库，比如关系型数据库MySQL，文档数据库MongoDB，对象存储服务等等。</li>
<li>使用另外几种实现前后端通信的技术取代ajax，比如Fetch API，Server-Sent Events (SSE)，GraphQL和WebRTC，以提高系统的性能。</li>
<li>学习并尝试使用Springboot框架和Go语言的后端框架。</li>
<li>使用k8s来自动化部署、扩展和管理容器化应用程序。</li>
</ol>
<h2 id="漫谈"><a href="#漫谈" class="headerlink" title="漫谈"></a>漫谈</h2><h3 id="后端的主要分类"><a href="#后端的主要分类" class="headerlink" title="后端的主要分类"></a>后端的主要分类</h3><p>算法与推荐系统、开发各种服务、数据库</p>
<h3 id="对于实现客户端与服务器之间的通信功能的技术的选择"><a href="#对于实现客户端与服务器之间的通信功能的技术的选择" class="headerlink" title="对于实现客户端与服务器之间的通信功能的技术的选择"></a>对于实现客户端与服务器之间的通信功能的技术的选择</h3><p>除了AJAX，现代Web开发中还有几种其他技术可以实现类似的客户端与服务器之间的通信功能。一些技术在特定场景下比AJAX更高效。以下是一些常用的技术：</p>
<ol>
<li><strong>Fetch API</strong>： Fetch API提供了一种更简洁和强大的方式来发起网络请求。它基于Promise，使得写异步代码更加简洁和直观。Fetch API是AJAX的现代替代方案，被广泛支持和使用。</li>
<li><strong>WebSocket</strong>： WebSocket提供了全双工通信渠道，使得客户端和服务器可以实时、双向地通信。它非常适用于需要频繁和即时数据更新的应用，如在线游戏、聊天应用和实时数据流。</li>
<li><strong>Server-Sent Events (SSE)</strong>： SSE允许服务器主动向客户端发送新数据。它是单向的，只有服务器可以发送消息给客户端。SSE适合实现如股票行情、新闻订阅等场景，其中服务器定期推送更新。</li>
<li><strong>GraphQL</strong>： GraphQL是一种数据查询和操作语言，它允许客户端以更灵活的方式请求数据。与REST相比，GraphQL可以减少数据传输量，因为它允许客户端精确指定所需的数据。</li>
<li><strong>WebRTC</strong>： WebRTC（Web Real-Time Communication）允许在不需要安装插件的情况下在Web应用中实现实时通信功能，常用于视频聊天和点对点数据共享。</li>
</ol>
<p>每种技术都有其特定的应用场景和优势。选择哪一种技术取决于应用的具体需求：</p>
<ul>
<li>对于简单的异步数据请求，AJAX和Fetch API都是不错的选择。</li>
<li>对于需要高实时性的应用，WebSocket或WebRTC可能更合适。</li>
<li>对于服务器主动推送数据的场景，SSE是一个好的选择。</li>
<li>对于需要更灵活数据交互的场景，GraphQL提供了更好的解决方案。</li>
</ul>
<p>在性能方面，WebSocket和WebRTC通常在需要频繁和快速通信的场景下比AJAX更高效，因为它们建立了持久的连接，而不是像AJAX那样为每个请求创建新的连接。</p>
<h3 id="如何使用MySQL，MongoDB，对象存储服务等外置的数据库（它们不像sqlite，不集成于后端框架内）"><a href="#如何使用MySQL，MongoDB，对象存储服务等外置的数据库（它们不像sqlite，不集成于后端框架内）" class="headerlink" title="如何使用MySQL，MongoDB，对象存储服务等外置的数据库（它们不像sqlite，不集成于后端框架内）"></a>如何使用MySQL，MongoDB，对象存储服务等外置的数据库（它们不像sqlite，不集成于后端框架内）</h3><ul>
<li>租一台数据库服务器</li>
<li>在框架中负责数据库的部分配置数据库服务器的连接/登录</li>
<li>下载该框架下使用该种数据库的包</li>
<li>在框架中负责数据库的部分调用包中的api完成对数据库的各种操作，比如读、写、删除等。</li>
</ul>
<p>在 Django 中，通常不需要直接使用 SQL 语句来操作 MySQL 数据库，因为 Django 提供了一个强大的 ORM（对象关系映射）系统，允许你通过 Python 代码来操作数据库。这意味着你可以使用 Django 的模型和查询 API 来查询和操作数据，而无需直接编写 SQL 语句。</p>
<p>Django 本身不直接支持 MongoDB，因为它是一个 NoSQL 数据库，与 Django 的 ORM 系统设计理念不同。如果你想在 Django 项目中使用 MongoDB，可以采取以下方法：</p>
<ul>
<li>使用 Djongo： Djongo 是一个将 Django ORM 映射到 MongoDB 的工具。通过 Djongo，你可以在一定程度上使用 Django ORM 的风格来操作 MongoDB。</li>
<li>使用 PyMongo： PyMongo 是 MongoDB 的官方 Python 驱动程序。使用 PyMongo，你可以直接以 Python 代码与 MongoDB 交互，但这意味着你需要手动编写数据库操作逻辑，而不是使用 Django ORM。</li>
</ul>
<p>对于对象存储服务（如 Amazon S3），通常使用的是 RESTful API 而非传统的数据库查询语言。在 Django 项目中使用对象存储通常涉及以下步骤：</p>
<ul>
<li>选择合适的库： 例如，对于 Amazon S3，你可以使用 boto3，这是 AWS 的官方 Python SDK。</li>
<li>进行配置和认证： 通常需要设置认证凭据和相关配置。</li>
<li>使用 SDK 提供的 API： 使用 SDK 提供的方法来上传、下载、列出文件等。</li>
</ul>
<h3 id="JWT可以存放在内存、local-storage和cookie中，这三个存放地各自有优缺点"><a href="#JWT可以存放在内存、local-storage和cookie中，这三个存放地各自有优缺点" class="headerlink" title="JWT可以存放在内存、local storage和cookie中，这三个存放地各自有优缺点"></a>JWT可以存放在内存、local storage和cookie中，这三个存放地各自有优缺点</h3><p>Cookie：<br>优点：自动由浏览器管理，并且可以设置为HttpOnly（无法通过JavaScript访问，增加安全性），支持跨域访问控制（SameSite属性）。<br>缺点：容易受到CSRF（跨站请求伪造）攻击，尽管可以通过适当的防范措施（如使用CSRF Token）来缓解。</p>
<p>LocalStorage：<br>优点：易于使用，可以在浏览器会话间持久存储。<br>缺点：容易受到XSS（跨站脚本攻击）攻击，因为恶意脚本可以访问LocalStorage并窃取令牌。</p>
<p>内存（JavaScript变量）：<br>优点：在浏览器关闭时自动清除，不容易受到XSS攻击（只要不将令牌暴露给恶意脚本）。<br>缺点：不持久，用户刷新页面或关闭浏览器时会丢失，可能需要重新认证。</p>
<p>最佳实践：<br>安全性考虑：通常推荐将JWT存储在HttpOnly的Cookie中，因为这样可以防止JavaScript访问令牌，从而减少XSS攻击的风险。</p>
<p>CSRF防范：如果使用Cookie，应结合CSRF保护机制。</p>
<p>易用性：如果需要在会话间持久保存用户的登录状态，LocalStorage可能更为方便。但是，务必注意XSS攻击的风险，并采取适当的安全措施。</p>
<p>短期使用：对于需要高安全性且可接受在会话结束后用户需要重新登录的场景，可以考虑仅将JWT存储在内存中。</p>
<p>在实践中，选择哪种方式取决于应用的安全需求、用户体验需求以及开发者对相关安全风险的管理能力。在处理任何形式的认证信息时，安全总是首要考虑的因素。<strong>在本项目中，出于安全性和短期使用的考量，我将JWT存储在了内存，即js变量中</strong>。如果没有明确地将JWT存储在Local Storage或Cookie中，那么它们就是存储在内存中。这意味着令牌只在当前页面会话中有效，一旦页面被关闭或刷新，令牌就会丢失。</p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>Django</tag>
        <tag>Frontend</tag>
        <tag>JQuery</tag>
        <tag>Ajax</tag>
        <tag>Database</tag>
        <tag>SQLite</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Understand an Open Source Project</title>
    <url>/2024/01/30/How-to-Understand-an-Open-Source-Project/</url>
    <content><![CDATA[<h2 id="快速了解项目"><a href="#快速了解项目" class="headerlink" title="快速了解项目"></a>快速了解项目</h2><p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-01-30_11-45-52.png?raw=true" alt="Snipaste_2024-01-30_11-45-52.png"></p>
<p>从0带读Java小说项目。项目：<a href="https://novel.xxyopen.com/">小说精品屋</a></p>
<p>首先看代码的简介（README），然后看代码的更新频率（几年没更新的就不用看了）。</p>
<p>接着看项目的介绍，看项目的技术栈和我们自己的技术栈是否匹配。</p>
<p>接着看包结构（项目结构）。</p>
<p>看技术选型。高级的技术：ShardingSphere-JDBC（数据库分库分表支持）、分布式缓存支持、搜索引擎服务、开源消息中间件、文件存储、对象存储。</p>
<p>接着看<strong>核心：项目如何安装，如何启动</strong>。</p>
<h2 id="了解项目依赖"><a href="#了解项目依赖" class="headerlink" title="了解项目依赖"></a>了解项目依赖</h2><p>通过github1s（在线查看项目的工具）看项目。</p>
<p>==看项目从整体到局部，先看项目的架构及关键配置文件==</p>
<p>比如assets放静态文件，sql放SQL语句。根目录下的pom.xml定义了父工程的配置。在父工程的配置中又定义了子模块，可以达到多包同时编译的效果。</p>
<p>dockerfile：可以用其来生成一个docker镜像</p>
<p>Java的项目主要分为两部分：resources放一些资源文件和配置，另一部分是java的核心代码。</p>
<p>看resources/application.yml：跑起这个项目需要启动哪些服务。</p>
<p>resources/mybatis：放一些SQL语句</p>
<p>resources/static：放前端的文件，比如javascript, css等等。</p>
<p>resources/templates：用的是thymeleaf，拓展标签可以动态地把一些后台数据渲染到页面。</p>
<p>resources/application-dev.yml：是项目的开发环境的配置。</p>
<p>resources/application-prod.yml：是项目生成环境的配置。</p>
<p>resources/logback.yml：日志</p>
<h2 id="了解项目结构"><a href="#了解项目结构" class="headerlink" title="了解项目结构"></a>了解项目结构</h2><p>现在java项目的目录结构比较清晰和规范。都是mvc结构：model view controller。</p>
<p>controller：控制层，接收用户的请求，给予一些响应，业务逻辑一般不写在其中</p>
<p>core：项目核心的类</p>
<p>mapper：mybatis的映射文件，在这个文件中定义操作数据库的方法</p>
<p>page：控制页面的返回。用户请求一个地址，请求发送到controller，会响应并返回某个页面给用户，和前端的模板有关联。</p>
<p>service：编写业务的逻辑</p>
<p>vo：返回给页面的数据</p>
<p>springboot的启动类，会自动帮助我启动一个tomcat服务器</p>
<h2 id="追踪请求（了解分层）"><a href="#追踪请求（了解分层）" class="headerlink" title="追踪请求（了解分层）"></a>追踪请求（了解分层）</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV13q4y1U7JU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bf2f8cedefdf16acd0e7a14d8e4669fd">带你读懂一个开源项目，学习通用套路！程序员阅读项目源码技巧、Java 编程项目分享</a></p>
<p><a href="https://www.code-nav.cn/">编程导航</a></p>
<p><a href="https://novel.xxyopen.com/">小说精品屋</a></p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>Java编程项目</tag>
        <tag>开源项目</tag>
        <tag>阅读项目源码技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Full Stack Netflix Clone</title>
    <url>/2024/02/22/Full-Stack-Netflix-Clone/</url>
    <content><![CDATA[<h1 id="Netflix-Clone"><a href="#Netflix-Clone" class="headerlink" title="Netflix Clone"></a>Netflix Clone</h1><h2 id="tech-stack"><a href="#tech-stack" class="headerlink" title="tech stack"></a>tech stack</h2><ul>
<li>Frontend: React</li>
<li>Server-side Rendering: Next.js</li>
<li>Styling: Tailwind CSS</li>
<li>Data abstraction layer: Prisma</li>
<li>Storage: MongoDB</li>
<li>Authentication: NextAuth</li>
<li>Deploy: Vercel</li>
<li>Typescript</li>
<li>the entire website fully</li>
</ul>
<p>The entire website fully responsive across all devices.</p>
<h2 id="function-overview"><a href="#function-overview" class="headerlink" title="function overview"></a>function overview</h2><p>credential login: username + password<br>profile: automatically generated once we register<br>homepage: loaded with a random movie-billboard<br>movies: load from database<br>favourites: add movies as favourites<br>botton:  shows more information about the movie<br>play the movie<br>Google oauth login</p>
<p>How to initialize next.js and Tailwind which is going to be crucial for our styling.</p>
<h2 id="Environment-setup"><a href="#Environment-setup" class="headerlink" title="Environment setup"></a>Environment setup</h2><h3 id="create-project"><a href="#create-project" class="headerlink" title="create project"></a>create project</h3><p>terminal:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-next-app --typescript</span><br></pre></td></tr></table></figure></p>
<p>set everything as default</p>
<p>open folder netflix-clone, enter command:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p>
<p>The website is running on: <a href="http://localhost:1689/">http://localhost:1689/</a></p>
<p>clean up the project:<br>remove pages/_document.tsx<br>remove everything in pages/index.tsx except the main function:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Netflix Clone<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remove all the content in styles/globals.css. Get a white page with Netflix Clone.</p>
<p>add <code>test.tsx</code> in pages folder. Add the below content in <code>test.tsx</code><br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MyPage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello New Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyPage</span>;</span><br></pre></td></tr></table></figure></p>
<p>I can visit Hello New Page in <a href="http://localhost:1689/test">http://localhost:1689/test</a>.<br>Delete <code>test.tsx</code>, it is just a demonstration of how easy it is to use Next.js.</p>
<h3 id="setup-tailwind"><a href="#setup-tailwind" class="headerlink" title="setup tailwind"></a>setup tailwind</h3><p>tailwind tutorial: <a href="https://tailwindcss.com/docs/guides/nextjs">https://tailwindcss.com/docs/guides/nextjs</a></p>
<p>run the following commands in terminal:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -D tailwindcss postcss autoprefixer</span><br><span class="line">npx tailwindcss init -p</span><br></pre></td></tr></table></figure></p>
<p>Now we have <code>tailwind.config.js</code> and <code>postcss.config.js</code>. Open <code>tailwind.config.js</code> and write the below code (according to tailwind tutorial above):<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">import(&#x27;tailwindcss&#x27;).Config</span>&#125; */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">content</span>: [</span><br><span class="line">    <span class="string">&quot;./app/**/*.&#123;js,ts,jsx,tsx&#125;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./pages/**/*.&#123;js,ts,jsx,tsx&#125;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./components/**/*.&#123;js,ts,jsx,tsx&#125;&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">theme</span>: &#123;</span><br><span class="line">    <span class="attr">extend</span>: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Write code in <code>styles/globals.css</code> to import tailwind styles:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@tailwind</span> base;</span><br><span class="line"><span class="keyword">@tailwind</span> components;</span><br><span class="line"><span class="keyword">@tailwind</span> utilities;</span><br></pre></td></tr></table></figure></p>
<p>enter the command <code>npm run dev</code> again and we can see a different web page, because the content in <code>globals.css</code> reset the css.</p>
<p>Try to change the color of netflix clone to green in the web page, just write the following code in <code>index.tsx</code>:<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;text-2xl text-green-500&quot;</span>&gt;</span>Netflix Clone<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Auth-Screen-UI"><a href="#Auth-Screen-UI" class="headerlink" title="Auth Screen UI"></a>Auth Screen UI</h2><p>In styles/globals.css, write:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@tailwind</span> base;</span><br><span class="line"><span class="keyword">@tailwind</span> components;</span><br><span class="line"><span class="keyword">@tailwind</span> utilities;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="keyword">@apply</span> bg-zinc-<span class="number">900</span> h-full overflow-x-hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>the web page turned to black. Add some code in globals.css:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#__next</span> &#123;</span><br><span class="line">    <span class="keyword">@apply</span> h-full;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="keyword">@apply</span> h-full;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>create <code>images</code> folder in <code>public</code> folder and download <code>hero.jpg</code> and <code>logo.png</code> from github repository.  </p>
<p>Create <code>auth.tsx</code> in pages. It is the auth page. Write the following code in it:<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Auth</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// first div: add background pictures in auth page</span></span><br><span class="line">        <span class="comment">// second dic: make the picture a bit darker in the large screen</span></span><br><span class="line">        <span class="comment">// img: set logo (NETFLIX) className=&quot;h-12&quot; makes it smaller</span></span><br><span class="line">        <span class="comment">// third div: container</span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;relative h-full w-full bg-[url(&#x27;/images/hero.jpg&#x27;)] bg-no-repeat bg-center bg-fixed bg-cover&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bg-black w-full h-full lg: bg-opacity-50&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">nav</span> <span class="attr">className</span>=<span class="string">&quot;px-12 py-5&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">alt</span> = <span class="string">&quot;Logo&quot;</span> <span class="attr">className</span>=<span class="string">&quot;h-12&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex justify-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bg-black bg-opacity-70 px-16 py-16 self-center mt-2 lg: w-2/5 lg: max-w-md rounded-md w-full&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-4xl mb-8 font-semibold&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            Sign in</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-col gap-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            </span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Auth</span>;</span><br></pre></td></tr></table></figure></p>
<p>create components folder and create <code>Input.tsx</code>. Write some codes in it:<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Input</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Input</span>;</span><br></pre></td></tr></table></figure></p>
<p>Now add the Input in <code>auth.tsx</code> :<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Input</span> <span class="keyword">from</span> <span class="string">&quot;@/components/Input&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-col gap-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>Now add some floating labels in <code>Input.tsx</code>:<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Input</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;relative&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    block</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    rounded-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    px-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    pt-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    pb-1</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    w-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    text-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    text-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    bg-neutral-700</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    appearance-none</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    focus: outline-none</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    focus: ring-0</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    peer</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">placeholder</span>=<span class="string">&quot; &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Input</span>;</span><br></pre></td></tr></table></figure></p>
<p>现在我们想在sign in之下的第一个输入框加上Email字样，当点击输入框时，Email变小，不点击输入框时，Email变大，这是一种浮动的特效。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// duration-150: duration for animation</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Input</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;relative&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">id</span> = <span class="string">&quot;email&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    block</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    rounded-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    px-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    pt-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    pb-1</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    w-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    text-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    text-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    bg-neutral-700</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    appearance-none</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    focus: outline-none</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    focus: ring-0</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    peer</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">placeholder</span>=<span class="string">&quot; &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">label</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                absolute</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                text-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                text-zinc-400</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                duration-150 </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                transform</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                -translate-y-3</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                scale-75</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                top-4</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                z-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                origin-[0]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                left-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                peer-placeholder-shown:scale-100</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                peer-placeholder-shown:translate-y-0</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                peer-focus:scale-75</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                peer-focus:-translate-y-3   </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">htmlFor</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                Email</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Input</span>;</span><br></pre></td></tr></table></figure></p>
<p>接下来让输入框模块化。加入react的一些特性：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InputProps</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">onChange</span>: <span class="built_in">any</span>;</span><br><span class="line">    <span class="attr">value</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">type</span>?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// duration-150: duration for animation</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Input</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">InputProps</span>&gt; = <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    id,</span></span></span><br><span class="line"><span class="params"><span class="function">    onChange,</span></span></span><br><span class="line"><span class="params"><span class="function">    value,</span></span></span><br><span class="line"><span class="params"><span class="function">    label,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">type</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;relative&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">type</span>=<span class="string">&#123;type&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">value</span>=<span class="string">&#123;value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">id</span>=<span class="string">&#123;id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    block</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    rounded-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    px-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    pt-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    pb-1</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    w-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    text-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    text-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    bg-neutral-700</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    appearance-none</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    focus: outline-none</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    focus: ring-0</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    peer</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">placeholder</span>=<span class="string">&quot; &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">label</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                absolute</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                text-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                text-zinc-400</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                duration-150 </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                transform</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                -translate-y-3</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                scale-75</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                top-4</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                z-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                origin-[0]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                left-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                peer-placeholder-shown:scale-100</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                peer-placeholder-shown:translate-y-0</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                peer-focus:scale-75</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                peer-focus:-translate-y-3   </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">htmlFor</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;label&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Input</span>;</span><br></pre></td></tr></table></figure></p>
<p>此时发现auth.tsx报错，在input处加入以下代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Input</span></span><br><span class="line">    label=<span class="string">&quot;Email&quot;</span></span><br><span class="line">    onChange=&#123;<span class="function">() =&gt;</span> &#123;&#125;&#125;</span><br><span class="line">    id=<span class="string">&quot;email&quot;</span></span><br><span class="line">    <span class="keyword">type</span>=<span class="string">&quot;email&quot;</span></span><br><span class="line">    value=<span class="string">&quot;&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们发现网页上的输入框无法输入内容，在<code>auth.tsx</code>中加入以下代码来解决这个问题：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Input</span> <span class="keyword">from</span> <span class="string">&quot;@/components/Input&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Auth</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [email, setEmail] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    label=<span class="string">&quot;Email&quot;</span></span><br><span class="line">    onChange=&#123;<span class="function">(<span class="params">ev</span>) =&gt;</span> <span class="title function_">setEmail</span>(ev.<span class="property">target</span>.<span class="property">value</span>)&#125;</span><br><span class="line">    id=<span class="string">&quot;email&quot;</span></span><br><span class="line">    <span class="keyword">type</span>=<span class="string">&quot;email&quot;</span></span><br><span class="line">    value=&#123;email&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在就可以在网页端的输入框内打字了。然后将上述内容复制两次，制造出username和password的输入框。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> [password, setPassword] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">label</span>=<span class="string">&quot;Username&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">onChange</span>=<span class="string">&#123;(ev:</span> <span class="attr">any</span>) =&gt;</span> setName(ev.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">    id=&quot;name&quot;</span></span><br><span class="line"><span class="language-xml">    value=&#123;name&#125;</span></span><br><span class="line"><span class="language-xml">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">label</span>=<span class="string">&quot;Password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">onChange</span>=<span class="string">&#123;(ev:</span> <span class="attr">any</span>) =&gt;</span> setPassword(ev.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">    id=&quot;password&quot;</span></span><br><span class="line"><span class="language-xml">    type=&quot;password&quot;</span></span><br><span class="line"><span class="language-xml">    value=&#123;password&#125;</span></span><br><span class="line"><span class="language-xml">/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来写按钮login botton：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;button className=<span class="string">&quot;bg-red-600 py-3 text-white rounded-md w-full mt-10 hover:bg-red-700 transition&quot;</span>&gt;</span><br><span class="line">    <span class="title class_">Login</span></span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<p>产生了一个红色的按钮，点击按钮颜色会变深。</p>
<p>接着<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;p className=<span class="string">&quot;text-neutral-500 mt-12&quot;</span>&gt;</span><br><span class="line">    <span class="title class_">First</span> time using <span class="title class_">Netflix</span>?</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;text-white ml-1 hover:underline cursor-pointer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Create account</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<p>接着在login和register之间产生一个跳转。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [variant, setVariant] = <span class="title function_">useState</span>(<span class="string">&#x27;login&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toggleVariant = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setVariant</span>(<span class="function">(<span class="params">currentVarient</span>) =&gt;</span> currentVarient === <span class="string">&#x27;login&#x27;</span> ? <span class="string">&#x27;register&#x27;</span>: <span class="string">&#x27;login&#x27;</span>)</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line">&lt;span onClick=&#123;toggleVariant&#125; className=<span class="string">&quot;text-white ml-1 hover:underline cursor-pointer&quot;</span>&gt;</span><br><span class="line">    <span class="title class_">Create</span> account</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
<p>接着再将原本的login改为<code>&#123;variant === &#39;login&#39; ? &#39;Sign in&#39;: &#39;Register&#39;&#125;</code>。这样点击create account就会在sign in和register之间切换。由于在sign in时不需要看到username，而在register时要输入username，因此将username包裹在register中：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&#123;variant === <span class="string">&#x27;register&#x27;</span> &amp;&amp; (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">label</span>=<span class="string">&quot;Username&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">onChange</span>=<span class="string">&#123;(ev:</span> <span class="attr">any</span>) =&gt;</span> setName(ev.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">    id=&quot;name&quot;</span></span><br><span class="line"><span class="language-xml">    value=&#123;name&#125;</span></span><br><span class="line"><span class="language-xml">/&gt;</span></span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着让按钮在sign in时显示为login，在register时显示为sign up。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;button className=<span class="string">&quot;bg-red-600 py-3 text-white rounded-md w-full mt-10 hover:bg-red-700 transition&quot;</span>&gt;</span><br><span class="line">    &#123;variant === <span class="string">&#x27;login&#x27;</span> ? <span class="string">&#x27;Login&#x27;</span>: <span class="string">&#x27;Sign up&#x27;</span>&#125;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<p>接着让login界面中显示提示语：First time using Netflix. Create account。在register页面中显示提出语：Already have an account?Login.<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;p className=<span class="string">&quot;text-neutral-500 mt-12&quot;</span>&gt;</span><br><span class="line">    &#123;variant === <span class="string">&#x27;login&#x27;</span> ? <span class="string">&#x27;First time using Netflix?&#x27;</span> : <span class="string">&#x27;Already have an account?&#x27;</span>&#125;</span><br><span class="line">    &lt;span onClick=&#123;toggleVariant&#125; className=<span class="string">&quot;text-white ml-1 hover:underline cursor-pointer&quot;</span>&gt;</span><br><span class="line">        &#123;variant === <span class="string">&#x27;login&#x27;</span> ? <span class="string">&#x27;Create account&#x27;</span> : <span class="string">&#x27;Login&#x27;</span>&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="NextAuth-Prisma-Mongo-Setup"><a href="#NextAuth-Prisma-Mongo-Setup" class="headerlink" title="NextAuth, Prisma, Mongo Setup"></a>NextAuth, Prisma, Mongo Setup</h2><p>将上述登录注册的UI界面通过prisma连接到mongodb。先在vscode中安装扩展prisma，其可以帮助对prisma文件进行格式化和高亮。接着在终端输入命令：<code>npm install -D prisma</code></p>
<p>再输入命令：<code>npx prisma init</code>，本命令可以产生一个<code>schema.prisma</code>文件。将其中的数据库修改为mongodb:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">generator client &#123;</span><br><span class="line">  provider = &quot;prisma-client-js&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">datasource db &#123;</span><br><span class="line">  provider = &quot;mongodb&quot;</span><br><span class="line">  url      = env(&quot;DATABASE_URL&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着在终端输入：<code>npm install @prisma/client</code>。接着再创建新的文件夹lib。在其中创建<code>prismadb.ts</code>文件，写入以下代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PrismaClient</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@prisma/client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="variable language_">global</span>.<span class="property">prismadb</span> || <span class="keyword">new</span> <span class="title class_">PrismaClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>) <span class="variable language_">global</span>.<span class="property">prismadb</span> = client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> client;</span><br></pre></td></tr></table></figure></p>
<p>next.js具有特性：hot reloading。每次代码改变时，我们的项目自动更新并重新运行。对prisma而言，每次会产生若干个PrismaClient实例，就会得到报错：已经有若干个Prisma Client正在运行。我们将PrismaClient存储在一个全局文件中，而全局文件并不会被hot reloading影响，因此就不会产生上面的报错。接着来解决prismadb标红的错误。</p>
<p>根目录下创建文件<code>global.d.ts</code>，在其中定义prismadb，写入以下内容：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PrismaClient</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@prisma/client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">    <span class="keyword">namespace</span> globalThis &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="attr">prismadb</span>: <span class="title class_">PrismaClient</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着进入<code>schema.prisma</code>文件，填入DATABASE_URL。需要先进入.env文件，将其中的database url换成有效的url。在谷歌中搜索mongodb atlas，注册并登录。点击build a database。我的database的username是cyf，密码是20001017。IP地址点击add my current IP address即可。接着在overview页面点击connect，选择mongodb for vscode。复制它给出的URL并粘贴到.env文件中。需要将URL中的<code>&lt;password&gt;</code>替换为自己真实的密码。并在URL的末尾加上我的实际数据库的名字：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATABASE_URL=&quot;mongodb+srv://cyf:20001017@cluster0.38xordg.mongodb.net/Cluster0&quot;</span><br></pre></td></tr></table></figure></p>
<p>接着，在<code>schema.prisma</code>文件中一次性定义好所有的models（数据模型）。因为反复修改数据模型和运行项目可能会导致一些麻烦和报错。<code>schema.prisma</code>文件内容如下所示：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// This is your Prisma schema file,</span><br><span class="line">// learn more about it in the docs: https://pris.ly/d/prisma-schema</span><br><span class="line"></span><br><span class="line">// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?</span><br><span class="line">// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init</span><br><span class="line"></span><br><span class="line">generator client &#123;</span><br><span class="line">  provider = &quot;prisma-client-js&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">datasource db &#123;</span><br><span class="line">  provider = &quot;mongodb&quot;</span><br><span class="line">  url      = env(&quot;DATABASE_URL&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">model User &#123;</span><br><span class="line">  id String @id @default(auto()) @map(&quot;_id&quot;) @db.ObjectId // 每个model都需要这一行，因为mongodb的model一定需要定义id</span><br><span class="line">  name String</span><br><span class="line">  image String? // ?表示可选，可要可不要</span><br><span class="line">  email String? @unique // 非必须，可能用到oauth login</span><br><span class="line">  emailVerified DateTime?</span><br><span class="line">  hashedPassword String? // 密码登录所需要</span><br><span class="line">  createAt DateTime @default(now())</span><br><span class="line">  updateAt DateTime @updatedAt // 自动更新 更新时间</span><br><span class="line">  favoriteIds String[] @db.ObjectId // 用户最喜欢的电影</span><br><span class="line">  sessions Session[]</span><br><span class="line">  accounts Account[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于Google Account或者GitHub Account</span><br><span class="line">model Account &#123;</span><br><span class="line">  id String @id @default(auto()) @map(&quot;_id&quot;) @db.ObjectId</span><br><span class="line">  userId String @db.ObjectId // account和userid之间的关系</span><br><span class="line">  type String</span><br><span class="line">  provider String</span><br><span class="line">  providerAccountId String</span><br><span class="line">  refresh_token String? @db.String</span><br><span class="line">  access_token String? @db.String</span><br><span class="line">  expires_at Int?</span><br><span class="line">  token_type String?</span><br><span class="line">  scope String?</span><br><span class="line">  id_token String? @db.String</span><br><span class="line">  session_state String?</span><br><span class="line"></span><br><span class="line">  // 将account model和user model之间通过userId连接, onDelate表示二者的删除是同步的(user被删除了，account也被删除)</span><br><span class="line">  user User @relation(fields: [userId], references: [id], onDelete: Cascade)</span><br><span class="line"></span><br><span class="line">  @@unique([provider, providerAccountId]) // 独一无二，不允许重复</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">model Session &#123;</span><br><span class="line">  id String @id @default(auto()) @map(&quot;_id&quot;) @db.ObjectId</span><br><span class="line">  sessionToken String @unique</span><br><span class="line">  userId String @db.ObjectId</span><br><span class="line">  expires DateTime</span><br><span class="line"></span><br><span class="line">  user User @relation(fields: [userId], references: [id], onDelete: Cascade)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">model VerificationToken &#123;</span><br><span class="line">  id String @id @default(auto()) @map(&quot;_id&quot;) @db.ObjectId</span><br><span class="line">  identifier String</span><br><span class="line">  token String @unique</span><br><span class="line">  expires DateTime</span><br><span class="line"></span><br><span class="line">  @@unique([identifier, token])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">model Movie &#123;</span><br><span class="line">  id String @id @default(auto()) @map(&quot;_id&quot;) @db.ObjectId</span><br><span class="line">  title String</span><br><span class="line">  description String</span><br><span class="line">  videoUrl String</span><br><span class="line">  thumbnailUrl String // 缩略网址</span><br><span class="line">  genre String // 类型</span><br><span class="line">  duration String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着在终端运行命令：<code>npx prisma db push</code>，将<code>schema.prisma</code>文件中定义的数据模型上传到云端，在mongodb的网页端选择database-browse collections，即可看到定义的5个数据模型。这说明prisma已经成功和mongodb连接起来了。</p>
<p>接着进入pages/api/hello.ts，可以通过链接：<a href="http://localhost:1689/api/hello访问到其中的内容。删除hello.ts，新建`[...nextauth].ts`文件，其会被next">http://localhost:1689/api/hello访问到其中的内容。删除hello.ts，新建`[...nextauth].ts`文件，其会被next</a> app识别。我们在这个文件中写next auth的middleware。通过命令<code>npm install next-auth</code>安装next-auth。还需要运行命令：<code>npm install bcrypt</code>。这个包用于用户名密码登录。在<code>[...nextauth].ts</code>文件中写下以下的内容：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">NextAuth</span> <span class="keyword">from</span> <span class="string">&#x27;next-auth&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Credentials</span> <span class="keyword">from</span> <span class="string">&#x27;next-auth/providers/credentials&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; compare &#125; <span class="keyword">from</span> <span class="string">&#x27;bcrypt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> prismadb <span class="keyword">from</span> <span class="string">&#x27;@/lib/prismadb&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">NextAuth</span>(&#123;</span><br><span class="line">    <span class="attr">providers</span>: [</span><br><span class="line">        <span class="title class_">Credentials</span>(&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="string">&#x27;credentials&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Credentials&#x27;</span>,</span><br><span class="line">            <span class="attr">credentials</span>: &#123;</span><br><span class="line">                <span class="attr">email</span>: &#123;</span><br><span class="line">                    <span class="attr">label</span>: <span class="string">&#x27;Email&#x27;</span>,</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">password</span>: &#123;</span><br><span class="line">                    <span class="attr">label</span>: <span class="string">&#x27;Password&#x27;</span>,</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> <span class="title function_">authorize</span>(<span class="params">credentials</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!credentials?.<span class="property">email</span> || !credentials?.<span class="property">password</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Email and password required&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 通过email找到用户，需要import prismadb</span></span><br><span class="line">                <span class="keyword">const</span> user = <span class="keyword">await</span> prismadb.<span class="property">user</span>.<span class="title function_">findUnique</span>(&#123;</span><br><span class="line">                    <span class="attr">where</span>: &#123;</span><br><span class="line">                        <span class="attr">email</span>: credentials.<span class="property">email</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断找到的user是否存在</span></span><br><span class="line">                <span class="keyword">if</span> (!user || !user.<span class="property">hashedPassword</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Email does not exist&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断用户输入的密码是否正确</span></span><br><span class="line">                <span class="keyword">const</span> isCorrectPassword = <span class="keyword">await</span> <span class="title function_">compare</span>(</span><br><span class="line">                    credentials.<span class="property">password</span>, </span><br><span class="line">                    user.<span class="property">hashedPassword</span></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!isCorrectPassword) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Incorrect password&quot;</span>); </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> user; <span class="comment">// 用户密码输入正确，则返回由email找到的唯一user</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="attr">pages</span>: &#123;</span><br><span class="line">        <span class="attr">signIn</span>: <span class="string">&#x27;/auth&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// debug on</span></span><br><span class="line">    <span class="attr">debug</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">session</span>: &#123;</span><br><span class="line">        <span class="attr">strategy</span>: <span class="string">&#x27;jwt&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>在<code>.env</code>文件中加入以下两个环境变量：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEXTAUTH_JWT_SECRET = &quot;NEXT-JWT-SECRET&quot;</span><br><span class="line">NEXTAUTH_SECRET = &quot;NEXT-SECRET&quot;</span><br></pre></td></tr></table></figure></p>
<p>在<code>[...nextauth].ts</code>文件中添加以下的内容：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">    <span class="attr">jwt</span>: &#123;</span><br><span class="line">        <span class="attr">secret</span>: process.<span class="property">env</span>.<span class="property">NEXTAUTH_JWT_SECRET</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">secret</span>: process.<span class="property">env</span>.<span class="property">NEXTAUTH_SECRET</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>接下来修复<code>bcrypt</code>标红的报错。在终端输入命令：<code>npm i -D @types/bcrypt</code>。安装了<code>bcrypt</code>后，不再标红报错。</p>
<p>进入<code>pages/auth.tsx</code>。在其中添加login和register的函数。首先通过命令行安装<code>axios</code>: <code>npm i axios</code>。然后在<code>auth.tsx</code>中引入<code>axios</code>并定义register函数：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// register function</span></span><br><span class="line"><span class="keyword">const</span> register = <span class="title function_">useCallback</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;, []); <span class="comment">// dependency: []</span></span><br></pre></td></tr></table></figure></p>
<p>接着写下完整的register函数：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// register function</span></span><br><span class="line"><span class="keyword">const</span> register = <span class="title function_">useCallback</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;/api/register&#x27;</span>, &#123;</span><br><span class="line">            email,</span><br><span class="line">            name,</span><br><span class="line">            password</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, []); <span class="comment">// dependency: []</span></span><br></pre></td></tr></table></figure></p>
<p>接着在<code>pages/api</code>中定义<code>register</code>。在<code>register.ts</code>中写下了如下的代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bcrypt <span class="keyword">from</span> <span class="string">&#x27;bcrypt&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextApiRequest</span>, <span class="title class_">NextApiResponse</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> prismadb <span class="keyword">from</span> <span class="string">&#x27;@/lib/prismadb&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params">req: NextApiRequest, res: NextApiResponse</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">method</span> !== <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">405</span>).<span class="title function_">end</span>(); <span class="comment">// we only want to allow post calls to /api/register</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try and catch block</span></span><br><span class="line">    <span class="comment">// try: extract some values from request.body</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; email, name, password &#125; = req.<span class="property">body</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check if an email is already in use</span></span><br><span class="line">        <span class="keyword">const</span> existinguser = <span class="keyword">await</span> prismadb.<span class="property">user</span>.<span class="title function_">findUnique</span>(&#123;</span><br><span class="line">            <span class="attr">where</span>: &#123;</span><br><span class="line">                email,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// email in use, return Email taken</span></span><br><span class="line">        <span class="keyword">if</span> (existinguser) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">422</span>).<span class="title function_">json</span>(&#123;<span class="attr">error</span>: <span class="string">&#x27;Email taken&#x27;</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash the password</span></span><br><span class="line">        <span class="keyword">const</span> hashedPassword = <span class="keyword">await</span> bcrypt.<span class="title function_">hash</span>(password, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将user信息存入数据库</span></span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> prismadb.<span class="property">user</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">            <span class="attr">data</span>: &#123;</span><br><span class="line">                email,</span><br><span class="line">                name,</span><br><span class="line">                hashedPassword,</span><br><span class="line">                <span class="attr">image</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                <span class="attr">emailVerified</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就完成了<code>/api/register</code>。在<code>auth.tsx</code>中填入dependency的具体内容：<code>[email, name, password]); // dependency in []</code>。</p>
<p>接着，我们需要在点击sign up按钮时呼叫<code>/api/register</code>。先不管按钮上写的是login还是register，将按钮统一绑定到register函数：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;register&#125; className=<span class="string">&quot;bg-red-600 py-3 text-white rounded-md w-full mt-10 hover:bg-red-700 transition&quot;</span>&gt;</span><br><span class="line">    &#123;variant === <span class="string">&#x27;login&#x27;</span> ? <span class="string">&#x27;Login&#x27;</span>: <span class="string">&#x27;Sign up&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>打开网页，F12打开调试模式，选择network，输入用户名、邮箱和密码，可以看到register函数被成功调用。接着打开mongodb atlas的网站，选择database-browse collections-user，可以看到其中添加了一条用户信息的数据，成功！到此，用户名密码注册部分完成了。</p>
<p>现在开始做Login部分。在<code>auth.tsx</code>中添加以下login函数：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// login function</span></span><br><span class="line"><span class="keyword">const</span> login = <span class="title function_">useCallback</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// try and catch block</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 需要用到[..nextauth].ts中的Credentials</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">signIn</span>(<span class="string">&#x27;credentials&#x27;</span>, &#123;</span><br><span class="line">            email,</span><br><span class="line">            password,</span><br><span class="line">            <span class="attr">redirect</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">callbackUrl</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [email, password]); <span class="comment">// login only need email and password</span></span><br></pre></td></tr></table></figure></p>
<p>接着在按钮处调用login函数：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;variant === <span class="string">&#x27;login&#x27;</span> ? login : register&#125; className=<span class="string">&quot;bg-red-600 py-3 text-white rounded-md w-full mt-10 hover:bg-red-700 transition&quot;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以在点击login按钮时调用login函数，在点击sign up按钮时调用register函数。点击login按钮，网页并没有产生预期的跳转，打印出错误信息：Error: This action with HTTP GET is not supported by NextAuth.js。尝试修复这个问题。在api文件夹中再创建auth文件夹，将<code>[...nextauth].ts</code>文件拖拽到其中。然后这个问题就被修复了。接着继续在login函数中添加router：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// login function</span></span><br><span class="line"><span class="keyword">const</span> login = <span class="title function_">useCallback</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// try and catch block</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 需要用到[..nextauth].ts中的Credentials</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">signIn</span>(<span class="string">&#x27;credentials&#x27;</span>, &#123;</span><br><span class="line">            email,</span><br><span class="line">            password,</span><br><span class="line">            <span class="attr">redirect</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">callbackUrl</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        router.<span class="title function_">push</span>(<span class="string">&#x27;/&#x27;</span>); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [email, password, router]); <span class="comment">// login only need email and password, and then we add router</span></span><br></pre></td></tr></table></figure></p>
<p>接着在register函数中添加login部分，一旦注册成功后就自动登录。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// register function</span></span><br><span class="line"><span class="keyword">const</span> register = <span class="title function_">useCallback</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;/api/register&#x27;</span>, &#123;</span><br><span class="line">            email,</span><br><span class="line">            name,</span><br><span class="line">            password</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">login</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [email, name, password, login]); <span class="comment">// dependency in []</span></span><br></pre></td></tr></table></figure></p>
<p>同时注意调整login和register函数的顺序，让login定义在register之前（因为register中需要调用login函数）。现在再次尝试输入邮箱和密码并点击login按钮，发现可以成功跳转到根目录。</p>
<h2 id="Google-and-Github-OAuth"><a href="#Google-and-Github-OAuth" class="headerlink" title="Google and Github OAuth"></a>Google and Github OAuth</h2><p>加入Google and Github OAuth非常简单。首先在终端中运行命令：<code>npm install react-icons</code>。通过这个包可以向项目中添加Google, Github和其他炫酷的icon。接下来写google和github一键登录的UI界面。在<code>auth.tsx</code>中加入以下代码。首先是引入react中包含icons的包，然后在login/sign up按钮下定义一个div，用于空出更大的空间。再定义一个div，用于存放按钮。在这个div中定义按钮的各种属性（居中、圆角等）。最后再通过<code>FcGoogle</code>引入Google的图标。接着，我们复制上面的代码，将图标改为Github。以上的代码如下所示：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FcGoogle</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-icons/fc&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FaGithub</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-icons/fa&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-row items-center gap-4 mt-8 justify-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            w-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            h-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            bg-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            rounded-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            flex</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            items-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            justify-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            cursor-pointer</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            hover:opacity-80</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            transition</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">FcGoogle</span> <span class="attr">size</span>=<span class="string">&#123;30&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            w-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            h-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            bg-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            rounded-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            flex</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            items-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            justify-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            cursor-pointer</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            hover:opacity-80</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            transition</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">FaGithub</span> <span class="attr">size</span>=<span class="string">&#123;30&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>接着进入<code>.env</code>文件中增加一些环境变量。如下所示：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GITHUB_ID=</span><br><span class="line">GITHUB_SECRET=</span><br><span class="line"></span><br><span class="line">GOOGLE_CLIENT_ID=</span><br><span class="line">GOOGLE_CLIENT_SECRET=</span><br></pre></td></tr></table></figure></p>
<p>接着在<code>[...nextauth].ts</code>文件中添加包和GithubProvider、GoogleProvider。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">GithubProvider</span> <span class="keyword">from</span> <span class="string">&#x27;next-auth/providers/github&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">GoogleProvider</span> <span class="keyword">from</span> <span class="string">&#x27;next-auth/providers/google&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">GithubProvider</span>(&#123;</span><br><span class="line">    <span class="attr">clientId</span>: process.<span class="property">env</span>.<span class="property">GITHUB_ID</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">clientSecret</span>: process.<span class="property">env</span>.<span class="property">GITHUB_SECRET</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="title class_">GoogleProvider</span>(&#123;</span><br><span class="line">    <span class="attr">clientId</span>: process.<span class="property">env</span>.<span class="property">GOOGLE_CLIENT_ID</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">clientSecret</span>: process.<span class="property">env</span>.<span class="property">GOOGLE_CLIENT_SECRET</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></p>
<p>接着执行命令：<code>npm install @next-auth/prisma-adapter</code>。接着在<code>[...nextauth].ts</code>文件中添加以下代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PrismaAdapter</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@next-auth/prisma-adapter&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="attr">adapter</span>: <span class="title class_">PrismaAdapter</span>(prismadb),</span><br></pre></td></tr></table></figure></p>
<p>接下来填入.env文件中的GITHUB_ID和GITHUB_SECRET。去到GITHUB-SETTINGS-DEVELOPER SETTINGS-OAUTH APPS-NEW OAUTH APP，填入以下内容：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Register a new OAuth application</span><br><span class="line">Application name</span><br><span class="line">netflix-clone</span><br><span class="line"></span><br><span class="line">Homepage URL</span><br><span class="line">http://localhost:1689</span><br><span class="line"></span><br><span class="line">Authorization callback URL</span><br><span class="line">http://localhost:1689</span><br></pre></td></tr></table></figure></p>
<p>接着点击register application，然后将生成的GITHUB_ID和GITHUB_SECRET复制到<code>.env</code>文件中。</p>
<p>现在我们在<code>auth.tsx</code>中给github一键登录写一个函数:<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">signIn</span>(<span class="string">&#x27;github&#x27;</span>, &#123; <span class="attr">callbackUrl</span>: <span class="string">&#x27;/&#x27;</span> &#125;)&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>并在<code>.env</code>文件中指定重定向URL的路径：<code>NEXTAUTH_URL=http://localhost:10564/</code></strong><br>进行上述操作后，github一键登录成功，一键登录成功后被导航回到了根目录。然后可以在mongodb的account中看到一条新的数据。本来应该在user中也看到一条新的数据，但我的user中没有github一键登录产生的新user的数据。这个问题在github的issues中有解释：<a href="https://github.com/AntonioErdeljac/next-netflix-tutorial/issues/13。这个问题应该不是一个问题，不用担心。">https://github.com/AntonioErdeljac/next-netflix-tutorial/issues/13。这个问题应该不是一个问题，不用担心。</a></p>
<p>现在开始完成google一键登录。相比于github，Google会更麻烦些。进入google cloud console: <a href="https://console.cloud.google.com/welcome?pli=1&amp;project=advance-proton-400620。新建项目并填入项目名称，点创建。选中该项目，搜索apis">https://console.cloud.google.com/welcome?pli=1&amp;project=advance-proton-400620。新建项目并填入项目名称，点创建。选中该项目，搜索apis</a> &amp; services。选择oauth权限请求页面，选择外部，点击创建。填入应用名称、用户支持电子邮件、开发者联系信息，然后保存并继续。然后一路点击保存并继续。点击凭据-创建凭据-创建 OAuth 客户端 ID。选择web应用-添加URL：<a href="http://localhost:10564/api/auth/callback/google。我们就可以得到client">http://localhost:10564/api/auth/callback/google。我们就可以得到client</a> ID和client secret。将它们复制到<code>.env</code>文件中。然后在<code>auth.tsx</code>中给google一键登录写一个函数:<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">signIn</span>(<span class="string">&#x27;google&#x27;</span>, &#123; <span class="attr">callbackUrl</span>: <span class="string">&#x27;/&#x27;</span> &#125;)&#125;</span><br></pre></td></tr></table></figure></p>
<p>在网页端尝试点击google一键登录，成功！</p>
<h2 id="Protecting-routes-Profiles-screen"><a href="#Protecting-routes-Profiles-screen" class="headerlink" title="Protecting routes, Profiles screen"></a>Protecting routes, Profiles screen</h2><p>如何通过授权登录保护client路径和api路径。在lib文件夹中创建<code>serverAuth.ts</code>。在其中写下如下的代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextApiRequest</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getSession &#125; <span class="keyword">from</span> <span class="string">&#x27;next-auth/react&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> prismadb <span class="keyword">from</span> <span class="string">&#x27;@/lib/prismadb&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; error &#125; <span class="keyword">from</span> <span class="string">&#x27;console&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">serverAuth</span> = <span class="keyword">async</span> (<span class="params">req: NextApiRequest</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// fetch log in user session</span></span><br><span class="line">    <span class="keyword">const</span> session = <span class="keyword">await</span> <span class="title function_">getSession</span>(&#123; req &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use serverAuth in api controller</span></span><br><span class="line">    <span class="comment">// req parameter  will hold jwt token to get logged in user</span></span><br><span class="line">    <span class="comment">// use session to get other fields</span></span><br><span class="line">    <span class="keyword">if</span> (!session?.<span class="property">user</span>?.<span class="property">email</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not signed in&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过email找到不同的user</span></span><br><span class="line">    <span class="keyword">const</span> currentUser = <span class="keyword">await</span> prismadb.<span class="property">user</span>.<span class="title function_">findUnique</span>(&#123;</span><br><span class="line">        <span class="attr">where</span>: &#123;</span><br><span class="line">            <span class="attr">email</span>: session.<span class="property">user</span>.<span class="property">email</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无currentUser, 说明jwt token或者session不正确或者过期了</span></span><br><span class="line">    <span class="keyword">if</span> (!currentUser) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not signed in&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; currentUser &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> serverAuth;</span><br></pre></td></tr></table></figure></p>
<p>用上述文件可以在所有的api routes中检查我们是否登录。进入<code>pages/api</code>中，创建<code>current.ts</code>，在其中写上以下的代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextApiRequest</span>, <span class="title class_">NextApiResponse</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> serverAuth <span class="keyword">from</span> <span class="string">&#x27;@/lib/serverAuth&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params">req: NextApiRequest, res: NextApiResponse</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">method</span> !== <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">405</span>).<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try and catch block</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; currentUser &#125; = <span class="keyword">await</span> <span class="title function_">serverAuth</span>(req); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(currentUser);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面开始写用于front end fetching的部分，在<code>libs/fetcher.ts</code>，在其中写下代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetcher</span> = (<span class="params">url: <span class="built_in">string</span></span>) =&gt; axios.<span class="title function_">get</span>(url).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="property">data</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fetcher;</span><br></pre></td></tr></table></figure></p>
<p>在前端写用于载入当前用户的代码。在根目录下新建hooks文件夹，在其中新建文件<code>useCurrentUser.ts</code>。然后在终端中运行命令：<code>npm install swr</code>。然后在<code>useCurrentUser.ts</code>中写入：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useSWR <span class="keyword">from</span> <span class="string">&#x27;swr&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fetcher <span class="keyword">from</span> <span class="string">&#x27;@/lib/fetcher&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// svr: versal developed package, which is good at fetching data</span></span><br><span class="line"><span class="comment">// If the data already exists, we are not going to fetch the data again</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useCurrentUser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data, error, isLoading, mutate &#125; = <span class="title function_">useSWR</span>(<span class="string">&#x27;/api/current&#x27;</span>, fetcher)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        data,</span><br><span class="line">        error,</span><br><span class="line">        isLoading,</span><br><span class="line">        mutate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useCurrentUser;</span><br></pre></td></tr></table></figure></p>
<p>下面我们来展示如何保护client routes。我们想让用户在不登陆的情况下访问不到我们的网站。在<code>pages/index.tsx</code>中首先创建一个sign out按钮。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;button className=<span class="string">&quot;h-10 w-full bg-white&quot;</span> onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">signOut</span>()&#125;&gt;<span class="title class_">Logout</span>!&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们来演示如何在<code>pages/index.tsx</code>中保护家路径。在其中写下以下的代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextPageContext</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getSession, signOut &#125; <span class="keyword">from</span> <span class="string">&quot;next-auth/react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch our session from client side</span></span><br><span class="line"><span class="comment">// cannot use serverAuth</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span>(<span class="params">context: NextPageContext</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> session = <span class="keyword">await</span> <span class="title function_">getSession</span>(context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// session不存在，则返回登录界面</span></span><br><span class="line">  <span class="keyword">if</span> (!session) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">redirect</span>: &#123;</span><br><span class="line">        <span class="attr">destination</span>: <span class="string">&#x27;/auth&#x27;</span>,</span><br><span class="line">        <span class="attr">permanent</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// session存在，则返回空</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;text-4xl text-green-500&quot;</span>&gt;</span>Netflix Clone<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;h-10 w-full bg-white&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> signOut()&#125;&gt;Logout!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在实现了功能：用户不能在未登录的情况下直接访问家目录。现在的问题：登出以后无法登录并进入到家目录。进入mongodb-network access。点击add ip address，选择allow access from anywhere。目前项目仍然不能正常登录。报错信息显示：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[next-auth][error][CLIENT_FETCH_ERROR] </span><br><span class="line">https://next-auth.js.org/errors#client_fetch_error fetch failed &#123;</span><br><span class="line">  error: &#123;</span><br><span class="line">    message: &#x27;fetch failed&#x27;,</span><br><span class="line">    stack: &#x27;TypeError: fetch failed\n&#x27; +</span><br><span class="line">      &#x27;    at node:internal/deps/undici/undici:12443:11\n&#x27; +</span><br><span class="line">      &#x27;    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)&#x27;,</span><br><span class="line">    name: &#x27;TypeError&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  url: &#x27;http://localhost:10564/api/auth/session&#x27;,</span><br><span class="line">  message: &#x27;fetch failed&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我尝试了若干种解决办法，最后是这样解决的：<br>由于在默认情况下，port和forwarded address是不同的，这样就会导致上面的报错，<strong>我猜测是产生了跨域问题，导致port和forwarded address之间的信息转发失败了</strong>。我们需要将port和forwarded address的端口号改成相同的，并在<code>.env</code>文件和<code>package.json</code>文件中做出相应的修改。以我在本项目中的实际操作为例。我将port改为10564，将forwarded address也改为10564（vscode-PORTS中会自动补全为<code>localhost:10564</code>），然后在<code>.env</code>文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEXTAUTH_URL=&quot;http://localhost:10564&quot;</span><br></pre></td></tr></table></figure>
<p>在<code>package.json</code>文件中添加：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;next dev -p 10564&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;next start -p 10564&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></p>
<p>然后重启项目，就可以成功地通过用户名密码/github/google登入登出根页面了。</p>
<p>接下来关注如何通过<code>useCurrentUser.ts</code>中的hook来获取用户信息。在<code>index.tsx</code>中加入以下代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useCurrentUser <span class="keyword">from</span> <span class="string">&quot;@/hooks/useCurrentUser&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; data : user &#125; = <span class="title function_">useCurrentUser</span>();</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white&quot;</span>&gt;</span>Logged in as : &#123;user?.email&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样在根页面就会显示Logged in as + 登录用户邮箱的信息。现在我们来创建用户档案页面。在pages文件夹下创建<code>profiles.tsx</code>文件，在其中加入以下框架：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Profiles</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-4xl&quot;</span>&gt;</span>Profiles<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Profiles</span>;</span><br></pre></td></tr></table></figure></p>
<p>接着访问<a href="http://localhost:10564/profiles，就可以看到白色的Profiles字样。接着在`profiles.tsx`文件中写`fetch">http://localhost:10564/profiles，就可以看到白色的Profiles字样。接着在`profiles.tsx`文件中写`fetch</a> session`的代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fetch our session from client side, just like  what we do in index.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span>(<span class="params">context: NextPageContext</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> session = <span class="keyword">await</span> <span class="title function_">getSession</span>(context); <span class="comment">// get session</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!session) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">redirect</span>: &#123;</span><br><span class="line">                <span class="attr">destination</span>: <span class="string">&#x27;/auth&#x27;</span>,</span><br><span class="line">                <span class="attr">permanent</span>: <span class="literal">false</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">props</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着在<code>auth.tsx</code>中，将三个登录处的重定向URL重定向到profiles页面并删除<code>router</code>。现在产生了效果：在未登录时访问profiles页面会被重定向到auth页面。在auth页面登录后会被重定向到profiles页面。从github仓库中下载default blue图片，作为用户的默认头像。在<code>profiles.tsx</code>中写下了如下的代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Profiles</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: user &#125; = <span class="title function_">useCurrentUser</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex items-center h-full justify-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-col&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;text-3xl md:text-6xl text-white text-center&quot;</span> &gt;</span>Who is watching?<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex items-center justify-center gap-8 mt-10&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;&#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;group flex-row w-44 mx-auto&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                                <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                w-44</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                h-44</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                rounded-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                flex</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                items-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                justify-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                border-2</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                border-transparent</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                group-hover:cursor-pointer</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                group-hover:border-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                overflow-hidden</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            &gt;</span></span></span><br><span class="line"><span class="language-xml">                                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/default-blue.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Profile&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                                <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                mt-4</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                text-gray-400</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                text-2xl</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                text-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                group-hover:text-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            &gt;</span></span></span><br><span class="line"><span class="language-xml">                                &#123;user?.name&#125;</span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>产生了如下的效果：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-02-25_04-32-09.png?raw=true" alt="Snipaste_2024-02-25_04-32-09.png"></p>
<p>然后让点击图片会重定向回到根网页。增加以下代码即可：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line"></span><br><span class="line">&lt;div onClick=&#123;<span class="function">() =&gt;</span> router.<span class="title function_">push</span>(<span class="string">&#x27;/&#x27;</span>)&#125;&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Navagation-Component"><a href="#Navagation-Component" class="headerlink" title="Navagation Component"></a>Navagation Component</h2><p>清理<code>index.tsx</code>文件，只剩下骨架即可（不需要按钮和sign out功能）：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextPageContext</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getSession &#125; <span class="keyword">from</span> <span class="string">&quot;next-auth/react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch our session from client side</span></span><br><span class="line"><span class="comment">// cannot use serverAuth</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span>(<span class="params">context: NextPageContext</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> session = <span class="keyword">await</span> <span class="title function_">getSession</span>(context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// session不存在，则返回登录界面</span></span><br><span class="line">  <span class="keyword">if</span> (!session) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">redirect</span>: &#123;</span><br><span class="line">        <span class="attr">destination</span>: <span class="string">&#x27;/auth&#x27;</span>,</span><br><span class="line">        <span class="attr">permanent</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// session存在，则返回空</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们需要在上述文件中添加<code>Navbar</code>，但目前<code>Navbar</code>尚不存在，因此需要在<code>components</code>文件夹中添加<code>Navbar.tsx</code>。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Navbar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            Navbar</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Navbar</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后在<code>index.tsx</code>中import并添加<code>Navbar</code>。接下来在<code>Navbar.tsx</code>中写入具体的内容。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Navbar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// navigation type</span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">className</span>=<span class="string">&quot;w-full fixed z-40&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    px-4</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    md:px-16</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    py-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    flex</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    flex-row</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    items-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    transition</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    duration-500</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    bg-zinc-900</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    bg-opacity-90</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">&quot;h-4 lg:h-7&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Logo&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    flex-row</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    ml-8</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    gap-7</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    hidden</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    lg:flex</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                &gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">NavbarItem</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Navbar</span>;</span><br></pre></td></tr></table></figure></p>
<p>接着在<code>components</code>中定义<code>NavbarItem.tsx</code>，写出其骨架：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">NavbarItem</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">NavbarItem</span>;</span><br></pre></td></tr></table></figure></p>
<p>接着丰满其中的细节：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NavbarItemProps</span> &#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NavbarItem</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">NavbarItemProps</span>&gt; = <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    label</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;text-white cursor-pointer hover:text-gray-300 trasition&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;label&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">NavbarItem</span>;</span><br></pre></td></tr></table></figure></p>
<p>需要从<code>Navbar.tsx</code>中传入label: <code>&lt;NavbarItem label=&quot;Home&quot; /&gt;</code>，并依照同样的方式创建另外几个导航组件：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">NavbarItem</span> label=<span class="string">&quot;Home&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavbarItem</span> <span class="attr">label</span>=<span class="string">&quot;Series&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavbarItem</span> <span class="attr">label</span>=<span class="string">&quot;Films&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavbarItem</span> <span class="attr">label</span>=<span class="string">&quot;New &amp; Popular&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavbarItem</span> <span class="attr">label</span>=<span class="string">&quot;My List&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavbarItem</span> <span class="attr">label</span>=<span class="string">&quot;Browse by languages&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;lg:hidden flex flex-row items-center gap-2 ml-8 cursor-pointer relative&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-sm&quot;</span>&gt;</span>Browse<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>小屏幕时，只出现Browse，不出现其他<code>navagation component</code>。接着去查找icons: <a href="https://react-icons.github.io/react-icons/。找到一个向下展开的小箭头，在`Navbar.tsx`中引入并使用这个小箭头：">https://react-icons.github.io/react-icons/。找到一个向下展开的小箭头，在`Navbar.tsx`中引入并使用这个小箭头：</a><br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BsChevronDown</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-icons/bs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">BsChevronDown</span> <span class="attr">className</span>=<span class="string">&quot;text-white transition&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>接着创建手机端（小屏幕）的菜单。先在<code>components</code>中创建<code>MobileMenu.tsx</code>，在其中写以下的代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MobileMenuProps</span> &#123;</span><br><span class="line">    visible?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MobileMenu</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">MobileMenuProps</span>&gt; = <span class="function">(<span class="params">&#123; visible &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visible) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bg-black w-56 absolute top-8 left-0 py-5 flex-col border-2 border-gray-800 flex&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;flex flex-col gap-4&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;px-3 text-center text-white hover:underline&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    Home</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MobileMenu</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后在<code>Navbar.tsx</code>中引入<code>MobileMenu</code>。并<strong>实现手机（小屏幕）上点击browse展开出home的功能</strong>。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [showMobileMenu, setShowMobileMenu] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toggleMobileMenu = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setShowMobileMenu</span>(<span class="function">(<span class="params">current</span>) =&gt;</span> !current);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MobileMenu</span> <span class="attr">visible</span>=<span class="string">&#123;showMobileMenu&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>对于上述代码的解释：这段代码是使用React Hooks编写的，主要用于在React组件中管理和切换移动设备菜单的显示状态。具体来说，这段代码定义了一个状态变量<code>showMobileMenu</code>和一个切换该状态的函数<code>toggleMobileMenu</code>。下面是这段代码的详细解释：</p>
<p><code>useState</code> 钩子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [showMobileMenu, setShowMobileMenu] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>useState</code>是一个React Hook，允许在函数组件中添加状态。这里，它被用来定义一个名为<code>showMobileMenu</code>的状态变量，用于跟踪移动菜单是否显示。该状态的初始值为<code>false</code>，意味着菜单默认是不显示的。</li>
<li><code>setShowMobileMenu</code>是一个函数，用于更新<code>showMobileMenu</code>状态的值。当调用这个函数并传入一个新的值时，组件会重新渲染，并且<code>showMobileMenu</code>的值会更新为传入的新值。</li>
</ul>
<p><code>useCallback</code> 钩子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toggleMobileMenu = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setShowMobileMenu</span>(<span class="function">(<span class="params">current</span>) =&gt;</span> !current);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>useCallback</code>是另一个React Hook，它返回一个记忆化的回调函数。这个回调函数只会在依赖项数组（这里是空数组<code>[]</code>）中的值发生变化时才会更新。在这个例子中，由于依赖项数组为空，<code>toggleMobileMenu</code>函数在组件的整个生命周期内保持不变。</li>
<li><code>toggleMobileMenu</code>函数的作用是调用<code>setShowMobileMenu</code>来切换<code>showMobileMenu</code>状态的值。它通过传递一个函数给<code>setShowMobileMenu</code>，这个函数接收当前的状态值<code>current</code>作为参数，并返回其相反值<code>!current</code>。这样，如果菜单当前是显示的（<code>true</code>），调用<code>toggleMobileMenu</code>会将其隐藏（设为<code>false</code>），反之亦然。</li>
</ul>
<p>总结</p>
<p>这段代码的主要目的是控制移动菜单的显示状态。通过点击或触发某个事件来调用<code>toggleMobileMenu</code>函数，可以在显示和隐藏移动菜单之间切换，从而为用户提供一个响应式的导航体验。这种模式在开发响应式Web应用时非常常见，特别是在需要改进移动设备上的用户界面和交互时。</p>
<p>进入<code>MobileMenu.tsx</code>中，加入一些新的class。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;div className=<span class="string">&#x27;px-3 text-center text-white hover:underline&#x27;</span>&gt;</span><br><span class="line">    <span class="title class_">Home</span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;px-3 text-center text-white hover:underline&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Series</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;px-3 text-center text-white hover:underline&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Films</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;px-3 text-center text-white hover:underline&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    New &amp; Popular</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;px-3 text-center text-white hover:underline&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    My List</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;px-3 text-center text-white hover:underline&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Browse by Languages</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样点开browse就会展开上述的内容。接下来是<code>profile menu</code>。首先在导航组件中添加一个search（即一个放大镜形状的图标）。再添加一个铃铛，最后添加用户的默认头像，然后在用户头像处也添加一个向下展开的箭头。在<code>Navbar.tsx</code>中使用如下代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;flex flex-row ml-auto gap-7 items-center&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;text-gray-200 hover:text-gray-300 cursor-pointer transition&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">BsSearch</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;text-gray-200 hover:text-gray-300 cursor-pointer transition&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">BsBell</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-row items-center gap-2 cursor-pointer relative&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;w-6 h-6 lg:w-10 lg:h-10 rounded-md overflow-hidden&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/default-blue.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">BsChevronDown</span> <span class="attr">className</span>=<span class="string">&quot;text-white transition&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>再添加<code>AccountMenu</code>。先在components中定义<code>AccountMenu.tsx</code>，在其中写一个骨架：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">AccountMenu</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">AccountMenu</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后再在<code>Navbar.tsx</code>中引入<code>AccountMenu</code>。在<code>AccountMenu.tsx</code>中写入具体的内容：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; signOut &#125; <span class="keyword">from</span> <span class="string">&quot;next-auth/react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AccountMenuProps</span> &#123;</span><br><span class="line">    <span class="attr">visible</span>: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AccountMenu</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">AccountMenuProps</span>&gt; = <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    visible</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visible) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bg-black w-56 absolute top-14 right-0 py-5 flex-col border-2 border-gray-800 flex&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-col gap-3&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;px-3 group/item flex flex-row gap-3 items-center w-full&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">&quot;w-8 rounded-md&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/default-blue.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-sm group-hover/item:underline&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        Username</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">AccountMenu</span>;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Navbar.tsx</code>中加入<code>&lt;AccountMenu visible/&gt;</code>，让<code>AccountMenu</code>。接下来再在<code>AccountMenu.tsx</code>中加入signOut按钮。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bg-black w-56 absolute top-14 right-0 py-5 flex-col border-2 border-gray-800 flex&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-col gap-3&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;px-3 group/item flex flex-row gap-3 items-center w-full&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">&quot;w-8 rounded-md&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/default-blue.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-sm group-hover/item:underline&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    Username</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">hr</span> <span class="attr">className</span>=<span class="string">&quot;bg-gray-600 border-0 h-px my-4&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> signOut()&#125; className=&quot;px-3 text-center text-white text-sm hover:underline&quot;&gt;</span></span><br><span class="line"><span class="language-xml">                Sign out of Netflix</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>然后还需要加入展开<code>AccountMenu</code>和收起<code>AccountMenu</code>的功能。在<code>Navbar.tsx</code>中加入代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [showAccountMenu, setShowAccountMenu] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toggleAccountMenu = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setShowAccountMenu</span>(<span class="function">(<span class="params">current</span>) =&gt;</span> !current);</span><br><span class="line">    &#125;, []);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;toggleAccountMenu&#125;</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-row items-center gap-2 cursor-pointer relative&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;w-6 h-6 lg:w-10 lg:h-10 rounded-md overflow-hidden&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/default-blue.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">BsChevronDown</span> <span class="attr">className</span>=<span class="string">&quot;text-white transition&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">AccountMenu</span> <span class="attr">visible</span>=<span class="string">&#123;showAccountMenu&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>然后加入旋转 控制<code>AccountMenu</code>展开和收起的箭头的功能。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">BsChevronDown</span> className=&#123;<span class="string">`text-white transition <span class="subst">$&#123;showAccountMenu ? <span class="string">`rotate-180`</span> : <span class="string">`rotate-0`</span>&#125;</span>`</span>&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>同理，对控制<code>browse</code>的箭头也做相同的处理。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">BsChevronDown</span> className=&#123;<span class="string">`text-white transition <span class="subst">$&#123;showMobileMenu ? <span class="string">`rotate-180`</span> : <span class="string">`rotate-0`</span>&#125;</span>`</span>&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在想加一个特效：向下滑动时页面变黑，其他情况下页面透明。在<code>Navbar.tsx</code>中加入以下代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [showBackground, setShowBackground] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleScroll</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">scrollY</span> &gt;= <span class="variable constant_">TOP_OFFSET</span>) &#123;</span><br><span class="line">            <span class="title function_">setShowBackground</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">setShowBackground</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, handleScroll); <span class="comment">// listen to scroll event</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, handleScroll); <span class="comment">// remove listener</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line">    &lt;nav className=&quot;w-full fixed z-40&quot;&gt;</span><br><span class="line">        &lt;div</span><br><span class="line">            className=&#123;`</span><br><span class="line">                px-4</span><br><span class="line">                md:px-16</span><br><span class="line">                py-6</span><br><span class="line">                flex</span><br><span class="line">                flex-row</span><br><span class="line">                items-center</span><br><span class="line">                transition</span><br><span class="line">                duration-500</span><br><span class="line">                $&#123;showBackground ? &#x27;bg-zinc-900 bg-opacity-90&#x27; : &#x27;&#x27;&#125;</span><br><span class="line"></span><br><span class="line">            `&#125;</span><br></pre></td></tr></table></figure></p>
<p>加上这些代码后，当滚动页面时，导航组件都是透明的，但当开始滑动鼠标滚轮时，导航组件的背景变为黑色。<br>可以在<code>index.sh</code>中添加代码来测试这个功能：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Navbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bg-gray-500&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-96&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加完上述代码后，页面可以滚动，发现功能是正常的。</p>
<h2 id="Billboard-Component-Random-Movie-Endpoint"><a href="#Billboard-Component-Random-Movie-Endpoint" class="headerlink" title="Billboard Component, Random Movie Endpoint"></a>Billboard Component, Random Movie Endpoint</h2><p>每次会随机加载一部电影。进入github仓库，打开<code>movies.json</code>。将其中的电影全部加入到数据库中。<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;Big Buck Bunny&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;Three rodents amuse themselves by harassing creatures of the forest. However, when they mess with a bunny, he decides to teach them a lesson.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;videoUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;thumbnailUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;https://upload.wikimedia.org/wikipedia/commons/7/70/Big.Buck.Bunny.-.Opening.Screen.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;genre&quot;</span><span class="punctuation">:</span><span class="string">&quot;Comedy&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;duration&quot;</span><span class="punctuation">:</span><span class="string">&quot;10 minutes&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;Sintel&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;A lonely young woman, Sintel, helps and befriends a dragon, whom she calls Scales. But when he is kidnapped by an adult dragon, Sintel decides to embark on a dangerous quest to find her lost friend Scales.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;videoUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;thumbnailUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://uhdtv.io/wp-content/uploads/2020/10/Sintel-3.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;genre&quot;</span><span class="punctuation">:</span><span class="string">&quot;Adventure&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;duration&quot;</span><span class="punctuation">:</span><span class="string">&quot;15 minutes&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;Tears of Steel&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;In an apocalyptic future, a group of soldiers and scientists takes refuge in Amsterdam to try to stop an army of robots that threatens the planet.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;videoUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/TearsOfSteel.mp4&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;thumbnailUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;https://mango.blender.org/wp-content/uploads/2013/05/01_thom_celia_bridge.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;genre&quot;</span><span class="punctuation">:</span><span class="string">&quot;Action&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;duration&quot;</span><span class="punctuation">:</span><span class="string">&quot;12 minutes&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;Elephant&#x27;s Dream&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;Friends Proog and Emo journey inside the folds of a seemingly infinite Machine, exploring the dark and twisted complex of wires, gears, and cogs, until a moment of conflict negates all their assumptions.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;videoUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;thumbnailUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;https://download.blender.org/ED/cover.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;genre&quot;</span><span class="punctuation">:</span><span class="string">&quot;Sci-Fi&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;duration&quot;</span><span class="punctuation">:</span><span class="string">&quot;15 minutes&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></p>
<p>上述json文件中的数据格式和<code>schema.prisma</code>中的movies数据类型中定义的内容相同，除了缺少由mongodb产生的id。在mongodb网站中选择database-browse collections-movie-insert document，将json文件中的内容粘贴进去即可。现在就完成了对数据模型movie的修改。</p>
<p>现在创建一条新的路径：<code>random</code>。在<code>pages/api/random.ts</code>中写下以下的代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// random movie will be loaded every time we refresh the page</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextApiRequest</span>, <span class="title class_">NextApiResponse</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> prismadb <span class="keyword">from</span> <span class="string">&#x27;@/lib/prismadb&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> serverAuth <span class="keyword">from</span> <span class="string">&quot;@/lib/serverAuth&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params">req: NextApiRequest, res: NextApiResponse</span>) &#123;</span><br><span class="line">    <span class="comment">// limit request method to GET</span></span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">method</span> !== <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">405</span>).<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try and catch block</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check if the user log in</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">serverAuth</span>(req);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> movieCount = <span class="keyword">await</span> prismadb.<span class="property">movie</span>.<span class="title function_">count</span>();</span><br><span class="line">        <span class="keyword">const</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * movieCount); <span class="comment">// a random integar</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> randomMovies = <span class="keyword">await</span> prismadb.<span class="property">movie</span>.<span class="title function_">findMany</span>(&#123;</span><br><span class="line">            <span class="attr">take</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">skip</span>: randomIndex</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(randomMovies[<span class="number">0</span>]); <span class="comment">// take only one movies</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">end</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>hooks/useBillboard.ts</code>中写下以下的代码，避免对首页推荐电影的重复加载：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useSWR <span class="keyword">from</span> <span class="string">&quot;swr&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fetcher <span class="keyword">from</span> <span class="string">&quot;@/lib/fetcher&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useBillboard</span> =(<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data, error, isLoading &#125; = <span class="title function_">useSWR</span>(<span class="string">&#x27;/api/random&#x27;</span>, fetcher, &#123;</span><br><span class="line">        <span class="comment">// static data only load once the user visits the page</span></span><br><span class="line">        <span class="comment">// not every time they lose focus out of the window</span></span><br><span class="line">        <span class="attr">revalidateIfStale</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">revalidateOnFocus</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">revalidateOnReconnect</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        data,</span><br><span class="line">        error,</span><br><span class="line">        isLoading,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useBillboard;</span><br></pre></td></tr></table></figure></p>
<p>在<code>components</code>中新建<code>Billboard.tsx</code>，并在其中搭建一个骨架：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Billboard</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Billboard</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后在<code>index.tsx</code>中引入<code>Billboard</code>。接着在<code>Billboard.tsx</code>中填入具体的内容，目的是fetch the data for a random movie。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useBillboard <span class="keyword">from</span> <span class="string">&quot;@/hooks/useBillboard&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Billboard</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="title function_">useBillboard</span>();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Billboard</span>;</span><br></pre></td></tr></table></figure></p>
<p>可以打开网页的调试界面：network-random-preview，就可以看到随机选择的电影的信息。接着继续写<code>Billboard.tsx</code>，在Billboard中添加随机的电影、电影名、电影介绍和More info按钮：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useBillboard <span class="keyword">from</span> <span class="string">&quot;@/hooks/useBillboard&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AiOutlineInfoCircle</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-icons/ai&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Billboard</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="title function_">useBillboard</span>();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;relative h-[56.25vw]&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">video</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    w-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    h-[56.25vw]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    object-cover</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    brightness-[60%]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">autoPlay</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">muted</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">loop</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">poster</span>=<span class="string">&#123;data?.thumbnailUrl&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">src</span>=<span class="string">&#123;data?.videoUrl&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;absolute top-[30%] md:top-[40%] ml-4 md:ml-16&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    text-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    text-1xl </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    md:text-5xl </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    h-full </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    w-[50%] </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    lg:text-6xl </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    font-bold </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    drop-shadow-xl</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    &quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;data?.title&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    text-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    text-[8px]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    md:text-lg</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    mt-3</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    md:mt-8</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    w-[90%]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    md:w-[80%]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    lg:w-[50%]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    drop-shadow-xl</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                &quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;data?.description&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-row items-center mt-3 md:mt-4 gap-3&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            bg-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            text-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            bg-opacity-30</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            rounded-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            py-1 md:py-2</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            px-2 md:px-4</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            w-auto</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            text-xs lg:text-lg</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            font-semibold</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            flex</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            flex-row</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            items-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            hover:bg-opacity-20</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            transition</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                        &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    &gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">AiOutlineInfoCircle</span> <span class="attr">className</span>=<span class="string">&quot;mr-1&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                        More Info</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Billboard</span>;</span><br></pre></td></tr></table></figure></p>
<p>本节到此结束，效果图如下所示：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-02-27_04-40-46.png?raw=true" alt="Snipaste_2024-02-27_04-40-46.png"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>await和async的区别和联系：在TypeScript中，<code>async</code>和<code>await</code>关键字一起使用，作为处理异步操作的一种方式，主要用于替代传统的回调函数和Promise。它们两者之间有着明确的区别和各自的用途：</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><ul>
<li><code>async</code>关键字用于声明一个异步函数，它让函数自动返回一个Promise。这意味着，当你在一个函数声明前加上<code>async</code>，这个函数就会返回一个Promise，而不是直接返回值。</li>
<li>使用<code>async</code>，你可以在函数内部使用<code>await</code>表达式。</li>
<li><code>async</code>函数可以包含零个或多个<code>await</code>表达式。</li>
</ul>
<p>例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 函数返回一个Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;data&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>fetchData</code>函数返回一个解析为字符串”data”的Promise。</p>
<h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><ul>
<li><code>await</code>关键字用于等待一个Promise解析，它只能在<code>async</code>函数内部使用。</li>
<li>当<code>await</code>前面的Promise被解析后，函数执行会继续，<code>await</code>表达式的结果就是Promise解析的值。</li>
<li>使用<code>await</code>可以让异步代码看起来像是同步代码，这使得代码更容易理解和维护。</li>
</ul>
<p>例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">showData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetchData</span>(); <span class="comment">// 等待fetchData解析</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>showData</code>函数内部调用了<code>fetchData</code>函数，并在其Promise解析之后继续执行，打印出解析后的数据。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>async</code>是一个使函数返回Promise的修饰符，而<code>await</code>是用于等待Promise解析的操作符。</li>
<li><code>await</code>只能在<code>async</code>函数内部使用。</li>
<li>它们一起使用提供了一种更简洁和直观的方式来处理JavaScript中的异步操作，避免了回调地狱（Callback Hell）的问题。</li>
</ul>
<h2 id="Movie-List-amp-Movie-Card-Components-Movies-Endpoint-Cool-hover-effect"><a href="#Movie-List-amp-Movie-Card-Components-Movies-Endpoint-Cool-hover-effect" class="headerlink" title="Movie List &amp; Movie Card Components, Movies Endpoint, Cool hover effect"></a>Movie List &amp; Movie Card Components, Movies Endpoint, Cool hover effect</h2><p>在pages/api中创建一个新的movies文件夹。在其中创建<code>index.ts</code>，并在其中写入这个api的具体内容：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextApiRequest</span>, <span class="title class_">NextApiResponse</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> prismadb <span class="keyword">from</span> <span class="string">&#x27;@/lib/prismadb&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> serverAuth <span class="keyword">from</span> <span class="string">&#x27;@/lib/serverAuth&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params">req: NextApiRequest, res: NextApiResponse</span>) &#123;</span><br><span class="line">    <span class="comment">// this api call only get request method</span></span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">method</span> !== <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">405</span>).<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try and catch block</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">serverAuth</span>(req); <span class="comment">// authenticate this route</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// load all the movies</span></span><br><span class="line">        <span class="keyword">const</span> movies = <span class="keyword">await</span> prismadb.<span class="property">movie</span>.<span class="title function_">findMany</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(movies);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">end</span>();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着再创建一个hook。在hook文件夹中创建<code>useMovieList.ts</code>。并写入以下代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useSWR <span class="keyword">from</span> <span class="string">&quot;swr&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> fetcher <span class="keyword">from</span> <span class="string">&quot;@/lib/fetcher&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useMovieList</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data, error, isLoading &#125;  = <span class="title function_">useSWR</span>(<span class="string">&#x27;api/movies&#x27;</span>, fetcher, &#123;</span><br><span class="line">        <span class="comment">// 不需要重新验证</span></span><br><span class="line">        <span class="attr">revalidateIfStale</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">revalidateOnFocus</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">revalidateOnReconnect</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        data,</span><br><span class="line">        error,</span><br><span class="line">        isLoading</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useMovieList;</span><br></pre></td></tr></table></figure></p>
<p>接着进入<code>pages/index.tsx</code>，加入以下代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;pb-40&quot;</span>&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">MovieList</span> /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>由于我们有多个MovieList，因此需要将MovieList包裹在div中。接着我们创建MovieList。在<code>components</code>中创建<code>MovieList.tsx</code>，并在其中搭建一个骨架：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MovieList</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MovieList</span>;</span><br></pre></td></tr></table></figure></p>
<p>接着丰满其中的细节：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; isEmpty &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MovieListProps</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;[]; <span class="comment">// type: array</span></span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MovieList</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">MovieListProps</span>&gt; = <span class="function">(<span class="params">&#123; data, title &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do not render empty data</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEmpty</span>(data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;px-4 md:px-12 mt-4 space-y-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-md md:text-xl lg:text-2xl font-semibold mb-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;title&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;grid grid-cols-4 gap-2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;data.map((movie) =&gt; (</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;movie.id&#125;</span>&gt;</span>movie<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    ))&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MovieList</span>;</span><br></pre></td></tr></table></figure></p>
<p>记得安装必要的库：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install lodash</span><br><span class="line">npm install -D @types/lodash</span><br></pre></td></tr></table></figure></p>
<p>接着在<code>pages/index.tsx</code>中给<code>MovieList</code>传入必要的参数：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">data</span>: movies = [] &#125; = <span class="title function_">useMovieList</span>(); <span class="comment">// use the newly created hook</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;pb-40&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">MovieList</span> <span class="attr">title</span>=<span class="string">&quot;Trending Now&quot;</span> <span class="attr">data</span>=<span class="string">&#123;movies&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>产生了如下效果：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-02-28_23-51-30.png?raw=true" alt="Snipaste_2024-02-28_23-51-30.png"></p>
<p>现在将黑色的movies小字转换成实际的电影，并用上炫酷的Tailwind hover效果。在<code>MovieList.tsx</code>中加入下面的代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">MovieCard</span> key=&#123;movie.<span class="property">id</span>&#125; data=&#123;movie&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>接着在<code>components</code>文件夹中创建<code>MovieCard.tsx</code>文件。填入以下的骨架：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MovieCardProps</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MovieCard</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">MovieCardProps</span>&gt; = <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    data</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MovieCard</span>;</span><br></pre></td></tr></table></figure></p>
<p>接着继续丰满上述代码的细节：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BsFillPlayFill</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-icons/bs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MovieCardProps</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MovieCard</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">MovieCardProps</span>&gt; = <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    data</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;group bg-zinc-900 col-span relative h-[12vw]&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">img</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            cursor-pointer</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            object-cover</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            transition</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            duration</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            shadow-xl</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            rounded-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            group-hover:opacity-90</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            sm:group-hover:opacity-0</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            delay-300</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            w-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            h-[12vw]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">src</span>=<span class="string">&#123;data.thumbnailUrl&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;Thumbnail&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    opacity-0</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    absolute</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    top-0</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    transition</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    duration-200</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    z-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    invisible</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    sm:visible</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    delay-300</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    w-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    scale-0</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    group-hover:scale-110</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    group-hover:-translate-y-[6vw]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    group-hover:translate-x-[2vw]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    group-hover:opacity-100</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">img</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    cursor-pointer</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    object-cover</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    transition</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    duration</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    shadow-xl</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    rounded-t-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    w-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    h-[12vw]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">src</span>=<span class="string">&#123;data.thumbnailUrl&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;Thumbnail&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                        z-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                        bg-zinc-800</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                        p-2</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                        lg:p-4</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                        absolute</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                        w-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                        transition</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                        shadow-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                        rounded-b-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                &gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-row items-center gap-3&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            cursor-pointer</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            w-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            h-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            lg:w-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            lg:h-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            bg-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            rounded-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            flex</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            justify-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            items-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            transition</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            hover:bg-neutral-300</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                            &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;&#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">BsFillPlayFill</span> <span class="attr">size</span>=<span class="string">&#123;30&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-green-400 font-semibold mt-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        New <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;text-white&quot;</span>&gt;</span>2024<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-row mt-4 gap-2 items-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-[10px] lg:text-sm&quot;</span>&gt;</span>&#123;data.duration&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-row mt-4 gap-2 items-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-[10px] lg:text-sm&quot;</span>&gt;</span>&#123;data.genre&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MovieCard</span>;</span><br></pre></td></tr></table></figure></p>
<p>最后实现的效果图如下所示：</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-02-29_02-48-28.png?raw=true" alt="Snipaste_2024-02-29_02-48-28.png"></p>
<h2 id="Favourites-My-List-functionality"><a href="#Favourites-My-List-functionality" class="headerlink" title="Favourites / My List functionality"></a>Favourites / My List functionality</h2><p>本节我们将实现favourite按钮，其在播放按钮的旁边。我们还将在Trending List下面实现My List，其中将只展示我们favourite的电影。在<code>pages/api/favorite.ts</code>中写下以下的代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// can handle both post request and delete request</span></span><br><span class="line"><span class="comment">// api to add and remove favourite ID in our list</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextApiRequest</span>, <span class="title class_">NextApiResponse</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; without &#125; <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> prismadb <span class="keyword">from</span> <span class="string">&#x27;@/lib/prismadb&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> serverAuth <span class="keyword">from</span> <span class="string">&quot;@/lib/serverAuth&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params">req: NextApiRequest, res: NextApiResponse</span>) &#123;</span><br><span class="line">    <span class="comment">// try and catch block</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// handle post request</span></span><br><span class="line">        <span class="keyword">if</span> (req.<span class="property">method</span> === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; currentUser &#125; = <span class="keyword">await</span> <span class="title function_">serverAuth</span>(req); <span class="comment">// get curent user</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123; movieId &#125; = req.<span class="property">body</span>; <span class="comment">// get movieId</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// check if the movieId is correct</span></span><br><span class="line">            <span class="keyword">const</span> existingMovie = <span class="keyword">await</span> prismadb.<span class="property">movie</span>.<span class="title function_">findUnique</span>(&#123;</span><br><span class="line">                <span class="attr">where</span>: &#123;</span><br><span class="line">                    <span class="attr">id</span>: movieId,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!existingMovie) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid ID&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update user and push movieId to their favoriteIds defined in schema.prisma</span></span><br><span class="line">            <span class="keyword">const</span> user = <span class="keyword">await</span> prismadb.<span class="property">user</span>.<span class="title function_">update</span>(&#123;</span><br><span class="line">                <span class="attr">where</span>: &#123;</span><br><span class="line">                    <span class="attr">email</span>: currentUser.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">data</span>: &#123;</span><br><span class="line">                    <span class="attr">favoriteIds</span>: &#123;</span><br><span class="line">                        <span class="attr">push</span>: movieId,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// handle delete request when a user want to unfavorite a movie</span></span><br><span class="line">        <span class="keyword">if</span> (req.<span class="property">method</span> === <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; currentUser &#125; = <span class="keyword">await</span> <span class="title function_">serverAuth</span>(req);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123; movieId &#125; = req.<span class="property">body</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> existingMovie = <span class="keyword">await</span> prismadb.<span class="property">movie</span>.<span class="title function_">findUnique</span>(&#123;</span><br><span class="line">                <span class="attr">where</span>: &#123;</span><br><span class="line">                    <span class="attr">id</span>: movieId,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!existingMovie) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid ID&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// a list of our current favorite IDs without the above movie id</span></span><br><span class="line">            <span class="keyword">const</span> updateFavoriteIds = <span class="title function_">without</span>(currentUser.<span class="property">favoriteIds</span>, movieId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update User information</span></span><br><span class="line">            <span class="keyword">const</span> updatedUser = <span class="keyword">await</span> prismadb.<span class="property">user</span>.<span class="title function_">update</span>(&#123;</span><br><span class="line">                <span class="attr">where</span>: &#123;</span><br><span class="line">                    <span class="attr">email</span>: currentUser.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">data</span>: &#123;</span><br><span class="line">                    <span class="attr">favoriteIds</span>: updateFavoriteIds,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(updatedUser);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">405</span>).<span class="title function_">end</span>(); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来创建一个<code>api route</code>，其将只加载我们最喜欢的电影列表。在<code>pages/api/favorites.ts</code>，写下如下的代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fetch all of our favorite movies</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextApiRequest</span>, <span class="title class_">NextApiResponse</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> prismadb <span class="keyword">from</span> <span class="string">&#x27;@/lib/prismadb&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> serverAuth <span class="keyword">from</span> <span class="string">&quot;@/lib/serverAuth&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params">req:NextApiRequest, res: NextApiResponse</span>) &#123;</span><br><span class="line">    <span class="comment">// limit this route only to get method</span></span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">method</span> !== <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">405</span>).<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try and catch block</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; currentUser &#125; = <span class="keyword">await</span> <span class="title function_">serverAuth</span>(req);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find all movies which have a relation to current user favorite IDs</span></span><br><span class="line">        <span class="keyword">const</span>  favoriteMovies  = <span class="keyword">await</span> prismadb.<span class="property">movie</span>.<span class="title function_">findMany</span>(&#123;</span><br><span class="line">            <span class="attr">where</span>: &#123;</span><br><span class="line">                <span class="attr">id</span>: &#123;</span><br><span class="line">                    <span class="attr">in</span>: currentUser?.<span class="property">favoriteIds</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(favoriteMovies);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着再写一个hook，用于加载最喜欢的电影列表。在<code>hooks/useFavorites.ts</code>中写入以下的代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useSWR <span class="keyword">from</span> <span class="string">&quot;swr&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> fetcher <span class="keyword">from</span> <span class="string">&quot;@/lib/fetcher&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useFavorites</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data, error, isLoading, mutate &#125; = <span class="title function_">useSWR</span>(<span class="string">&#x27;/api/favorites&#x27;</span>, fetcher, &#123;</span><br><span class="line">        <span class="attr">revalidateIfStale</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">revalidateOnFocus</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">revalidateOnReconnect</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        data,</span><br><span class="line">        error,</span><br><span class="line">        isLoading,</span><br><span class="line">        mutate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useFavorites;</span><br></pre></td></tr></table></figure></p>
<p>再写一个组件：<code>components/FavoriteButton.tsx</code>，作为按钮：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useCallback, useMemo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useCurrentUser <span class="keyword">from</span> <span class="string">&quot;@/hooks/useCurrentUser&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useFavorites <span class="keyword">from</span> <span class="string">&quot;@/hooks/useFavorites&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">FavoriteButtonProps</span> &#123;</span><br><span class="line">    <span class="attr">movieId</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only one parameter: movieId</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FavoriteButton</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">FavoriteButtonProps</span>&gt; = <span class="function">(<span class="params">&#123; movieId &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">FavoriteButton</span>;</span><br></pre></td></tr></table></figure></p>
<p>将该按钮加在MovieCard中。在<code>components/MovieCard.tsx</code>中的播放按钮之后加入：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">FavoriteButton</span> movieId=&#123;data?.<span class="property">id</span>&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>补充知识：在JavaScript和TypeScript中，<code>?</code>操作符在这个上下文中被用作可选链（Optional Chaining）操作符。当你在一个对象后面加上<code>?</code>后跟属性名或方法，这意味着如果这个对象存在（即不是<code>null</code>或<code>undefined</code>），则会尝试访问该属性或方法；如果对象是<code>null</code>或<code>undefined</code>，则不会尝试访问该属性或方法，而是直接返回<code>undefined</code>。这避免了在访问深层嵌套对象属性时可能出现的类型错误。</p>
<p>接着写<code>components/FavoriteButton.tsx</code>：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useCallback, useMemo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AiOutlinePlus</span>  &#125; <span class="keyword">from</span> <span class="string">&quot;react-icons/ai&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useCurrentUser <span class="keyword">from</span> <span class="string">&quot;@/hooks/useCurrentUser&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useFavorites <span class="keyword">from</span> <span class="string">&quot;@/hooks/useFavorites&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">FavoriteButtonProps</span> &#123;</span><br><span class="line">    <span class="attr">movieId</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only one parameter: movieId</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FavoriteButton</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">FavoriteButtonProps</span>&gt; = <span class="function">(<span class="params">&#123; movieId &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            cursor-pointer</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            group/item</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            w-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            h-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            lg:w-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            lg:h-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            border-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            border-2</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            rounded-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            flex</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            justify-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            items-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            transition</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            hover:border-neutral-300</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        &quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">AiOutlinePlus</span> <span class="attr">className</span>=<span class="string">&quot;text-white&quot;</span> <span class="attr">size</span> =<span class="string">&#123;25&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">FavoriteButton</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后在Trending Now列表以外再创建一个My Favorites列表。进入<code>pages/index.tsx</code>中，增加以下的代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">data</span>: favorites = [] &#125; = <span class="title function_">useFavorites</span>(); <span class="comment">// use hook to get favorite movies</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MovieList</span> <span class="attr">title</span>=<span class="string">&quot;My List&quot;</span> <span class="attr">data</span>=<span class="string">&#123;favorites&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>由于目前还没有最喜欢的电影，因此My List为空。在<code>FavoriteButton.tsx</code>中添加以下代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">mutate</span>: mutateFavorites &#125; = <span class="title function_">useFavorites</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">data</span>: currentUser, mutate &#125; = <span class="title function_">useCurrentUser</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if the favorite list of current user includes movieId</span></span><br><span class="line"><span class="keyword">const</span> isFavorite = useMemo (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> list = currentUser?.<span class="property">favoriteIds</span> || [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list.<span class="title function_">include</span>(movieId);</span><br><span class="line">&#125;, [currentUser, movieId]); <span class="comment">// dependency in []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// once we click the favorite, we will check if the current movie is favorited</span></span><br><span class="line"><span class="comment">// if yes, trigger the delete request</span></span><br><span class="line"><span class="comment">// if no, add the movie in the favorite list</span></span><br><span class="line"><span class="keyword">const</span> toggleFavorites = <span class="title function_">useCallback</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> response;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFavorite) &#123;</span><br><span class="line">        response = <span class="keyword">await</span> axios.<span class="title function_">delete</span>(<span class="string">&#x27;/api/favorite&#x27;</span>, &#123; <span class="attr">data</span>: &#123; movieId &#125;&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;/api/favorite&#x27;</span>, &#123; movieId &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update the favorite list of current user</span></span><br><span class="line">    <span class="keyword">const</span> updatedFavoriteIds = response?.<span class="property">data</span>?.<span class="property">favoriteIds</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mutate用于更新currentUser数据</span></span><br><span class="line">    <span class="title function_">mutate</span>(&#123;</span><br><span class="line">        ...currentUser, <span class="comment">// 复制了currentUser对象中的所有属性到一个新对象中</span></span><br><span class="line">        <span class="comment">// 如果currentUser对象中已经存在favoriteIds属性，这一操作将会覆盖原有的值。如果不存在，就会添加一个新的favoriteIds属性</span></span><br><span class="line">        <span class="attr">favoriteIds</span>: updatedFavoriteIds,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">mutateFavorites</span>(); <span class="comment">// 来自useFavorites中的mutate，每次更新currentUser的favoriteIds的数据后，立即刷新</span></span><br><span class="line">&#125;, [movieId, isFavorite, currentUser, mutate, mutateFavorites]);</span><br></pre></td></tr></table></figure></p>
<p>实现了上述函数后，我们要让favorite按钮变得可交互。添加以下代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Icon</span> = isFavorite ? <span class="title class_">AiOutlineCheck</span> : <span class="title class_">AiOutlinePlus</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;toggleFavorites&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        cursor-pointer</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        group/item</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        w-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        h-6</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        lg:w-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        lg:h-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        border-white</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        border-2</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        rounded-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        flex</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        justify-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        items-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        transition</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        hover:border-neutral-300</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">    &quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">className</span>=<span class="string">&quot;text-white&quot;</span> <span class="attr">size</span> =<span class="string">&#123;25&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这样点击Trending Now列表上的电影上的加号时，其就会被添加到My List，然后加号会变成勾。这样一部电影就被选择为favorite了。同理，在My List中点击打勾符号，电影就会被取消选中，从My List里面消失。但目前该功能还是有bug。解决方法似乎是：<a href="https://github.com/nextauthjs/next-auth/issues/7199，需要将getSession替换为getServerSession。替换后问题得到了解决。">https://github.com/nextauthjs/next-auth/issues/7199，需要将getSession替换为getServerSession。替换后问题得到了解决。</a></p>
<p>详细解决步骤：在<code>[..nextauth].ts</code>中添加<code>AuthOptions</code>，然后在<code>serverAuth.ts</code>中使用getServerSession替换getSession，并给getServerSession传入三个参数：req, res, authOptions，最后在所有用到serverAuth的api中将<code>const &#123; currentUser &#125; = await serverAuth(req)</code>替换为<code>const &#123; currentUser &#125; = await serverAuth(req, res);</code>。即可以修复上述bug。</p>
<h2 id="Play-Button-Video-Player-Single-Movie-Endpoint"><a href="#Play-Button-Video-Player-Single-Movie-Endpoint" class="headerlink" title="Play Button, Video Player, Single Movie Endpoint"></a>Play Button, Video Player, Single Movie Endpoint</h2><p>在billboard中加入播放按钮。还要创建player route。</p>
<p>首先创建<code>pages/api/movies/[movieId].ts</code>，在其中写入代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextApiRequest</span>, <span class="title class_">NextApiResponse</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> prismadb <span class="keyword">from</span> <span class="string">&#x27;@/lib/prismadb&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> serverAuth <span class="keyword">from</span> <span class="string">&quot;@/lib/serverAuth&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params">req: NextApiRequest, res: NextApiResponse</span>) &#123;</span><br><span class="line">    <span class="comment">// limit to get request</span></span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">method</span> !== <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">405</span>).<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try and catch block</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">serverAuth</span>(req, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; movieId &#125; = req.<span class="property">query</span>; <span class="comment">// search for movie Id</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> movieId !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid ID&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!movieId) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid ID&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find movie using movieId</span></span><br><span class="line">        <span class="keyword">const</span> movie = <span class="keyword">await</span> prismadb.<span class="property">movie</span>.<span class="title function_">findUnique</span>(&#123;</span><br><span class="line">            <span class="attr">where</span>: &#123;</span><br><span class="line">                <span class="attr">id</span>: movieId</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!movie) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid ID&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(movie);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着创建一个hook。创建<code>hooks/useMovie.ts</code>，在其中写入代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useSWR <span class="keyword">from</span> <span class="string">&quot;swr&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> fetcher <span class="keyword">from</span> <span class="string">&quot;@/lib/fetcher&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parameter: id，该id会被/api/movies/[movieId].ts中的[movieId]解析</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useMovie</span> = (<span class="params">id?: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; </span><br><span class="line">        data, </span><br><span class="line">        error, </span><br><span class="line">        isLoading </span><br><span class="line">    &#125; = <span class="title function_">useSWR</span>(id ? <span class="string">`/api/movies/<span class="subst">$&#123;id&#125;</span>`</span> : <span class="literal">null</span>, fetcher, &#123;</span><br><span class="line">        <span class="attr">revalidateIfStale</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">revalidateOnFocus</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">revalidateOnReconnect</span>: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        data,</span><br><span class="line">        error,</span><br><span class="line">        isLoading,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useMovie;</span><br></pre></td></tr></table></figure></p>
<p>接着创建一个play按钮的component。创建<code>components/PlayButton.tsx</code>，在其中写入骨架：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BsFillPlayFill</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-icons/bs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PlayButtonProps</span> &#123;</span><br><span class="line">    <span class="attr">movieId</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PlayButton</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">PlayButtonProps</span>&gt; = <span class="function">(<span class="params">&#123; movieId &#125;</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="title function_">useRouter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PlayButton</span>;</span><br></pre></td></tr></table></figure></p>
<p>接着在<code>components/Billboard.tsx</code>中加入上述组件。在写有more info字样的按钮前加入：<code>&lt;PlayButton movieId=&#123;data?.id&#125; /&gt;</code>。接着继续丰满<code>components/PlayButton.tsx</code>中的细节：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BsFillPlayFill</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-icons/bs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PlayButtonProps</span> &#123;</span><br><span class="line">    <span class="attr">movieId</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PlayButton</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">PlayButtonProps</span>&gt; = <span class="function">(<span class="params">&#123; movieId &#125;</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="title function_">useRouter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> router.push(`/watch/$&#123;movieId&#125;`)&#125;</span></span><br><span class="line"><span class="language-xml">            className=&quot;</span></span><br><span class="line"><span class="language-xml">                bg-white</span></span><br><span class="line"><span class="language-xml">                rounded-md</span></span><br><span class="line"><span class="language-xml">                py-1 md:py-2</span></span><br><span class="line"><span class="language-xml">                px-2 md:px-4</span></span><br><span class="line"><span class="language-xml">                w-auto</span></span><br><span class="line"><span class="language-xml">                text-xs lg:text-lg</span></span><br><span class="line"><span class="language-xml">                font-semibold</span></span><br><span class="line"><span class="language-xml">                flex</span></span><br><span class="line"><span class="language-xml">                flex-row</span></span><br><span class="line"><span class="language-xml">                items-center</span></span><br><span class="line"><span class="language-xml">                hover:bg-neutral-300</span></span><br><span class="line"><span class="language-xml">                transition</span></span><br><span class="line"><span class="language-xml">            &quot;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">BsFillPlayFill</span> <span class="attr">size</span>=<span class="string">&#123;25&#125;</span> <span class="attr">className</span>=<span class="string">&quot;mr-1&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            Play</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PlayButton</span>;</span><br></pre></td></tr></table></figure></p>
<p>现在就实现了点击播放按钮，跳转到另一个页面。接着在MovieCard组件中也实现上述点击播放然后跳转的功能。进入<code>components/MovieCard.tsx</code>，在其中添加代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>();</span><br><span class="line">onClick=&#123;<span class="function">() =&gt;</span> router.<span class="title function_">push</span>(<span class="string">`/watch/<span class="subst">$&#123;data?.id&#125;</span>`</span>)&#125;&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在需要具体写跳转到的页面。开始写<code>/watch</code>页面。创建<code>pages/watch/[movieId].tsx</code>，在其中写入以下的骨架：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// outside of api folder, so this is a client route</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useMovie <span class="keyword">from</span> <span class="string">&quot;@/hooks/useMovie&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;next/router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Watch</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="title function_">useRouter</span>();</span><br><span class="line">    <span class="keyword">const</span> &#123; movieId &#125; = router.<span class="property">query</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="title function_">useMovie</span>(movieId <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Watch</span>;</span><br></pre></td></tr></table></figure></p>
<p>现在点击播放按钮，会跳转到一个空白页面。继续丰满上述代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// outside of api folder, so this is a client route</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AiOutlineArrowLeft</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-icons/ai&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useMovie <span class="keyword">from</span> <span class="string">&quot;@/hooks/useMovie&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;next/router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Watch</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="title function_">useRouter</span>();</span><br><span class="line">    <span class="keyword">const</span> &#123; movieId &#125; = router.<span class="property">query</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="title function_">useMovie</span>(movieId <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;h-screen w-screnn bg-black&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">nav</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    fixed</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    w-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    p-4</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    z-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    flex-row</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    items-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    gap-8</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    bg-black</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    bg-opacity-70</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">AiOutlineArrowLeft</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> router.push(&#x27;/&#x27;)&#125; className=&quot;text-white cursor-pointer&quot; size=&#123;40&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-1xl md:text-3xl font-bold&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;font-light&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        Watching:</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;data?.title&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">video</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">autoPlay</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">controls</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&quot;h-full w-full&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">src</span>=<span class="string">&#123;data?.videoUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Watch</span>;</span><br></pre></td></tr></table></figure></p>
<p>现在就实现了功能：点击播放按钮，跳转到播放视频的页面，播放视频的页面会自动加载视频的名字，并有一个返回按钮，点击之可以返回到homepage。播放视频的页面中的视频可以播放、暂停、拖动时间条。</p>
<h2 id="Info-Modal-Component"><a href="#Info-Modal-Component" class="headerlink" title="Info Modal Component"></a>Info Modal Component</h2><p>点击More Info按钮，会显示电影的信息。在Treanding Now下面会加一个展开按钮，会展开电影相关的信息。</p>
<p>创建<code>hooks/useInfoModel.ts</code>，并通过命令<code>npm install zustand</code>安装新的库。<code>zustand</code>是一个轻量化的全局状态管理库。在<code>useInfoModel.ts</code>中写入以下的代码：<br><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; create &#125; <span class="keyword">from</span> <span class="string">&quot;zustand&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ModalStoreInterface</span> &#123;</span><br><span class="line">    movieId?: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">isOpen</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">openModal</span>: <span class="function">(<span class="params">movieId: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    <span class="attr">closeModal</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook</span></span><br><span class="line"><span class="keyword">const</span> useInfoModal = create&lt;<span class="title class_">ModalStoreInterface</span>&gt;(<span class="function">(<span class="params">set</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">movieId</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">isOpen</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">openModal</span>: <span class="function">(<span class="params">movieId: <span class="built_in">string</span></span>) =&gt;</span> <span class="title function_">set</span>(&#123; <span class="attr">isOpen</span>: <span class="literal">true</span>, movieId &#125;),</span><br><span class="line">    <span class="attr">closeModal</span>: <span class="function">() =&gt;</span> <span class="title function_">set</span>(&#123; <span class="attr">isOpen</span>: <span class="literal">false</span>, <span class="attr">movieId</span>: <span class="literal">undefined</span>&#125;),</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useInfoModal;</span><br></pre></td></tr></table></figure></p>
<p>创建<code>components/InfoModal.tsx</code>，写入以下的代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useCallback, useEffect, useState&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AiOutlineClose</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-icons/ai&quot;</span>; <span class="comment">// close Button</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PlayButton</span> <span class="keyword">from</span> <span class="string">&quot;./PlayButton&quot;</span>; <span class="comment">// PlayButton</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FavoriteButton</span> <span class="keyword">from</span> <span class="string">&quot;./FavoriteButton&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useInfoModal <span class="keyword">from</span> <span class="string">&quot;@/hooks/useInfoModal&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useMovie <span class="keyword">from</span> <span class="string">&quot;@/hooks/useMovie&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InfoModalProps</span> &#123;</span><br><span class="line">    visible?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">onClose</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InfoModal</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">InfoModalProps</span>&gt; = <span class="function">(<span class="params">&#123; visible, onClose &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// a state for visible, visible is boolean so !! before it</span></span><br><span class="line">    <span class="keyword">const</span> [isVisible, setIsVisible] = <span class="title function_">useState</span>(!!visible);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fetch moveId</span></span><br><span class="line">    <span class="keyword">const</span> &#123; movieId &#125; = <span class="title function_">useInfoModal</span>();</span><br><span class="line">    <span class="comment">// fetch data from movie</span></span><br><span class="line">    <span class="keyword">const</span> &#123; data = &#123;&#125; &#125; = <span class="title function_">useMovie</span>(movieId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use Effect</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setIsVisible</span>(!!visible); <span class="comment">// set visible on every new visible change that we get</span></span><br><span class="line">    &#125;, [visible]); <span class="comment">// visible in dependency</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleClose = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setIsVisible</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// a cool animation</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">onClose</span>();</span><br><span class="line">        &#125;, <span class="number">300</span>); <span class="comment">// 300 ms </span></span><br><span class="line">    &#125;, [onClose]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!visible) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">InfoModal</span>;</span><br></pre></td></tr></table></figure></p>
<p>在<code>pages/index.tsx</code>中加入<code>InfoModal</code>：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">InfoModal</span> <span class="keyword">from</span> <span class="string">&quot;@/components/InfoModal&quot;</span>;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">InfoModal</span> <span class="attr">visible</span> <span class="attr">onClose</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;&#125;&#125; /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来继续丰满<code>InfoModal.tsx</code>：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useCallback, useEffect, useState&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AiOutlineClose</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-icons/ai&quot;</span>; <span class="comment">// close Button</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PlayButton</span> <span class="keyword">from</span> <span class="string">&quot;./PlayButton&quot;</span>; <span class="comment">// PlayButton</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FavoriteButton</span> <span class="keyword">from</span> <span class="string">&quot;./FavoriteButton&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useInfoModal <span class="keyword">from</span> <span class="string">&quot;@/hooks/useInfoModal&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useMovie <span class="keyword">from</span> <span class="string">&quot;@/hooks/useMovie&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InfoModalProps</span> &#123;</span><br><span class="line">    visible?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">onClose</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InfoModal</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">InfoModalProps</span>&gt; = <span class="function">(<span class="params">&#123; visible, onClose &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// a state for visible, visible is boolean so !! before it</span></span><br><span class="line">    <span class="keyword">const</span> [isVisible, setIsVisible] = <span class="title function_">useState</span>(!!visible);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fetch moveId</span></span><br><span class="line">    <span class="keyword">const</span> &#123; movieId &#125; = <span class="title function_">useInfoModal</span>();</span><br><span class="line">    <span class="comment">// fetch data from movie</span></span><br><span class="line">    <span class="keyword">const</span> &#123; data = &#123;&#125; &#125; = <span class="title function_">useMovie</span>(movieId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use Effect</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setIsVisible</span>(!!visible); <span class="comment">// set visible on every new visible change that we get</span></span><br><span class="line">    &#125;, [visible]); <span class="comment">// visible in dependency</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleClose = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setIsVisible</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// a cool animation</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">onClose</span>();</span><br><span class="line">        &#125;, <span class="number">300</span>); <span class="comment">// 300 ms </span></span><br><span class="line">    &#125;, [onClose]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!visible) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                z-50</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                transition</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                duration-300</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                bg-black</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                bg-opacity-80</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                flex</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                justify-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                items-center</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                overflow-x-hidden</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                overflow-y-auto</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                fixed</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                inset-0</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    relative</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    w-auto</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    mx-auto</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    max-w-3xl</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    rounded-md</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                    overflow-hidden</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">className</span>=<span class="string">&#123;</span>`</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        $&#123;<span class="attr">isVisible</span> ? &#x27;<span class="attr">scale-100</span>&#x27;<span class="attr">:</span> &#x27;<span class="attr">scale-0</span>&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">transform</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">duration-300</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">relative</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">flex-auto</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">bg-zinc-900</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">drop-shadow-md</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    `&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;relative h-96&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">video</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                                <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                    w-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                    brightness-[60%]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                    object-cover</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                    h-full</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                                &quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                                <span class="attr">autoPlay</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                                <span class="attr">muted</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                                <span class="attr">loop</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                                <span class="attr">poster</span>=<span class="string">&#123;data?.thumbnailUrl&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                                <span class="attr">src</span>=<span class="string">&#123;data?.videoUrl&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            &gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">InfoModal</span>;</span><br></pre></td></tr></table></figure></p>
<p>产生了如下的效果：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-03-05_06-42-52.png?raw=true" alt="Snipaste_2024-03-05_06-42-52.png"></p>
<p>接下来再给上面的黑色方框加上一个关闭按钮，并添加播放按钮和收藏按钮。在<code>InfoModal.tsx</code>中添加以下代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;div </span><br><span class="line">className=<span class="string">&quot;</span></span><br><span class="line"><span class="string">    cursor-pointer</span></span><br><span class="line"><span class="string">    absolute</span></span><br><span class="line"><span class="string">    top-3</span></span><br><span class="line"><span class="string">    right-3</span></span><br><span class="line"><span class="string">    h-10</span></span><br><span class="line"><span class="string">    w-10</span></span><br><span class="line"><span class="string">    rounded-full</span></span><br><span class="line"><span class="string">    bg-black</span></span><br><span class="line"><span class="string">    bg-opacity-70</span></span><br><span class="line"><span class="string">    flex</span></span><br><span class="line"><span class="string">    items-center</span></span><br><span class="line"><span class="string">    justify-center</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">onClick=&#123;<span class="function">() =&gt;</span> &#123;&#125;&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">AiOutlineClose</span> <span class="attr">className</span>=<span class="string">&quot;text-white&quot;</span> <span class="attr">size</span>=<span class="string">&#123;20&#125;</span> /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">    absolute</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">    bottom-[10%]</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">    left-10</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-3xl md:text-4xl h-full lg:text-5xl font-bold mb-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;data?.title&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-row gap-4 items-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">PlayButton</span> <span class="attr">movieId</span>=<span class="string">&#123;data?.id&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">FavoriteButton</span> <span class="attr">movieId</span>=<span class="string">&#123;data?.id&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>最后再加上New字样和电影的各类信息：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;px-12 py-8&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-green-400 font-semibold text-lg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        New</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-lg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;data?.duration&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-lg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;data?.genre&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-lg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;data?.description&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>并加上点击关闭按钮实现关闭页面的功能，即在<code>onClick</code>函数中调用<code>handleClose</code>即可：<code>onClick=&#123;handleClose&#125;&gt;</code></p>
<p>然后在<code>pages/index.tsx</code>中实现对上述模块<code>InfoModal.tsx</code>的触发。<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; isOpen, closeModal &#125; = <span class="title function_">useInfoModal</span>(); <span class="comment">// use useInfoModal hook to trigger InfoModal </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">InfoModal</span> <span class="attr">visible</span>=<span class="string">&#123;isOpen&#125;</span> <span class="attr">onClose</span>=<span class="string">&#123;closeModal&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>现在需要实现在<code>billboard</code>中点击More Info按钮展现上述的<code>Info Modal</code>组件的功能。进入<code>components/Billboard.tsx</code>中，写入以下的代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; openModal &#125; = <span class="title function_">useInfoModal</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleOpenModal = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">openModal</span>(data?.<span class="property">id</span>);</span><br><span class="line">&#125;, [openModal, data?.<span class="property">id</span>]);</span><br><span class="line"></span><br><span class="line">onClick=&#123;handleOpenModal&#125;</span><br></pre></td></tr></table></figure></p>
<p>在电影卡片中再插入一个按钮。使得点击该按钮，可以展现影片的详细信息，在<code>components/MovieCard.tsx</code>中加入以下的代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; openModal &#125; = <span class="title function_">useInfoModal</span>();</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> openModal(data?.id)&#125;</span></span><br><span class="line"><span class="language-xml">    className=&quot;</span></span><br><span class="line"><span class="language-xml">        cursor-pointer </span></span><br><span class="line"><span class="language-xml">        ml-auto </span></span><br><span class="line"><span class="language-xml">        group/item </span></span><br><span class="line"><span class="language-xml">        w-6 </span></span><br><span class="line"><span class="language-xml">        h-6 </span></span><br><span class="line"><span class="language-xml">        lg:w-10 </span></span><br><span class="line"><span class="language-xml">        lg:h-10 </span></span><br><span class="line"><span class="language-xml">        border-white </span></span><br><span class="line"><span class="language-xml">        border-2 </span></span><br><span class="line"><span class="language-xml">        rounded-full </span></span><br><span class="line"><span class="language-xml">        flex </span></span><br><span class="line"><span class="language-xml">        justify-center </span></span><br><span class="line"><span class="language-xml">        items-center </span></span><br><span class="line"><span class="language-xml">        transition </span></span><br><span class="line"><span class="language-xml">        hover:border-neutral-300&quot;&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">BiChevronDown</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">size</span>=<span class="string">&#123;30&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">className</span>=<span class="string">&quot;text-white group-hover/item:text-neutral-300&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样，点击电影卡片上的向下的箭头，就会显示出影片的详细信息。调用我们在本节实现的<code>useInfoModal</code>这个hook即可轻松地实现上述功能。</p>
<p>现在继续修复个人profile中名字始终加载为username的问题。将username改为用户实际的名字。进入<code>components/AccountMenu.tsx</code>中，修改以下的代码：<br><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data &#125; = <span class="title function_">useCurrentUser</span>();</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text-white text-sm group-hover/item:underline&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;data?.name&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>即可在个人profile中加载出实际的用户名。</p>
<h2 id="Vercel-Deployment"><a href="#Vercel-Deployment" class="headerlink" title="Vercel Deployment"></a>Vercel Deployment</h2><p>可以同时复制并粘贴多行命令，命令行会自动逐一执行这些命令。要想在vercel上部署，要确保没有warning。要解决所有warning，只需要在<code>.eslintrc.json</code>中加入代码：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;@next/next/no-img-element&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>然后在命令行中输入：<code>npm run lint</code>，即可得到：<code>No ESLint warnings or errors</code>。此时所有warning就都被消去了。</p>
<p>注册vercel时，注意用github账号注册vercel，否则需要将账号绑定到github。进入vercel，点击add new，选中想要导入的github仓库，点击import，在configure project页面添加一些environment variables，即将原本项目中.env文件中的各个环境变量（除去NEXTAUTH_URL外）填入即可。</p>
<p>然后点击deploy即可。部署大概需要两三分钟的时间。部署以后，就可以直接通过域名访问我们的项目的网页。我发现要在本地启动项目，即运行命令：<code>npm run dev</code>，才能实现正常的登录功能。尚不清楚为什么，按理来说部署到云平台后就本地的服务就不需要启动了。</p>
<p>目前该问题依然无法解决，而且似乎部署在vercel上的项目无法正常进行google/github oauth验证登录，尚不明白原因，但不再浪费时间去尝试。至少本项目在本地是能够成功运行的，我将本地的项目回滚到了<a href="https://github.com/yfchenkeepgoing/Netflix_clone/commit/5b14e5cd38afa0d138759bf1b9cce77530761cb3">fix prisma error when deploying</a>的版本。通过链接：<a href="http://localhost:33350可以正常进行oauth登录，注册和邮箱密码登录。">http://localhost:33350可以正常进行oauth登录，注册和邮箱密码登录。</a></p>
<p>尝试在vercel上重新部署本应用，现在发现账号密码登录和github oauth登录都可以正常使用了（不需要在本地启动项目，项目直接在vercel上运行），但google oauth还是无法正常运行，我猜测是账号邮箱重复的问题，可以在数据库中查看并验证我的猜测。实际上应该不是账号邮箱重复的问题，就是哪一步配置不对或者网站抽风，不管了。</p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>Frontend</tag>
        <tag>React</tag>
        <tag>Tailwind CSS</tag>
        <tag>Next.JS</tag>
        <tag>Prisma</tag>
        <tag>MongoDB</tag>
        <tag>NextAuth</tag>
        <tag>Vercel</tag>
      </tags>
  </entry>
  <entry>
    <title>How to use Typora</title>
    <url>/2024/01/20/Typora/</url>
    <content><![CDATA[<h2 id="（1）标题"><a href="#（1）标题" class="headerlink" title="（1）标题"></a>（1）标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="（2）快捷键"><a href="#（2）快捷键" class="headerlink" title="（2）快捷键"></a>（2）快捷键</h2><p>普通模式和源代码模式：ctrl+/<br>md语法正确显示需要在有文字的一行后面再空一行，把鼠标放在有文字的最后一行的后两行的位置</p>
<p>标题：按下ctrl和+，则当前行变成第六级的标题，每按一次ctrl和+则当前标题的等级提升一级。按下ctrl和-则是按下ctrl和+的逆向操作。</p>
<h2 id="（3）字体"><a href="#（3）字体" class="headerlink" title="（3）字体"></a>（3）字体</h2><p><strong>加粗</strong><br><em>倾斜</em><br><strong><em>斜体加粗</em></strong><br><del>删除线</del> （~<em>2删除线~</em>2）<br>==高亮==<br>我是^上标^<br>我是~下标~       （注意用英文的~）</p>
<h2 id="（4）列表"><a href="#（4）列表" class="headerlink" title="（4）列表"></a>（4）列表</h2><p>无序列表：<br>下一级是加号前面空两格<br>第一级是实心的圆，第二级是空心的圆，第三级开始都是实心的小方框</p>
<ul>
<li>一二三四五<ul>
<li>上山打老虎<ul>
<li>老虎没打到<ul>
<li>打到小松鼠</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有序列表：</p>
<ol>
<li>一二三四五</li>
<li>上山打老虎</li>
<li>老虎没达到</li>
<li>打到小松鼠</li>
</ol>
<h2 id="（5）表格"><a href="#（5）表格" class="headerlink" title="（5）表格"></a>（5）表格</h2><div class="table-container">
<table>
<thead>
<tr>
<th>MON</th>
<th>TUE</th>
<th>WED</th>
<th>THU</th>
<th>FRI</th>
</tr>
</thead>
<tbody>
<tr>
<td>上山</td>
<td>上山</td>
<td>上山</td>
<td>上山</td>
<td>上山</td>
</tr>
<tr>
<td>打老虎</td>
<td>打老虎</td>
<td>打老虎</td>
<td>打老虎</td>
<td>打老虎</td>
</tr>
</tbody>
</table>
</div>
<p>在普通模式下，输入：|MON|TUE|WED|THU|FRI|，再输入回车，即可出现表格，可以增加表格的行和列，以及左右居中等等</p>
<h2 id="（6）引用"><a href="#（6）引用" class="headerlink" title="（6）引用"></a>（6）引用</h2><p>下一级别：加一个&gt;</p>
<blockquote>
<p>一二三四五</p>
<blockquote>
<p>上山打老虎</p>
<blockquote>
<p>老虎没达到</p>
<blockquote>
<p>打到小松鼠</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="（7）分割线"><a href="#（7）分割线" class="headerlink" title="（7）分割线"></a>（7）分割线</h2><p>疯狂打——-即可</p>
<hr>
<h2 id="（7）代码"><a href="#（7）代码" class="headerlink" title="==（7）代码=="></a>==（7）代码==</h2><p><code>我是代码</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="（8）字数和侧边栏"><a href="#（8）字数和侧边栏" class="headerlink" title="（8）字数和侧边栏"></a>（8）字数和侧边栏</h2><p>字数在右下角<br>侧边栏在左侧，可以通过在普通模式中点击左下角的小圆圈呼出<br>大纲也在侧边栏中</p>
<h2 id="（9）插入图片"><a href="#（9）插入图片" class="headerlink" title="（9）插入图片"></a>（9）插入图片</h2><p>将图片放入到图片文件夹中，然后复制图片将其直接粘贴进来即可</p>
<p><img src="D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/Snipaste_2023-12-27_04-15-35.png" alt="Snipaste_2023-12-27_04-15-35"></p>
<p><img src="D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/Snipaste_2023-12-27_04-12-14.png" alt="Snipaste_2023-12-27_04-12-14"></p>
<h2 id="（10）改变字体颜色"><a href="#（10）改变字体颜色" class="headerlink" title="（10）改变字体颜色"></a>（10）改变字体颜色</h2><p>将字体改变为红色：<code>&lt;font color=red&gt;</code>文字 <code>&lt;/font&gt;</code></p>
<p>==平常用高亮即可，不要用红色==</p>
<h2 id="11-diff代码块"><a href="#11-diff代码块" class="headerlink" title="(11) diff代码块"></a>(11) diff代码块</h2><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- 这行被删除了</span></span><br><span class="line"><span class="addition">+ 这行被添加了</span></span><br><span class="line">  这行没有改变</span><br></pre></td></tr></table></figure>
<h2 id="12-enter和shift-enter的区别"><a href="#12-enter和shift-enter的区别" class="headerlink" title="(12) enter和shift enter的区别"></a>(12) enter和shift enter的区别</h2><p>enter: 新起一段（空一行）<br>shift enter: 新起一行</p>
<h2 id="13-markdown-source-code"><a href="#13-markdown-source-code" class="headerlink" title="(13) markdown source code"></a>(13) markdown source code</h2><pre><code>
## （1）标题

# 一级标题

## 二级标题

### 三级标题

#### 四级标题

##### 五级标题

###### 六级标题

## （2）快捷键

普通模式和源代码模式：ctrl+/
md语法正确显示需要在有文字的一行后面再空一行，把鼠标放在有文字的最后一行的后两行的位置

标题：按下ctrl和+，则当前行变成第六级的标题，每按一次ctrl和+则当前标题的等级提升一级。按下ctrl和-则是按下ctrl和+的逆向操作。

## （3）字体

**加粗**
*倾斜*
***斜体加粗***
~~删除线~~ （~*2删除线~*2）
==高亮==
我是^上标^
我是~下标~       （注意用英文的~）

## （4）列表

无序列表：
下一级是加号前面空两格
第一级是实心的圆，第二级是空心的圆，第三级开始都是实心的小方框

+ 一二三四五
  + 上山打老虎
    + 老虎没打到
      + 打到小松鼠

有序列表：

1. 一二三四五
2. 上山打老虎
3. 老虎没达到
4. 打到小松鼠

## （5）表格

| MON    | TUE    | WED    | THU    | FRI    |
| ------ | ------ | ------ | ------ | ------ |
| 上山   | 上山   | 上山   | 上山   | 上山   |
| 打老虎 | 打老虎 | 打老虎 | 打老虎 | 打老虎 |

在普通模式下，输入：|MON|TUE|WED|THU|FRI|，再输入回车，即可出现表格，可以增加表格的行和列，以及左右居中等等

## （6）引用

下一级别：加一个>

> 一二三四五
>
>> 上山打老虎
>>
>>> 老虎没达到
>>>
>>>> 打到小松鼠
>>>>
>>>
>>

## （7）分割线

疯狂打-----即可

---

##==（7）代码==

`我是代码`

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## （8）字数和侧边栏

字数在右下角
侧边栏在左侧，可以通过在普通模式中点击左下角的小圆圈呼出
大纲也在侧边栏中

## （9）插入图片

将图片放入到图片文件夹中，然后复制图片将其直接粘贴进来即可

![Snipaste_2023-12-27_04-15-35](D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/Snipaste_2023-12-27_04-15-35.png)

![Snipaste_2023-12-27_04-12-14](D:/OneDrive%20-%20stu.xjtu.edu.cn/%E5%9B%BE%E7%89%87/Snipaste_2023-12-27_04-12-14.png)

## （10）改变字体颜色

将字体改变为红色：`<font color=red>`文字 `</font>`

==平常用高亮即可，不要用红色==

## (11) diff代码块

<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- 这行被删除了</span></span><br><span class="line"><span class="addition">+ 这行被添加了</span></span><br><span class="line">  这行没有改变</span><br></pre></td></tr></table></figure>

## (12) enter和shift enter的区别

enter: 新起一段（空一行）
shift enter: 新起一行
</code></pre>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Mardown</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode problems prepared for a TikTok interview</title>
    <url>/2024/05/10/LeetCode-problems-prepared-for-a-TikTok-interview/</url>
    <content><![CDATA[<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><p>本题是整数二分的加强版。本题的要点为：</p>
<ol>
<li><p>写两个函数，分别寻找target的左边界和右边界。本题的区间定义为左闭右闭。</p>
</li>
<li><p>寻找左边界，说明target在[left, mid]之间，因此在[left, mid]中更新左边界。寻找右边界，说明target在[mid, right]之间，因此在[mid, right]中更新右边界。</p>
</li>
<li><p>寻找左边界，就要在<code>nums[mid] == target</code>的时候更新right，然后将right赋给左边界。寻找右边界，就要在<code>nums[mid] == target</code>的时候更新left，然后将left赋给右边界。</p>
</li>
<li><p>实际上的左右边界是<code>mid</code>，而非<code>right</code>和<code>left</code>，因此在主函数中需要将左边界+1，恢复为<code>mid</code>；将右边界-1，也恢复为<code>mid</code>。也可以直接让左右边界是<code>mid</code>，这样就不需要加1减1，参见我的第二种写法。</p>
</li>
<li><p>target的三种情况：</p>
<ul>
<li>target在数组范围的右边或者左边</li>
<li>target 在数组范围中，且数组中存在target</li>
<li>target 在数组范围中，且数组中不存在target<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 寻找左边界</span></span><br><span class="line">    <span class="comment">// 说明target在[left, mid]之间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLeftBorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftBorder = <span class="number">-2</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 在[left, mid]中更新左边界</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                leftBorder = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找右边界</span></span><br><span class="line">    <span class="comment">// 说明target在[mid, right]之间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRightBorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rightBorder = <span class="number">-2</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 在[mid, right]中更新右边界</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                rightBorder = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftBorder = <span class="built_in">findLeftBorder</span>(nums, target);</span><br><span class="line">        <span class="type">int</span> rightBorder = <span class="built_in">findRightBorder</span>(nums, target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// target在数组范围的右边或者左边</span></span><br><span class="line">        <span class="keyword">if</span> (leftBorder == <span class="number">-2</span> || rightBorder == <span class="number">-2</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// target 在数组范围中，且数组中存在target</span></span><br><span class="line">        <span class="keyword">if</span> (rightBorder - leftBorder &gt; <span class="number">1</span>) <span class="keyword">return</span> &#123;leftBorder + <span class="number">1</span>, rightBorder - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// target 在数组范围中，且数组中不存在target</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>我写出了以下的变式代码。在这个代码里，通过<code>mid</code>来更新左右边界。这样若找到了左右边界，则直接返回左右边界即可，不需要做加1减1的操作。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 寻找左边界</span></span><br><span class="line">    <span class="comment">// 说明target在[left, mid]之间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLeftBorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftBorder = <span class="number">-2</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 在[left, mid]中更新左边界</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                leftBorder = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找右边界</span></span><br><span class="line">    <span class="comment">// 说明target在[mid, right]之间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRightBorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rightBorder = <span class="number">-2</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 在[mid, right]中更新右边界</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                rightBorder = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftBorder = <span class="built_in">findLeftBorder</span>(nums, target);</span><br><span class="line">        <span class="type">int</span> rightBorder = <span class="built_in">findRightBorder</span>(nums, target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// target在数组范围的右边或者左边</span></span><br><span class="line">        <span class="keyword">if</span> (leftBorder == <span class="number">-2</span> || rightBorder == <span class="number">-2</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// target 在数组范围中，且数组中存在target</span></span><br><span class="line">        <span class="keyword">if</span> (rightBorder - leftBorder &gt;= <span class="number">0</span>) <span class="keyword">return</span> &#123;leftBorder, rightBorder&#125;;</span><br><span class="line">        <span class="comment">// target 在数组范围中，且数组中不存在target</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="278-第一个坏版本"><a href="#278-第一个坏版本" class="headerlink" title="278.第一个坏版本"></a>278.第一个坏版本</h2><p>我独立写出了以下代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid) == <span class="number">0</span>) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在本题中，尽管是左闭右闭的写法，但循环的条件应该为<code>left &lt; right</code>，因为当<code>left = right</code>时，实际上就锁定了第一个坏版本，循环就应当结束。这种题目当出现超时，要着重检查是不是循环的条件不对。</p>
<p>和本题同样的题目：输入一个数组，比如<code>[0, 0, 0, 1, 1, 1, 1]</code>，找到第一个为1的数的下标，代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == <span class="number">1</span>) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">firstBadVersion</span>(arr) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><p>本题直接采用（快慢）双指针解法即可。一遍过，但需要注意不要在<code>for</code>循环中重复定义指针<code>j</code>。本题的暴力做法甚至比双指针做法更复杂，也更容易写错。相向双指针做法暂时不用管。</p>
<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p>暴力解法非常简单，也能通过测试。我先在纸上模拟了双指针的过程，然后独立写出了如下的双指针代码，时间和空间复杂度都是$O(n)$。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针经典题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = size; i &lt;= j; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &lt;= nums[j] * nums[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                res[size] = nums[j] * nums[j];</span><br><span class="line">                j -- ;</span><br><span class="line">                size -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[size] = nums[i] * nums[i];</span><br><span class="line">                i ++ ;</span><br><span class="line">                size -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>不要追求把代码写得过度简洁，而导致可能的问题，宁可把代码写长一些，也要让代码清楚地表达算法思想。</p>
<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p>一时想不起来具体怎么写了，只记得遍历整个数组的同时，有数划入窗口，该数被累加到和中，有数划出窗口，则该数被从和中减去。看了我自己的笔记后，我独立写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = INT_MAX;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>; <span class="comment">// 滑动窗口的和</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// j为终止位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            s += nums[j]; <span class="comment">// 终止位置划入</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (s &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sub = j - i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (sub &lt; len) len = sub;</span><br><span class="line">                s -= nums[i]; <span class="comment">// 起始位置从和中滑出</span></span><br><span class="line">                i ++ ; <span class="comment">// 起始位置从滑动窗口中滑出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == INT_MAX) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意：</p>
<ul>
<li><p>i为起始位置，j为终止位置</p>
</li>
<li><p>循环中，终止位置先划入。若和大于等于目标值，则先更新最小长度，再将起始位置划出。</p>
</li>
<li><p>起始位置的值需要先从和中滑出，起始位置再从滑动窗口中滑出。顺序不可颠倒。</p>
</li>
<li><p>for循环中是while循环，而非if判断</p>
</li>
<li><p>数组中的每个元素至多被滑入一次再滑出一次，因此时间复杂度是$O(2n)$，即$O(n)$。</p>
</li>
</ul>
<h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><p>我记得本题是个模拟题。但实在记不得怎么做了，看以前的笔记。复习完后，我写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>, cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j ++ )</span><br><span class="line">                res[startx][j] = cnt ++ ;</span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i ++ )</span><br><span class="line">                res[i][j] = cnt ++ ;</span><br><span class="line">            <span class="keyword">for</span> (j = n - offset; j &gt; starty; j -- )</span><br><span class="line">                res[i][j] = cnt ++ ;</span><br><span class="line">            <span class="keyword">for</span> (i = n - offset; i &gt; startx; i -- )</span><br><span class="line">                res[i][j] = cnt ++ ;</span><br><span class="line">            offset ++ ;</span><br><span class="line">            startx ++ ;</span><br><span class="line">            starty ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) res[n / <span class="number">2</span>][n / <span class="number">2</span>] = cnt;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意：</p>
<ol>
<li><p><strong>画图理解（记住本图，就可以写出这道题的代码）</strong>：</p>
<p><img src="https://github.com/yfchenkeepgoing/image/blob/main/Snipaste_2024-01-26_06-26-17.png?raw=true" alt="Snipaste_2024-01-26_06-26-17.png"></p>
</li>
<li><p>顺时针转圈，转多少圈可以填满整个二维数组？从(0, 0)的位置开始转圈，终止的位置为中心(n/2, n/2)。每转一圈横纵坐标均加1，因此一共转了n/2圈。</p>
</li>
<li><p>切记遵守循环不变量原则，所有边都是左闭右开的。所以是<code>j &lt; n - offset</code>，且<code>offset</code>的初始值为1，因为右边界是开的。</p>
</li>
<li><p><code>startx</code>, <code>starty</code>, <code>offset</code>每转一圈都要加1。</p>
</li>
<li><p>定义二维数组的方式是将一位数组复制行数遍。</p>
</li>
<li><p>若n为奇数，则最后记得向二维数组的中心填入最后一个数。</p>
</li>
</ol>
<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189.旋转数组"></a>189.旋转数组</h2><p>首先我写出了可以正常运行但会超时的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>不超时的代码我写不出来，看卡尔的讲解。</p>
<p>本题的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题其实原理不难，类似于旋转字符串的题目，总结如下：</p>
<ol>
<li>首先反转整个数组，这样在不考虑顺序的情况下，就将两段数字放在了正确的位置上。</li>
<li>然后反转前k个数，将前k个数的顺序调整正确。</li>
<li>最后反转剩下的数，将剩下的数的顺序调整正确。</li>
<li>需要注意的是，若<code>k &gt; nums.size()</code>，则右移<code>k % nums.size()</code>即可，因为右移<code>nums.size()</code>次相当于没有改变原数组。</li>
<li>不要对nums.end()进行加减操作，nums.end()不指向一个特定的元素（不要下意识地以为其指向最后一个元素后面的紧邻的位置），对其进行加减操作会导致未定义的随机行为。对nums.begin()进行操作就没有这个问题。因此反转的第三步不要写成<code>reverse(nums.end() - k - 1, nums.end())</code>。</li>
</ol>
<h2 id="153-寻找旋转数组中的最小值"><a href="#153-寻找旋转数组中的最小值" class="headerlink" title="153.寻找旋转数组中的最小值"></a>153.寻找旋转数组中的最小值</h2><p>应该是先要将其恢复为有序的数组，然后返回有序数组的第一个元素即可。本题应该结合了二分法和旋转数组。我直接看题解吧。</p>
<p>虽然但是，本题用暴力做法也可以通过：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述算法的时间复杂度是O(nlogn)。用二分法应该可以将时间复杂度优化为O(logn)。</p>
<p>本题的二分做法如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环的终止条件：left = right。此时必然已经找到了数组中的最小值</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 中间数字大于右边数字，比如[3,4,5,1,2]，则左侧是有序上升的，最小值在右侧</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 中间数字小于右边数字，比如[6,7,1,2,3,4,5]，则右侧是有序上升的，最小值在左侧</span></span><br><span class="line">            <span class="comment">// 以[6, 7, 1, 2, 3, 4]为例，mid = 2, right = 2，即恰好在[left, mid]中取到最小值1</span></span><br><span class="line">            <span class="comment">// 若right = mid - 1，则[left, right]会错过最小值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) right = mid;</span><br><span class="line">            <span class="comment">// 中间数字等于右边数字，则说明数组中只有一个元素，返回该元素即可</span></span><br><span class="line">            <span class="comment">// 也可以直接写作else right = mid;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题延续了二分法的思路和代码形式，但细节和二分法略有不同，需要注意复习。</p>
<p>本题的思路：</p>
<ul>
<li><p>本题是左闭右闭写法，区间为<code>[left, right]</code></p>
</li>
<li><p>数组中的最小值要么在数组的右侧，要么在数组的左侧</p>
</li>
<li>数组的最小值在数组右侧的情况：[3, 4, 5, 1, 2]。数组的最小值在数组左侧的情况：[6, 7, 1, 2, 3, 4, 5]</li>
<li>若数组的最小值在数组的右侧，由于<code>nums[mid] &gt; nums[right]</code>，因此<code>nums[mid]</code>必然不可能是数组的最小值，因此<code>left = mid + 1</code></li>
<li>对于剩下的情况，即<code>nums[mid] &lt;= nums[right]</code>，数组的最小值在数组的左侧。由于可能存在<code>nums[mid] = nums[right]</code>的情况，因此<code>nums[mid]</code>可能是最小值，因此有<code>right = mid</code></li>
<li>记住始终是<code>nums[mid]</code>和<code>nums[right]</code>比较。始终是中间和右边比！</li>
</ul>
<p><strong>本题的另一种思路（更推荐这种，因为这种思路可以推广到33）</strong>：</p>
<ul>
<li><code>nums[mid]</code>和<code>nums[right]</code>的关系可以分为大于，等于，小于三种情况</li>
<li><code>nums[mid] == nums[right]</code>时，中间的数字等于最右边的数字，说明数组中只有一个元素，此时返回<code>nums[left]</code>即可，这种情况不需要考虑</li>
<li><code>nums[mid] &gt; nums[right]</code>时，例如[3, 4, 5, 1, 2]。数组的最小值在数组的右侧，<code>nums[mid]</code>必定不为最小值，因此有<code>left = mid + 1</code></li>
<li><code>nums[mid] &lt; nums[right]</code>时，数组的最小值在数组的左侧。例如[6, 7, 1, 2, 3, 4, 5]，也有可能是[6, 7, 1, 2, 3, 4]，此时<code>mid = 2, right = 2</code>，即恰好在[left, mid]中取到最小值1。若<code>right = mid - 1</code>，则[left, right]会错过最小值，因此<code>right = mid</code></li>
</ul>
<h2 id="154-寻找旋转数组中的最小值II"><a href="#154-寻找旋转数组中的最小值II" class="headerlink" title="154.寻找旋转数组中的最小值II"></a>154.寻找旋转数组中的最小值II</h2><p>本题的思路：</p>
<ul>
<li>延续上题的思路，<code>nums[mid]</code>和<code>nums[right]</code>的关系可以分为大于，等于，小于三种情况</li>
<li><code>nums[mid] &gt; nums[right]</code>和<code>nums[mid] &lt; nums[right]</code>的情况同上</li>
<li>由于数组中可以有重复的元素，因此需要考虑<code>nums[mid] == mums[right]</code>的情况，例如[2,3,1,1,1]或者[4,1,2,3,3,3,3]。此时，重复值<code>nums[right]</code>可能是最小值，也可能最小值在重复值的左侧，因此right左移一位：<code>right -= 1</code></li>
</ul>
<p>本题的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// [5, 6, 7, 1, 2]</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// [7, 1, 2, 3, 4]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) right = mid;</span><br><span class="line">            <span class="keyword">else</span> right -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h2><p>我对本题的初步思路：先找到最小的那个点，然后分别对两段单调递增的区间用二分法进行搜索。根据这个原理，我独立写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 二分查找有序数组中的数</span></span><br><span class="line">    <span class="comment">// 左闭右闭写法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchTarget</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先找到最小的数字, 下标为left</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// nums[mid] nums[right], [4, 5, 6, 7, 0, 1, 2]</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftIndex = <span class="built_in">searchTarget</span>(nums, <span class="number">0</span>, left - <span class="number">1</span>, target);</span><br><span class="line">        <span class="type">int</span> rightIndex = <span class="built_in">searchTarget</span>(nums, left, nums.<span class="built_in">size</span>() - <span class="number">1</span>, target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftIndex == <span class="number">-1</span> &amp;&amp; rightIndex == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (leftIndex == <span class="number">-1</span>) <span class="keyword">return</span> rightIndex;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rightIndex == <span class="number">-1</span>) <span class="keyword">return</span> leftIndex;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度也是$O(logn)$。</p>
<p>更简单的写法如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 本质是查找target，因此是小于等于。若是查找最小值，则是小于</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一种情况，直接找到</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于第一种情况已经讨论过nums[mid] == target，因此第二三种情况不用再讨论</span></span><br><span class="line">            <span class="comment">// 第二种情况，数组最小值在右侧, [left, mid]为有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// target在[left, mid](有序)内</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// target在无序区间内</span></span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第三种情况，数组最小值在左侧，[mid, right]为有序</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// target在[mid, right]区间内</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// target在无序区间内</span></span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>分三种情况讨论：</p>
<ul>
<li>直接在mid处找到target</li>
<li>数组最小值在右侧, [left, mid]为有序<ul>
<li>target在[left, mid]有序区间内</li>
<li>target在剩余的无序区间内</li>
</ul>
</li>
<li>数组最小值在左侧，[mid, right]为有序<ul>
<li>target在[mid, right]有序区间内</li>
<li>target在剩余的无序区间内</li>
</ul>
</li>
</ul>
<h2 id="81-搜索旋转排序数组II"><a href="#81-搜索旋转排序数组II" class="headerlink" title="81.搜索旋转排序数组II"></a>81.搜索旋转排序数组II</h2><p>本题依然可以用老思路：找到最小值点，将区间划分为两个单调区间，然后分别在两个单调区间中进行搜索。本题实际上不可以这样做，因为本题中数组的元素可以重复，可能存在不止一个最小值点。</p>
<p>看了答案后，发现本题有两种写法，第一种：在循环内部跳过数组左侧和右侧的重复元素：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 跳过数组左侧的重复元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">            <span class="comment">// 跳过数组右侧的重复元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断有序部分</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) &#123;  <span class="comment">// 左侧有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 右侧有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>第二种，在循环外部直接删去数组尾部与数组头部重复的元素：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 移除重复的末尾元素以减少干扰</span></span><br><span class="line">        <span class="comment">// 可以处理如下情况：[1, 0, 1, 1, 1], [1, 2, 2, 2, 2, 0, 1]</span></span><br><span class="line">        <span class="comment">// nums.front() == nums.back()时，可能数组右边有序，也可能左边有序</span></span><br><span class="line">        <span class="comment">// 也可写作nums[0] == nums[nums.size() - 1]</span></span><br><span class="line">        <span class="keyword">while</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; nums.<span class="built_in">front</span>() == nums.<span class="built_in">back</span>()) nums.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// [3, 4, 5, 1, 2]</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 有序区间[left, mid]</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 无序区间[mid, right]</span></span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 有序区间[mid, right]</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 无序区间[left, mid]</span></span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意：需要先移除重复的末尾元素以减少干扰，再给<code>left</code>和<code>right</code>赋值。</p>
<p>建议采用第二种写法，因为第二种写法相当于在33.搜索旋转排序数组的基础上仅仅添加了移除重复的末尾元素的代码。这道题相当与上一题区别在于这道题包含了重复元素，其实影响到的是，当左端点和右端点相等时，无法判断mid在左半边有序数组还是右半边有序数组，所以只需要一直pop直到左端点和右端点不相等就可以了。</p>
<h2 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a>442. 数组中重复的数据</h2><h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h2><p>只有当数字的范围和数组的大小相等，或者有一定偏移关系时，才可以用原地哈希。本题的数字范围1-n，本题的数组中有n个元素，数组下标的范围是0-n-1。这种原地哈希算法适用于和正整数有关，且数字范围和数组长度有关的题目里，映射之后能利用映射关系（下标和值一一对应）来找到解。</p>
<p>对于本题，本质就是将原数组的下标为<code>nums[i] - 1</code>处放上<code>nums[i]</code>，最终希望达到的效果是<code>nums[nums[i] - 1] == nums[i]</code>。本题的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将nums[i]放到下标为nums[i] - 1的位置上</span></span><br><span class="line">        <span class="comment">// 由于原来下标为nums[i] - 1的位置上可能有数，因此需要将该数暂存到nums[i]上</span></span><br><span class="line">        <span class="comment">// 之后可以通过while循环将再将该数放到合适的位置上去</span></span><br><span class="line">        <span class="comment">// 可以举例子来模拟，即可以弄清楚这个过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> tmp = nums[idx];</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若nums[i]上的数字不为i + 1，则说明该数字缺失，将其插入结果集中</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题的精简注释版本如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 确保将nums[i]放到下标为nums[i] - 1的位置上</span></span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> idx = nums[i] - <span class="number">1</span>; <span class="comment">// 即将占用的元素的下标</span></span><br><span class="line">                <span class="type">int</span> tmp = nums[idx]; <span class="comment">// 暂存下标为idx处的元素，因为其即将被nums[i]占用</span></span><br><span class="line">                nums[idx] = nums[i]; <span class="comment">// 将nums[i]放到下标为nums[i] - 1的位置上</span></span><br><span class="line">                nums[i] = tmp; <span class="comment">// 将原来数组中下标为nums[i] - 1的数暂存到位置i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>while循环中的顺序：先写：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line">nums[idx] = nums[i];</span><br></pre></td></tr></table></figure></p>
<p>确保nums[i]被放在了下标为nums[i] - 1处。</p>
<p>再将原本下标为idx处的元素缓存下来，暂存到下标i处：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tmp = nums[idx];</span><br><span class="line">nums[i] = tmp;</span><br></pre></td></tr></table></figure></p>
<p>由此构成完整的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tmp = nums[idx];</span><br><span class="line">nums[idx] = nums[i];</span><br><span class="line">nums[i] = tmp;</span><br></pre></td></tr></table></figure></p>
<h2 id="442-数组中重复的数据-1"><a href="#442-数组中重复的数据-1" class="headerlink" title="442. 数组中重复的数据"></a>442. 数组中重复的数据</h2><p>本题依然可以用448的原地哈希法完成，唯一地不同在于，448是将<code>i + 1</code>插入<code>res</code>数组中，本题是将<code>nums[i]</code>插入<code>res</code>数组中，举一个实际的例子即可理解为什么是将<code>nums[i]</code>插入结果集中。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> tmp = nums[idx];</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对原地哈希可进行总结：</p>
<ul>
<li><p>情景：数组的长度为<code>n</code>，数组中元素的范围为<code>[1, n]</code></p>
</li>
<li><p>若是找缺失的数字，则插入结果集的是索引下标+1；若是找出现了两遍的数字，则插入结果集的是元素的值<code>nums[i]</code></p>
</li>
<li><p>使用代码块：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tmp = nums[idx];</span><br><span class="line">        nums[idx] = nums[i];</span><br><span class="line">        nums[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对数组进行原地哈希后，数组中出现过的数字<code>nums[i]</code>会被重新放置在下标为<code>nums[i] - 1</code>的位置上。范围为<code>[1, n]</code>但数组中没出现过的数字<code>nums[j]</code>，其本来应该放置在下标为<code>nums[j] - 1</code>处，但由于没有出现过，现在下标为<code>nums[j] - 1</code>处放置了原数组中的重复元素。这是因为循环的条件<code>nums[nums[i] - 1] != nums[i]</code>，当未填满的位置填入了重复元素后，while循环也会终止。例如，对<code>[4, 3, 2, 2, 3, 1]</code>进行原地哈希，结果为<code>[1, 2, 3, 4, 3, 2]</code>，原数组中出现过的1, 2, 3, 4被放置在下标为0, 1, 2, 3的位置上，原数组中没有出现过5, 6，因此下标为4，5处放置了原数组中重复的元素2, 3。</p>
</li>
<li><p>原地哈希法的时间复杂度都为O(n)，空间复杂度都为O(1)</p>
</li>
<li><p>为什么是 O(n) 时间复杂度？</p>
<p>每个元素在整个过程中最多被处理两次（一次是放置在正确位置，一次是在最终遍历中检查），因此总体时间复杂度是 O(2n)==O(n)。</p>
</li>
</ul>
<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h2><p>本题的思路和448、442相同，只不过while循环多了限制条件，同时返回值时需要考虑一种特殊情况。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 为避免nums[i] - 1超出索引的范围，需要对nums[i]的大小进行限制</span></span><br><span class="line">            <span class="comment">// 0 &lt;= nums[i] - 1 &lt;= n - 1，因此1 &lt;= nums[i] &lt;= n</span></span><br><span class="line">            <span class="comment">// 不需要对此范围之外的数进行操作，也无法用原地哈希法操作它们，因为它们会超出索引范围</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 这四行代码可以简写为swap(nums[nums[i] - 1], nums[i]);</span></span><br><span class="line">                <span class="type">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> tmp = nums[idx];</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊情况, nums = [1], 上面的循环不会返回结果，此时返回n + 1即可</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题中，数的个数为n个，但数的范围不在<code>[1, n]</code>中。需要返回缺失的第一个正整数。虽然乍一看不完全符合上题总结的原地哈希法的使用条件，但加上限制条件的原地哈希法依然可以被应用于解决本题。</p>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><p>本题不能这样写：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ListNode* cur = dummyHead; cur != <span class="literal">NULL</span>; cur = cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;val == val)</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样写会导致删除节点后，<code>cur</code> 指针向后移动到了 <code>cur-&gt;next-&gt;next</code>，从而可能跳过了紧接着的需要删除的节点。比如：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 2 -&gt; 3, target = 2</span><br></pre></td></tr></table></figure></p>
<p>上述写法会导致第三个节点2不能被删除。</p>
<p>本题应当用while循环写，对一个节点，如果是目标节点，则将其删除，否则，向后移动一个节点，不能同时既删除节点又后移一位。本题正确的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果既删又后移，则会漏掉节点</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">// 要么删</span></span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;next; <span class="comment">// 要么后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题的完整主函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">remove</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    ListNode* cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// head = [1,2,6,3]</span></span><br><span class="line">    ListNode* node1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* node2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    ListNode* node3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">6</span>);</span><br><span class="line">    ListNode* node4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = node4;</span><br><span class="line"></span><br><span class="line">    ListNode* head = <span class="built_in">remove</span>(node1, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (ListNode* cur = head; cur != <span class="literal">NULL</span>; cur = cur-&gt;next) cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造链表时，也可以采用函数写法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">appendNode</span><span class="params">(ListNode*&amp; head, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 头为空，则将新节点作为头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    <span class="comment">// 头不为空，则遍历到链表最后一个节点，将新节点添加到最后一个节点之后</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) cur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">remove</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    ListNode* cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// head = [1,2,6,3]</span></span><br><span class="line">    ListNode* node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">appendNode</span>(node, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">appendNode</span>(node, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">appendNode</span>(node, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">appendNode</span>(node, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ListNode* head = <span class="built_in">remove</span>(node, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (ListNode* cur = head; cur != <span class="literal">NULL</span>; cur = cur-&gt;next) cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在定义链表时，特别要注意下面用来赋值的这句话：<code>ListNode(int x): val(x), next(NULL) &#123;&#125;</code>。</p>
<h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h2><p>本题的细节很多，需要特别注意。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get函数的复杂写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    LinkedList* cur = _dummyHead;</span><br><span class="line">    index ++ ;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        index -- ;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本题的完整代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedList</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedList* next;</span><br><span class="line">        <span class="built_in">LinkedList</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        LinkedList* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index -- ) cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedList* head = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line">        head-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = head;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedList* tail = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) cur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tail;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size) <span class="keyword">return</span>;</span><br><span class="line">        LinkedList* newNode = <span class="keyword">new</span> <span class="built_in">LinkedList</span>(val);</span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index -- ) cur = cur-&gt;next;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        LinkedList* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index -- ) cur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        _size -- ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LinkedList* _dummyHead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意事项：</p>
<ol>
<li><p>带下划线的变量表示类中的变量，而非局部变量</p>
</li>
<li><p>记得在private中定义类中的变量</p>
</li>
<li><p>注意插入节点时先更新后面的边，再更新前面的边</p>
</li>
<li><p>别忘记_size ++ / _size —</p>
</li>
<li><p>注意对参数index进行判断</p>
</li>
<li><p><code>while (index -- ) cur = cur-&gt;next</code>的意思是，首先判断<code>index</code>是否大于0，是，则<code>index = index - 1</code>，然后执行<code>cur = cur-&gt;next</code></p>
</li>
</ol>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><p>我记得有递归写法，迭代写法，先尝试实现迭代写法，其本质是双指针。记住下面的图，即可写出本题的双指针法的代码：<br><img src="https://github.com/yfchenkeepgoing/image/blob/main/leetcode206.png?raw=true" alt="leetcode206.png"></p>
<p>注意：pre从NULL开始，cur在NULL结束。</p>
<p>一个经典的错误：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样写的结果是导致未将列表的最后一个节点（即反转后的头节点）的 <code>next</code> 指针正确设置。</p>
<p>本题的递归写法其实更加好写，但其空间复杂度为O(n)，高于双指针写法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* last = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p>首先尝试用双指针做法解决本题。直接看答案，记住本题的方法。其实不需要双指针，本题是一道单纯的模拟题，但要搞清楚循环终止条件。看过博客后，我写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 终止条件：分别对应有偶数个节点和有奇数个节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 存1</span></span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 存3</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// d-&gt;2</span></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 2-&gt;1</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp;</span><br><span class="line">            <span class="comment">// 1-&gt;3</span></span><br><span class="line">            tmp-&gt;next = tmp1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后移两位</span></span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><p>本题的笨办法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 计算节点数目</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            num ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒数第n个节点是正数第num - n个节点</span></span><br><span class="line">        cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; n) <span class="comment">// 不可以写成(num - n) -- </span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            num -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>看博客，复习巧妙解法。本题的巧妙解法是快慢双指针。<strong>快指针先移动n位，然后快慢指针同时移动，直到快指针移动到链表的最后一个节点。此时，慢指针就指向了需要删除的节点</strong>。据此，我写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        <span class="comment">// &amp;&amp; fast可加可不加，因为本题有限制n&lt;=链表长度，若无此限制，则必须加，否则会出现空指针异常</span></span><br><span class="line">        <span class="keyword">while</span> (n -- &amp;&amp; fast) fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next) </span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>也可以让快指针先移动n + 1步，然后快慢指针同时移动，直到快指针移动到链表的NULL节点。</p>
<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h2><p>本题拿到我没什么思路，直接看以前的博客。本题的思路：首先计算两个链表的长度，将较长的链表作为链表a，较短的链表作为链表b。然后a链表从sizea - sizeb处开始, b链表从0处开始遍历，直到找到二者的交汇点。本质上体现的是一种<strong>末尾对齐</strong>的思想。示意图和代码如下所示：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_2.png" alt="面试题02.07.链表相交_2"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* cura = headA, *curb = headB;</span><br><span class="line">        <span class="type">int</span> sizea = <span class="number">0</span>, sizeb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算a的长度</span></span><br><span class="line">        <span class="keyword">while</span> (cura)</span><br><span class="line">        &#123;</span><br><span class="line">            cura = cura-&gt;next;</span><br><span class="line">            sizea ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算b的长度</span></span><br><span class="line">        <span class="keyword">while</span> (curb)</span><br><span class="line">        &#123;</span><br><span class="line">            curb = curb-&gt;next;</span><br><span class="line">            sizeb ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让a为较长的链表, b为较短的链表</span></span><br><span class="line">        <span class="keyword">if</span> (sizea &lt; sizeb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(sizea, sizeb);</span><br><span class="line">            <span class="built_in">swap</span>(headA, headB);</span><br><span class="line">            <span class="built_in">swap</span>(cura, curb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a链表从sizea - sizeb处开始, b链表从0处开始</span></span><br><span class="line">        cura = headA, curb = headB;</span><br><span class="line">        <span class="type">int</span> delta = sizea - sizeb;</span><br><span class="line">        <span class="keyword">while</span> (delta -- ) cura = cura-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cura == curb) <span class="keyword">return</span> cura;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                cura = cura-&gt;next;</span><br><span class="line">                curb = curb-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n + m)，空间复杂度O(1)。</p>
<h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2><p>我记得本题是用快慢指针解决的，快指针一次走两格，慢指针一次走一格，二者必然会在节点处相遇。我还记得公式怎么推导，但具体的思路记不清楚了，看博客。看完博客后，我写出了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head, * slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fast != NULL保证fast-&gt;next不报空指针异常</span></span><br><span class="line">        <span class="comment">// fast-&gt;next != NULL保证fast-&gt;next-&gt;next不报空指针异常</span></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* node1 = head, * node2 = fast;</span><br><span class="line">                <span class="keyword">while</span> (node1 != node2)</span><br><span class="line">                &#123;</span><br><span class="line">                    node1 = node1-&gt;next;</span><br><span class="line">                    node2 = node2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> node1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题的思路：快慢指针必然会在环中的某处相交，且慢指针在进入环的第一圈中就会和快指针相交。记下交点，让一个指针从起点开始走，另一个指针从交点开始走，二者相交的位置就是环的入口。详细的数学推导和细节见博客。</p>
<p>时间复杂度O(n)，空间复杂度O(1)。</p>
<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><p>本题简单，用数组做哈希，用数组统计一个字符串中各个字母出现的次数，然后遍历另一个字符串，在数组中做减减操作，最后判断数组中的所有元素是否都为0。我独立写出了本题的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp1 = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            hash[tmp1] ++ ;</span><br><span class="line">            <span class="type">int</span> tmp2 = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            hash[tmp2] -- ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意，数组的长度为26，而非<code>s.size()</code>，因为s和t中只含有26个英文字母。可以不用<code>vector</code>，用<code>int</code>类型的数组即可。</p>
<p>本题更简洁的版本的代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            hash[s[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line">            hash[t[i] - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (hash[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p>由于本题数据范围的限制，可以用数组做哈希，也可以用<code>unordered_set</code>做哈希。我首先写出了数组做哈希的写法（数组索引的范围与元素取值的范围相同），数组做哈希非常快：</p>
<h3 id="数组哈希，数组去重"><a href="#数组哈希，数组去重" class="headerlink" title="数组哈希，数组去重"></a>数组哈希，数组去重</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash1[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> hash2[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash1[nums1[i]] ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash2[nums2[i]] ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1010</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash1[i] &amp;&amp; hash2[i]) res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>尝试用<code>unordered_set</code>做本题。我不记得怎么用<code>unordered_set</code>做了，也忘记了<code>unordered_set</code>的基本做法，复习博客。</p>
<h3 id="数组哈希，set去重"><a href="#数组哈希，set去重" class="headerlink" title="数组哈希，set去重"></a>数组哈希，set去重</h3><p>可以将数组和set结合，这样只需要一个数组即可完成本题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res; <span class="comment">// 用于结果集去重</span></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            hash[nums1[i]] ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (hash[nums2[i]]) res.<span class="built_in">insert</span>(nums2[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的set只是起到了去重的功能，没有起到哈希的功能，哈希的任务还是由数组承担了。注意如何将set转换为vector输出，直接<code>vector&lt;int&gt; (res.begin(), res.end())</code>。</p>
<h3 id="set哈希，set去重"><a href="#set哈希，set去重" class="headerlink" title="set哈希，set去重"></a>set哈希，set去重</h3><p>也可以完全用set做本题，set既用来做哈希，又用来去重，代码如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完全用set做本题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (s1.<span class="built_in">find</span>(nums2[i]) != s1.<span class="built_in">end</span>()) res.<span class="built_in">insert</span>(nums2[i]);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p>我记得本题有个巧妙的做法。本题使用的数据结构应该是set。我直接看博客复习本题的写法。我错误的根本原因还是对本题的算法思路理解不清晰。在明确了思路后，我写下了如下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 用于存储各位数字的平方和</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> digit = n % <span class="number">10</span>;</span><br><span class="line">                sum += digit * digit;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(sum) != s.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n = sum;</span><br><span class="line">            s.<span class="built_in">insert</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题的思路其实很简单，<strong>关键在于对平方和的计算和分类讨论（分为三类）</strong>。<strong>开一个死循环，计算n的各位数字的平方和。若平方和为1，则是快乐数。若平方和在set中出现过，则说明进入了死循环，不是快乐数。否则，将平方和加入到set中，将sum赋给n，进入下一重循环</strong>。</p>
<p>时间复杂度和空间复杂度都是O(logn)，详情参见博客。</p>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>本题要用map解决。用map的key存储索引，map的value存储nums中的值。首先将数组中的值依次存入map中，然后再在map中搜索<code>target - nums[i]</code>，若找到，则返回一对索引。本题思路我是清楚的，但由于忘了map的一些写法，因此复习博客。</p>
<p>实际上，我对本题的理解还是不够深刻。应该是用map的key存储数组中的值，map的value存储数组中的元素的下标，因为我们的目的是快速查找值是否出现过，被快速查找的对象应该被作为key。</p>
<h3 id="先查再插"><a href="#先查再插" class="headerlink" title="先查再插"></a>先查再插</h3><p>看完博客后，我写出了以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(t) != m.<span class="built_in">end</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(t);</span><br><span class="line">                <span class="keyword">return</span> &#123;i, it-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题的思路为：<strong>先查后插。先查现有的map中有无<code>target - nums[i]</code>，有，则将其索引和i一起加入结果集。无，则将遍历到的元素继续插入map中。这样天然的可以防止同一个元素被取出两次</strong>。</p>
<p>记住map的一些用法：</p>
<ul>
<li><code>m.insert(&#123;nums[i], i&#125;)</code></li>
<li><code>m.find(key) != m.end()</code></li>
<li><code>auto it = m.find(t); int value = it-&gt;second;</code></li>
</ul>
<h3 id="插完再查"><a href="#插完再查" class="headerlink" title="插完再查"></a>插完再查</h3><p>本题更复杂版本的代码，由于没有先查后插，导致要对找到的索引进行判断，其不能等于当前遍历到的索引，否则会导致同一个数字被使用了两次：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            m.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(t);</span><br><span class="line">            <span class="keyword">if</span> (it != m.<span class="built_in">end</span>() &amp;&amp; it-&gt;second != i) <span class="keyword">return</span> &#123;i, it-&gt;second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="压缩字符串（面试真题）"><a href="#压缩字符串（面试真题）" class="headerlink" title="压缩字符串（面试真题）"></a>压缩字符串（面试真题）</h2><p>将<code>aaaabb</code>压缩为<code>a4b2</code>，将<code>abcde</code>保持原样不动。我独立写出了以下的代码，可以通过所有的测试样例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">compress</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">char</span> tmp = s[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        res += tmp;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == s[i - <span class="number">1</span>]) </span><br><span class="line">        &#123;</span><br><span class="line">            i ++ ;</span><br><span class="line">            size ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">1</span>) res += <span class="built_in">to_string</span>(size); <span class="comment">// 也可以写成res += &#x27;0&#x27; + size;</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; s.<span class="built_in">size</span>()) tmp = s[i];</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后一个字符</span></span><br><span class="line">    <span class="keyword">if</span> (s[s.<span class="built_in">size</span>() - <span class="number">1</span>] != s[s.<span class="built_in">size</span>() - <span class="number">2</span>]) res += s[s.<span class="built_in">size</span>() - <span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将aaabb转换为a3b2输出</span></span><br><span class="line">    <span class="comment">// 将abcde原样输出</span></span><br><span class="line">    string s = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    string res = <span class="built_in">compress</span>(s);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实没有必要在for循环中嵌套while循环，直接用一个for循环就可以搞定。以下的写法为推荐写法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// aaabb-&gt;a3b2</span></span><br><span class="line"><span class="function">string <span class="title">compress</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span> || s.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">char</span> tmp = s[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 出现相同字母</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>]) size ++ ;</span><br><span class="line">        <span class="comment">// 出现不同字母</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将上一个字符和其出现次数（&gt;1）插入res中</span></span><br><span class="line">            res += tmp;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">1</span>) res += <span class="built_in">to_string</span>(size);</span><br><span class="line">            <span class="comment">// 恢复现场</span></span><br><span class="line">            tmp = s[i];</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理字符串的最后一位</span></span><br><span class="line">    res += tmp;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">1</span>) res += <span class="built_in">to_string</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;aaaanbv&quot;</span>;</span><br><span class="line">    string res = <span class="built_in">compress</span>(s);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>本题的关键在于分两种情况讨论：出现相同的字母/出现不同的字母，最后记得处理字符串的最后一位</strong></p>
<p>通过本题，记住常用操作——将数字转换为字符：<code>to_string(size)</code></p>
<p>可以写出上述操作的逆过程的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isdigit</span><span class="params">(<span class="type">char</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">decompress</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s的第一个元素必为字母，从第二个元素开始可能为数字</span></span><br><span class="line">    <span class="comment">// 一对对处理，先处理字母，再处理数字（可能有，也可能没有）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理字母</span></span><br><span class="line">        <span class="type">char</span> tmp = s[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理数字，计算count</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[i + <span class="number">1</span>])) </span><br><span class="line">        &#123;</span><br><span class="line">            count = count * <span class="number">10</span> + s[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字母加入结果集</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) res += tmp;</span><br><span class="line">        <span class="comment">// 若有数字，则将字母重复数字遍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">while</span> (count -- ) res += tmp; <span class="comment">// 也可调用函数res.append(count, tmp);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;a56b12&quot;</span>;</span><br><span class="line">    string res = <span class="built_in">decompress</span>(s);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>本题的关键在于字母和数字成对出现（当然数字可能没有），成对地处理字母和数字，将它们成对地放入res中。</strong></p>
<h2 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h2><p>本题用哈希做的时间复杂度应该为O(n^2)。先枚举nums1和nums2中所有元素之和的组合，然后再在nums3和nums4中查找所有元素之和为<code>-nums1[i] -  nums2[j]</code>的情况。由于涉及到索引，所以要用map，map的key存数值，map的value存索引。value似乎要存一组索引，比如(i, j)，我忘记怎么写了，看下博客。</p>
<p><strong>实际上，应该是用map的key存储和，map的value存储出现这个和的次数</strong>。据此，我写出了以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">                m[nums1[i] + nums2[j]] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums3.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums4.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.<span class="built_in">find</span>(-nums3[i] - nums4[j]) != m.<span class="built_in">end</span>()) </span><br><span class="line">                    count += m.<span class="built_in">find</span>(-nums3[i] - nums4[j])-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更简洁的写法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num1: nums1)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num2: nums2)</span><br><span class="line">                m[num1 + num2] ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num3: nums3)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num4: nums4)</span><br><span class="line">                <span class="keyword">if</span> (m.<span class="built_in">find</span>(-num3 - num4) != m.<span class="built_in">end</span>())</span><br><span class="line">                    count += m[-num3 - num4];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>用map的key存储和，map的value存储出现这个和的次数</li>
<li>map的key不可重复，map的value可以重复。本题中的map起到一个将相同的和归拢，并用value统计其出现次数的作用</li>
<li>cpp中的map中的value是支持++操作的，且value可以通过key直接索引到，就像普通的数组那样</li>
<li>时间和空间复杂度均为$O(n^2)$，空间复杂度为$O(n^2)$是两数组的数字各不相同，产生了$n^2$种组合。</li>
</ul>
<h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h2><p>本题用数组做哈希就可以，因为对象就是26个小写英文字母。据此，我写出了以下的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            cnt[magazine[i] - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ransomNote.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            cnt[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: cnt)</span><br><span class="line">            <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>终极优化版本：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Each letter in magazine can only be used once in ransomNote</span></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> m: magazine)</span><br><span class="line">            cnt[m - <span class="string">&#x27;a&#x27;</span>] ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> r: ransomNote)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[r - <span class="string">&#x27;a&#x27;</span>] -- ;</span><br><span class="line">            <span class="keyword">if</span> (cnt[r - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>Tiktok</tag>
        <tag>复习</tag>
        <tag>补充</tag>
      </tags>
  </entry>
  <entry>
    <title>Summary of full stack netflix clone</title>
    <url>/2024/03/07/Summary-of-full-stack-netflix-clone/</url>
    <content><![CDATA[<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li>Frontend: React</li>
<li>Server-side Rendering: Next.js</li>
<li>Styling: Tailwind CSS</li>
<li>Data abstraction layer: Prisma</li>
<li>Storage: MongoDB</li>
<li>Authentication: NextAuth</li>
<li>Deploy: Vercel</li>
<li>Typescript</li>
<li>the entire website fully</li>
</ul>
<p>The entire website fully responsive across all devices.</p>
<h2 id="实现的功能"><a href="#实现的功能" class="headerlink" title="实现的功能"></a>实现的功能</h2><ul>
<li>credential login: username + password</li>
<li>profile: automatically generated once we register</li>
<li>homepage: loaded with a random movie-billboard</li>
<li>movies: load from database</li>
<li>favourites: add movies as favourites</li>
<li>botton:  shows more information about the movie</li>
<li>play the movie</li>
<li>Google and GitHub oauth login</li>
</ul>
<h2 id="精简笔记与全栈开发的一般流程"><a href="#精简笔记与全栈开发的一般流程" class="headerlink" title="精简笔记与全栈开发的一般流程"></a>精简笔记与全栈开发的一般流程</h2><h3 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h3><p>先在pages中创建auth.tsx，然后在components中创建Input.tsx，将其加入到auth.tsx中。实现next auth时需要创建pages/api/[…nextauth].ts文件。</p>
<h3 id="通过授权登录保护登录界面以外的路径"><a href="#通过授权登录保护登录界面以外的路径" class="headerlink" title="通过授权登录保护登录界面以外的路径"></a>通过授权登录保护登录界面以外的路径</h3><p>保护路由：</p>
<ul>
<li>serverAuth.ts（lib）：利用 next-auth 的 getSession 实现API路由的用户登录检查，防止未登录用户访问。</li>
<li>current.ts（pages/api）：API路由，使用 serverAuth.ts 验证用户登录，返回用户信息或错误。</li>
</ul>
<p>前端用户信息获取：</p>
<ul>
<li>fetcher.ts（lib）：通过 axios 封装的简易数据获取函数。</li>
<li>useCurrentUser.ts（hooks）：自定义Hook，结合 swr 和 fetcher.ts 从 /api/current 获取当前登录用户信息。</li>
</ul>
<p>客户端路由保护与个人资料页面：</p>
<ul>
<li>index.tsx 和 profiles.tsx（pages）：通过 getServerSideProps 中的 getSession 实现路由保护，控制访问权限。</li>
<li>页面重定向：auth.tsx 调整登录后重定向逻辑，确保正确导向 /profiles。</li>
</ul>
<p>实现细节：</p>
<ul>
<li>用户状态展示：在 profiles.tsx 中展示用户信息，并实现点击默认头像返回首页的功能。</li>
<li>环境配置调整：通过修改 .env 和 package.json 解决开发中遇到的端口配置问题，保证登录流程正常。</li>
</ul>
<h3 id="导航组件"><a href="#导航组件" class="headerlink" title="导航组件"></a>导航组件</h3><p>在这个项目中，开发了一个导航组件（Navigation Component），涉及了几个主要的文件和它们之间的关系，以及各自的功能和作用：</p>
<ol>
<li><p>index.tsx（主页文件）：这是应用的入口页面，最初被清理以只保留基本结构。它通过 getServerSideProps 功能检查用户的会话，基于会话存在与否决定重定向到登录页面或显示主内容。后续，Navbar 组件被引入到此文件中，作为页面的一部分。</p>
</li>
<li><p>Navbar.tsx（导航栏组件）：位于 components 文件夹内，Navbar 是顶部的导航条组件，负责显示应用的导航链接。它包括了一个动态背景变化的功能，随着页面滚动，背景从透明变为不透明。</p>
</li>
<li><p>NavbarItem.tsx（导航项组件）：同样位于 components 文件夹内，用于表示 Navbar 中的单个导航链接。它通过 props 接收 label 来显示不同的导航项。</p>
</li>
<li><p>MobileMenu.tsx（移动菜单组件）：这个组件负责在小屏幕上显示一个可展开的移动菜单。它通过 visible prop 控制显示状态，包含多个 NavbarItem 组件来展示导航选项。</p>
</li>
<li><p>AccountMenu.tsx（账户菜单组件）：用于在 Navbar 组件中显示用户的账户菜单，它提供了注销功能并可以通过 visible prop 控制其显示。</p>
</li>
</ol>
<p>项目中还实现了一些额外的交互特性，比如：</p>
<ul>
<li>使用 React 的 useState 和 useEffect Hooks 来管理组件的状态和生命周期，例如控制菜单的显示状态和根据页面滚动动态改变导航栏背景。</li>
<li>通过 useCallback 来优化事件处理函数，避免不必要的重新渲染。</li>
<li>导航组件和移动菜单的显示逻辑，包括在小屏幕上通过点击“浏览”来展开和隐藏导航项。</li>
<li>在 Navbar 组件中，引入了 react-icons 库中的图标来增强视觉效果，并通过条件渲染实现了箭头图标的旋转动画，以指示菜单的展开和收起状态。</li>
</ul>
<p>整体而言，这个导航组件通过组合多个子组件和利用 React 的特性，实现了一个响应式、具有交互性的用户界面，能够适应不同的设备和屏幕尺寸。</p>
<h3 id="广告牌组件"><a href="#广告牌组件" class="headerlink" title="广告牌组件"></a>广告牌组件</h3><p>首先将定义有电影信息的json文件手动添加到MongoDB中。<br>然后创建新的api：random，用于随机返回一部电影。<br>在<code>hooks/useBillboard.ts</code>中写代码以避免对首页推荐电影的重复加载。在<code>components</code>中新建<code>Billboard.tsx</code>，然后在<code>index.tsx</code>中引入<code>Billboard</code>。<br>接着在<code>Billboard.tsx</code>中填入具体的内容，目的是fetch the data for a random movie，并继续加入电影、电影名、电影介绍和More info按钮。</p>
<h3 id="电影列表和电影卡片组件"><a href="#电影列表和电影卡片组件" class="headerlink" title="电影列表和电影卡片组件"></a>电影列表和电影卡片组件</h3><p>定义api: <code>pages/api/movies/index.ts</code>，加载所有电影。<br>接着在hooks文件夹中创建<code>useMovieList.ts</code>，用于返回<code>api/movies</code>中得到的数据。<br>接着在<code>components</code>中创建<code>MovieList.tsx</code>，并在<code>pages/index.tsx</code>中装入MovieList并传入必要的参数，并使用上面定义的hook: <code>useMovieList.ts</code>。<br>接着在<code>components</code>文件夹中创建<code>MovieCard.tsx</code>文件，用于实现电影卡片组件，并将<code>MovieCard</code>放入<code>MovieList.tsx</code>中。</p>
<h3 id="收藏功能"><a href="#收藏功能" class="headerlink" title="收藏功能"></a>收藏功能</h3><p>定义api: <code>pages/api/favorite.ts</code>，用于实现用户在收藏和取消收藏电影时对数据库的操作。<br>再定义一个api: <code>pages/api/favorites.ts</code>，用于加载我们收藏的电影列表。<br>接着写一个hook: <code>useFavorites.ts</code>，用于调用第二个api从而加载我们收藏的电影列表。<br>再写一个组件<code>components/FavoriteButton.tsx</code>，作为收藏按钮。<br>将该按钮加入MovieCard中。然后在Trending Now列表以外再创建一个My Favorites列表，这是在<code>pages/index.tsx</code>中实现的。<br>最后让favorite按钮变得可交互。这样在Trending Now列表上的电影上的加号时，其就会被添加到My List，然后加号会变成勾。这样一部电影就被收藏了。取消收藏也是同理。</p>
<h3 id="电影播放功能"><a href="#电影播放功能" class="headerlink" title="电影播放功能"></a>电影播放功能</h3><p>首先定义api: 创建<code>pages/api/movies/[movieId].ts</code>，用于通过外部传入的movieId找到电影。<br>再创建<code>hooks/useMovie.ts</code>，调用上述api，并负责给上述api传入参数movieId。<br>接着写播放按钮：<code>components/PlayButton.tsx</code>，并在<code>components/Billboard.tsx</code>中加入播放按钮。<br>现在实现了点击播放按钮，跳转到另一个页面的功能，接着在MovieCard组件中也实现这个功能。<br>然后具体写跳转到的<code>/watch</code>页面，创建<code>pages/watch/[movieId].tsx</code>，并在这个页面中实现加载视频名字、返回等功能。</p>
<h3 id="电影详细信息功能"><a href="#电影详细信息功能" class="headerlink" title="电影详细信息功能"></a>电影详细信息功能</h3><p>实现的功能：点击More Info按钮，会显示电影的信息。<br>创建用于状态管理（打开或关闭More Info）的钩子：<code>hooks/useInfoModel.ts</code>。<br>创建显示电影详细信息的组件：<code>components/InfoModal.tsx</code><br>在pages/index.tsx中加入上述组件。<br>给InfoModal组件加上关闭、播放、收藏按钮，最后加上电影信息等字样。<br>利用onClick函数实现点击关闭按钮关闭页面的功能。<br>在<code>pages/index.tsx</code>中实现对组件<code>InfoModal.tsx</code>的触发，从而展现电影的详细信息。<br><code>components/Billboard.tsx</code>中实现点击More Info按钮触发组件<code>InfoModal.tsx</code>，从而展现电影的详细信息。<br>在电影卡片组件中同样实现点击按钮展现电影详细信息。<br>修复个人profile中名字始终加载为username的问题。</p>
<h3 id="给全栈项目开发新功能的一般过程"><a href="#给全栈项目开发新功能的一般过程" class="headerlink" title="给全栈项目开发新功能的一般过程"></a>给全栈项目开发新功能的一般过程</h3><p>熟悉了上述精简版本的笔记后，我们可以对全栈项目（react + next.js）的开发做一些总结。</p>
<p>对于实现登录页面和通过授权登录保护登录界面以外的路径，这两项属于偏后端的范畴，主要利用的是next.js的一些特性（特别是pages和api）。这两个任务没有什么一般性的套路，需要用到的文件夹也比较复杂，包括pages, hooks, lib等，跟着讲义一步步实现。</p>
<p>对于实现导航组件，这个属于偏前端的范畴，主要需要在pages中定义一个菜单界面，再在components中定义若干个组件。在这里需要注意组件的复用。组件拼凑组合起来就能实现一个网页。同时还需要注意如何实现交互特性和其他的一些细节。</p>
<p>对于广告牌组件、电影列表和电影卡片组件、收藏功能、电影播放功能、电影详细信息功能，这些都属于前后端交互的范畴，是有统一的开发套路的。<strong>一般来说是先定义api，再定义hook（调用api），再定义组件（调用hook获取api的数据），再将组件加入到页面（pages）中</strong>。这就是开发全栈项目的一般的新功能（非拓荒）的一般过程。</p>
<h2 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h2><ol>
<li><p>Tailwind CSS的好处：我的主要感受是不需要手写css文件，直接在classname中写内容就可以。注意使用Tailwind CSS前，需要进行必要的配置。Tailwind CSS的具体优点如下所示：</p>
<ul>
<li><p>快速原型开发<br>Tailwind 的实用工具类使得快速原型设计变得非常简单。你可以通过组合不同的类来快速构建界面，而不需要离开 HTML 文件去编写和调试 CSS 文件，这可以显著加快开发速度。</p>
</li>
<li><p>一致性和可重用性<br>通过使用 Tailwind 提供的实用工具类，可以在整个项目中保持样式的一致性。由于你在不同的地方复用相同的实用工具类，这自然而然地导致了样式的可重用性和一致性。</p>
</li>
<li><p>可定制和可配置<br>Tailwind CSS 高度可定制。你可以根据项目的设计指南调整配置文件（如颜色、字体大小、边距等），这使得创建符合品牌指南的设计变得简单。</p>
</li>
<li><p>减少 CSS 的复杂性<br>由于采用实用工具类的方式，你可以避免编写过多的自定义 CSS 和处理复杂的 CSS 继承关系，这降低了代码的复杂性。</p>
</li>
<li><p>响应式设计友好<br>Tailwind CSS 内置了响应式设计的支持，通过简单的前缀可以轻松地实现不同屏幕尺寸的样式适配，而不需要编写额外的媒体查询。</p>
</li>
<li><p>减少未使用的 CSS<br>通过与 PurgeCSS 的集成，Tailwind CSS 可以在构建过程中自动移除未使用的 CSS，这意味着最终的样式表非常精简，加载时间快。</p>
</li>
<li><p>总结<br>尽管 Tailwind CSS 提供了诸多好处，如加速开发、提高一致性和可维护性，但它也有一定的学习曲线，尤其是对于习惯了传统 CSS 开发方式的开发者来说。此外，一些开发者可能会对在 HTML 中大量使用实用工具类表示担忧，担心这会导致 HTML 文件的可读性降低。不过，对于许多项目和团队而言，Tailwind CSS 提供的好处远远超过了这些潜在的缺点。</p>
</li>
</ul>
</li>
<li><p>Google oauth比较难用。在本地将项目跑起来时，Google oauth功能正常，但当我尝试在vercel上部署本项目时，Google oauth就完全无法正常使用，甚至每次产生的报错信息都不相同。与此形成鲜明对比的是，GitHub oauth比较好用，配置和更改都较为简单，且将项目部署在vercel上以后再使用GitHub oauth也不会出问题。</p>
</li>
<li><p>Next.js和React各自的作用：</p>
<p>React 和 Next.js 在一个项目中的共存实际上非常常见，并且它们各自扮演着互补的角色。理解它们的主要用途有助于更好地利用这两个库/框架来构建你的应用。</p>
<p>React</p>
<p>React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发。它的主要特点是组件化开发和声明式编程，使得开发复杂、高性能的单页应用（SPA）变得简单。React 本身主要关注于视图层（UI），允许开发者以组件的形式构建复杂的用户界面。它并不提供诸如路由、服务器端渲染等功能，这些通常需要通过其他库或框架来实现。</p>
<p>Next.js</p>
<p>Next.js 是一个基于 Node.js 的框架，它为 React 应用提供了额外的结构和功能，如自动的代码分割、服务器端渲染（SSR）、静态站点生成（SSG）、基于文件的路由系统、API 路由等。Next.js 旨在解决 React 单页应用的一些限制，特别是在 SEO 和首屏加载性能方面。通过服务器端渲染，Next.js 可以提前渲染页面，使其内容能够被搜索引擎索引，同时也提升了页面加载的速度。</p>
<p>它们是如何一起工作的</p>
<ul>
<li>React 在项目中的角色：负责定义应用的组件结构、状态管理和用户交互逻辑。开发者会使用 React 来创建应用的各个界面组件。</li>
<li>Next.js 在项目中的角色：提供框架和额外功能，帮助这些 React 组件以更高效、优化的方式被呈现和服务。<strong>例如，Next.js 通过文件系统提供的路由功能，自动将位于 <code>pages/</code> 目录下的 React 组件转换为可访问的页面</strong>。</li>
</ul>
<p>总结</p>
<p>在一个项目中，React 用来构建用户界面的组件，而 Next.js 则用来增强 React 应用，提供路由、预渲染（SSR 或 SSG）等功能，以及优化应用的性能和可访问性。Next.js 让开发者能够更专注于业务逻辑和组件本身，而不是底层的架构问题，从而简化了 React 应用的开发和部署过程。简言之，你可以将 React 视为构建应用的砖块，而 Next.js 则是将这些砖块组织起来，建造出结构化、高效、易于维护的应用的框架。<strong>我的理解：React只能做前端，而React+Next.js就可以做全栈了</strong>。</p>
</li>
<li><p>Prisma是一款现代化的ORM框架，它可以连接到多种数据库类型（如 PostgreSQL 、 MySQL 、 SQLite 和 SQL Server等），在本项目中我们用Prisma连接了MongoDB。在ORM的帮助下，我们不需要写SQL语句，只需要定义数据库中的数据名称和数据类型，就可以实现对数据库的各种操作。</p>
</li>
<li><p>本项目中的大多数代码都是Typescript（.ts）代码或者TypeScript JSX(.tsx)代码。前者是基于javascript开发的。TypeScript 是 JavaScript 的一个超集，这意味着它包含了 JavaScript 的所有功能，并在此基础上添加了更多的特性。后者是 TypeScript 的扩展，允许在 TypeScript 文件中使用 JSX 语法。JSX 是一种语法糖，允许开发者在 JavaScript 代码中写像HTML一样的标记语言，这在React 开发中非常常见。由于 TypeScript 默认不理解 JSX 语法，TSX（<code>.tsx</code> 文件扩展名）提供了一种方式来使用 TypeScript 和 JSX。因此，<code>.tsx</code> 文件通常用于包含 JSX 的 TypeScript 项目，尤其是在开发 React 组件时。<strong>简而言之，当代码中需要有类似HTML的代码时，即需要创建一个页面或者页面的一部分时，用tsx。无类似HTML的代码，则用ts</strong>。在本项目中，定义所有组件的components文件夹中的文件全用了tsx，因为要写HTML代码；同理，pages文件夹中除了api文件夹以外的所有文件用的也是tsx。剩下的文件夹中的文件普遍用的是ts，包括hooks文件夹，lib文件夹和pages/api文件夹。</p>
</li>
<li><p>本项目中几个主要文件夹的作用：</p>
<p>属于 Next.js 的特定文件夹：</p>
<ul>
<li><strong>pages</strong>：这是 Next.js 特有的一个文件夹，用于基于文件系统的路由。在 Next.js 中，<code>pages</code> 目录下的每一个文件都会自动对应一个路由，这是 Next.js 框架的核心特性之一。pages中还有api文件夹，因此在本项目中可以像前后端分离的项目那样在后端定义api，然后在前端调用。<strong>只不过本项目中是在next.js实现的伪后端中定义api，然后在react实现的纯前端中调用api</strong>。</li>
<li><strong>public</strong>：这个文件夹也是 Next.js 的标准部分，用于存放静态文件，如图片、字体等。在项目中，你可以通过相对路径直接引用 <code>public</code> 文件夹中的资源。</li>
<li><strong>styles</strong>：虽然存放样式的做法在前端项目中非常常见，但在 Next.js 项目中，<code>styles</code> 文件夹通常用于组织 CSS 或 SCSS 文件。Next.js 支持 CSS Modules 和内置的 Sass 支持，这个文件夹通常用来利用这些特性。本项目中的styles文件夹中只有一个global.css文件，主要负责对tailwind css的配置和定义一些默认的css格式。</li>
</ul>
<p>通常属于开发者根据项目需求创建的文件夹（既适用于 React，也适用于 Next.js）：</p>
<ul>
<li><p>components：存放 React 组件的文件夹。这些组件可以在不同的页面中复用。这是 React 项目的常见结构，但在 Next.js 项目中同样适用。</p>
</li>
<li><p>hooks：存放自定义 React 钩子（Hooks）。自定义钩子是 React 16.8 引入的功能，用于在函数组件之间复用状态逻辑。</p>
</li>
<li><p>lib：通常用于存放一些工具库或者用于与 API 交互的函数等。这个文件夹的具体用途依项目需求而定，既适用于纯 React 项目，也适用于 Next.js 项目。</p>
</li>
</ul>
<p>数据库相关的文件：</p>
<p>prisma：这个文件夹通常用于存放与 Prisma 相关的配置和模型文件。Prisma 是一个流行的 Node.js 和 TypeScript ORM（对象关系映射），用于构建数据库访问。这不是 Next.js 或 React 特有的，而是根据你的项目是否需要与数据库交互来决定使用。</p>
<p>总结：<br>Next.js 特有：pages 和 public 文件夹是 Next.js 特定的，而 styles 虽然不是 Next.js 特有的，但其在 Next.js 项目中的使用方式往往利用了 Next.js 的一些特性。</p>
<p>React 和 Next.js 通用：components、hooks、lib 和 prisma 文件夹是根据开发者的项目需求创建的，它们既适用于 React 项目，也适用于 Next.js 项目。这些文件夹的使用反映了现代前端项目的一些最佳实践，如组件化开发、自定义钩子的使用等。</p>
</li>
<li><p>本项目中使用到了hook的以下功能：</p>
<ul>
<li><p>状态管理 (<code>useState</code>)<br>这是 Hooks 最基本的用途之一，允许在函数组件中添加状态。这对于实现按钮点击、输入表单处理、切换UI组件显示隐藏等功能至关重要。</p>
</li>
<li><p>数据获取（<code>useSWR</code>）<br><code>useSWR</code> 是一个由 Vercel 团队开发的 React Hook，它是 SWR (Stale-While-Revalidate) 数据获取库的一部分。SWR 是一种缓存策略，其名称来自 HTTP 缓存无效化策略，意味着“先返回缓存中的数据（陈旧的），然后发送请求（重新验证），最后用新数据替换旧数据”。<code>useSWR</code> 主要用于数据获取场景，特别是在需要频繁请求更新数据的应用中，它提供了一种简单而强大的方法来获取、缓存、更新远程数据。</p>
</li>
<li><p>副作用处理 (<code>useEffect</code>)<br>用于执行副作用操作，如数据获取（调用API）、订阅/取消订阅事件、直接操作DOM。这对于在组件加载、更新或卸载时执行外部操作非常有用。</p>
</li>
<li><p>性能优化 (<code>useCallback</code>)<br><code>useCallback</code> 可以避免在每次渲染时都进行不必要的计算或创建新的函数实例，从而提高性能。</p>
<p>需要特别注意的是，hook是一种概念，因此不局限于定义在某个特定的文件夹（如 <code>hooks</code> 文件夹）中，而是可以在函数的任何地方使用。在本项目中，hooks文件夹中的hooks主要负责对api的调用，而components, pages等文件夹中的hooks主要负责状态管理和性能优化。</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>recipe</title>
    <url>/2024/06/19/recipe/</url>
    <content><![CDATA[<h1 id="菜谱"><a href="#菜谱" class="headerlink" title="菜谱"></a>菜谱</h1><p>下面是我目前已经掌握的菜肴做法。</p>
<h2 id="青椒炒牛肉"><a href="#青椒炒牛肉" class="headerlink" title="青椒炒牛肉"></a>青椒炒牛肉</h2><p><a href="https://www.xiaohongshu.com/explore/64084cf10000000014024bf6?xsec_token=ABjk8kDPjbnjQBy5ninATf_t4OFqDsNTj2tvDoDR8YAew=&amp;xsec_source=pc_user">https://www.xiaohongshu.com/explore/64084cf10000000014024bf6?xsec_token=ABjk8kDPjbnjQBy5ninATf_t4OFqDsNTj2tvDoDR8YAew=&amp;xsec_source=pc_user</a></p>
<h2 id="素炒小青菜"><a href="#素炒小青菜" class="headerlink" title="素炒小青菜"></a>素炒小青菜</h2><p><a href="https://www.xiaohongshu.com/explore/649eb823000000001203d1d0?xsec_token=ABhF-yZeYWU_KFyde9iuIRaP4osN7hN84uBTDHM4muOJY=&amp;xsec_source=pc_user">https://www.xiaohongshu.com/explore/649eb823000000001203d1d0?xsec_token=ABhF-yZeYWU_KFyde9iuIRaP4osN7hN84uBTDHM4muOJY=&amp;xsec_source=pc_user</a></p>
<h2 id="酸汤水饺"><a href="#酸汤水饺" class="headerlink" title="酸汤水饺"></a>酸汤水饺</h2><p><a href="https://www.xiaohongshu.com/explore/640626770000000013030f32?xsec_token=ABKMjy9V_2e41wBdiSonEoj8xIax3g9thkyzM_zYygvEo=&amp;xsec_source=pc_user">https://www.xiaohongshu.com/explore/640626770000000013030f32?xsec_token=ABKMjy9V_2e41wBdiSonEoj8xIax3g9thkyzM_zYygvEo=&amp;xsec_source=pc_user</a></p>
<h2 id="烤鸡腿"><a href="#烤鸡腿" class="headerlink" title="烤鸡腿"></a>烤鸡腿</h2><p><a href="https://www.xiaohongshu.com/explore/61d80f75000000000102f662?xsec_token=ABFeZ243mB41AtUkgopJjbtnfNUjXvXk5X0vREX-Cr9-o=&amp;xsec_source=pc_user">https://www.xiaohongshu.com/explore/61d80f75000000000102f662?xsec_token=ABFeZ243mB41AtUkgopJjbtnfNUjXvXk5X0vREX-Cr9-o=&amp;xsec_source=pc_user</a></p>
<h2 id="清汤面"><a href="#清汤面" class="headerlink" title="清汤面"></a>清汤面</h2><p><a href="https://www.xiaohongshu.com/explore/64ef0d47000000001e031fc3?xsec_token=ABhdjuqwDUBOmK31gzU44aiEzUHgQx9krLx1OMg7WbYlQ=&amp;xsec_source=pc_user">https://www.xiaohongshu.com/explore/64ef0d47000000001e031fc3?xsec_token=ABhdjuqwDUBOmK31gzU44aiEzUHgQx9krLx1OMg7WbYlQ=&amp;xsec_source=pc_user</a></p>
<h2 id="辣椒炒鸡丁"><a href="#辣椒炒鸡丁" class="headerlink" title="辣椒炒鸡丁"></a>辣椒炒鸡丁</h2><p><a href="https://www.xiaohongshu.com/explore/642ef0440000000013003052?xsec_token=ABP-oNHr9xdj_dfJ3PFdEz90JgCfpOKhxwZCwXod7BaKM=&amp;xsec_source=pc_user">https://www.xiaohongshu.com/explore/642ef0440000000013003052?xsec_token=ABP-oNHr9xdj_dfJ3PFdEz90JgCfpOKhxwZCwXod7BaKM=&amp;xsec_source=pc_user</a></p>
<h2 id="耗油生菜"><a href="#耗油生菜" class="headerlink" title="耗油生菜"></a>耗油生菜</h2><p><a href="https://www.xiaohongshu.com/explore/6331a4890000000017019ee3?xsec_token=ABvHsXQ8990EWiCV0UivQ0VJJbi921rouqm8fD0HcXocg=&amp;xsec_source=pc_user">https://www.xiaohongshu.com/explore/6331a4890000000017019ee3?xsec_token=ABvHsXQ8990EWiCV0UivQ0VJJbi921rouqm8fD0HcXocg=&amp;xsec_source=pc_user</a></p>
<h2 id="蛋炒饭"><a href="#蛋炒饭" class="headerlink" title="蛋炒饭"></a>蛋炒饭</h2><p><a href="https://www.xiaohongshu.com/explore/6539c724000000001f036536?xsec_token=AByuVdQE_Yu5WBwBdOxBbp1JqGxwtjXagF-Ct3aIRyTB4=&amp;xsec_source=pc_user">https://www.xiaohongshu.com/explore/6539c724000000001f036536?xsec_token=AByuVdQE_Yu5WBwBdOxBbp1JqGxwtjXagF-Ct3aIRyTB4=&amp;xsec_source=pc_user</a></p>
<h2 id="炒米粉"><a href="#炒米粉" class="headerlink" title="炒米粉"></a>炒米粉</h2><p><a href="https://www.xiaohongshu.com/explore/63d11d5e000000002203b147?xsec_token=AB6hQFjxlcFe1hFOtuDSpjFvIpDPYH0fIElCl-xqe0uk8=&amp;xsec_source=pc_search">https://www.xiaohongshu.com/explore/63d11d5e000000002203b147?xsec_token=AB6hQFjxlcFe1hFOtuDSpjFvIpDPYH0fIElCl-xqe0uk8=&amp;xsec_source=pc_search</a></p>
<h2 id="排骨汤"><a href="#排骨汤" class="headerlink" title="排骨汤"></a>排骨汤</h2><p><a href="https://www.xiaohongshu.com/explore/63b295f3000000001c0349e2?xsec_token=ABx6mW_uBfj9nVHk20uySHX_8uZaNhS6D0mnuGF2iL0IY=&amp;xsec_source=pc_search">https://www.xiaohongshu.com/explore/63b295f3000000001c0349e2?xsec_token=ABx6mW_uBfj9nVHk20uySHX_8uZaNhS6D0mnuGF2iL0IY=&amp;xsec_source=pc_search</a></p>
<p><a href="https://www.xiaohongshu.com/explore/654d46ab000000003103d1b1?xsec_token=ABC1d6ftIfXeIjYWoQ6zTAFYDNRBJPT1MTjZYuH7pO92o=&amp;xsec_source=pc_search">https://www.xiaohongshu.com/explore/654d46ab000000003103d1b1?xsec_token=ABC1d6ftIfXeIjYWoQ6zTAFYDNRBJPT1MTjZYuH7pO92o=&amp;xsec_source=pc_search</a></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>做菜</tag>
        <tag>菜谱</tag>
        <tag>小红书</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/01/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
